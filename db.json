{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/navy/source/css/navy.styl","path":"css/navy.styl","modified":0,"renderable":1},{"_id":"themes/navy/source/images/arr-left.svg","path":"images/arr-left.svg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/arr-right.svg","path":"images/arr-right.svg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/c_structure_data_a.png","path":"images/c_structure_data_a.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/c_structure_data_b.png","path":"images/c_structure_data_b.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/c_wiced-make.png","path":"images/c_wiced-make.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/c_wiced-wilddog.png","path":"images/c_wiced-wilddog.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/data.jpg","path":"images/data.jpg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/display.jpg","path":"images/display.jpg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/favicon-160x160.png","path":"images/favicon-160x160.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/github.svg","path":"images/github.svg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/introduction.png","path":"images/introduction.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/ios-danmu.png","path":"images/ios-danmu.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/navy/source/js/mobile_nav.js","path":"js/mobile_nav.js","modified":0,"renderable":1},{"_id":"themes/navy/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/navy/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/navy/source/js/ui.js","path":"js/ui.js","modified":1,"renderable":1},{"_id":"themes/navy/source/images/nowifi.png","path":"images/nowifi.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/rules.png","path":"images/rules.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/testApp.jpeg","path":"images/testApp.jpeg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/wilddogid.png","path":"images/wilddogid.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/c_tutorial_b.jpg","path":"images/c_tutorial_b.jpg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/openanonymous.png","path":"images/openanonymous.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/openemail.png","path":"images/openemail.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/protect.png","path":"images/protect.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/rule-overview.png","path":"images/rule-overview.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/c_tutorial_a.jpg","path":"images/c_tutorial_a.jpg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/save.jpg","path":"images/save.jpg","modified":0,"renderable":1},{"_id":"themes/navy/source/images/starwar.png","path":"images/starwar.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/listen.gif","path":"images/listen.gif","modified":0,"renderable":1},{"_id":"themes/navy/source/images/routeapp.png","path":"images/routeapp.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/saveapp.png","path":"images/saveapp.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/wildroute.png","path":"images/wildroute.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/demoapp.png","path":"images/demoapp.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/sketchboard.png","path":"images/sketchboard.png","modified":0,"renderable":1},{"_id":"themes/navy/source/images/syncdevices.png","path":"images/syncdevices.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/plugins.yml","hash":"f2d9341f4e9409ca36492f9a9930d77e3131b48e","modified":1473133102510},{"_id":"source/_data/sidebar.yml","hash":"b3964c6b5a251a211fe1175294a53224f0e1c967","modified":1473254663094},{"_id":"source/_data/themes.yml","hash":"18861b0aa1eb982f390b9ff4b79db9bd8db16a88","modified":1473133102511},{"_id":"source/_posts/hello-world.md","hash":"f6c737628f3370a393405798ae30d563dca22725","modified":1473133102512},{"_id":"source/console/creat.md","hash":"4c6d4ec9524b1b68d37477d09c618d5014d1370e","modified":1473133102518},{"_id":"source/console/administer.md","hash":"ac8ea01de56c63003a8e6496cca3ae76f3507e85","modified":1473133102518},{"_id":"source/overview/auth.md","hash":"259bc890712fdabbea306c2b7dc51ffd5e2301d6","modified":1473148948257},{"_id":"source/overview/index.md","hash":"f0b79eb703c4d90e20dcb0d3137de30e4d71c2fb","modified":1473254663118},{"_id":"source/overview/sync.md","hash":"16c294244452e412bec81cbaa7695183518ba099","modified":1473254663121},{"_id":"themes/navy/languages/zh-cn.yml","hash":"c477c7e75f21863c3b4dd07886f2471d8579e017","modified":1473133102556},{"_id":"themes/navy/layout/archive.swig","hash":"ab15b69930f1700b00a7184e1a330b7cba21dfa1","modified":1473133102556},{"_id":"themes/navy/layout/layout.swig","hash":"c7900151feb15ee0b860cd819a3cb725faa28346","modified":1473133102557},{"_id":"themes/navy/layout/index.swig","hash":"7e3dc90bf21ff6e1fa66ea79f28da54c2ed2ed74","modified":1473133102557},{"_id":"themes/navy/layout/page.swig","hash":"377fdf15a6504400ef6c290e7ac3c191cbe85158","modified":1473251021375},{"_id":"themes/navy/layout/plugins.swig","hash":"538273b6657bd7e7f61c1ead355be8422f8d02aa","modified":1473133102562},{"_id":"themes/navy/layout/post.swig","hash":"d8e2547a1a21f1c374b679f91e041697ee2fac89","modified":1473133102562},{"_id":"source/api/auth/android.md","hash":"44598ee1fb456ebb767ebb3c1c972dce5470a554","modified":1473133102513},{"_id":"source/api/auth/ios.md","hash":"5eb3c5f0587008643066dabfd2720a27f549ae50","modified":1473133102513},{"_id":"source/api/auth/web.md","hash":"b8b1f2476170c28505277c021d00bb08f795e7fc","modified":1473254663096},{"_id":"source/api/sync/android.md","hash":"defac5966a43823cd910a27afd5744227103bb17","modified":1473133102514},{"_id":"source/api/sync/arduino.md","hash":"d9b668de43cb68b646664fbbf013daaadae4b924","modified":1473133102515},{"_id":"source/api/sync/c.md","hash":"27aaf9b139e5751844c121c146a0ca59f9311a92","modified":1473133102515},{"_id":"source/api/sync/ios.md","hash":"3ae08c12a9f65019c8d971a4dd6427da59014618","modified":1473133102516},{"_id":"source/api/sync/rest.md","hash":"786342572fe2aa052c4a58d864979b060c32db2c","modified":1473133102516},{"_id":"source/api/sync/rule.md","hash":"f42190601b0cbc287527c7aa3729c01fc7a38464","modified":1473133102517},{"_id":"source/api/sync/web.md","hash":"458b916cfe076669af571c7f23739210604c5761","modified":1473133102517},{"_id":"source/quickstart/auth/android.md","hash":"4e13f55dccfa000ad8254c67b5c8224da8a15dba","modified":1473133102549},{"_id":"source/quickstart/auth/ios.md","hash":"8288db955e27f1589b3706bf21a50b91bc065144","modified":1473133102549},{"_id":"source/quickstart/auth/web.md","hash":"a1e610890f5a9e4693754c0cb06af7bafe06403a","modified":1473160539572},{"_id":"source/quickstart/sync/android.md","hash":"5c6c4094850676aa38e8073dec313f5bc7b72277","modified":1473133102550},{"_id":"source/quickstart/sync/c.md","hash":"69cd8918e7d4ac27a854867c25541ab754bb659b","modified":1473133102551},{"_id":"source/quickstart/sync/ios.md","hash":"4ae38b14d4c17ffbd3c9f071e2b0ed965387f318","modified":1473133102551},{"_id":"source/quickstart/sync/rest.md","hash":"fcd3e459390b61742fd08214e205ceae2568671d","modified":1473133102551},{"_id":"source/quickstart/sync/web.md","hash":"319c74f844ab2c25475b070e79c8b54e0b499557","modified":1473254663171},{"_id":"themes/navy/layout/partial/after_footer.swig","hash":"fbce3c0f3d5e5275e9ba79f0dcf1aceac774c960","modified":1473234161880},{"_id":"themes/navy/layout/partial/comment.swig","hash":"fd48d69561e5ae01abc04672030db64df1cf679f","modified":1473133102558},{"_id":"themes/navy/layout/partial/gtm.swig","hash":"67addd36527128a61066334aa425326f471d3ff2","modified":1473233999883},{"_id":"themes/navy/layout/partial/footer.swig","hash":"8f6ba563104d146bb0db60539dc24929dd700125","modified":1473133102559},{"_id":"themes/navy/layout/partial/head.swig","hash":"896d0a6418f5162446679b9cdbea6767f7148c76","modified":1473234125821},{"_id":"themes/navy/layout/partial/header.swig","hash":"449b8a016d84220bfb64e85715bfda0f50ac7b3a","modified":1473166968780},{"_id":"themes/navy/layout/partial/mobile_nav.swig","hash":"d490caca1ffee2ae92eea2dc35e6da5ec6945e16","modified":1473133102560},{"_id":"themes/navy/layout/partial/plugin.swig","hash":"b8539477a33580d9e493365f16e7b7d40afc5e5c","modified":1473133102561},{"_id":"themes/navy/layout/partial/post.swig","hash":"d5020a02f66aa96552a14b3a11a9fe5f1c7016ea","modified":1473133102561},{"_id":"themes/navy/layout/partial/theme.swig","hash":"96ae0d2429f712faf2964ed74fbeffc395accac2","modified":1473133102562},{"_id":"themes/navy/layout/partial/sidebar.swig","hash":"01afbaab902b063f83badb651852e8130bcc2dbe","modified":1473133102561},{"_id":"themes/navy/source/css/_variables.styl","hash":"891cda186c6781f1b5964ae84aa9fe7f15ef0577","modified":1473252333949},{"_id":"themes/navy/source/css/navy.styl","hash":"06751170a3fd7152bfafab6d42d0c96f2265b013","modified":1473143405005},{"_id":"themes/navy/source/images/arr-left.svg","hash":"16116de6085a31b6337f1187f2787ca4e25ee2f2","modified":1473133102569},{"_id":"themes/navy/source/images/arr-right.svg","hash":"9bd06d6b981e724c58d4968f9193ec541a957a7d","modified":1473133102569},{"_id":"themes/navy/source/images/c_structure_data_a.png","hash":"fae6c2ee04efa62909ec46aaf5614c58dec983e0","modified":1473133102569},{"_id":"themes/navy/source/images/c_structure_data_b.png","hash":"cbb9815f0a984c8dbb75595ed0c63fb23391f8ac","modified":1473133102570},{"_id":"themes/navy/source/images/c_wiced-make.png","hash":"1008ebe3e29042a449130afa15d66e77d63bba2f","modified":1473133102574},{"_id":"themes/navy/source/images/c_wiced-wilddog.png","hash":"fbe05d35b7ae66a190fc222e26da6f8121a1f1e5","modified":1473133102575},{"_id":"themes/navy/source/images/data.jpg","hash":"dcb880f2ae51261b752c582d86e65fd0b8e7e236","modified":1473133102576},{"_id":"themes/navy/source/images/display.jpg","hash":"0479c281dcee93071ab9f591f812008af6f4577f","modified":1473133102577},{"_id":"themes/navy/source/images/favicon-160x160.png","hash":"7627ddb12034725f3ad4ec8f7b2743f312d25211","modified":1473133102577},{"_id":"themes/navy/source/images/favicon.png","hash":"275510eb32a5a957d1c0148e9fdeadbfbc26dea0","modified":1473133102578},{"_id":"themes/navy/source/images/github.svg","hash":"1f89f10ba233c36c1ef59e0a14aaae098c4ed13c","modified":1473133102578},{"_id":"themes/navy/source/images/introduction.png","hash":"24a94e9e40964a0df2cfef4b899c66e7f88b93d8","modified":1473254663135},{"_id":"themes/navy/source/images/ios-danmu.png","hash":"146eb56486e1caea5b15ee3599963af67a962d3b","modified":1473133102579},{"_id":"themes/navy/source/images/logo.svg","hash":"6306f887c4c3f1c4208aa98f00e118b97c866d15","modified":1473133102595},{"_id":"themes/navy/source/js/mobile_nav.js","hash":"4c8896fd490e463c673329390a66b95e88adf10a","modified":1473133102617},{"_id":"themes/navy/source/js/plugins.js","hash":"63e93eee75d6a83717af73dcc9829983123e01c1","modified":1473133102617},{"_id":"themes/navy/source/js/toc.js","hash":"ad9a384d8f3717f7070f5023fb475829f7791b69","modified":1473133102618},{"_id":"themes/navy/source/js/ui.js","hash":"129490e4c107d7199745a38939ea4f9f10b12578","modified":1473257401377},{"_id":"themes/navy/source/images/nowifi.png","hash":"d17b35a993a9c0112bec4c3645db49dc80b64390","modified":1473133102596},{"_id":"themes/navy/source/images/rules.png","hash":"6c6625adc7b4bec93d277d12a55f2e407040d83a","modified":1473133102603},{"_id":"themes/navy/source/images/testApp.jpeg","hash":"68a978b1eed4cb3db41991f7d53624b56fa2ebe4","modified":1473133102615},{"_id":"themes/navy/source/images/wilddogid.png","hash":"baa1cf97b6a713d7eae3449066e82b7071e240cd","modified":1473254663151},{"_id":"source/guide/auth/android/anonymous.md","hash":"ecece169f2e5b7b0adcfa29a8cde3f06408d6557","modified":1473133102520},{"_id":"source/guide/auth/android/custom.md","hash":"b9ee1a69a99ef82f63d02dd3191d5bc7b12a93b9","modified":1473133102520},{"_id":"source/guide/auth/android/link.md","hash":"03940ee71142d92115cea87486d7e9e436317735","modified":1473133102520},{"_id":"source/guide/auth/android/manageuser.md","hash":"69ae79048cd450b78dae618e237649509d625b33","modified":1473133102521},{"_id":"source/guide/auth/android/qq.md","hash":"d65a6589baaadc779c6e115d3c7d9792d88c034b","modified":1473133102522},{"_id":"source/guide/auth/android/password.md","hash":"7a12e8038ad29f1f1219a4966cfae09e8de9c4a4","modified":1473133102521},{"_id":"source/guide/auth/android/weibo.md","hash":"51e43172a1e8965134bf9f3850f399bbc43acbfc","modified":1473133102522},{"_id":"source/guide/auth/android/weixin.md","hash":"153d79f05d3b2c3b1b1d1f14ee81bf4708b35939","modified":1473133102522},{"_id":"source/guide/auth/core/concept.md","hash":"4cd26d960f1cbbabadf19acb38f2c1472cf9e28c","modified":1473152414842},{"_id":"source/guide/auth/ios/anonymous.md","hash":"558358d255013c667ed1ac01da2a84b3d12760e6","modified":1473133102523},{"_id":"source/guide/auth/ios/api.md","hash":"bc33c7a1c6a047414d71b6b28580b8e389341bb1","modified":1473133102524},{"_id":"source/guide/auth/ios/custom.md","hash":"8dc092d20e059f11164a8e254e7a7c5a7ce12022","modified":1473133102524},{"_id":"source/guide/auth/ios/errorcode.md","hash":"a0925bb1205982ac9a0c4888c9304d8158742210","modified":1473133102525},{"_id":"source/guide/auth/ios/manageuser.md","hash":"7f015ef67b482e7f9a4a93d31e94490dc884e093","modified":1473133102526},{"_id":"source/guide/auth/ios/link.md","hash":"c2788b6447ac929cfde40c1b7f771560cda4531f","modified":1473133102525},{"_id":"source/guide/auth/ios/password.md","hash":"64a99fed886e10cef746bce5b04a43b6f0734545","modified":1473133102526},{"_id":"source/guide/auth/ios/qq.md","hash":"8727c120cda209ea4edb17a0e92b8f96fb12d68f","modified":1473133102527},{"_id":"source/guide/auth/ios/resources.md","hash":"0f435cd73e2d60d73703f0aee866fbdd98e4d782","modified":1473133102527},{"_id":"source/guide/auth/ios/weibo.md","hash":"97bba83ecd38dd4193eb917817b8836e0b558a74","modified":1473133102528},{"_id":"source/guide/auth/ios/weixin.md","hash":"d4167896a8cdaec9df4015903cc36645e0820544","modified":1473133102528},{"_id":"source/guide/auth/server/introduction.md","hash":"2ef16ccfad2f1a393f169f261c128a09f0b436bb","modified":1473254663099},{"_id":"source/guide/auth/server/server.md","hash":"b5cf327508c2092d1e51ba7aa50e38a2c0b90a28","modified":1473254663101},{"_id":"source/guide/auth/web/anonymous.md","hash":"5afc30659d72945a97a2f6f9c73b8cad51c64eea","modified":1473133102530},{"_id":"source/guide/auth/web/api.md","hash":"def44e4d8a5aafc8e2b2acfe302685e7c2dfdb81","modified":1473133102530},{"_id":"source/guide/auth/web/custom.md","hash":"86cd7ee5e19e8b0735bb688d657dbe8f8c88f696","modified":1473133102531},{"_id":"source/guide/auth/web/errorcode.md","hash":"fbcbde45571936e3a997fa23eb01606444eac140","modified":1473133102531},{"_id":"source/guide/auth/web/manageuser.md","hash":"a6edf6aa0b9541fba2a1f7d7b18578f34ba29c4d","modified":1473254663106},{"_id":"source/guide/auth/web/link.md","hash":"bbdae0e1995556d76cad104affe764bf411d8718","modified":1473254663104},{"_id":"source/guide/auth/web/password.md","hash":"c7323560a7aaa3b38b2d712ba0d3d8bc38b23027","modified":1473133102533},{"_id":"source/guide/auth/web/qq.md","hash":"43cb42795fe43e90ee9ce21a14922daa6500771e","modified":1473254663109},{"_id":"source/guide/auth/web/weibo.md","hash":"ca22365c83b7f3d66363240b96a4c8a47550e13b","modified":1473254663111},{"_id":"source/guide/auth/web/weixin.md","hash":"dce602b9e0c30c2dbd6f1b5b86b79c8c0e62d059","modified":1473164141041},{"_id":"source/guide/auth/web/weixinpublic.md","hash":"5f414edb8fae0c6b1754c3ecd92fc6b9341ace4c","modified":1473254663114},{"_id":"source/guide/sync/android/offline-capabilities.md","hash":"1b0050d2df30dc78f6fbeeaaceed3d47f39b1c67","modified":1473133102536},{"_id":"source/guide/sync/android/retrieve-data.md","hash":"4e85aad45a632100c7ee60f4a26b23453aa0157d","modified":1473133102536},{"_id":"source/guide/sync/android/save-data.md","hash":"9c526578c44bf7796b7dda57300bdaadcb23f504","modified":1473133102537},{"_id":"source/guide/sync/bestpractice/array.md","hash":"ae1740eb8f89df7e48d20ffd20035c091410cfd7","modified":1473164695005},{"_id":"source/guide/sync/bestpractice/structure-data.md","hash":"c2255856b8270668d788ec4371cbb46efb38025c","modified":1473254663116},{"_id":"source/guide/sync/c/config-and-porting.md","hash":"f5034185ed14e2b88a87085a64c3abcfa89f012c","modified":1473133102538},{"_id":"source/guide/sync/c/offline-capabilities.md","hash":"b70ea98862a9d57906dbd746d0bf205df16381a8","modified":1473133102539},{"_id":"source/guide/sync/c/retrieve-data.md","hash":"7ef396f2619d7b3ace76f568f3b6668af91707c8","modified":1473133102539},{"_id":"source/guide/sync/c/save-data.md","hash":"590eabb5746719caedcee5c205c9a2f082ed25bf","modified":1473133102540},{"_id":"source/guide/sync/ios/offline-capabilities.md","hash":"efe070ccd4a17e07e9bd43a08747ed834bdb5ce5","modified":1473133102541},{"_id":"source/guide/sync/ios/retrieve-data.md","hash":"9635d62041695015411cac445937042dd1ca3b33","modified":1473133102541},{"_id":"source/guide/sync/ios/save-data.md","hash":"7681220d85fb955f17ba793bd08ad4fa0bfe9edf","modified":1473133102542},{"_id":"source/guide/sync/rest/guide.md","hash":"b049f65e25efeaf5477aec23d8be7e0cdaf8539f","modified":1473133102543},{"_id":"source/guide/sync/rest/library.md","hash":"a522dc769c8083636f3f0b7a772526773d96a91a","modified":1473133102543},{"_id":"source/guide/sync/rules/guide.md","hash":"6629a99b0588ac282827bbf67371d9d22cef4504","modified":1473133102544},{"_id":"source/guide/sync/rules/introduce.md","hash":"11fbeae6090218ee151bbd3b568a08b148e97d85","modified":1473133102545},{"_id":"source/guide/sync/web/offline-capabilities.md","hash":"07f87d34af75d57e4dbe211e9173021a3fcdf79d","modified":1473133102545},{"_id":"source/guide/sync/web/retrieve-data.md","hash":"c13b5e49077bbc15b8ad57ce8f3563a3823c97c3","modified":1473133102546},{"_id":"source/guide/sync/web/save-data.md","hash":"63e95567b9978d88866f86f633f5a46559e529b9","modified":1473133102546},{"_id":"source/guide/sync/web/structure-data.md","hash":"f2082a575259250ed3708ea69abea4fd55dae2ae","modified":1473133102547},{"_id":"source/resources/sync/c/resources.md","hash":"86677c7f178a57d70426d2571b9c9880156e5897","modified":1473254663123},{"_id":"source/resources/sync/c/tutorial.md","hash":"b6fd6ef034141b0743bb9af50769a42ce7ff659b","modified":1473133102553},{"_id":"source/resources/sync/ios/resources.md","hash":"a5bca121dda16ab1dca64e1172ac2d3595ab95f3","modified":1473254663126},{"_id":"source/resources/sync/ios/tutorial.md","hash":"9b41b1b454316ab22c0150997977b1c97b0efab0","modified":1473133102554},{"_id":"source/resources/sync/web/resources.md","hash":"49d75320984a6ac0ee901089081efa55f9527fa9","modified":1473254663128},{"_id":"source/resources/sync/web/tutorial.md","hash":"398ab6e926291e860e0f5184dc31b3c2ab836f3a","modified":1473152414845},{"_id":"themes/navy/source/css/_partial/archive.styl","hash":"9b1719d877ca2bda26d5d1ae3cff74bf90333a64","modified":1473133102563},{"_id":"themes/navy/source/css/_partial/base.styl","hash":"7416abb7c4f8957432740d8a2583ddf3e30d585c","modified":1473256268780},{"_id":"themes/navy/source/css/_partial/common.styl","hash":"6ac1f1d27abc68edce5269eae44789518852ec94","modified":1473256935133},{"_id":"themes/navy/source/css/_partial/custom.styl","hash":"a83ae8a6603ae825c9d21b2e4a783b57ba636be5","modified":1473133102564},{"_id":"themes/navy/source/css/_partial/footer.styl","hash":"3bf0846f0687b8f0b23558e2c04f5eb98522ae59","modified":1473133102564},{"_id":"themes/navy/source/css/_partial/header.styl","hash":"71b4a893803b1046919896eedaefa0f2ed7e4a41","modified":1473253311957},{"_id":"themes/navy/source/css/_partial/highlight.styl","hash":"20de0411aa049b3e8c47f6beb5cd6fa465eff22f","modified":1473133102565},{"_id":"themes/navy/source/css/_partial/mobile_nav.styl","hash":"d7020b889f75cdd0dfb693d1d5adbc0b6a58a93d","modified":1473133102566},{"_id":"themes/navy/source/css/_partial/index.styl","hash":"68081a95a23a6b510723789051a5cbf25693728d","modified":1473133102566},{"_id":"themes/navy/source/css/_partial/page.styl","hash":"b8d0e05a886f250edfa83c955d3b3d09a46a9c5c","modified":1473252483565},{"_id":"themes/navy/source/css/_partial/plugins.styl","hash":"830f5aa916588069fd4fb73954e8e50c6b12a0a6","modified":1473133102567},{"_id":"themes/navy/source/css/_partial/post.styl","hash":"290029b8968f5c5d8712d92fd0246e6caed0aed6","modified":1473133102567},{"_id":"themes/navy/source/css/_partial/sidebar.styl","hash":"c46c83b77af03a2177cb9e1286c18b8888b52a65","modified":1473246856290},{"_id":"themes/navy/source/images/c_tutorial_b.jpg","hash":"1c17b660c3a3b77b884ddc4abfca7bedbf922cfa","modified":1473133102574},{"_id":"themes/navy/source/images/openanonymous.png","hash":"b11750407aaa3fd4727c51e15166084bf6c5895e","modified":1473133102598},{"_id":"themes/navy/source/images/openemail.png","hash":"a2283dd2d2e05fcda24220fd75c4e858920fb8c4","modified":1473133102599},{"_id":"themes/navy/source/images/protect.png","hash":"584f85e34d4e6df94f539f47168ac162226fe77c","modified":1473254663138},{"_id":"themes/navy/source/images/rule-overview.png","hash":"14c4298e48c8277f6c31f2841e9e7f9fa998a5c9","modified":1473133102601},{"_id":"themes/navy/source/images/c_tutorial_a.jpg","hash":"8bb90aff66f248fd9ebc0fc96d130ab56dad211b","modified":1473133102572},{"_id":"themes/navy/source/images/save.jpg","hash":"d3c298c7e92d96665b54aae2256d933ecdda76f4","modified":1473133102607},{"_id":"themes/navy/source/images/starwar.png","hash":"a6aed1c1ec76b54246e1a8f8ad00f4221d980bb7","modified":1473133102614},{"_id":"themes/navy/source/images/listen.gif","hash":"673350ddc1c998c119f080c452cc146444d788c3","modified":1473133102594},{"_id":"themes/navy/source/images/routeapp.png","hash":"60ef8fdff95e16d2ec8b2683e3d1a7f1041acb9e","modified":1473254663141},{"_id":"themes/navy/source/images/saveapp.png","hash":"782744bdb1b9b42148b707bba1216936d95c42bc","modified":1473254663144},{"_id":"themes/navy/source/images/wildroute.png","hash":"daa038837fdeedddc76c9e1000d74637ce20eba7","modified":1473254663153},{"_id":"themes/navy/source/images/demoapp.png","hash":"aaaedc32df8e92af94ba221730ce3c6b589f2692","modified":1473254663131},{"_id":"themes/navy/source/images/sketchboard.png","hash":"20f024899c99ac62b43aab5445e451106a6aaa2a","modified":1473254663146},{"_id":"themes/navy/source/images/syncdevices.png","hash":"adc8b74cace17981fff3b0bca9dea1636099ad2d","modified":1473254663148}],"Category":[],"Data":[{"_id":"plugins","data":[{"name":"hexo-generator-fragments","description":"Generate paged html fragments for `Index`, `Category` and `Tag` pages, let `Hexo` support elegant ajax pagination.","link":"https://github.com/mamboer/hexo-generator-fragments","tags":["generator","pagination","ajax-pagination","fragments"]},{"name":"hexo-filter-cleanup","description":"All in one. Minifier & Optimization plugin for Hexo. Inspired by `hexo-all-minifier` but including more features.","link":"https://github.com/mamboer/hexo-filter-cleanup","tags":["filter","imagemin","html-minifier","uglify","useref","favicons"]},{"name":"hexo-helper-obfuscate","description":"Obfuscate strings using html entities. Handy against crawlers.","link":"https://github.com/andrewpeterprifer/hexo-helper-obfuscate/","tags":["helper","obfuscate","encode","email","crawler","entity","entities"]},{"name":"hexo-wordcount","description":"Word Count Plugin for Hexo.","link":"https://github.com/willin/hexo-wordcount","tags":["wordcount","count","words"]},{"name":"hexo-imagemin","description":"Minify images with imagemin.","link":"https://github.com/vseventer/hexo-imagemin","tags":["assets","filter","imagemin","images"]},{"name":"hexo-more-css","description":"Compress CSS with more-css.","link":"https://github.com/vseventer/hexo-more-css","tags":["css","filter","minify","more-css"]},{"name":"hexo-uncss","description":"Remove unused styles from CSS with uncss.","link":"https://github.com/vseventer/hexo-uncss","tags":["css","filter","html","uncss"]},{"name":"hexo-ruby-character","description":"Ruby character tag for Hexo, like <ruby>博客<rp> (</rp><rt>bó kè</rt><rp>) </rp></ruby>.","link":"https://github.com/JamesPan/hexo-ruby-character","tags":["tag","ruby-character","pinyin"]},{"name":"hexo-filter-indicate-the-source","description":"Insert informations that can indicate the source of blog posts.","link":"https://github.com/JamesPan/hexo-filter-indicate-the-source","tags":["filter","indicate-the-source","anti-crawl"]},{"name":"hexo-server","description":"Server module for Hexo.","link":"https://github.com/hexojs/hexo-server","tags":["official","server","console"]},{"name":"hexo-cli","description":"Command line interface for Hexo.","link":"https://github.com/hexojs/hexo-cli","tags":["official","console","cli"]},{"name":"hexo-browsersync","description":"BrowserSync plugin for Hexo.","link":"https://github.com/hexojs/hexo-browsersync","tags":["official","browsersync","server"]},{"name":"hexo-renderer-less","description":"Less renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-less","tags":["official","renderer","less","style","css"]},{"name":"hexo-renderer-webpack","description":"Webpack renderer for Hexo.","link":"https://github.com/briangonzalez/hexo-renderer-webpack","tags":["renderer","js","webpack"]},{"name":"hexo-generator-amp","description":"AMP (acccelerated mobile pages) page generator plugin for Hexo.","link":"https://github.com/tea3/hexo-generator-amp","tags":["generator","amp"]},{"name":"hexo-generator-archive","description":"Archive generator plugin for Hexo.","link":"https://github.com/hexojs/hexo-generator-archive","tags":["official","generator","archive"]},{"name":"hexo-generator-category","description":"Category generator plugin for Hexo.","link":"https://github.com/hexojs/hexo-generator-category","tags":["official","generator","category"]},{"name":"hexo-generator-tag","description":"Tag generator plugin for Hexo.","link":"https://github.com/hexojs/hexo-generator-tag","tags":["official","generator","tag"]},{"name":"hexo-generator-index","description":"Index generator plugin for Hexo.","link":"https://github.com/hexojs/hexo-generator-index","tags":["official","generator","index"]},{"name":"hexo-generator-search","description":"Search data generator for Hexo.","link":"https://github.com/PaicHyperionDev/hexo-generator-search","tags":["generator","search"]},{"name":"hexo-renderer-marked","description":"Markdown renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-marked","tags":["official","renderer","markdown","marked"]},{"name":"hexo-renderer-kramed","description":"Markdown renderer for Hexo with kramed engine.","link":"https://github.com/sun11/hexo-renderer-kramed","tags":["renderer","markdown","kramed"]},{"name":"hexo-autoprefixer","description":"Autoprefixer plugin for Hexo.","link":"https://github.com/hexojs/hexo-autoprefixer","tags":["official","filter","css","autoprefixer"]},{"name":"hexo-clean-css","description":"Minify CSS files with clean-css.","link":"https://github.com/hexojs/hexo-clean-css","tags":["official","filter","css","cleancss","minify"]},{"name":"hexo-html-minifier","description":"Minify HTML files with HTMLMinifier.","link":"https://github.com/hexojs/hexo-html-minifier","tags":["official","filter","html","minify"]},{"name":"hexo-uglify","description":"Minify JavaScript files with UglifyJS.","link":"https://github.com/hexojs/hexo-uglify","tags":["official","filter","js","uglify","minify"]},{"name":"hexo-notify","description":"Notification plugins for Hexo.","link":"https://github.com/hexojs/hexo-notify","tags":["official","notify"]},{"name":"hexo-deployer-openshift","description":"OpenShift deployer for Hexo.","link":"https://github.com/hexojs/hexo-deployer-openshift","tags":["official","deployer","openshift"]},{"name":"hexo-deployer-heroku","description":"Heroku deployer for Hexo.","link":"https://github.com/hexojs/hexo-deployer-heroku","tags":["official","deployer","heroku"]},{"name":"hexo-deployer-git","description":"Git deployer plugin for Hexo.","link":"https://github.com/hexojs/hexo-deployer-git","tags":["official","deployer","git"]},{"name":"hexo-deployer-rsync","description":"Rsync deployer plugin for Hexo.","link":"https://github.com/hexojs/hexo-deployer-rsync","tags":["official","deployer","rsync"]},{"name":"hexo-deployer-s3","description":"Amazon S3 deployer plugin for Hexo.","link":"https://github.com/nt3rp/hexo-deployer-s3","tags":["deployer","s3"]},{"name":"hexo-deployer-s3-cloudfront","description":"Amazon S3 and Cloudfront deployer plugin for Hexo.","link":"https://github.com/Wouter33/hexo-deployer-s3-cloudfront","tags":["deployer","s3","cloudfront"]},{"name":"hexo-deployer-ansible","description":"Ansible deployer plugin for Hexo.","link":"https://github.com/zyuyou/hexo-deployer-ansible","tags":["deployer","ansible"]},{"name":"hexo-generator-sitemap","description":"Sitemap generator for Hexo.","link":"https://github.com/hexojs/hexo-generator-sitemap","tags":["official","generator","sitemap"]},{"name":"hexo-generator-seo-friendly-sitemap","description":"SEO friendly sitemap generator for Hexo. Generate separated sitemap files for pages, posts, categories, tags and add a XSL stylesheet.","link":"https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap","tags":["generator","sitemap","SEO"]},{"name":"hexo-generator-feed","description":"Feed generator for Hexo.","link":"https://github.com/hexojs/hexo-generator-feed","tags":["official","generator","feed","rss"]},{"name":"hexo-renderer-stylus","description":"Stylus renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-stylus","tags":["official","renderer","css","stylus"]},{"name":"hexo-filter-auto-spacing","description":"Add spaces between CJK characters and western characters.","link":"https://github.com/hexojs/hexo-filter-auto-spacing","tags":["official","filter","spacing"]},{"name":"hexo-migrator-wordpress","description":"WordPress migrator for Hexo.","link":"https://github.com/hexojs/hexo-migrator-wordpress","tags":["official","migrator","wordpress"]},{"name":"hexo-migrator-rss","description":"RSS migrator for Hexo.","link":"https://github.com/hexojs/hexo-migrator-rss","tags":["official","migrator","rss"]},{"name":"hexo-migrator-github-issue","description":"Github issue migrator for Hexo.","link":"https://github.com/Yikun/hexo-migrator-github-issue","tags":["migrator","github","issue"]},{"name":"hexo-renderer-ejs","description":"EJS renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-ejs","tags":["official","renderer","ejs"]},{"name":"hexo-renderer-jade","description":"Jade renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-jade","tags":["official","renderer","jade"]},{"name":"hexo-renderer-haml","description":"Haml renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-haml","tags":["official","renderer","haml"]},{"name":"hexo-renderer-dot","description":"doT renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-dot","tags":["official","renderer","dot"]},{"name":"hexo-renderer-coffeescript","description":"CoffeeScript renderer for Hexo.","link":"https://github.com/hexojs/hexo-renderer-coffeescript","tags":["official","renderer","coffeescript","coffee"]},{"name":"hexo-livereload","description":"Livereload plugin for Hexo.","link":"https://github.com/hexojs/hexo-livereload","tags":["official","server","livereload"]},{"name":"hexo-generator-alias","description":"Generate alias pages for redirecting to post, pages or URL.","link":"https://github.com/hexojs/hexo-generator-alias","tags":["official","generator","alias","redirect"]},{"name":"hexo-deployer-ftpsync","description":"FTP deployer for Hexo.","link":"https://github.com/hexojs/hexo-deployer-ftpsync","tags":["official","deployer","ftp"]},{"name":"hexo-migrator-blogger","description":"Blogger (blogspot.com) migrator for Hexo.","link":"https://github.com/hr6r/hexo-migrator-blogger","tags":["migrator","blogger","blogspot"]},{"name":"hexo-renderer-markdown-it","description":"Very fast Markdown renderer with support for CommonMark, GFM and more.","link":"https://github.com/celsomiranda/hexo-renderer-markdown-it","tags":["renderer","markdown","markdown-it"]},{"name":"hexo-renderer-org","description":"Hexo renderer plugin for emacs org-mode.","link":"https://github.com/CodeFalling/hexo-renderer-org","tags":["renderer","orgmode"]},{"name":"hexo-renderer-bourbon","description":"An up-to-date node-sass wrapper for Hexo that includes Bourbon mixins.","link":"https://github.com/celsomiranda/hexo-renderer-bourbon","tags":["renderer","sass","libsass","bourbon"]},{"name":"hexo-migrator-joomla","description":"Joomla migrator for Hexo.","link":"https://github.com/welksonramos/hexo-migrator-joomla","tags":["official","joomla","migrator"]},{"name":"hexo-renderer-yasr","description":"A Stylus CSS renderer for Hexo that uses Nib, Axis, Rupture, Jeet and Autoprefixer with Sourcemaps.","link":"https://github.com/celsomiranda/hexo-renderer-yasr","tags":["renderer","css","stylus","nib","jeet","rupture","axis","sourcemaps"]},{"name":"hexo-renderer-pandoc","description":"A pandoc-flavored-markdown renderer for Hexo. Also supports rendering textile, reStructedText, etc.","link":"https://github.com/wzpan/hexo-renderer-pandoc","tags":["renderer","pandoc","markdown","textile","reStructedText"]},{"name":"hexo-renderer-restructuredtext","description":"Renderer for restructuredtext using Docutils","link":"https://gitlab.com/mcepl/hexo-renderer-restructuredtext.git","tags":["renderer","reStructedText","rst"]},{"name":"hexo-tag-bootstrap","description":"hexo-tag-bootstrap is a collection of Hexo tag plugins, which wraps most Twitter-Bootstrap 3.1.1 components in a uniform way.","link":"https://github.com/wzpan/hexo-tag-bootstrap","tags":["tag_plugins","bootstrap"]},{"name":"hexo-tag-spotify","description":"Server module for Hexo.","link":"https://github.com/ivanovyordan/hexo-tag-spotify","tags":["tag","spotify","music","widget"]},{"name":"hexo-tag-plantuml","description":"hexo-tag-plantuml is a tag plugin for Hexo. It can work with plantuml to draw uml.","link":"https://github.com/oohcoder/hexo-tag-plantuml","tags":["tag_plugins","plantuml","uml"]},{"name":"hexo-tag-katex","description":"Hexo Tag Plugin to support LaTeX using Katex library.","link":"https://github.com/iamprasad88/hexo-tag-katex","tags":["tag","latex","katex","tex"]},{"name":"hexo-toc","description":"Insert a markdown TOC (Table Of Contents) before posts are rendered when and where a placeholder is found.","link":"https://github.com/bubkoo/hexo-toc","tags":["toc","filter","markdown","placeholder"]},{"name":"hexo-filter-fenced-code","description":"Extend syntax for the native fenced code block. Use tag-plugins as fenced code block.","link":"https://github.com/bubkoo/hexo-filter-fenced-code","tags":["filter","code block","extend","syntax","markdown"]},{"name":"hexo-beautify","description":"Beautify Hexo generated HTML, CSS and JS files, using js-beautify.","link":"https://github.com/celsomiranda/hexo-beautify","tags":["filter","beautify","html","css","js"]},{"name":"hexo-qiniu-sync","description":"Sync static files to Qiniu CDN for you automatically","link":"https://github.com/gyk001/hexo-qiniu-sync","tags":["sync","qiniu","cdn","image","css","js"]},{"name":"hexo-front-matter-excerpt","description":"Write post excerpts using YAML front matter.","link":"https://github.com/lalunamel/hexo-front-matter-excerpt","tags":["excerpt","front-matter"]},{"name":"hexo-github","description":"Display a GitHub repository badge with timeline in your post to keep track of version difference.","link":"https://github.com/akfish/hexo-github","tags":["tag","timeline","badge","github","version control"]},{"name":"hexo-math","description":"Add MathJax support","link":"https://github.com/akfish/hexo-math","tags":["tag","math","MathJax"]},{"name":"hexo-tag-googlemaps","description":"A hexo tag for google maps. Does much more than a simple embedded iFrame","link":"https://github.com/the-simian/hexo-tag-googlemaps","tags":["tag","googlemaps","map","latitude","longitude","markers"]},{"name":"hexo-tag-googlecharts","description":"A hexo tag for inserting google charts in your blog","link":"https://github.com/juampi92/hexo-tag-googlecharts","tags":["tag","googlecharts","chart"]},{"name":"hexo-tag-deezer","description":"Tag for showing Deezer track widget on page.","link":"https://github.com/OdinsHat/hexo-tag-deezer","tags":["tag","deezer","music","widget"]},{"name":"hexo-tag-flickr","description":"Allows you to embed Flickr photo on your blog posts.","link":"https://github.com/visioncan/hexo-tag-flickr","tags":["tag","flickr","photo","image"]},{"name":"hexo-tag-imgurgal","description":"Embed imgur galleries/albums","link":"https://github.com/DrummerHead/hexo-tag-imgurgal","tags":["tag","imgur","photos","image","gallery","album"]},{"name":"hexo-tag-vine","description":"Embed your Vine videos in posts/pages.","link":"https://github.com/welksonramos/hexo-tag-vine","tags":["tag","vine","video","social"]},{"name":"hexo-tag-xvideos","description":"Embed xvideos player in your posts/pages.","link":"https://github.com/welksonramos/hexo-tag-xvideos","tags":["tag","xvideos","video"]},{"name":"hexo-hey","description":"An admin plugin for Hexo.","link":"https://github.com/nihgwu/hexo-hey","tags":["admin","dashboard","editor"]},{"name":"hexo-admin","description":"Edit your content in style with this integrating blogging environment.","link":"https://github.com/jaredly/hexo-admin","tags":["admin","interface","editor","IDE","preview","ghost","dashboard"]},{"name":"hexo-tag-bilibili","description":"Embed bilibili videos in Hexo posts/pages.","link":"https://github.com/Z4Tech/hexo-tag-bilibili","tags":["tag","bilibili","video"]},{"name":"hexo-generator-json-content","description":"Generate a JSON file for generic use or consumption with the contents of posts and pages. Useful for AJAX search or content API.","link":"https://github.com/alexbruno/hexo-generator-json-content","tags":["generator","content","json","data","search","api"]},{"name":"hexo-generator-json-feed","description":"Generate a JSON file similar to RSS feed channel structure with posts contents for generic use or consumption.","link":"https://github.com/alexbruno/hexo-generator-json-feed","tags":["generator","content","json","feed","rss","search","api"]},{"name":"hexo-tag-niconico","description":"Embed NicoNico seiga/douga in Hexo posts/pages.","link":"https://github.com/kamiya555/hexo-tag-niconico","tags":["tag","niconico","video","image"]},{"name":"hexo-cli-extras","description":"Unofficial CLI plugin for convenient editing, renaming, deleting, isolating and integrating posts and pages from the command line.","link":"https://github.com/greg-js/hexo-cli-extras","tags":["console","cli","editor","admin"]},{"name":"hexo-filter-fix-cjk-spacing","description":"Join continuous CJK lines in markdown before rendering.","link":"https://github.com/lotabout/hexo-filter-fix-cjk-spacing","tags":["filter","cjk","spacing","line"]},{"name":"hexo-tag-owl","description":"A media tag for Hexo 3.x","link":"https://github.com/m80126colin/hexo-tag-owl","tags":["hexo","blog","tag","video","youtube","niconico","bilibili","vimeo","tudou","youku","tencent","image","giphy"]},{"name":"hexo-tag-githubimage","description":"Inserts an image tag using a github content distribution.","link":"https://github.com/wizicer/hexo-tag-githubimage/","tags":["website","blog","hexo","image","embedded","github"]},{"name":"hexo-imgix","description":"Use the imgix API for image manipulation via a tag, filter and helper.","link":"https://github.com/mshick/hexo-imgix/","tags":["hexo","imgix","filter","tag","helper","manipulation","image"]},{"name":"hexo-pdf","description":"Hexo tag to embed pdf in posts/pages.","link":"https://github.com/superalsrk/hexo-pdf/","tags":["hexo","tag","pdf"]},{"name":"hexo-all-minifier","description":"Minifier & Optimization plugin for Hexo, include HTML, CSS, JS and Image.","link":"https://github.com/unhealthy/hexo-all-minifier","tags":["hexo","filter","minify","optimize","html","css","js","image"]},{"name":"hexo-autonofollow","description":"Adds nofollow attribute to all external links in your hexo blog posts automatically.","link":"https://github.com/liuzc/hexo-autonofollow","tags":["hexo-autonofollow","SEO","nofollow","external"]},{"name":"hexo-auto-canonical","description":"A generator automatically make canonical link for hexo.","link":"https://github.com/HyunSeob/hexo-auto-canonical","tags":["hexo-auto-canonical","helper","canonical","SEO"]},{"name":"hexo-generator-postmap","description":"Generates a page with an embedded Google map, showing the locations of all geo-tagged posts and pages.","link":"https://github.com/jamiei/hexo-generator-postmap","tags":["hexo-generator-postmap","maps","generator","google","location"]},{"name":"hexo-tag-aplayer","description":"Embed aplayer in Hexo posts/pages.","link":"https://github.com/grzhan/hexo-tag-aplayer","tags":["hexo-tag-aplayer","tag","player","aplayer","music"]},{"name":"hexo-tag-dplayer","description":"Embed dplayer in Hexo posts/pages.","link":"https://github.com/NextMoe/hexo-tag-dplayer","tags":["hexo-tag-dplayer","tag","player","dplayer","video"]},{"name":"hexo-tag-youku","description":"A hexo tag for inserting youku video in your blog.","link":"https://github.com/zhoulvjun/hexo-tag-youku","tags":["hexo-tag-youku","tag","youku","video"]},{"name":"hexo-tag-echarts","description":"A hexo tag for inserting echarts chart in your blog.","link":"https://github.com/zhoulvjun/hexo-tag-echarts","tags":["hexo-tag-echarts","tag","echarts","chart"]},{"name":"hexo-featured-image","description":"A plugin that adds support for featured images in posts and json-content.","link":"https://github.com/poacher2k/hexo-featured-image","tags":["hexo-featured-image","featured","image","json","json-content"]},{"name":"hexo-url-image","description":"adding url_image in front-matter, then refer post.url_image in your templates;","link":"https://github.com/roybein/hexo-url-image","tags":["hexo-url-image","url","image"]},{"name":"hexo-tag-admonition","description":"Tag plugin for inserting admonition in your blog.","link":"https://github.com/haishanh/hexo-tag-admonition","tags":["hexo-tag-admonition","tag","admonition"]},{"name":"hexo-addlink","description":"An plugin for adding current post link in hexo post page.","link":"https://github.com/acwong00/hexo-addlink","tags":["hexo-addlink","filter","post"]},{"name":"hexo-tag-cloud","description":"Yet, another tag cloud plugin for hexo.","link":"https://github.com/MikeCoder/hexo-tag-cloud","tags":["hexo-tag-cloud","tag","cloud"]},{"name":"hexo-critical-css","description":"Add critical css to your HTML for faster rendering pages.","link":"https://github.com/john-whitley/hexo-critical-css","tags":["hexo-critical-css","css","critical","filter"]},{"name":"hexo-github-card","description":"Display a card for GitHub profile and repo in your hexo blog post.","link":"https://github.com/Gisonrg/hexo-github-card","tags":["tag","github","card","profile"]},{"name":"hexo-autolinker","description":"Automatically create HTML links from URLs, emails, Twitter handles and more.","link":"https://github.com/klugjo/hexo-autolinker","tags":["hexo-autolinker","hyperlink","link","email","URL"]},{"name":"hexo-footnotes","description":"A plugin to support markdown footnotes in your Hexo blog posts","link":"https://github.com/LouisBarranqueiro/hexo-footnotes","tags":["filter","markdown","footnotes"]},{"name":"hexo-generator-recent","description":"Creates a list of recent articles in JSON","link":"https://github.com/leviwheatcroft/hexo-generator-recent","tags":["generator","recent"]},{"name":"hexo-index-anything","description":"Generate custom indexes","link":"https://github.com/leviwheatcroft/hexo-index-anything","tags":["index","generator"]},{"name":"hexo-thumbnails","description":"generate image thumbnails","link":"https://github.com/leviwheatcroft/hexo-thumbnails","tags":["thumbs","thumbnails"]},{"name":"hexo-imgur","description":"populate post variables from imgur gallery","link":"https://github.com/leviwheatcroft/hexo-imgur","tags":["imgur","photos","gallery","tag"]},{"name":"hexo-filter-pathfix","description":"using absolute path for assets","link":"https://github.com/wayou/hexo-filter-pathfix","tags":["assets","filter","path","tag"]},{"name":"hexo-image-caption","description":"add caption for images within posts","link":"https://github.com/wayou/hexo-image-caption","tags":["posts","image","caption"]},{"name":"hexo-uuid","description":"give your posts an uuid","link":"https://github.com/chekun/hexo-uuid","tags":["post","uuid"]},{"name":"hexo-excerpt","description":"automatic excerpt generator","link":"https://github.com/chekun/hexo-excerpt","tags":["post","excerpt"]},{"name":"hexo-hrefmd","description":"set hexo can modfiy .md to html in links. |md链接支持","link":"https://github.com/rozbo/hexo-hrefmd","tags":["href","md","中文支持"]},{"name":"hexo-neat","description":"auto Minify html、js、css and make it neat","link":"https://github.com/rozbo/hexo-neat","tags":["minify","all in on","中文支持","html","js","css"]},{"name":"hexo-abbrlink","description":"auto create one and only link for every post for hexo","link":"https://github.com/rozbo/hexo-abbrlink","tags":["permalink","link","固定链接"]},{"name":"hexo-generator-github","description":"Github generator for Hexo","link":"https://github.com/Jamling/hexo-generator-github","tags":["github","generator","helper"]},{"name":"hexo-generator-i18n","description":"Multi-languages pages generator for Hexo","link":"https://github.com/Jamling/hexo-generator-i18n","tags":["i18n","generator","helper"]},{"name":"hexo-encrypt","description":"encrypt the content of your post(对你的文章内容进行加密)","link":"https://github.com/edolphin-ydf/hexo-encrypt","tags":["encrypt","permission","private"]},{"name":"hexo-tag-leaflet","description":"Add a new tag to integrate leaflet based online maps.","link":"https://github.com/ender74/hexo-tag-leaflet","tags":["tag","map","leaflet","osm","tracks"]},{"name":"hexo-tag-asciinema","description":"Embed asciinema into your post","link":"https://github.com/zenyai/hexo-tag-asciinema","tags":["tag","asciinema"]},{"name":"hexo-tag-kbd","description":"Displays the keycaps in your post/page.","link":"https://github.com/kamiya555/hexo-tag-kbd","tags":["tag","keycaps"]},{"name":"hexo-generator-index-i18n","description":"I18n index generator plugin for Hexo.","link":"https://github.com/xcatliu/hexo-generator-index-i18n","tags":["generator","index","i18n"]},{"name":"hexo-generator-archive-alphabet","description":"Generate alphabetical archive for Hexo.","link":"https://github.com/xcatliu/hexo-generator-archive-alphabet","tags":["generator","archive","alphabet"]},{"name":"hexo-generator-archive-alphabet-i18n","description":"Generate i18n alphabetical archive for Hexo.","link":"https://github.com/xcatliu/hexo-generator-archive-alphabet-i18n","tags":["generator","archive","alphabet","i18n"]},{"name":"hexo-tag-tencent","description":"A hexo plugin for inserting youku or tencent video in your site.","link":"https://github.com/HmyBmny/hexo-tag-tencent","tags":["tag","video","youku","tencent video"]},{"name":"hexo-filter-date-from-git","description":"Read git log and overwrite the front-matter properties `date` and `updated` for each posts.","link":"https://github.com/xcatliu/hexo-filter-date-from-git","tags":["date","updated","git"]},{"name":"hexo-filter-author-from-git","description":"Read git log and add the properties `author` and `contributors` for each posts.","link":"https://github.com/xcatliu/hexo-filter-author-from-git","tags":["author","contributors","git"]},{"name":"hexo-medium-image","description":"A medium-like image lazyload plugin.","link":"https://github.com/ele828/hexo-medium-image-plugin","tags":["image","medium","lazyload"]},{"name":"hexo-generator-index2","description":"Filtered index generator for Hexo","link":"https://github.com/Jamling/hexo-generator-index2","tags":["generator","index"]},{"name":"hexo-algoliasearch","description":"A plugin to index posts of your Hexo blog on Algolia","link":"https://github.com/LouisBarranqueiro/hexo-algoliasearch","tags":["algoliasearch","algolia","search"]},{"name":"hexo-filter-file-link","description":"A plugin to make convenient to link local posted file in markdown style","link":"https://github.com/zhenyong/hexo-filter-file-link","tags":["filter","link","file"]},{"name":"hexo-prism-plugin","description":"A plugin for code highlight by Prism.js","link":"https://github.com/ele828/hexo-prism-plugin","tags":["code","highlight","prism.js"]},{"name":"hexo-generator-type","description":"clasify hexo site.pages and create pagination list","link":"https://github.com/callmelanmao/hexo-generator-type","tags":["generator","cliasify","types"]}]},{"_id":"sidebar","data":{"overview":{"野狗概览":{"简介":"/overview/index.html","实时数据同步":"/overview/sync.html","身份认证":"/overview/auth.html"}},"quickstart":{"实时数据同步":{"Web":"/quickstart/sync/web.html","Android":"/quickstart/sync/android.html","iOS":"/quickstart/sync/ios.html","C/嵌入式":"/quickstart/sync/c.html","REST":"/quickstart/sync/rest.html"},"身份认证":{"Web":"/quickstart/auth/web.html","Android":"/quickstart/auth/android.html","iOS":"/quickstart/auth/ios.html"}},"guide":{"实时数据同步":{"Web":{"操作数据":"/guide/sync/web/save-data.html","读取和查询数据":"/guide/sync/web/retrieve-data.html","离线功能":"/guide/sync/web/offline-capabilities.html"},"Android":{"操作数据":"/guide/sync/android/save-data.html","读取和查询数据":"/guide/sync/android/retrieve-data.html","离线功能":"/guide/sync/android/offline-capabilities.html"},"iOS":{"操作数据":"/guide/sync/ios/save-data.html","读取和查询数据":"/guide/sync/ios/retrieve-data.html","离线功能":"/guide/sync/ios/offline-capabilities.html"},"C/嵌入式":{"配置和移植":"/guide/sync/c/config-and-porting.html","组织数据":"/guide/sync/c/structure-data.html","操作数据":"/guide/sync/c/save-data.html","读取和查询数据":"/guide/sync/c/retrieve-data.html","离线功能":"/guide/sync/c/offline-capabilities.html"},"REST":{"完整指南":"/guide/sync/rest/guide.html","其他平台":"/guide/sync/rest/library.html"},"规则表达式":{"简介":"/guide/sync/rules/introduce.html","指南":"/guide/sync/rules/guide.html"},"最佳实践":{"组织数据":"/guide/sync/bestpractice/structure-data.html","数组":"/guide/sync/bestpractice/array.html"}},"身份认证":{"核心概念":{"Wilddog 用户":"/guide/auth/core/concept.html"},"Web":{"管理用户":"/guide/auth/web/manageuser.html","邮箱登录":"/guide/auth/web/password.html","QQ登录":"/guide/auth/web/qq.html","微信登录":"/guide/auth/web/weixin.html","微信公众号登录":"/guide/auth/web/weixinpublic.html","微博登录":"/guide/auth/web/weibo.html","自定义身份认证":"/guide/auth/web/custom.html","匿名身份认证":"/guide/auth/web/anonymous.html","链接多种登录方式":"/guide/auth/web/link.html"},"Android":{"管理用户":"/guide/auth/android/manageuser.html","邮箱登录":"/guide/auth/android/password.html","QQ登录":"/guide/auth/android/qq.html","微信登录":"/guide/auth/android/weixin.html","微博登录":"/guide/auth/android/weibo.html","自定义身份认证":"/guide/auth/android/custom.html","匿名身份认证":"/guide/auth/android/anonymous.html","链接多种登录方式":"/guide/auth/android/link.html"},"iOS":{"管理用户":"/guide/auth/ios/manageuser.html","邮箱登录":"/guide/auth/ios/password.html","QQ 登录":"/guide/auth/ios/qq.html","微信登录":"/guide/auth/ios/weixin.html","微博登录":"/guide/auth/ios/weibo.html","自定义身份认证":"/guide/auth/ios/custom.html","匿名身份认证":"/guide/auth/ios/anonymous.html","链接多种登录方式":"/guide/auth/ios/link.html"},"Server":{"简介":"/guide/auth/server/introduction.html","使用 Server SDK 进行认证":"/guide/auth/server/server.html"}}},"api":{"实时数据同步":{"Web":"/api/sync/web.html","Android":"/api/sync/android.html","iOS":"/api/sync/ios.html","C/嵌入式":"/api/sync/c.html","Arduino":"/api/sync/arduino.html","REST":"/api/sync/rest.html","规则表达式":"/api/sync/rule.html"},"身份认证":{"Web":"/api/auth/web.html","Android":"/api/auth/android.html","iOS":"/api/auth/ios.html"}},"resources":{"实时数据同步":{"Web":{"实战教程":"/resources/sync/web/tutorial.html","demo库":"/resources/sync/web/resources.html"},"iOS":{"实战教程":"/resources/sync/ios/tutorial.html","demo库":"/resources/sync/ios/resources.html"},"C/嵌入式":{"实战教程":"/resources/sync/c/tutorial.html","demo库":"/resources/sync/c/resources.html"}}},"console":{"控制面板":{"创建应用":"/console/creat.html","管理应用":"/console/administer.html"}}}},{"_id":"themes","data":[{"name":"landscape","description":"A brand new default theme for Hexo.","link":"https://github.com/hexojs/hexo-theme-landscape","preview":"http://hexo.io/hexo-theme-landscape","tags":["official","responsive","widget","two_column","one_column"]},{"name":"phase","description":"Feel the flow of time with Phase.","link":"https://github.com/hexojs/hexo-theme-phase","preview":"http://hexo.io/hexo-theme-phase","tags":["official","one_column"]},{"name":"light","description":"Default theme for Hexo.","link":"https://github.com/hexojs/hexo-theme-light","preview":"http://hexo.io/hexo-theme-light","tags":["official","responsive","two_column"]},{"name":"NexT","description":"NexT is an elegant theme for Hexo.","link":"https://github.com/iissnan/hexo-theme-next","preview":"http://notes.iissnan.com/","tags":["responsive","one_column","clean","white"]},{"name":"Icarus","description":"The blog theme you may fall in love with, coming to Hexo.","link":"https://github.com/ppoffice/hexo-theme-icarus","preview":"https://ppoffice.github.io/hexo-theme-icarus","tags":["responsive","three_column","clean","flat","light"]},{"name":"Hueman","description":"A redesign of Alx's wordpress theme Hueman, ported to Hexo.","link":"https://github.com/ppoffice/hexo-theme-hueman","preview":"https://ppoffice.github.io/hexo-theme-hueman","tags":["responsive","two_column","wordpress","elegant","hueman"]},{"name":"Flexy","description":"Flexy is a modern theme for Hexo, written in Jade and Stylus using Flexbox.","link":"https://github.com/sjaakvandenberg/flexy","preview":"https://svdb.co/","tags":["responsive","flexbox","two_column","clean","css3","jade","stylus","translate3d"]},{"name":"carbon","description":"Carbon is a simple theme using pjax for elegant loading.","link":"https://github.com/icylogic/carbon","preview":"https://blog.icylogic.net","tags":["simple","white & black","pjax"]},{"name":"hexadillax","description":"XadillaX built this theme with love and an otaku heart.","link":"https://github.com/XadillaX/hexadillax","preview":"https://xcoder.in/","tags":["bootstrap","simple","otaku"]},{"name":"Jacman","description":"A fresh looking and responsive theme for Hexo.","link":"https://github.com/wuchong/jacman","preview":"http://wuchong.me/jacman","tags":["responsive","two_column","blue","elegant"]},{"name":"Wixo","description":"Turn your Hexo into a Wiki!","link":"https://github.com/wzpan/hexo-theme-wixo","preview":"http://wzpan.github.io/hexo-theme-wixo/","tags":["wiki","responsive","simple","tag_plugins","bootstrap","modal"]},{"name":"Freemind","description":"Fully taking advantages of Bootstrap.","link":"https://github.com/wzpan/hexo-theme-freemind","preview":"http://wzpan.github.io/hexo-theme-freemind/","tags":["two_column","responsive","elegant","tag_plugins","bootstrap","color_themes"]},{"name":"Simplest","description":"Very simple, written with swig & scss.","link":"https://github.com/dnxbf321/hexo-theme-simplest","preview":"https://dnxbf321.github.io","tags":["responsive","swig","scss","one_column"]},{"name":"hexoThemeKacper","description":"Suitable for products blog","link":"https://github.com/jaywcjlove/hexoThemeKacper","preview":"http://JSlite.io","tags":["bootstrap","tag_plugins","elegant"]},{"name":"Tranquilpeak","description":"A gorgeous responsive theme for Hexo blog framework","link":"https://github.com/LouisBarranqueiro/tranquilpeak-hexo-theme","preview":"http://louisbarranqueiro.github.io/hexo-theme-tranquilpeak","tags":["responsive","gorgeous","sidebar","two_column","one_column","tag_plugins"]},{"name":"Minos","description":"A simple and retro styled Hexo theme, concentrated more on your ideas.","link":"https://github.com/ppoffice/hexo-theme-minos","preview":"http://ppoffice.github.io/hexo-theme-minos","tags":["responsive","one_column","simple","retro","white"]},{"name":"Foundation","description":"A theme based on the Zurb Foundation 5 theme.","link":"https://github.com/chrisjlee/hexo-theme-zurb-foundation","preview":"http://chrisjlee.github.io/hexo-theme-zurb-foundation","tags":["responsive","mobile_first","simple","white"]},{"name":"simpleblock","description":"A simple theme inspired by Twenty Twelve.","link":"https://github.com/jysperm/hexo-theme-simpleblock","preview":"https://jysperm.me","tags":["responsive","two_column","simple","light"]},{"name":"yinwang","description":"Simplest View For Your Article Best.","link":"https://github.com/mickeyouyou/yinwang","preview":"http://www.fzb.me","tags":["responsive","simple","chinese"]},{"name":"zzoman2015","description":"Simplest Theme by ZZOMAN","link":"https://github.com/reumia/hexo-theme-zzoman2015","preview":"http://dev.zzoman.com","tags":["simple","responsive","one_column","korean"]},{"name":"Maupassant","description":"A simple Hexo template with great performance on different devices.","link":"https://github.com/tufu9441/maupassant-hexo","preview":"https://www.haomwei.com","tags":["simple","responsive","two_column","white","jade","scss"]},{"name":"ttstyle","description":"A three column theme for hexo.Responsive And SEO best.","link":"https://github.com/tangkunyin/hexo-theme-ttstyle","preview":"http://shuoit.net","tags":["responsive","simple","seo","chinese","three_column"]},{"name":"Jekyll","description":"A Hexo theme inspired by jekyllrb.com.","link":"https://github.com/pinggod/hexo-theme-jekyll","preview":"https://github.com/pinggod/hexo-theme-jekyll","tags":["中文","jekyll","dark"]},{"name":"Yelee","description":"Another simple and elegant Hexo theme by MOxFIVE","link":"https://github.com/MOxFIVE/hexo-theme-yelee","preview":"http://moxfive.xyz","tags":["responsive","two_column","toc","elegant","simple","background_image"]},{"name":"Apollo","description":"A Hexo theme inspired by http://cn.vuejs.org/.","link":"https://github.com/pinggod/hexo-theme-apollo","preview":"http://pinggod.com/","tags":["中文","apollo","light"]},{"name":"Freemind.386","description":"Freemind.386 is a retro-style theme of Hexo.","link":"https://github.com/blackshow/hexo-theme-freemind.386","preview":"http://blackshow.me/","tags":["bootstrap","pixel_style","responsive","two_column","tag_plugins","retro"]},{"name":"spfk","description":"A simple solemn theme for Hexo","link":"https://github.com/luuman/hexo-theme-spfk","preview":"http://luuman.github.io/","tags":["black","responsive","two_column","personality"]},{"name":"Bootstrap-Blog","description":"A simple Twitter Bootstrap blog theme for Hexo","link":"https://github.com/cgmartin/hexo-theme-bootstrap-blog","preview":"http://cgmartin.github.io/hexo-theme-bootstrap-blog/","tags":["bootstrap","simple","responsive","two_column"]},{"name":"Very-Simple","description":"A black/white theme for Hexo which tend to be simple and elegant","link":"https://github.com/lotabout/very-simple","preview":"http://lotabout.github.io/very-simple/","tags":["white & black","flexbox","simple","responsive"]},{"name":"Corporate","description":"A professional Hexo theme based on the Corporate Frontend framework.","link":"https://github.com/ptsteadman/hexo-theme-corporate","preview":"http://hexotest.computerlab.io","tags":["responsive","two_column","light","bootstrap","metronic"]},{"name":"Again","description":"Medium like, but more awesome","link":"https://github.com/DrakeLeung/hexo-theme-again","preview":"http://drakeleung.github.io/blog/","tags":["medium","material"]},{"name":"LandFarZ","description":"A blue-colored theme based on theme Light.","link":"https://github.com/wizardforcel/hexo-theme-landfarz","preview":"http://it-ebooks.flygon.net/","tags":["responsive","two_column","chinese","simple","dark"]},{"name":"jane","description":"A very simple theme for Hexo.","link":"https://github.com/Alex-fun/hexo-theme-jane","preview":"http://hejx.me","tags":["chinese","simple","concise"]},{"name":"Weightless","description":"A lightweight theme with minimal fuss","link":"https://jerry.im/essays/2016/02/hexo-theme-weightless/","preview":"https://jerry.im/essays/","tags":["responsive","light"]},{"name":"CyanStyle","description":"Inspired by Wordpress theme Twentytwelve.","link":"https://github.com/wizardforcel/hexo-theme-cyanstyle","preview":"http://www.flygon.net/","tags":["responsive","two_column","chinese","wordpress","light"]},{"name":"indigo","description":"Material Design theme for Hexo.","link":"https://github.com/yscoder/hexo-theme-indigo","preview":"http://www.imys.net/","tags":["responsive","chinese","material","less"]},{"name":"Simple","description":"Simple & Fresh, written with jade & less.","link":"https://github.com/chuguixin/Simple","preview":"http://jser.it","tags":["simple","fresh","responsive","jade","less","one_column"]},{"name":"Primer","description":"Github Style Theme for Hexo","link":"https://github.com/yumemor/hexo-theme-primer","preview":"http://yumemor.github.io","tags":["simple","github","responsive","two_column","one_column"]},{"name":"Chan","description":"A super simple and elegant theme for Hexo.","link":"https://github.com/denjones/hexo-theme-chan","preview":"http://denjones.github.io/hexo-theme-chan","tags":["simple","cc_4.0","photoswipe","responsive","two_column","中文"]},{"name":"Free2mind","description":"A new debonaire theme for Hexo.","link":"https://github.com/rudy-yuan/free2mind","preview":"http://www.rudy-yuan.net","tags":["simple","中文","bootstrap","debonaire","responsive"]},{"name":"Raytaylorism","description":"A Material Design theme of Hexo with powerful features.","link":"https://github.com/raytaylorlin/hexo-theme-raytaylorism","preview":"http://raytaylorlin.com/","tags":["material","responsive","simple","中文"]},{"name":"CleanBlog","description":"Fully featured, bootstrap blog for Hexo.","link":"https://github.com/klugjo/hexo-theme-clean-blog","preview":"http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/","tags":["simple","MIT","responsive","one_column","elegant","standard"]},{"name":"Hacker","description":"A simple theme inspired by Wordpress theme Hacker","link":"https://github.com/CodeDaraW/Hacker","preview":"http://blog.daraw.cn/","tags":["responsive","chinese","wordpress","simple"]},{"name":"Magnetic","description":"Full featured, visual blog for Hexo.","link":"https://github.com/klugjo/hexo-theme-magnetic","preview":"http://www.codeblocq.com/assets/projects/hexo-theme-magnetic/","tags":["portfolio","visual","responsive","three_column","elegant","standard"]},{"name":"Paperbox","description":"A responsive paper-like theme for hexo blog.","link":"https://github.com/sun11/hexo-theme-paperbox","preview":"http://sun11.me/","tags":["responsive","widget","two_column","one_column"]},{"name":"Phantom","description":"Full featured, visual blog for Hexo.","link":"https://github.com/klugjo/hexo-theme-phantom","preview":"http://www.codeblocq.com/assets/projects/hexo-theme-phantom/","tags":["portfolio","visual","responsive","three_column","elegant","standard"]},{"name":"MyFairLady","description":"Girls pink heart hexo theme","link":"https://github.com/yzzting/hexo-theme-MyFairLady","preview":"http://www.yzz1995.cn/","tags":["responsive","chinese","Grils pink","simple","less","ejs"]},{"name":"even","description":"A simple theme for Hexo blog framework","link":"https://github.com/ahonn/hexo-theme-even","preview":"http://www.ahonn.me/","tags":["responsive","simple","less","jade"]},{"name":"Pln","description":"A plain theme for Hexo.","link":"https://github.com/gaoryrt/hexo-theme-pln","preview":"http://gaoryrt.com/","tags":["responsive","elegant","white","simple","chinese","one_column"]},{"name":"Huxblog","description":"A lean and elegant Theme with optimized SEO (Ported)","link":"https://github.com/Kaijun/hexo-theme-huxblog","preview":"http://kaijun.rocks/hexo-theme-huxblog/","tags":["lean","responsive","featured_tags","elegant","standard","SEO"]},{"name":"gstyle","description":"a hexo theme with google style","link":"https://github.com/wayou/hexo-theme-gstyle","preview":"http://wayou.github.io/hexo-theme-gstyle/public/","tags":["google","responsive","widget","two_column","one_column","toc","material"]},{"name":"Random","description":"A hexo theme with random fullscreen background image.","link":"https://github.com/stiekel/hexo-theme-random","preview":"http://hexo-theme-random.herokuapp.com/","tags":["responsive","one_column","background_image","random","iconfont","modal"]},{"name":"Anisina","description":"A support qiniu image cdn , simple responsive theme for hexo","link":"https://github.com/haojen/hexo-theme-Anisina","preview":"http://haojen.github.io/","tags":["qiniu_cdn","wechat_title_img_custom","responsive","toc","SEO","fixed_nav","中文","anisina"]},{"name":"Typescript","description":"A mininal theme for Hexo.","link":"https://github.com/artchen/hexo-theme-typescript","preview":"http://otakism.org","tags":["responsive","one_column","中文","typescript"]},{"name":"Nova","description":"A theme using swig template aimed to build github project site conveniently.","link":"https://github.com/Jamling/hexo-theme-nova","preview":"http://ieclipse.cn","tags":["bootstrap","responsive","widget","two_column","three_column","project layout","multi-languages"]},{"name":"yujuan","description":"A simple solemn theme for Hexo","link":"https://github.com/smile-leaf-language/hexo-theme-yujuan","preview":"http://smile-leaf-language.github.io/","tags":["black","responsive","two_column","personality"]},{"name":"hollow","description":"A pure and elegant theme for Hexo.","link":"https://github.com/zchen9/hexo-theme-hollow","preview":"http://www.chen9.info/fragment/","tags":["responsive","chinese","elegant","one_column","white"]},{"name":"concise","description":"A beautiful and simple theme for hexo","link":"https://github.com/HmyBmny/hexo-theme-concise","preview":"https://hmybmny.github.io/hexo-theme-concise/","tags":["material","responsive","elegant","two_column","white"]},{"name":"wiki-i18n","description":"A hexo theme for i18n wiki site","link":"https://github.com/xcatliu/hexo-theme-wiki-i18n","preview":"http://js-index.com/","tags":["wiki","i18n"]},{"name":"beautiful-hexo","description":"A simple responsive beautiful theme.","link":"https://github.com/twoyao/beautiful-hexo","preview":"http://twoyao.cn/beautiful-hexo/","tags":["responsive","beautiful","simple","white"]},{"name":"AlphaDust","description":"A futuristic responsive theme.","link":"https://github.com/klugjo/hexo-theme-alpha-dust","preview":"http://www.codeblocq.com/assets/projects/hexo-theme-alpha-dust/","tags":["responsive","beautiful","simple","blue","futuristic"]},{"name":"Pixel","description":"A pixel level theme","link":"https://github.com/callmelanmao/hexo-theme-pixel","preview":"https://ideras.me","tags":["pixel","simple","widget","two_column"]}]}],"Page":[{"title":"创建应用","_content":"\n\n进入野狗后台创建一个应用，这是你基于野狗进行开发的第一步。\n\n创建完应用后，你可以进入控制面板查询、修改数据，统计应用资源使用情况，配置用户登录方式、安全域名等等。\n\n## 创建一个野狗应用\n你可以看到应用的卡片列表。每个应用都有唯一的 应用ID 和对应的 URL `https://<appId>.wilddogio.com`。注意这里的 URL 是 wilddogio.com，而不是 wilddog.com。这 URL 可以理解为该应用的数据空间。\n\n**应用ID 只可由小写字母、数字和 - 组成。**\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/New%20app.gif%21thumbnail)\n\n这里的应用 ID ，它只可由小写字母、数字和符号组成。每个用户可以免费创建 5 个应用。\n\n## 添加开发者\n\n你的每个应用，都可以邀请其他开发者加入一起开发。你只需要在应用的卡片下方点击 ＋ 号，然后输入对方的邮箱，便可以向他发送邀请。对方确认邀请之后，就能成为该应用的开发者。\n\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/addUser.gif%21thumbnail)\n\n\n每个应用只有一个拥有者(Owner)，可以有多个开发者(Developer)。拥有者有所有权限。开发者可以预览与配置数据，不能够移除应用，编辑账单、删除其他开发者。\n","source":"console/creat.md","raw":"title: 创建应用\n---\n\n\n进入野狗后台创建一个应用，这是你基于野狗进行开发的第一步。\n\n创建完应用后，你可以进入控制面板查询、修改数据，统计应用资源使用情况，配置用户登录方式、安全域名等等。\n\n## 创建一个野狗应用\n你可以看到应用的卡片列表。每个应用都有唯一的 应用ID 和对应的 URL `https://<appId>.wilddogio.com`。注意这里的 URL 是 wilddogio.com，而不是 wilddog.com。这 URL 可以理解为该应用的数据空间。\n\n**应用ID 只可由小写字母、数字和 - 组成。**\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/New%20app.gif%21thumbnail)\n\n这里的应用 ID ，它只可由小写字母、数字和符号组成。每个用户可以免费创建 5 个应用。\n\n## 添加开发者\n\n你的每个应用，都可以邀请其他开发者加入一起开发。你只需要在应用的卡片下方点击 ＋ 号，然后输入对方的邮箱，便可以向他发送邀请。对方确认邀请之后，就能成为该应用的开发者。\n\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/addUser.gif%21thumbnail)\n\n\n每个应用只有一个拥有者(Owner)，可以有多个开发者(Developer)。拥有者有所有权限。开发者可以预览与配置数据，不能够移除应用，编辑账单、删除其他开发者。\n","date":"2016-09-06T03:38:22.518Z","updated":"2016-09-06T03:38:22.518Z","path":"console/creat.html","comments":1,"layout":"page","_id":"cisswi9gx0001z4fwo9dxn3pt","content":"<p>进入野狗后台创建一个应用，这是你基于野狗进行开发的第一步。</p>\n<p>创建完应用后，你可以进入控制面板查询、修改数据，统计应用资源使用情况，配置用户登录方式、安全域名等等。</p>\n<h2 id=\"创建一个野狗应用\"><a href=\"#创建一个野狗应用\" class=\"headerlink\" title=\"创建一个野狗应用\"></a>创建一个野狗应用</h2><p>你可以看到应用的卡片列表。每个应用都有唯一的 应用ID 和对应的 URL <code>https://&lt;appId&gt;.wilddogio.com</code>。注意这里的 URL 是 wilddogio.com，而不是 wilddog.com。这 URL 可以理解为该应用的数据空间。</p>\n<p><strong>应用ID 只可由小写字母、数字和 - 组成。</strong></p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/New%20app.gif%21thumbnail\" alt=\"\"></p>\n<p>这里的应用 ID ，它只可由小写字母、数字和符号组成。每个用户可以免费创建 5 个应用。</p>\n<h2 id=\"添加开发者\"><a href=\"#添加开发者\" class=\"headerlink\" title=\"添加开发者\"></a>添加开发者</h2><p>你的每个应用，都可以邀请其他开发者加入一起开发。你只需要在应用的卡片下方点击 ＋ 号，然后输入对方的邮箱，便可以向他发送邀请。对方确认邀请之后，就能成为该应用的开发者。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/addUser.gif%21thumbnail\" alt=\"\"></p>\n<p>每个应用只有一个拥有者(Owner)，可以有多个开发者(Developer)。拥有者有所有权限。开发者可以预览与配置数据，不能够移除应用，编辑账单、删除其他开发者。</p>\n","excerpt":"","more":"<p>进入野狗后台创建一个应用，这是你基于野狗进行开发的第一步。</p>\n<p>创建完应用后，你可以进入控制面板查询、修改数据，统计应用资源使用情况，配置用户登录方式、安全域名等等。</p>\n<h2 id=\"创建一个野狗应用\"><a href=\"#创建一个野狗应用\" class=\"headerlink\" title=\"创建一个野狗应用\"></a>创建一个野狗应用</h2><p>你可以看到应用的卡片列表。每个应用都有唯一的 应用ID 和对应的 URL <code>https://&lt;appId&gt;.wilddogio.com</code>。注意这里的 URL 是 wilddogio.com，而不是 wilddog.com。这 URL 可以理解为该应用的数据空间。</p>\n<p><strong>应用ID 只可由小写字母、数字和 - 组成。</strong></p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/New%20app.gif%21thumbnail\" alt=\"\"></p>\n<p>这里的应用 ID ，它只可由小写字母、数字和符号组成。每个用户可以免费创建 5 个应用。</p>\n<h2 id=\"添加开发者\"><a href=\"#添加开发者\" class=\"headerlink\" title=\"添加开发者\"></a>添加开发者</h2><p>你的每个应用，都可以邀请其他开发者加入一起开发。你只需要在应用的卡片下方点击 ＋ 号，然后输入对方的邮箱，便可以向他发送邀请。对方确认邀请之后，就能成为该应用的开发者。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/addUser.gif%21thumbnail\" alt=\"\"></p>\n<p>每个应用只有一个拥有者(Owner)，可以有多个开发者(Developer)。拥有者有所有权限。开发者可以预览与配置数据，不能够移除应用，编辑账单、删除其他开发者。</p>\n"},{"title":"身份认证","_content":"\n<h2 id='简介' class=\"article-heading top-heading\">简介</h2>\n野狗提供多种方式，帮助简化应用中用户认证流程的开发：\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/wilddog-auth.png)\n\n如果应用没有开发登录注册流程，可以采用以下 3 种方式对用户进行身份认证：邮箱地址认证、匿名登录以及常见的第三方登录（包括 QQ 、微信、新浪微博等）。如果应用已有自己的用户系统，也可以方便地集成到野狗中。\n\n\n## 功能特性\n野狗提供以下 4 种方式，对用户进行身份认证。你可以通过 [快速入门](/quickstart/auth/web.html) 学会使用基本功能。\n\n### 电子邮箱与密码认证\n\n野狗 SDK 提供使用电子邮件地址及密码登录进行管理，同时也支持重设密码电子邮件的发送。\n\n更多细节，请参考文档 [电子邮箱与密码](/guide/auth/web/password.html)\n\n### 第三方身份认证\n\n野狗 SDK 提供QQ、微信、微信公众账号、新浪微博等常见第三方对用户进行身份认证。\n\n更多细节，请参考文档 [第三方身份认证](/guide/auth/web/qq.html)\n\n### 匿名用户\n\n野狗 SDK 提供创建临时匿名账户的功能。同时支持账号关联方式，匿名用户可以通过关联其他登录方式，成为一个可再次访问的用户。\n\n更多细节，请参考文档 [匿名用户认证](/guide/auth/web/anonymous.html)\n\n### 集成已有身份认证\n\n应用可以将已有的用户系统集成到野狗 SDK 中,来获取野狗的实时数据同步及其他服务的访问权限。\n\n更多细节，请参考文档 [自定义认证](/guide/auth/web/custom.html)\n\n","source":"overview/auth.md","raw":"title: 身份认证\n---\n\n<h2 id='简介' class=\"article-heading top-heading\">简介</h2>\n野狗提供多种方式，帮助简化应用中用户认证流程的开发：\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/wilddog-auth.png)\n\n如果应用没有开发登录注册流程，可以采用以下 3 种方式对用户进行身份认证：邮箱地址认证、匿名登录以及常见的第三方登录（包括 QQ 、微信、新浪微博等）。如果应用已有自己的用户系统，也可以方便地集成到野狗中。\n\n\n## 功能特性\n野狗提供以下 4 种方式，对用户进行身份认证。你可以通过 [快速入门](/quickstart/auth/web.html) 学会使用基本功能。\n\n### 电子邮箱与密码认证\n\n野狗 SDK 提供使用电子邮件地址及密码登录进行管理，同时也支持重设密码电子邮件的发送。\n\n更多细节，请参考文档 [电子邮箱与密码](/guide/auth/web/password.html)\n\n### 第三方身份认证\n\n野狗 SDK 提供QQ、微信、微信公众账号、新浪微博等常见第三方对用户进行身份认证。\n\n更多细节，请参考文档 [第三方身份认证](/guide/auth/web/qq.html)\n\n### 匿名用户\n\n野狗 SDK 提供创建临时匿名账户的功能。同时支持账号关联方式，匿名用户可以通过关联其他登录方式，成为一个可再次访问的用户。\n\n更多细节，请参考文档 [匿名用户认证](/guide/auth/web/anonymous.html)\n\n### 集成已有身份认证\n\n应用可以将已有的用户系统集成到野狗 SDK 中,来获取野狗的实时数据同步及其他服务的访问权限。\n\n更多细节，请参考文档 [自定义认证](/guide/auth/web/custom.html)\n\n","date":"2016-09-06T08:02:28.260Z","updated":"2016-09-06T08:02:28.257Z","path":"overview/auth.html","comments":1,"layout":"page","_id":"cisswi9gx0002z4fw0ghymfrt","content":"<p></p><h2 id=\"简介\" class=\"article-heading top-heading\">简介</h2><br>野狗提供多种方式，帮助简化应用中用户认证流程的开发：<p></p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/wilddog-auth.png\" alt=\"\"></p>\n<p>如果应用没有开发登录注册流程，可以采用以下 3 种方式对用户进行身份认证：邮箱地址认证、匿名登录以及常见的第三方登录（包括 QQ 、微信、新浪微博等）。如果应用已有自己的用户系统，也可以方便地集成到野狗中。</p>\n<h2 id=\"功能特性\"><a href=\"#功能特性\" class=\"headerlink\" title=\"功能特性\"></a>功能特性</h2><p>野狗提供以下 4 种方式，对用户进行身份认证。你可以通过 <a href=\"/quickstart/auth/web.html\">快速入门</a> 学会使用基本功能。</p>\n<h3 id=\"电子邮箱与密码认证\"><a href=\"#电子邮箱与密码认证\" class=\"headerlink\" title=\"电子邮箱与密码认证\"></a>电子邮箱与密码认证</h3><p>野狗 SDK 提供使用电子邮件地址及密码登录进行管理，同时也支持重设密码电子邮件的发送。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/password.html\">电子邮箱与密码</a></p>\n<h3 id=\"第三方身份认证\"><a href=\"#第三方身份认证\" class=\"headerlink\" title=\"第三方身份认证\"></a>第三方身份认证</h3><p>野狗 SDK 提供QQ、微信、微信公众账号、新浪微博等常见第三方对用户进行身份认证。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/qq.html\">第三方身份认证</a></p>\n<h3 id=\"匿名用户\"><a href=\"#匿名用户\" class=\"headerlink\" title=\"匿名用户\"></a>匿名用户</h3><p>野狗 SDK 提供创建临时匿名账户的功能。同时支持账号关联方式，匿名用户可以通过关联其他登录方式，成为一个可再次访问的用户。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/anonymous.html\">匿名用户认证</a></p>\n<h3 id=\"集成已有身份认证\"><a href=\"#集成已有身份认证\" class=\"headerlink\" title=\"集成已有身份认证\"></a>集成已有身份认证</h3><p>应用可以将已有的用户系统集成到野狗 SDK 中,来获取野狗的实时数据同步及其他服务的访问权限。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/custom.html\">自定义认证</a></p>\n","excerpt":"","more":"<p><h2 id='简介' class=\"article-heading top-heading\">简介</h2><br>野狗提供多种方式，帮助简化应用中用户认证流程的开发：</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/wilddog-auth.png\" alt=\"\"></p>\n<p>如果应用没有开发登录注册流程，可以采用以下 3 种方式对用户进行身份认证：邮箱地址认证、匿名登录以及常见的第三方登录（包括 QQ 、微信、新浪微博等）。如果应用已有自己的用户系统，也可以方便地集成到野狗中。</p>\n<h2 id=\"功能特性\"><a href=\"#功能特性\" class=\"headerlink\" title=\"功能特性\"></a>功能特性</h2><p>野狗提供以下 4 种方式，对用户进行身份认证。你可以通过 <a href=\"/quickstart/auth/web.html\">快速入门</a> 学会使用基本功能。</p>\n<h3 id=\"电子邮箱与密码认证\"><a href=\"#电子邮箱与密码认证\" class=\"headerlink\" title=\"电子邮箱与密码认证\"></a>电子邮箱与密码认证</h3><p>野狗 SDK 提供使用电子邮件地址及密码登录进行管理，同时也支持重设密码电子邮件的发送。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/password.html\">电子邮箱与密码</a></p>\n<h3 id=\"第三方身份认证\"><a href=\"#第三方身份认证\" class=\"headerlink\" title=\"第三方身份认证\"></a>第三方身份认证</h3><p>野狗 SDK 提供QQ、微信、微信公众账号、新浪微博等常见第三方对用户进行身份认证。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/qq.html\">第三方身份认证</a></p>\n<h3 id=\"匿名用户\"><a href=\"#匿名用户\" class=\"headerlink\" title=\"匿名用户\"></a>匿名用户</h3><p>野狗 SDK 提供创建临时匿名账户的功能。同时支持账号关联方式，匿名用户可以通过关联其他登录方式，成为一个可再次访问的用户。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/anonymous.html\">匿名用户认证</a></p>\n<h3 id=\"集成已有身份认证\"><a href=\"#集成已有身份认证\" class=\"headerlink\" title=\"集成已有身份认证\"></a>集成已有身份认证</h3><p>应用可以将已有的用户系统集成到野狗 SDK 中,来获取野狗的实时数据同步及其他服务的访问权限。</p>\n<p>更多细节，请参考文档 <a href=\"/guide/auth/web/custom.html\">自定义认证</a></p>\n"},{"title":"管理应用","_content":"\n点击应用卡片上的管理应用，会进入控制面板，它就是对应用进行配置和管理的地方。下面我们来重点看看控制面板里各个版块的使用。\n\n## 实时数据同步\n\n### 数据预览\n\n数据预览用于查看 APP 中现有的数据，它是根据 APP 的数据变化而实时变化的。你可以在这里方便地新增、删除数据。\n\n![](http://ocpo37x5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%8810.05.02.png)\n\n\n### 导入和导出数据\n\n在数据预览中，你可以通过文件夹上传或直接拖拽的方式导入你的本地数据。注意这里的文件的格式要求必须是 JSON 格式 ：\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/45083791.jpg)\n\n\n当然你也可以通过一键导出的方式，把数据下载到本地：\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/32430219.jpg)\n\n### 配置规则表达式\n\n\n规则表达式是野狗保护你的数据安全的最重要手段之一，我们强烈建议在你开始实时同步数据时，第一件事就是配置它。\n\n参考文档 [规则表达式](/guide/sync/rules/introduce.html)  深入了解具体配置的方法。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/21755337.jpg)\n\n## 资源统计\n\n资源统计页面可以查看你的应用数据存储、流量和并发连接的使用情况。同时我们每个月会发送资源统计情况到你的绑定邮箱，野狗工程团队在不遗余力地进行服务优化，以期提供更好的应用性能和更经济的费用。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/23554419.jpg)\n\n并发是指任何一个时间点，服务器上建立的长链接数量。这个长接连是可以复用的，也就是说对于同一个终端的用户，多次进行的数据读写或同一时间的多个数据读写，会复用这一个长接连。\n\n## 身份认证\n\n### 用户列表\n\n用户列表页面用于查看你的用户登录情况，这里会显示所有登录方式的终端用户。你可以随时追踪到他们的的登录方式、上次登录的时间等信息。同时，你可以通过邮箱搜索用户。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3057243.jpg)\n\n### 不同的身份认证方式\n\n通过配置你可以让你的用户通过邮箱密码、匿名、自定义登录方式或第三方的方式登录你的 App 。只需要在控制台里开启登录方式，然后进行相应配置就可以。\n\n你可以参考 [身份认证](/guide/auth/core/concept.html) 文档了解更多细节。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/83626118.jpg)\n\n\n#### 登录方式的设置\n\n在这里配置应用到的所有登录方式及 Wilddog ID Token 有效时长。当你使用自己的用户体系时，可以为特定用户单独配置 Wilddog ID Token有效时长。\n​该 Token 作为野狗用户进行数据操作等其他操作凭证。\n\n#### 超级密钥\n\n你可以配置 10 个超级密钥，并且可以为每一个超级密钥添加备注，使用时便于识别。\n\n\n## 安全\n\n安全域名是野狗保护你的数据安全的重要手段之一 。\n你开启安全域名后，可以设置 6 个域名作为你的“安全域名白名单”。只有在这个白名单下的域名，才能使用你的野狗应用，其他域名均无法调用。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3348371.jpg)\n\n\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/5151856.jpg)\n\n## 升级套餐\n\n点击应用卡片上的升级套餐，更改你的当前套餐。升级或付费套餐的升降级，都在下个计费周期生效，野狗暂不提供退费/补费服务。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2437996.jpg)\n\n更多关于费用和账单的问题，你可以去 [常见问题](https://z.wilddog.com/questions)了解详情\n\n","source":"console/administer.md","raw":"title: 管理应用\n---\n\n点击应用卡片上的管理应用，会进入控制面板，它就是对应用进行配置和管理的地方。下面我们来重点看看控制面板里各个版块的使用。\n\n## 实时数据同步\n\n### 数据预览\n\n数据预览用于查看 APP 中现有的数据，它是根据 APP 的数据变化而实时变化的。你可以在这里方便地新增、删除数据。\n\n![](http://ocpo37x5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%8810.05.02.png)\n\n\n### 导入和导出数据\n\n在数据预览中，你可以通过文件夹上传或直接拖拽的方式导入你的本地数据。注意这里的文件的格式要求必须是 JSON 格式 ：\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/45083791.jpg)\n\n\n当然你也可以通过一键导出的方式，把数据下载到本地：\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/32430219.jpg)\n\n### 配置规则表达式\n\n\n规则表达式是野狗保护你的数据安全的最重要手段之一，我们强烈建议在你开始实时同步数据时，第一件事就是配置它。\n\n参考文档 [规则表达式](/guide/sync/rules/introduce.html)  深入了解具体配置的方法。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/21755337.jpg)\n\n## 资源统计\n\n资源统计页面可以查看你的应用数据存储、流量和并发连接的使用情况。同时我们每个月会发送资源统计情况到你的绑定邮箱，野狗工程团队在不遗余力地进行服务优化，以期提供更好的应用性能和更经济的费用。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/23554419.jpg)\n\n并发是指任何一个时间点，服务器上建立的长链接数量。这个长接连是可以复用的，也就是说对于同一个终端的用户，多次进行的数据读写或同一时间的多个数据读写，会复用这一个长接连。\n\n## 身份认证\n\n### 用户列表\n\n用户列表页面用于查看你的用户登录情况，这里会显示所有登录方式的终端用户。你可以随时追踪到他们的的登录方式、上次登录的时间等信息。同时，你可以通过邮箱搜索用户。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3057243.jpg)\n\n### 不同的身份认证方式\n\n通过配置你可以让你的用户通过邮箱密码、匿名、自定义登录方式或第三方的方式登录你的 App 。只需要在控制台里开启登录方式，然后进行相应配置就可以。\n\n你可以参考 [身份认证](/guide/auth/core/concept.html) 文档了解更多细节。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/83626118.jpg)\n\n\n#### 登录方式的设置\n\n在这里配置应用到的所有登录方式及 Wilddog ID Token 有效时长。当你使用自己的用户体系时，可以为特定用户单独配置 Wilddog ID Token有效时长。\n​该 Token 作为野狗用户进行数据操作等其他操作凭证。\n\n#### 超级密钥\n\n你可以配置 10 个超级密钥，并且可以为每一个超级密钥添加备注，使用时便于识别。\n\n\n## 安全\n\n安全域名是野狗保护你的数据安全的重要手段之一 。\n你开启安全域名后，可以设置 6 个域名作为你的“安全域名白名单”。只有在这个白名单下的域名，才能使用你的野狗应用，其他域名均无法调用。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3348371.jpg)\n\n\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/5151856.jpg)\n\n## 升级套餐\n\n点击应用卡片上的升级套餐，更改你的当前套餐。升级或付费套餐的升降级，都在下个计费周期生效，野狗暂不提供退费/补费服务。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2437996.jpg)\n\n更多关于费用和账单的问题，你可以去 [常见问题](https://z.wilddog.com/questions)了解详情\n\n","date":"2016-09-06T03:38:22.518Z","updated":"2016-09-06T03:38:22.518Z","path":"console/administer.html","comments":1,"layout":"page","_id":"cisswi9hd0003z4fwflfenw6h","content":"<p>点击应用卡片上的管理应用，会进入控制面板，它就是对应用进行配置和管理的地方。下面我们来重点看看控制面板里各个版块的使用。</p>\n<h2 id=\"实时数据同步\"><a href=\"#实时数据同步\" class=\"headerlink\" title=\"实时数据同步\"></a>实时数据同步</h2><h3 id=\"数据预览\"><a href=\"#数据预览\" class=\"headerlink\" title=\"数据预览\"></a>数据预览</h3><p>数据预览用于查看 APP 中现有的数据，它是根据 APP 的数据变化而实时变化的。你可以在这里方便地新增、删除数据。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%8810.05.02.png\" alt=\"\"></p>\n<h3 id=\"导入和导出数据\"><a href=\"#导入和导出数据\" class=\"headerlink\" title=\"导入和导出数据\"></a>导入和导出数据</h3><p>在数据预览中，你可以通过文件夹上传或直接拖拽的方式导入你的本地数据。注意这里的文件的格式要求必须是 JSON 格式 ：</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/45083791.jpg\" alt=\"\"></p>\n<p>当然你也可以通过一键导出的方式，把数据下载到本地：</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/32430219.jpg\" alt=\"\"></p>\n<h3 id=\"配置规则表达式\"><a href=\"#配置规则表达式\" class=\"headerlink\" title=\"配置规则表达式\"></a>配置规则表达式</h3><p>规则表达式是野狗保护你的数据安全的最重要手段之一，我们强烈建议在你开始实时同步数据时，第一件事就是配置它。</p>\n<p>参考文档 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>  深入了解具体配置的方法。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/21755337.jpg\" alt=\"\"></p>\n<h2 id=\"资源统计\"><a href=\"#资源统计\" class=\"headerlink\" title=\"资源统计\"></a>资源统计</h2><p>资源统计页面可以查看你的应用数据存储、流量和并发连接的使用情况。同时我们每个月会发送资源统计情况到你的绑定邮箱，野狗工程团队在不遗余力地进行服务优化，以期提供更好的应用性能和更经济的费用。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/23554419.jpg\" alt=\"\"></p>\n<p>并发是指任何一个时间点，服务器上建立的长链接数量。这个长接连是可以复用的，也就是说对于同一个终端的用户，多次进行的数据读写或同一时间的多个数据读写，会复用这一个长接连。</p>\n<h2 id=\"身份认证\"><a href=\"#身份认证\" class=\"headerlink\" title=\"身份认证\"></a>身份认证</h2><h3 id=\"用户列表\"><a href=\"#用户列表\" class=\"headerlink\" title=\"用户列表\"></a>用户列表</h3><p>用户列表页面用于查看你的用户登录情况，这里会显示所有登录方式的终端用户。你可以随时追踪到他们的的登录方式、上次登录的时间等信息。同时，你可以通过邮箱搜索用户。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3057243.jpg\" alt=\"\"></p>\n<h3 id=\"不同的身份认证方式\"><a href=\"#不同的身份认证方式\" class=\"headerlink\" title=\"不同的身份认证方式\"></a>不同的身份认证方式</h3><p>通过配置你可以让你的用户通过邮箱密码、匿名、自定义登录方式或第三方的方式登录你的 App 。只需要在控制台里开启登录方式，然后进行相应配置就可以。</p>\n<p>你可以参考 <a href=\"/guide/auth/core/concept.html\">身份认证</a> 文档了解更多细节。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/83626118.jpg\" alt=\"\"></p>\n<h4 id=\"登录方式的设置\"><a href=\"#登录方式的设置\" class=\"headerlink\" title=\"登录方式的设置\"></a>登录方式的设置</h4><p>在这里配置应用到的所有登录方式及 Wilddog ID Token 有效时长。当你使用自己的用户体系时，可以为特定用户单独配置 Wilddog ID Token有效时长。<br>​该 Token 作为野狗用户进行数据操作等其他操作凭证。</p>\n<h4 id=\"超级密钥\"><a href=\"#超级密钥\" class=\"headerlink\" title=\"超级密钥\"></a>超级密钥</h4><p>你可以配置 10 个超级密钥，并且可以为每一个超级密钥添加备注，使用时便于识别。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全域名是野狗保护你的数据安全的重要手段之一 。<br>你开启安全域名后，可以设置 6 个域名作为你的“安全域名白名单”。只有在这个白名单下的域名，才能使用你的野狗应用，其他域名均无法调用。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3348371.jpg\" alt=\"\"></p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/5151856.jpg\" alt=\"\"></p>\n<h2 id=\"升级套餐\"><a href=\"#升级套餐\" class=\"headerlink\" title=\"升级套餐\"></a>升级套餐</h2><p>点击应用卡片上的升级套餐，更改你的当前套餐。升级或付费套餐的升降级，都在下个计费周期生效，野狗暂不提供退费/补费服务。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2437996.jpg\" alt=\"\"></p>\n<p>更多关于费用和账单的问题，你可以去 <a href=\"https://z.wilddog.com/questions\" target=\"_blank\" rel=\"external\">常见问题</a>了解详情</p>\n","excerpt":"","more":"<p>点击应用卡片上的管理应用，会进入控制面板，它就是对应用进行配置和管理的地方。下面我们来重点看看控制面板里各个版块的使用。</p>\n<h2 id=\"实时数据同步\"><a href=\"#实时数据同步\" class=\"headerlink\" title=\"实时数据同步\"></a>实时数据同步</h2><h3 id=\"数据预览\"><a href=\"#数据预览\" class=\"headerlink\" title=\"数据预览\"></a>数据预览</h3><p>数据预览用于查看 APP 中现有的数据，它是根据 APP 的数据变化而实时变化的。你可以在这里方便地新增、删除数据。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-30%20%E4%B8%8B%E5%8D%8810.05.02.png\" alt=\"\"></p>\n<h3 id=\"导入和导出数据\"><a href=\"#导入和导出数据\" class=\"headerlink\" title=\"导入和导出数据\"></a>导入和导出数据</h3><p>在数据预览中，你可以通过文件夹上传或直接拖拽的方式导入你的本地数据。注意这里的文件的格式要求必须是 JSON 格式 ：</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/45083791.jpg\" alt=\"\"></p>\n<p>当然你也可以通过一键导出的方式，把数据下载到本地：</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/32430219.jpg\" alt=\"\"></p>\n<h3 id=\"配置规则表达式\"><a href=\"#配置规则表达式\" class=\"headerlink\" title=\"配置规则表达式\"></a>配置规则表达式</h3><p>规则表达式是野狗保护你的数据安全的最重要手段之一，我们强烈建议在你开始实时同步数据时，第一件事就是配置它。</p>\n<p>参考文档 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>  深入了解具体配置的方法。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/21755337.jpg\" alt=\"\"></p>\n<h2 id=\"资源统计\"><a href=\"#资源统计\" class=\"headerlink\" title=\"资源统计\"></a>资源统计</h2><p>资源统计页面可以查看你的应用数据存储、流量和并发连接的使用情况。同时我们每个月会发送资源统计情况到你的绑定邮箱，野狗工程团队在不遗余力地进行服务优化，以期提供更好的应用性能和更经济的费用。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/23554419.jpg\" alt=\"\"></p>\n<p>并发是指任何一个时间点，服务器上建立的长链接数量。这个长接连是可以复用的，也就是说对于同一个终端的用户，多次进行的数据读写或同一时间的多个数据读写，会复用这一个长接连。</p>\n<h2 id=\"身份认证\"><a href=\"#身份认证\" class=\"headerlink\" title=\"身份认证\"></a>身份认证</h2><h3 id=\"用户列表\"><a href=\"#用户列表\" class=\"headerlink\" title=\"用户列表\"></a>用户列表</h3><p>用户列表页面用于查看你的用户登录情况，这里会显示所有登录方式的终端用户。你可以随时追踪到他们的的登录方式、上次登录的时间等信息。同时，你可以通过邮箱搜索用户。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3057243.jpg\" alt=\"\"></p>\n<h3 id=\"不同的身份认证方式\"><a href=\"#不同的身份认证方式\" class=\"headerlink\" title=\"不同的身份认证方式\"></a>不同的身份认证方式</h3><p>通过配置你可以让你的用户通过邮箱密码、匿名、自定义登录方式或第三方的方式登录你的 App 。只需要在控制台里开启登录方式，然后进行相应配置就可以。</p>\n<p>你可以参考 <a href=\"/guide/auth/core/concept.html\">身份认证</a> 文档了解更多细节。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/83626118.jpg\" alt=\"\"></p>\n<h4 id=\"登录方式的设置\"><a href=\"#登录方式的设置\" class=\"headerlink\" title=\"登录方式的设置\"></a>登录方式的设置</h4><p>在这里配置应用到的所有登录方式及 Wilddog ID Token 有效时长。当你使用自己的用户体系时，可以为特定用户单独配置 Wilddog ID Token有效时长。<br>​该 Token 作为野狗用户进行数据操作等其他操作凭证。</p>\n<h4 id=\"超级密钥\"><a href=\"#超级密钥\" class=\"headerlink\" title=\"超级密钥\"></a>超级密钥</h4><p>你可以配置 10 个超级密钥，并且可以为每一个超级密钥添加备注，使用时便于识别。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全域名是野狗保护你的数据安全的重要手段之一 。<br>你开启安全域名后，可以设置 6 个域名作为你的“安全域名白名单”。只有在这个白名单下的域名，才能使用你的野狗应用，其他域名均无法调用。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/3348371.jpg\" alt=\"\"></p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/5151856.jpg\" alt=\"\"></p>\n<h2 id=\"升级套餐\"><a href=\"#升级套餐\" class=\"headerlink\" title=\"升级套餐\"></a>升级套餐</h2><p>点击应用卡片上的升级套餐，更改你的当前套餐。升级或付费套餐的升降级，都在下个计费周期生效，野狗暂不提供退费/补费服务。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2437996.jpg\" alt=\"\"></p>\n<p>更多关于费用和账单的问题，你可以去 <a href=\"https://z.wilddog.com/questions\">常见问题</a>了解详情</p>\n"},{"title":"简介","_content":"\n<h2 id='野狗是什么' class=\"article-heading top-heading\">野狗是什么</h2>\n野狗是国内领先的实时后端云。野狗为应用和开发者提供低成本的实时消息、语音、视频通信能力，以及安全的身份认证服务。它具有成本低、集成快和可按需扩容的特点。\n\n\n## 野狗的产品\n目前野狗的产品有 [实时数据同步](/overview/sync.html) 和 [身份认证](/overview/auth.html)。\n\n实时数据同步是野狗的核心实时通信引擎。它帮助用户快速实现基础通信、实时数据分发以及实时数据持久化。\n\n![](/images/introduction.png)\n\n\n身份认证帮助快速简化应用中用户认证流程的开发。\n\n![](/images/wilddogid.png)\n\n我们即将推出实时推送、实时音视频通话、多人在线会议的场景化 API 和 IM SDK。\n\n\n\n","source":"overview/index.md","raw":"title:  简介\n---\n\n<h2 id='野狗是什么' class=\"article-heading top-heading\">野狗是什么</h2>\n野狗是国内领先的实时后端云。野狗为应用和开发者提供低成本的实时消息、语音、视频通信能力，以及安全的身份认证服务。它具有成本低、集成快和可按需扩容的特点。\n\n\n## 野狗的产品\n目前野狗的产品有 [实时数据同步](/overview/sync.html) 和 [身份认证](/overview/auth.html)。\n\n实时数据同步是野狗的核心实时通信引擎。它帮助用户快速实现基础通信、实时数据分发以及实时数据持久化。\n\n![](/images/introduction.png)\n\n\n身份认证帮助快速简化应用中用户认证流程的开发。\n\n![](/images/wilddogid.png)\n\n我们即将推出实时推送、实时音视频通话、多人在线会议的场景化 API 和 IM SDK。\n\n\n\n","date":"2016-09-07T13:24:23.118Z","updated":"2016-09-07T13:24:23.118Z","path":"overview/index.html","_id":"cisswi9hd0004z4fwu6jr5jxv","comments":1,"layout":"page","content":"<p></p><h2 id=\"野狗是什么\" class=\"article-heading top-heading\">野狗是什么</h2><br>野狗是国内领先的实时后端云。野狗为应用和开发者提供低成本的实时消息、语音、视频通信能力，以及安全的身份认证服务。它具有成本低、集成快和可按需扩容的特点。<p></p>\n<h2 id=\"野狗的产品\"><a href=\"#野狗的产品\" class=\"headerlink\" title=\"野狗的产品\"></a>野狗的产品</h2><p>目前野狗的产品有 <a href=\"/overview/sync.html\">实时数据同步</a> 和 <a href=\"/overview/auth.html\">身份认证</a>。</p>\n<p>实时数据同步是野狗的核心实时通信引擎。它帮助用户快速实现基础通信、实时数据分发以及实时数据持久化。</p>\n<p><img src=\"/images/introduction.png\" alt=\"\"></p>\n<p>身份认证帮助快速简化应用中用户认证流程的开发。</p>\n<p><img src=\"/images/wilddogid.png\" alt=\"\"></p>\n<p>我们即将推出实时推送、实时音视频通话、多人在线会议的场景化 API 和 IM SDK。</p>\n","excerpt":"","more":"<p><h2 id='野狗是什么' class=\"article-heading top-heading\">野狗是什么</h2><br>野狗是国内领先的实时后端云。野狗为应用和开发者提供低成本的实时消息、语音、视频通信能力，以及安全的身份认证服务。它具有成本低、集成快和可按需扩容的特点。</p>\n<h2 id=\"野狗的产品\"><a href=\"#野狗的产品\" class=\"headerlink\" title=\"野狗的产品\"></a>野狗的产品</h2><p>目前野狗的产品有 <a href=\"/overview/sync.html\">实时数据同步</a> 和 <a href=\"/overview/auth.html\">身份认证</a>。</p>\n<p>实时数据同步是野狗的核心实时通信引擎。它帮助用户快速实现基础通信、实时数据分发以及实时数据持久化。</p>\n<p><img src=\"/images/introduction.png\" alt=\"\"></p>\n<p>身份认证帮助快速简化应用中用户认证流程的开发。</p>\n<p><img src=\"/images/wilddogid.png\" alt=\"\"></p>\n<p>我们即将推出实时推送、实时音视频通话、多人在线会议的场景化 API 和 IM SDK。</p>\n"},{"title":"实时数据同步","_content":"<h2 id='简介' class=\"article-heading top-heading\">简介</h2>\n**实时数据同步是野狗的核心实时通信引擎。** 用户在设备上对数据的任何修改，云端会自动推送到所有连接设备，时差以毫秒计算。\n\n![](/images/syncdevices.png)\n\n首先通过 2 个例子，让你了解野狗实时同步的强大之处。\n\n第 1 个例子：打开 2 个浏览器，进入[在线画板](http://drawing.wilddogapp.com/)，这是通过野狗实现的在线画板，一个人画的画可以实时同步到其他连接的浏览器。\n\n![](/images/sketchboard.png)\n\n第 2 个例子：打开浏览器，进入[多人外太空对战](https://www.wilddog.com/examples/game#)，这是通过野狗实现的 H5 实时游戏，扫描二维码，立刻可以体验实时多端对战。\n\n![](/images/starwar.png)\n\n野狗实时同步采用`本地操作，云端同步`。我们在每台设备上维护了一个数据副本，用户更改数据时，会优先对本地数据进行操作，再同步到云端。这样做能有效提升访问速度，同时很好地解决了网络不稳定时断网、离线问题。\n\n\n## 实时数据同步能做什么 \n实时数据同步主要应用在：基础实时通信、实时数据分发、数据持久化存储三个方向。以下介绍实时数据同步常见的应用场景。\n\n### 实时物联\n- 支持智能家居设备远程操作及状态同步、消息推送，地理位置实时更新，大量设备集中控制，实时状态统计，设备故障等实时推送场景。\n\n### 实时游戏\n- H5 互动游戏中的操作实时同步；可配合白鹭引擎等第三方开发工具，开发强互动的 H5 3D游戏。[查看 Demo](http://starwars.wilddogapp.com/)\n\n### 实时协作\n- 适用于多人在线文档协同编辑，资料实时同步、在线问答、需求沟通、项目管理等场景。[查看 Demo](http://wildpad.wilddogapp.com/#1)\n\n### 实时金融\n\n- 适用金融服务中大量的实时数据同步业务、包括股票行情、实盘演示；期货、黄金、债券、证券等金融领域的实时新闻推送。\n\n\n### 实时定位\n\n- 结合GPS数据，可以应用于外卖配送、物流定位等互动场景；也可应用于打车应用中的司机、乘客实时定位；社交应用中，最常见的场景就是：分享我的位置。[查看 Demo](http://geomap.wilddogapp.com/)\n\n\n\n## 实时数据同步解决的问题\n\n### 改变通信方式\n提升应用使用体验。帮助开发者将数据从一端迅速传递到另外一端，时差只有毫秒级。\n\n### 改变开发方式\n让开发者避开基础设施的构建，只需不到原来一半的时间和成本，完成产品开发任务。\n\n### 节省流量资源\n让开发者避免长期购买带宽造成资源浪费，使用野狗来完成动态数据的海量分发。\n\n\n## 实时数据同步的数据访问权限\n\n野狗提供身份认证、规则表达式两种方式，控制不同用户对数据的访问权限。\n\n![](/images/protect.png)\n\n### 身份认证：\n\n用户的登录信息中包含了唯一 ID，称为 Wilddog ID。并且用户认证身份后，其 Wilddog ID 永远保持不变。 Wilddog ID 控制不同用户对数据的访问权限。\n\n更多具体细节，请参考[身份认证](/overview/auth.html) 的文档。\n\n\n#### 规则表达式：\n\n\n我们提供了一种类 JavaScript 语法的表达式，用于定义数据的读写权限和校验规则，可以控制用户有权限访问哪些数据。\n \n更多具体细节，请参考 [规则表达式](/guide/sync/rules/introduce.html) 的文档。\n  \n\n\n\n\n","source":"overview/sync.md","raw":"title: 实时数据同步\n---\n<h2 id='简介' class=\"article-heading top-heading\">简介</h2>\n**实时数据同步是野狗的核心实时通信引擎。** 用户在设备上对数据的任何修改，云端会自动推送到所有连接设备，时差以毫秒计算。\n\n![](/images/syncdevices.png)\n\n首先通过 2 个例子，让你了解野狗实时同步的强大之处。\n\n第 1 个例子：打开 2 个浏览器，进入[在线画板](http://drawing.wilddogapp.com/)，这是通过野狗实现的在线画板，一个人画的画可以实时同步到其他连接的浏览器。\n\n![](/images/sketchboard.png)\n\n第 2 个例子：打开浏览器，进入[多人外太空对战](https://www.wilddog.com/examples/game#)，这是通过野狗实现的 H5 实时游戏，扫描二维码，立刻可以体验实时多端对战。\n\n![](/images/starwar.png)\n\n野狗实时同步采用`本地操作，云端同步`。我们在每台设备上维护了一个数据副本，用户更改数据时，会优先对本地数据进行操作，再同步到云端。这样做能有效提升访问速度，同时很好地解决了网络不稳定时断网、离线问题。\n\n\n## 实时数据同步能做什么 \n实时数据同步主要应用在：基础实时通信、实时数据分发、数据持久化存储三个方向。以下介绍实时数据同步常见的应用场景。\n\n### 实时物联\n- 支持智能家居设备远程操作及状态同步、消息推送，地理位置实时更新，大量设备集中控制，实时状态统计，设备故障等实时推送场景。\n\n### 实时游戏\n- H5 互动游戏中的操作实时同步；可配合白鹭引擎等第三方开发工具，开发强互动的 H5 3D游戏。[查看 Demo](http://starwars.wilddogapp.com/)\n\n### 实时协作\n- 适用于多人在线文档协同编辑，资料实时同步、在线问答、需求沟通、项目管理等场景。[查看 Demo](http://wildpad.wilddogapp.com/#1)\n\n### 实时金融\n\n- 适用金融服务中大量的实时数据同步业务、包括股票行情、实盘演示；期货、黄金、债券、证券等金融领域的实时新闻推送。\n\n\n### 实时定位\n\n- 结合GPS数据，可以应用于外卖配送、物流定位等互动场景；也可应用于打车应用中的司机、乘客实时定位；社交应用中，最常见的场景就是：分享我的位置。[查看 Demo](http://geomap.wilddogapp.com/)\n\n\n\n## 实时数据同步解决的问题\n\n### 改变通信方式\n提升应用使用体验。帮助开发者将数据从一端迅速传递到另外一端，时差只有毫秒级。\n\n### 改变开发方式\n让开发者避开基础设施的构建，只需不到原来一半的时间和成本，完成产品开发任务。\n\n### 节省流量资源\n让开发者避免长期购买带宽造成资源浪费，使用野狗来完成动态数据的海量分发。\n\n\n## 实时数据同步的数据访问权限\n\n野狗提供身份认证、规则表达式两种方式，控制不同用户对数据的访问权限。\n\n![](/images/protect.png)\n\n### 身份认证：\n\n用户的登录信息中包含了唯一 ID，称为 Wilddog ID。并且用户认证身份后，其 Wilddog ID 永远保持不变。 Wilddog ID 控制不同用户对数据的访问权限。\n\n更多具体细节，请参考[身份认证](/overview/auth.html) 的文档。\n\n\n#### 规则表达式：\n\n\n我们提供了一种类 JavaScript 语法的表达式，用于定义数据的读写权限和校验规则，可以控制用户有权限访问哪些数据。\n \n更多具体细节，请参考 [规则表达式](/guide/sync/rules/introduce.html) 的文档。\n  \n\n\n\n\n","date":"2016-09-07T13:24:23.121Z","updated":"2016-09-07T13:24:23.121Z","path":"overview/sync.html","_id":"cisswi9hd0005z4fwniel07jg","comments":1,"layout":"page","content":"<p></p><h2 id=\"简介\" class=\"article-heading top-heading\">简介</h2><br><strong>实时数据同步是野狗的核心实时通信引擎。</strong> 用户在设备上对数据的任何修改，云端会自动推送到所有连接设备，时差以毫秒计算。<p></p>\n<p><img src=\"/images/syncdevices.png\" alt=\"\"></p>\n<p>首先通过 2 个例子，让你了解野狗实时同步的强大之处。</p>\n<p>第 1 个例子：打开 2 个浏览器，进入<a href=\"http://drawing.wilddogapp.com/\" target=\"_blank\" rel=\"external\">在线画板</a>，这是通过野狗实现的在线画板，一个人画的画可以实时同步到其他连接的浏览器。</p>\n<p><img src=\"/images/sketchboard.png\" alt=\"\"></p>\n<p>第 2 个例子：打开浏览器，进入<a href=\"https://www.wilddog.com/examples/game#\" target=\"_blank\" rel=\"external\">多人外太空对战</a>，这是通过野狗实现的 H5 实时游戏，扫描二维码，立刻可以体验实时多端对战。</p>\n<p><img src=\"/images/starwar.png\" alt=\"\"></p>\n<p>野狗实时同步采用<code>本地操作，云端同步</code>。我们在每台设备上维护了一个数据副本，用户更改数据时，会优先对本地数据进行操作，再同步到云端。这样做能有效提升访问速度，同时很好地解决了网络不稳定时断网、离线问题。</p>\n<h2 id=\"实时数据同步能做什么\"><a href=\"#实时数据同步能做什么\" class=\"headerlink\" title=\"实时数据同步能做什么\"></a>实时数据同步能做什么</h2><p>实时数据同步主要应用在：基础实时通信、实时数据分发、数据持久化存储三个方向。以下介绍实时数据同步常见的应用场景。</p>\n<h3 id=\"实时物联\"><a href=\"#实时物联\" class=\"headerlink\" title=\"实时物联\"></a>实时物联</h3><ul>\n<li>支持智能家居设备远程操作及状态同步、消息推送，地理位置实时更新，大量设备集中控制，实时状态统计，设备故障等实时推送场景。</li>\n</ul>\n<h3 id=\"实时游戏\"><a href=\"#实时游戏\" class=\"headerlink\" title=\"实时游戏\"></a>实时游戏</h3><ul>\n<li>H5 互动游戏中的操作实时同步；可配合白鹭引擎等第三方开发工具，开发强互动的 H5 3D游戏。<a href=\"http://starwars.wilddogapp.com/\" target=\"_blank\" rel=\"external\">查看 Demo</a></li>\n</ul>\n<h3 id=\"实时协作\"><a href=\"#实时协作\" class=\"headerlink\" title=\"实时协作\"></a>实时协作</h3><ul>\n<li>适用于多人在线文档协同编辑，资料实时同步、在线问答、需求沟通、项目管理等场景。<a href=\"http://wildpad.wilddogapp.com/#1\" target=\"_blank\" rel=\"external\">查看 Demo</a></li>\n</ul>\n<h3 id=\"实时金融\"><a href=\"#实时金融\" class=\"headerlink\" title=\"实时金融\"></a>实时金融</h3><ul>\n<li>适用金融服务中大量的实时数据同步业务、包括股票行情、实盘演示；期货、黄金、债券、证券等金融领域的实时新闻推送。</li>\n</ul>\n<h3 id=\"实时定位\"><a href=\"#实时定位\" class=\"headerlink\" title=\"实时定位\"></a>实时定位</h3><ul>\n<li>结合GPS数据，可以应用于外卖配送、物流定位等互动场景；也可应用于打车应用中的司机、乘客实时定位；社交应用中，最常见的场景就是：分享我的位置。<a href=\"http://geomap.wilddogapp.com/\" target=\"_blank\" rel=\"external\">查看 Demo</a></li>\n</ul>\n<h2 id=\"实时数据同步解决的问题\"><a href=\"#实时数据同步解决的问题\" class=\"headerlink\" title=\"实时数据同步解决的问题\"></a>实时数据同步解决的问题</h2><h3 id=\"改变通信方式\"><a href=\"#改变通信方式\" class=\"headerlink\" title=\"改变通信方式\"></a>改变通信方式</h3><p>提升应用使用体验。帮助开发者将数据从一端迅速传递到另外一端，时差只有毫秒级。</p>\n<h3 id=\"改变开发方式\"><a href=\"#改变开发方式\" class=\"headerlink\" title=\"改变开发方式\"></a>改变开发方式</h3><p>让开发者避开基础设施的构建，只需不到原来一半的时间和成本，完成产品开发任务。</p>\n<h3 id=\"节省流量资源\"><a href=\"#节省流量资源\" class=\"headerlink\" title=\"节省流量资源\"></a>节省流量资源</h3><p>让开发者避免长期购买带宽造成资源浪费，使用野狗来完成动态数据的海量分发。</p>\n<h2 id=\"实时数据同步的数据访问权限\"><a href=\"#实时数据同步的数据访问权限\" class=\"headerlink\" title=\"实时数据同步的数据访问权限\"></a>实时数据同步的数据访问权限</h2><p>野狗提供身份认证、规则表达式两种方式，控制不同用户对数据的访问权限。</p>\n<p><img src=\"/images/protect.png\" alt=\"\"></p>\n<h3 id=\"身份认证：\"><a href=\"#身份认证：\" class=\"headerlink\" title=\"身份认证：\"></a>身份认证：</h3><p>用户的登录信息中包含了唯一 ID，称为 Wilddog ID。并且用户认证身份后，其 Wilddog ID 永远保持不变。 Wilddog ID 控制不同用户对数据的访问权限。</p>\n<p>更多具体细节，请参考<a href=\"/overview/auth.html\">身份认证</a> 的文档。</p>\n<h4 id=\"规则表达式：\"><a href=\"#规则表达式：\" class=\"headerlink\" title=\"规则表达式：\"></a>规则表达式：</h4><p>我们提供了一种类 JavaScript 语法的表达式，用于定义数据的读写权限和校验规则，可以控制用户有权限访问哪些数据。</p>\n<p>更多具体细节，请参考 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 的文档。</p>\n","excerpt":"","more":"<p><h2 id='简介' class=\"article-heading top-heading\">简介</h2><br><strong>实时数据同步是野狗的核心实时通信引擎。</strong> 用户在设备上对数据的任何修改，云端会自动推送到所有连接设备，时差以毫秒计算。</p>\n<p><img src=\"/images/syncdevices.png\" alt=\"\"></p>\n<p>首先通过 2 个例子，让你了解野狗实时同步的强大之处。</p>\n<p>第 1 个例子：打开 2 个浏览器，进入<a href=\"http://drawing.wilddogapp.com/\">在线画板</a>，这是通过野狗实现的在线画板，一个人画的画可以实时同步到其他连接的浏览器。</p>\n<p><img src=\"/images/sketchboard.png\" alt=\"\"></p>\n<p>第 2 个例子：打开浏览器，进入<a href=\"https://www.wilddog.com/examples/game#\">多人外太空对战</a>，这是通过野狗实现的 H5 实时游戏，扫描二维码，立刻可以体验实时多端对战。</p>\n<p><img src=\"/images/starwar.png\" alt=\"\"></p>\n<p>野狗实时同步采用<code>本地操作，云端同步</code>。我们在每台设备上维护了一个数据副本，用户更改数据时，会优先对本地数据进行操作，再同步到云端。这样做能有效提升访问速度，同时很好地解决了网络不稳定时断网、离线问题。</p>\n<h2 id=\"实时数据同步能做什么\"><a href=\"#实时数据同步能做什么\" class=\"headerlink\" title=\"实时数据同步能做什么\"></a>实时数据同步能做什么</h2><p>实时数据同步主要应用在：基础实时通信、实时数据分发、数据持久化存储三个方向。以下介绍实时数据同步常见的应用场景。</p>\n<h3 id=\"实时物联\"><a href=\"#实时物联\" class=\"headerlink\" title=\"实时物联\"></a>实时物联</h3><ul>\n<li>支持智能家居设备远程操作及状态同步、消息推送，地理位置实时更新，大量设备集中控制，实时状态统计，设备故障等实时推送场景。</li>\n</ul>\n<h3 id=\"实时游戏\"><a href=\"#实时游戏\" class=\"headerlink\" title=\"实时游戏\"></a>实时游戏</h3><ul>\n<li>H5 互动游戏中的操作实时同步；可配合白鹭引擎等第三方开发工具，开发强互动的 H5 3D游戏。<a href=\"http://starwars.wilddogapp.com/\">查看 Demo</a></li>\n</ul>\n<h3 id=\"实时协作\"><a href=\"#实时协作\" class=\"headerlink\" title=\"实时协作\"></a>实时协作</h3><ul>\n<li>适用于多人在线文档协同编辑，资料实时同步、在线问答、需求沟通、项目管理等场景。<a href=\"http://wildpad.wilddogapp.com/#1\">查看 Demo</a></li>\n</ul>\n<h3 id=\"实时金融\"><a href=\"#实时金融\" class=\"headerlink\" title=\"实时金融\"></a>实时金融</h3><ul>\n<li>适用金融服务中大量的实时数据同步业务、包括股票行情、实盘演示；期货、黄金、债券、证券等金融领域的实时新闻推送。</li>\n</ul>\n<h3 id=\"实时定位\"><a href=\"#实时定位\" class=\"headerlink\" title=\"实时定位\"></a>实时定位</h3><ul>\n<li>结合GPS数据，可以应用于外卖配送、物流定位等互动场景；也可应用于打车应用中的司机、乘客实时定位；社交应用中，最常见的场景就是：分享我的位置。<a href=\"http://geomap.wilddogapp.com/\">查看 Demo</a></li>\n</ul>\n<h2 id=\"实时数据同步解决的问题\"><a href=\"#实时数据同步解决的问题\" class=\"headerlink\" title=\"实时数据同步解决的问题\"></a>实时数据同步解决的问题</h2><h3 id=\"改变通信方式\"><a href=\"#改变通信方式\" class=\"headerlink\" title=\"改变通信方式\"></a>改变通信方式</h3><p>提升应用使用体验。帮助开发者将数据从一端迅速传递到另外一端，时差只有毫秒级。</p>\n<h3 id=\"改变开发方式\"><a href=\"#改变开发方式\" class=\"headerlink\" title=\"改变开发方式\"></a>改变开发方式</h3><p>让开发者避开基础设施的构建，只需不到原来一半的时间和成本，完成产品开发任务。</p>\n<h3 id=\"节省流量资源\"><a href=\"#节省流量资源\" class=\"headerlink\" title=\"节省流量资源\"></a>节省流量资源</h3><p>让开发者避免长期购买带宽造成资源浪费，使用野狗来完成动态数据的海量分发。</p>\n<h2 id=\"实时数据同步的数据访问权限\"><a href=\"#实时数据同步的数据访问权限\" class=\"headerlink\" title=\"实时数据同步的数据访问权限\"></a>实时数据同步的数据访问权限</h2><p>野狗提供身份认证、规则表达式两种方式，控制不同用户对数据的访问权限。</p>\n<p><img src=\"/images/protect.png\" alt=\"\"></p>\n<h3 id=\"身份认证：\"><a href=\"#身份认证：\" class=\"headerlink\" title=\"身份认证：\"></a>身份认证：</h3><p>用户的登录信息中包含了唯一 ID，称为 Wilddog ID。并且用户认证身份后，其 Wilddog ID 永远保持不变。 Wilddog ID 控制不同用户对数据的访问权限。</p>\n<p>更多具体细节，请参考<a href=\"/overview/auth.html\">身份认证</a> 的文档。</p>\n<h4 id=\"规则表达式：\"><a href=\"#规则表达式：\" class=\"headerlink\" title=\"规则表达式：\"></a>规则表达式：</h4><p>我们提供了一种类 JavaScript 语法的表达式，用于定义数据的读写权限和校验规则，可以控制用户有权限访问哪些数据。</p>\n<p>更多具体细节，请参考 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 的文档。</p>\n"},{"title":"完整 API 文档","_content":"\n# AuthResult\n\npublic interface **AuthResult**\n\n结果对象获得的操作会影响认证状态。包含一个方法,在操作完成后返回当前登录用户。\n\n## Public Method Summary\n\nWilddogUser  abstract  getUser() \n\n\n## Public Methods\n\npublic abstract FirebaseUser getUser ()\n\n### returns\n\n当前帐号WilddogUser,如果没有则为null(即用户登出)。\n\n----\n# WilddogAuth.AuthStateListener\n\npublic static interface **WilddogAuth.AuthStateListener**\n\n当身份验证状态有一个变化的时候调用。\n\n使用`addAuthStateListener(AuthStateListener)`和`removeAuthStateListener(AuthStateListener)`来注册或者注销监听\n## Public Method Summary\nvoid    abstract      onAuthStateChanged(WilddogAuth auth)\n\n         当状态发生变化的时候，这个方法在UI线程中调用\n\n               * 注册监听的时候\n               * 用户登录的时候\n               * 用户登出的时候\n               * 当前用户改变的时候\n               * 当前用户的token改变的时候\n\n## Public Methods\n\npublic abstract void onAuthStateChanged (WilddogAuth auth)\n\n\n 当状态发生变化的时候，这个方法在UI线程中调用：\n\n               * 注册监听的时候\n               * 用户登录的时候\n               * 用户登出的时候\n               * 当前用户改变的时候\n               * 当前用户的token改变的时候\n\n\n### Parameters\nauth  当前WilddogAuth 对象，用来进行Auth相关操作。  \n\n\n----\n             \n# WilddogAuthProvider\n\npublic interface **WilddogAuthProvider**\n\n提供Auth身份验证类型\n\n## Constant Summary\n\nString  PROVIDER_ID\t  身份验证类型唯一字符标识。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\nUnique string identifier for this provider type.\n\nConstant Value: \"wilddog\"    \n          \n-----               \n               \n# UserInfo\n\n\npublic interface **UserInfo**\n\n已知直接子类\n\nWilddogUser\n\n  获取一个用户的标准用户配置信息。可用于身份验证提供者返回的用户配置信息，例如QQ登录或者微信登录。\n  \n## Public Method Summary\n\n  abstract String getDisplayName()\n  \n  如果可用，返回用户昵称。\n  \n  abstract String getEmail()\n  \n  如果可用，返回指定认证提供类型的电子邮箱地址\n  \n  abstract Uri\tgetPhotoUrl()\n  \n  如果可用，返回用户设置的形象照片的URL\n  \n  abstract String getProviderId()\n  \n 返回提供者类型实例的唯一标识符\n\n  abstract String\tgetUid()\n  \n  返回一个身份验证提供者指定的用户标识符。\n  \n## Public Methods\n\npublic abstract String getDisplayName ()\n  \n如果可用，返回用户昵称。\n   \n   \npublic abstract String getEmail ()\n  \n返回对应于指定提供者的用户帐户的电子邮件地址，包含可选。\n  \npublic abstract Uri getPhotoUrl ()\n  \n如果可用，返回用户形象照片。\n  \npublic abstract String getProviderId ()\n  \n返回提供者类型实例的唯一标识符，例如QQ，weixin。\n  \npublic abstract String getUid ()\n  \n返回一个身份验证提供者指定的用户标识符。例如，如果是qq返回qq的uid，如果是微博，返回微博的openId。\n\n----                 \n\n\n# AuthCredential\npublic abstract class **AuthCredential** extends Object\n\n已知直接子类\nEmailAuthCredential，QQAuthCredential，WeiboAuthCredential，WeiXinAuthCredential\n\n代表Wilddog支持的身份认证的方式的认证凭据。\n\n## Public Method Summary\n\nabstract String    getProvider\\(\\)\n\n返回使用的认证方式的类型唯一标识。\n\n## Public Methods\n\npublic abstract String getProvider \\(\\)\n\n返回使用的认证方式的类型唯一标识。例如：\"weixin\"，\"qq\"，\"weibo\"，\"password\"\n\n----\n# EmailAuthCredential\n\npublic class **EmailAuthCredential** extends AuthCredential\n\n包含邮箱和密码的身份认证方式\n\n## Public Method Summary\nString\tgetProvider()\n\n返回使用的认证方式的类型唯一标识。\n\n## public String getProvider ()\n\n返回类型为\"password\"类型的认证方式唯一标识。\n\n----\n# EmailAuthProvider\npublic class **EmailAuthProvider** extends Object\n\n代表了电子邮件和密码身份验证机制，使用这个类来获取EmailAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\nstatic AuthCredential\tgetCredential(String email, String password)\n\n返回一个带有用户名和密码的用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"password\"\n\n\n## Public Methods\npublic static AuthCredential getCredential (String email, String password)\n\n返回一个带有用户名和密码的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n# QQAuthCredential \npublic class QQAuthCredential extends AuthCredential\n\n包含qq accessToken的认证凭据\n\n## Public Method Summary\n\nString\tgetProvider()\n\n返回身份认证的唯一标识 \"qq\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\n## Public Methods\n\npublic String getProvider ()\n\n返回身份认证的唯一标识 \"qq\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\n----\n# QQAuthProvider\n\npublic class **QQAuthProvider** extends Object\n\n代表了QQ身份认证机制，使用这个类来获取QQAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\nstatic AuthCredential\tgetCredential(String token)\n\n返回一个带有accessToken的QQ用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"qq\"\n\n\n## Public Methods\npublic static AuthCredential getCredential (String token)\n\n返回一个带有用户名和密码的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n# WeiboAuthCredential\n\npublic class WeiboAuthCredential extends AuthCredential\n\n包含微博 accessToken和uid的认证凭据\n\n## Public Method Summary\n\nString\tgetProvider()\n\n返回身份认证的唯一标识 \"weibo\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\n public String getUid()\n \n 返回要上传的微博平台唯一标识uid。\n\n## Public Methods\n\npublic String getProvider ()\n\n返回身份认证的唯一标识 \"weibo\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\npublic String getUid()\n \n返回要上传的微博平台唯一标识uid。\n\n----\n# WeiboAuthProvider\n\npublic class **WeiboAuthProvider** extends Object\n\n代表了新浪微博身份认证机制，使用这个类来获取WeiboAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\n static AuthCredential getCredential( String token,String openId) \n\n返回一个带有token和openId的用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"weibo\"\n\n\n## Public Methods\npublic static AuthCredential getCredential (String token,String openId)\n\n返回一个带有用户名和密码的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n\n# WeiXinAuthCredential\n\npublic class WeiboAuthCredential extends AuthCredential\n\n包含微信code的认证凭据\n\n## Public Method Summary\n\nString\tgetProvider()\n\n返回身份认证的唯一标识 \"weixin\"\n\npublic String getCode()\n\n返回微信授权认证返回的code。\n\n## Public Methods\n\npublic String getProvider ()\n\n返回身份认证的唯一标识 \"weixin\"\n\npublic String getCode()\n\n返回微信授权认证返回的code。\n\n----\n\n# WeiXinAuthProvider\n\npublic class **WeiXinAuthProvider** extends Object\n\n代表了微信身份认证机制，使用这个类来获取WeiXinAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\n static AuthCredential getCredential( String code) \n\n返回一个带有code的用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"weixin\"\n\n\n## Public Methods\npublic static AuthCredential getCredential ( String code)\n\n返回一个带有code的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n\n# GetTokenResult\n\npublic class GetTokenResult extends Object\n\n返回WilddogIdToken结果对象\n\n## Public Method Summary\n\nString\tgetToken()\n\nWilddog ID Token.\n\n## Public Methods\n\npublic String getToken ()\n\nWilddog ID Token. 身份认证成功后返回的Wilddog Id token字符串。用于验证之后操作的身份完整性和安全性。\n\n----\n# UserProfileChangeRequest\n\n\n\npublic class UserProfileChangeRequest extends Object\nimplements SafeParcelable\n\n用来更新用户信息的请求对象\n\n\n## Nested Class Summary\n\nclass\tUserProfileChangeRequest.Builder\t\n\n构建请求的内部类\n\n\n\n\n## Public Method Summary\n\nString\tgetDisplayName()\n\n返回要修改的昵称信息\n\nUri\tgetPhotoUri()\n\n返回要修改的头像URL\n\n\n## Public Methods\n\npublic String getDisplayName ()\n\n返回要修改的昵称信息\n\npublic Uri getPhotoUri ()\n\n返回要修改的头像URL\n\n----\n\n# UserProfileChangeRequest.Builder\n\n\n\n\npublic static class UserProfileChangeRequest.Builder extends Object\n\n请求构建器\n\n## Public Constructor Summary\n\nUserProfileChangeRequest.Builder()\n\n## Public Method Summary\n\nUserProfileChangeRequest\tbuild()\n\n构建一个修改用户信息的请求对象\n\nUserProfileChangeRequest.Builder setDisplayName(String displayName)\n\n设置要更新的昵称\n\nUserProfileChangeRequest.Builder setPhotoUri(Uri photoUri)\n\n设置要更新头像的URL.\n\n\n## Public Constructors\n\npublic UserProfileChangeRequest.Builder ()\n\n## Public Methods\n\npublic UserProfileChangeRequest build ()\n\n### returns\n\n* 一个UserProfileChangeRequest实例\n\n\n\npublic UserProfileChangeRequest.Builder setDisplayName (String displayName)\n\n设置要修改的昵称。\n\n### returns\n\n* 一个可以链式调用的UserProfileChangeRequest.Builder对象\n\n\n\npublic UserProfileChangeRequest.Builder setPhotoUri (Uri photoUri)\n\n设置要修改的头像的URL。\n\n\n### returns\n\n* 一个可以链式调用的UserProfileChangeRequest.Builder对象\n\n----\n\n\n\n\n# WilddogAuth\n\npublic abstract class WilddogAuth extends Object\n\nWilddogAuth SDK入口对象。\n\n首先通过调用 getInstance(\"appId\",context)获取一个WilddogAuth实例对象。\n接着，可以使用一下方法进行用户登录认证：\n    \n*      createUserWithEmailAndPassword(String, String)\n*      signInWithEmailAndPassword(String, String)\n*      signInWithCredential(AuthCredential)\n*      signInAnonymously()\n*      signInWithCustomToken(String)\n\n最后，调用 `getCurrentUser()`获取包含用户信息的WilddogUser对象.\n\n## Nested Class Summary\ninterface\tWilddogAuth.AuthStateListener\t\n    当认证状态发生变化的时候调用\n    \n ## Public Method Summary\n \n void\taddAuthStateListener(FirebaseAuth.AuthStateListener listener)\n \n 注册认证状态改变的监听.\n \n\n \n Task<```AuthResult```>\tcreateUserWithEmailAndPassword(String email, String password)\n \n 试图去创建一个新的邮箱密码的用户账号。\n \n\n \n Task<```ProviderQueryResult```>\tfetchProvidersForEmail(String email)\n \n 如果存在，则通过邮箱获取所有的认证类型。\n \n\n \n WilddogUser\tgetCurrentUser()\n \n \n 返回当前认证的用户信息，如果未认证返回null.\n \n\n \n static WilddogAuth\tgetInstance()\n \n 返回初始化之后，可以用本方法获取WilddogAuth实例对象\n \n\n \n static WilddogAuth\tgetInstance(String appId，Context context)\n \n 返回初始化WilddogAuth 实例对象。\n \n \n\n \n void\tremoveAuthStateListener(WilddogAuth.AuthStateListener listener)\n \n 注销曾经认证状态监听对象\n \n\n \n Task<Void>\tsendPasswordResetEmail(String email)\n \n 给当前应用中现有的绑定当前email的用户发送密码重置邮件.\n \n\n Task<```AuthResult```>\tsignInAnonymously()\n \n 使用匿名方法登录，不需要凭据，可以绑定其他认证方式.\n \n\n \n Task<```AuthResult```>\tsignInWithCredential(AuthCredential credential)\n \n 通过AuthCredential进行用户认证，支持的认证方式：qq，微博，微信，密码\n \n\n \n Task<```AuthResult```>\tsignInWithCustomToken(String token)\n \n 通过用户自定义的token进行用户认证。\n \n\n \n Task<```AuthResult```>\tsignInWithEmailAndPassword(String email, String password)\n \n 通过用户邮箱密码的方式进行用户认证\n \n\n \n void\tsignOut()\n \n 登出当前用户，清除登录数据\n \n ## Public Methods\n \n \n public void addAuthStateListener (FirebaseAuth.AuthStateListener listener)\n \n 注册一个认证状态的监听。一个WilddogAuth对象可以设置多个监听对象，也可以为不同的WilddogAuth添加监听对象。\n \n   当以下情况出现，会在UI线程中触发回调：\n \n   * 在监听对象注册的时候\n   * 在用户登录认证的时候\n   * 在当前用户登出的时候\n   * 在当前用户改变的时候\n   * 在当前用户的Wilddog Id token 改变的时候\n\n    推荐的做法总是监听注销事件，因为你可能要提示用户再次登录并且可能限制用户获取信息或者操作.\n    \n    可以使用`removeAuthStateListener(AuthStateListener)`注销监听.\n    \n \n    \n  public Task<```AuthResult```> createUserWithEmailAndPassword (String email, String password)  \n  试图用给定的邮箱和密码创建一个用户账号，如果成功，这个用户也将登录成功。\n  \n  然后可以通过`getCurrentUser()`访问用户信息和进行用户操作.\n  \n  一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法\n  \n  **注意:** 你必须在Wilddog控制面板中打开这种登录认证方式。\n  \n  ### returns\n\n返回带有AuthResult的操作结果对象Task\n\n\n\npublic Task<```ProviderQueryResult```> fetchProvidersForEmail (String email)\n\n  返回通过绑定的主邮箱获取当前用户的认证方式列表\n\n当你绑定多种认证机制的时候，这个方法将会返回所有的认证方式列表。\n\n### Parameters\n\nemail\n\n用户返回登录认证方式列表的邮箱地址\n\n### returns\n\n返回带有AuthResult的操作结果对象Task\n\n\npublic WilddogUser getCurrentUser ()\n\n如果有用户认证登录返回登录用户，如果没有登录，则返回为空。\n\n可以通过 `getCurrentUser() != null` 来判断当前是否有用户登录\n\n### returns\n* 当前认证用户或者null\n\n\n\n\npublic static WilddogAuth getInstance ()\n\n\n\n 返回初始化之后，可以用本方法获取当前WilddogAuth实例对象\n\n\n\n public static WilddogAuth getInstance(String appId，Context context)\n \n  返回初始化WilddogAuth 实例对象。\n \n\n \n public void removeAuthStateListener (WilddogAuth.AuthStateListener listener)\n \n 注销认证状态的监听\n \n \n \n public Task<Void> sendPasswordResetEmail (String email)\n \n  给当前应用中现有的绑定当前email的用户发送密码重置邮件.\n  \n  \n  返回当前操作结果的Task对象\n  \n\n  \n  public Task<```AuthResult```> signInAnonymously ()\n  \n   使用匿名方法登录，不需要凭据，可以绑定其他认证方式.\n   \n   这个操作将在Wilddog创建一个匿名的用户账号，其中通过`getCurrentUser()`获取用户信息包含uid。\n   \n一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n   \n   \n  \n   \n  **注意:** 你必须在Wilddog控制面板中打开这种登录认证方式。\n    \n    \n\npublic Task<AuthResult> signInWithCredential (AuthCredential credential)\n\n通过给定的`AuthCredential`对象进行相应的认证登录。其中包含QQ，微信，新浪微博和密码认证登录。\n\n所有`AuthCredential`都会创建一个用户账号。\n\n**注意:** 你必须在Wilddog控制面板中打开相应的登录认证方式。\n    \n ### returns\n\n返回带有AuthResult的操作结果对象Task    \n\n\npublic Task<`AuthResult`> signInWithCustomToken (String token)\n\n通过用户自定义的token进行用户认证。\n\n  从用户服务器首先获取到Wilddog Custom Token,然后登录到Wilddog服务器，进行数据操作，可以通过getCurrentUser获取当前登录认证用户信息。\n  \n  一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n  \n  阅读[自定义Token]()\n  \n### returns\n\n返回带有AuthResult的操作结果对象Task   \n\npublic Task<AuthResult> signInWithEmailAndPassword (String email, String password)\n\n通过邮箱和密码进行登录认证。\n\n可以通过getCurrentUser获取当前登录认证用户信息。\n\n  一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n  \n  **注意:** 你必须在Wilddog控制面板中打开这种登录认证方式。\n  \n  这个方法和`signInWithCredential（）`的`EmailAuthCredential`登录认证方式是等效的。\n  \n### returns\n\n返回带有AuthResult的操作结果对象Task\n\n\npublic void signOut ()\n\n登出当前用户，清除登录数据\n\n一旦登出成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n\n\n----\n\n# WilddogUser\n\npublic abstract class WilddogUser extends Object\nimplements UserInfo\n\n获取用户在Wilddog Auth的个人资料信息。它还有辅助方法进行用户信息的修改和查询，以及管理用户的身份验证方式。\n\n## Public Constructor Summary\nWilddogUser（）\n\n## Public Method Summary\n\nTask<Void> delete()\n\n从Wilddog Auth 系统中删除用户.\n\n\n\nabstract String\tgetDisplayName()\n\n获取在Wilddog Auth 系统中的用户的昵称.\n\n\n\nabstract String\tgetEmail()\n\n获取在Wilddog Auth 系统中的用户的邮箱.\n\n\nabstract Uri\tgetPhotoUrl()\n\n获取在Wilddog Auth 系统中的用户的头像的URL.\n\n\n\nabstract List<? extends UserInfo>\tgetProviderData()\n\n获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.\n\n\n\nabstract String\tgetProviderId()\n\n返回PROVIDER_ID，例如 \"qq\",\"weixin\".\n\n\n\nTask<`GetTokenResult`>\tgetToken(boolean forceRefresh)\n\n获取Wilddog ID Token\n\n\n\nabstract String\tgetUid()\n\n获取在Wilddog Auth 系统中的用户的唯一标识.\n\n\n\nabstract boolean\tisAnonymous()\n\n判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。\n\n\n\nTask<`AuthResult`>\tlinkWithCredential(AuthCredential credential)\n\n将当前用户与给定的登录认证方式绑定。\n\n\n\nTask<`Void`>\treauthenticate(AuthCredential credential)\n\n用给定的登录认证方式重新认证。\n\n\nTask<`Void`>\treload()\n\n手动刷新当前用户的数据。（连接提供者，显示名称等等）\n\n\n\nTask<`AuthResult`>\tunlink(String provider)\n\n将给定的登录认证类型从当前用户绑定列表中解除绑定.\n\n\n\nTask<`Void`>\tupdateEmail(String email)\n\n更新当前登录认证用户的邮箱信息.\n\n\n\nTask<`Void`>\tupdatePassword(String password)\n\n更新当前登录认证用户的密码信息.\n\n\n\nTask<`Void`>\tupdateProfile(UserProfileChangeRequest request)\n\n更新当前用户的昵称信息和头像URL\n\n\n\n## Public Constructors\n\npublic WilddogUser ()\n\n\n\n\n## Public Methods\n\n\n  public Task<`Void`> delete ()\n  \n  从Wilddog Auth 系统中删除用户.\n  如果操作成功，用户将从登录系统中登出。\n  这个是一个安全敏感操作，需要用户用户最近登录过才能操作成功，如果失败，请先使用`reauthenticate(AuthCredential)`方法.\n  \n\n  \n  public abstract String getDisplayName ()\n  \n    获取当前用户的昵称，如果是第三方登录方式，不能修改昵称信息，因此不会第三方登录平台昵称不会受到影响。使用`updateProfile(UserProfileChangeRequest)`方法会更新这个属性。\n\n如果使用`signInWithCredential （ AuthCredential ）`登录的时候包含这个属性，将在登录时候自动创建填充属性。\n  \n\n  \n  public abstract String getEmail ()\n  \n  \n  返回当前用户设置的邮箱地址，如果第三方登录中含有这个属性，将不能被修改。\n  其他情况下可以通过`updateProfile(UserProfileChangeRequest)`方法会更新这个属性.\n  \n  这个属性将会在`signInWithCredential(AuthCredential)`的`EmailAuthCredential`或者`createUserWithEmailAndPassword(String, String)`填充这个属性.\n  \n\n  \n  public abstract Uri getPhotoUrl ()\n  \n  返回当前用户的头像的url，如果第三方登录中含有这个属性，将不能被修改。\n   其他情况下可以通过`updateProfile(UserProfileChangeRequest)`方法会更新这个属性.\n   \n   如果使用`signInWithCredential （ AuthCredential ）`登录的时候包含这个属性，将在登录时候自动创建填充属性。\n   \n\n   \n  abstract List<? extends UserInfo>\tgetProviderData()\n\n获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.\n\n\n\n\nabstract String\tgetProviderId()\n\n返回PROVIDER_ID，例如 \"qq\",\"weixin\"，\"weibo\"，\"password\"。\n\n\npublic Task<`GetTokenResult`> getToken (boolean forceRefresh)\n\n获取Wilddog ID Token，使用我们的服务器SDK或按照官方文件安全地验证此token的完整性和有效性。\n\n\n### returns\n\n返回一个带有`GetTokenResult`信息的Task对象.\n\n\n\n\npublic abstract String getUid ()\n\n获取在Wilddog Auth 系统中的用户的唯一标识.\n   \n该标识符是不透明的，不一定对应于用户的电子邮件地址或任何其它属性.\n\n  \n\n\npublic abstract boolean isAnonymous ()\n\n判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。\n\n\n\npublic Task<`AuthResult`> linkWithCredential (AuthCredential credential)\n\n将当前用户与给定的登录认证方式绑定。之后支持绑定的所有登录认证方式。\n\n\npublic Task<`Void`> reauthenticate (AuthCredential credential)\n\n用给定的登录认证方式重新认证。\n\n\n\nTask<`Void`>\treload()\n\n手动刷新当前用户的数据。（连接提供者，显示名称等等）\n\n\nTask<`AuthResult`>\tunlink(String provider)\n\n将给定的登录认证类型从当前用户绑定列表中解除绑定.\n\n\n\n\nTask<`Void`>\tupdateEmail(String email)\n\n更新当前登录认证用户的邮箱信息.\n\n\n\nTask<`Void`>\tupdatePassword(String password)\n\n更新当前登录认证用户的密码信息.\n\n\n\nTask<`Void`>\tupdateProfile(UserProfileChangeRequest request)\n\n更新当前用户的昵称信息和头像URL\n\n----\n\n","source":"api/auth/android.md","raw":"title:  完整 API 文档\n---\n\n# AuthResult\n\npublic interface **AuthResult**\n\n结果对象获得的操作会影响认证状态。包含一个方法,在操作完成后返回当前登录用户。\n\n## Public Method Summary\n\nWilddogUser  abstract  getUser() \n\n\n## Public Methods\n\npublic abstract FirebaseUser getUser ()\n\n### returns\n\n当前帐号WilddogUser,如果没有则为null(即用户登出)。\n\n----\n# WilddogAuth.AuthStateListener\n\npublic static interface **WilddogAuth.AuthStateListener**\n\n当身份验证状态有一个变化的时候调用。\n\n使用`addAuthStateListener(AuthStateListener)`和`removeAuthStateListener(AuthStateListener)`来注册或者注销监听\n## Public Method Summary\nvoid    abstract      onAuthStateChanged(WilddogAuth auth)\n\n         当状态发生变化的时候，这个方法在UI线程中调用\n\n               * 注册监听的时候\n               * 用户登录的时候\n               * 用户登出的时候\n               * 当前用户改变的时候\n               * 当前用户的token改变的时候\n\n## Public Methods\n\npublic abstract void onAuthStateChanged (WilddogAuth auth)\n\n\n 当状态发生变化的时候，这个方法在UI线程中调用：\n\n               * 注册监听的时候\n               * 用户登录的时候\n               * 用户登出的时候\n               * 当前用户改变的时候\n               * 当前用户的token改变的时候\n\n\n### Parameters\nauth  当前WilddogAuth 对象，用来进行Auth相关操作。  \n\n\n----\n             \n# WilddogAuthProvider\n\npublic interface **WilddogAuthProvider**\n\n提供Auth身份验证类型\n\n## Constant Summary\n\nString  PROVIDER_ID\t  身份验证类型唯一字符标识。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\nUnique string identifier for this provider type.\n\nConstant Value: \"wilddog\"    \n          \n-----               \n               \n# UserInfo\n\n\npublic interface **UserInfo**\n\n已知直接子类\n\nWilddogUser\n\n  获取一个用户的标准用户配置信息。可用于身份验证提供者返回的用户配置信息，例如QQ登录或者微信登录。\n  \n## Public Method Summary\n\n  abstract String getDisplayName()\n  \n  如果可用，返回用户昵称。\n  \n  abstract String getEmail()\n  \n  如果可用，返回指定认证提供类型的电子邮箱地址\n  \n  abstract Uri\tgetPhotoUrl()\n  \n  如果可用，返回用户设置的形象照片的URL\n  \n  abstract String getProviderId()\n  \n 返回提供者类型实例的唯一标识符\n\n  abstract String\tgetUid()\n  \n  返回一个身份验证提供者指定的用户标识符。\n  \n## Public Methods\n\npublic abstract String getDisplayName ()\n  \n如果可用，返回用户昵称。\n   \n   \npublic abstract String getEmail ()\n  \n返回对应于指定提供者的用户帐户的电子邮件地址，包含可选。\n  \npublic abstract Uri getPhotoUrl ()\n  \n如果可用，返回用户形象照片。\n  \npublic abstract String getProviderId ()\n  \n返回提供者类型实例的唯一标识符，例如QQ，weixin。\n  \npublic abstract String getUid ()\n  \n返回一个身份验证提供者指定的用户标识符。例如，如果是qq返回qq的uid，如果是微博，返回微博的openId。\n\n----                 \n\n\n# AuthCredential\npublic abstract class **AuthCredential** extends Object\n\n已知直接子类\nEmailAuthCredential，QQAuthCredential，WeiboAuthCredential，WeiXinAuthCredential\n\n代表Wilddog支持的身份认证的方式的认证凭据。\n\n## Public Method Summary\n\nabstract String    getProvider\\(\\)\n\n返回使用的认证方式的类型唯一标识。\n\n## Public Methods\n\npublic abstract String getProvider \\(\\)\n\n返回使用的认证方式的类型唯一标识。例如：\"weixin\"，\"qq\"，\"weibo\"，\"password\"\n\n----\n# EmailAuthCredential\n\npublic class **EmailAuthCredential** extends AuthCredential\n\n包含邮箱和密码的身份认证方式\n\n## Public Method Summary\nString\tgetProvider()\n\n返回使用的认证方式的类型唯一标识。\n\n## public String getProvider ()\n\n返回类型为\"password\"类型的认证方式唯一标识。\n\n----\n# EmailAuthProvider\npublic class **EmailAuthProvider** extends Object\n\n代表了电子邮件和密码身份验证机制，使用这个类来获取EmailAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\nstatic AuthCredential\tgetCredential(String email, String password)\n\n返回一个带有用户名和密码的用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"password\"\n\n\n## Public Methods\npublic static AuthCredential getCredential (String email, String password)\n\n返回一个带有用户名和密码的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n# QQAuthCredential \npublic class QQAuthCredential extends AuthCredential\n\n包含qq accessToken的认证凭据\n\n## Public Method Summary\n\nString\tgetProvider()\n\n返回身份认证的唯一标识 \"qq\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\n## Public Methods\n\npublic String getProvider ()\n\n返回身份认证的唯一标识 \"qq\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\n----\n# QQAuthProvider\n\npublic class **QQAuthProvider** extends Object\n\n代表了QQ身份认证机制，使用这个类来获取QQAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\nstatic AuthCredential\tgetCredential(String token)\n\n返回一个带有accessToken的QQ用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"qq\"\n\n\n## Public Methods\npublic static AuthCredential getCredential (String token)\n\n返回一个带有用户名和密码的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n# WeiboAuthCredential\n\npublic class WeiboAuthCredential extends AuthCredential\n\n包含微博 accessToken和uid的认证凭据\n\n## Public Method Summary\n\nString\tgetProvider()\n\n返回身份认证的唯一标识 \"weibo\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\n public String getUid()\n \n 返回要上传的微博平台唯一标识uid。\n\n## Public Methods\n\npublic String getProvider ()\n\n返回身份认证的唯一标识 \"weibo\"\n\npublic String getAccessToken()\n\n返回要上传的token信息\n\npublic String getUid()\n \n返回要上传的微博平台唯一标识uid。\n\n----\n# WeiboAuthProvider\n\npublic class **WeiboAuthProvider** extends Object\n\n代表了新浪微博身份认证机制，使用这个类来获取WeiboAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\n static AuthCredential getCredential( String token,String openId) \n\n返回一个带有token和openId的用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"weibo\"\n\n\n## Public Methods\npublic static AuthCredential getCredential (String token,String openId)\n\n返回一个带有用户名和密码的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n\n# WeiXinAuthCredential\n\npublic class WeiboAuthCredential extends AuthCredential\n\n包含微信code的认证凭据\n\n## Public Method Summary\n\nString\tgetProvider()\n\n返回身份认证的唯一标识 \"weixin\"\n\npublic String getCode()\n\n返回微信授权认证返回的code。\n\n## Public Methods\n\npublic String getProvider ()\n\n返回身份认证的唯一标识 \"weixin\"\n\npublic String getCode()\n\n返回微信授权认证返回的code。\n\n----\n\n# WeiXinAuthProvider\n\npublic class **WeiXinAuthProvider** extends Object\n\n代表了微信身份认证机制，使用这个类来获取WeiXinAuthCredential。\n\n## Constant Summary\nString\tPROVIDER_ID\t认证类型的唯一字符串标识。\n\n## Public Method Summary\n static AuthCredential getCredential( String code) \n\n返回一个带有code的用户凭证，用于后续的登录或者绑定邮箱认证方式。\n\n## Constants\n\npublic static final String **PROVIDER_ID**\n\n认证方式的唯一字符串标识\n\n常量值: \"weixin\"\n\n\n## Public Methods\npublic static AuthCredential getCredential ( String code)\n\n返回一个带有code的用户凭证，当调用`signInWithCredential(AuthCredential)`或者`linkWithCredential(AuthCredential)`时候使用\n\n----\n\n# GetTokenResult\n\npublic class GetTokenResult extends Object\n\n返回WilddogIdToken结果对象\n\n## Public Method Summary\n\nString\tgetToken()\n\nWilddog ID Token.\n\n## Public Methods\n\npublic String getToken ()\n\nWilddog ID Token. 身份认证成功后返回的Wilddog Id token字符串。用于验证之后操作的身份完整性和安全性。\n\n----\n# UserProfileChangeRequest\n\n\n\npublic class UserProfileChangeRequest extends Object\nimplements SafeParcelable\n\n用来更新用户信息的请求对象\n\n\n## Nested Class Summary\n\nclass\tUserProfileChangeRequest.Builder\t\n\n构建请求的内部类\n\n\n\n\n## Public Method Summary\n\nString\tgetDisplayName()\n\n返回要修改的昵称信息\n\nUri\tgetPhotoUri()\n\n返回要修改的头像URL\n\n\n## Public Methods\n\npublic String getDisplayName ()\n\n返回要修改的昵称信息\n\npublic Uri getPhotoUri ()\n\n返回要修改的头像URL\n\n----\n\n# UserProfileChangeRequest.Builder\n\n\n\n\npublic static class UserProfileChangeRequest.Builder extends Object\n\n请求构建器\n\n## Public Constructor Summary\n\nUserProfileChangeRequest.Builder()\n\n## Public Method Summary\n\nUserProfileChangeRequest\tbuild()\n\n构建一个修改用户信息的请求对象\n\nUserProfileChangeRequest.Builder setDisplayName(String displayName)\n\n设置要更新的昵称\n\nUserProfileChangeRequest.Builder setPhotoUri(Uri photoUri)\n\n设置要更新头像的URL.\n\n\n## Public Constructors\n\npublic UserProfileChangeRequest.Builder ()\n\n## Public Methods\n\npublic UserProfileChangeRequest build ()\n\n### returns\n\n* 一个UserProfileChangeRequest实例\n\n\n\npublic UserProfileChangeRequest.Builder setDisplayName (String displayName)\n\n设置要修改的昵称。\n\n### returns\n\n* 一个可以链式调用的UserProfileChangeRequest.Builder对象\n\n\n\npublic UserProfileChangeRequest.Builder setPhotoUri (Uri photoUri)\n\n设置要修改的头像的URL。\n\n\n### returns\n\n* 一个可以链式调用的UserProfileChangeRequest.Builder对象\n\n----\n\n\n\n\n# WilddogAuth\n\npublic abstract class WilddogAuth extends Object\n\nWilddogAuth SDK入口对象。\n\n首先通过调用 getInstance(\"appId\",context)获取一个WilddogAuth实例对象。\n接着，可以使用一下方法进行用户登录认证：\n    \n*      createUserWithEmailAndPassword(String, String)\n*      signInWithEmailAndPassword(String, String)\n*      signInWithCredential(AuthCredential)\n*      signInAnonymously()\n*      signInWithCustomToken(String)\n\n最后，调用 `getCurrentUser()`获取包含用户信息的WilddogUser对象.\n\n## Nested Class Summary\ninterface\tWilddogAuth.AuthStateListener\t\n    当认证状态发生变化的时候调用\n    \n ## Public Method Summary\n \n void\taddAuthStateListener(FirebaseAuth.AuthStateListener listener)\n \n 注册认证状态改变的监听.\n \n\n \n Task<```AuthResult```>\tcreateUserWithEmailAndPassword(String email, String password)\n \n 试图去创建一个新的邮箱密码的用户账号。\n \n\n \n Task<```ProviderQueryResult```>\tfetchProvidersForEmail(String email)\n \n 如果存在，则通过邮箱获取所有的认证类型。\n \n\n \n WilddogUser\tgetCurrentUser()\n \n \n 返回当前认证的用户信息，如果未认证返回null.\n \n\n \n static WilddogAuth\tgetInstance()\n \n 返回初始化之后，可以用本方法获取WilddogAuth实例对象\n \n\n \n static WilddogAuth\tgetInstance(String appId，Context context)\n \n 返回初始化WilddogAuth 实例对象。\n \n \n\n \n void\tremoveAuthStateListener(WilddogAuth.AuthStateListener listener)\n \n 注销曾经认证状态监听对象\n \n\n \n Task<Void>\tsendPasswordResetEmail(String email)\n \n 给当前应用中现有的绑定当前email的用户发送密码重置邮件.\n \n\n Task<```AuthResult```>\tsignInAnonymously()\n \n 使用匿名方法登录，不需要凭据，可以绑定其他认证方式.\n \n\n \n Task<```AuthResult```>\tsignInWithCredential(AuthCredential credential)\n \n 通过AuthCredential进行用户认证，支持的认证方式：qq，微博，微信，密码\n \n\n \n Task<```AuthResult```>\tsignInWithCustomToken(String token)\n \n 通过用户自定义的token进行用户认证。\n \n\n \n Task<```AuthResult```>\tsignInWithEmailAndPassword(String email, String password)\n \n 通过用户邮箱密码的方式进行用户认证\n \n\n \n void\tsignOut()\n \n 登出当前用户，清除登录数据\n \n ## Public Methods\n \n \n public void addAuthStateListener (FirebaseAuth.AuthStateListener listener)\n \n 注册一个认证状态的监听。一个WilddogAuth对象可以设置多个监听对象，也可以为不同的WilddogAuth添加监听对象。\n \n   当以下情况出现，会在UI线程中触发回调：\n \n   * 在监听对象注册的时候\n   * 在用户登录认证的时候\n   * 在当前用户登出的时候\n   * 在当前用户改变的时候\n   * 在当前用户的Wilddog Id token 改变的时候\n\n    推荐的做法总是监听注销事件，因为你可能要提示用户再次登录并且可能限制用户获取信息或者操作.\n    \n    可以使用`removeAuthStateListener(AuthStateListener)`注销监听.\n    \n \n    \n  public Task<```AuthResult```> createUserWithEmailAndPassword (String email, String password)  \n  试图用给定的邮箱和密码创建一个用户账号，如果成功，这个用户也将登录成功。\n  \n  然后可以通过`getCurrentUser()`访问用户信息和进行用户操作.\n  \n  一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法\n  \n  **注意:** 你必须在Wilddog控制面板中打开这种登录认证方式。\n  \n  ### returns\n\n返回带有AuthResult的操作结果对象Task\n\n\n\npublic Task<```ProviderQueryResult```> fetchProvidersForEmail (String email)\n\n  返回通过绑定的主邮箱获取当前用户的认证方式列表\n\n当你绑定多种认证机制的时候，这个方法将会返回所有的认证方式列表。\n\n### Parameters\n\nemail\n\n用户返回登录认证方式列表的邮箱地址\n\n### returns\n\n返回带有AuthResult的操作结果对象Task\n\n\npublic WilddogUser getCurrentUser ()\n\n如果有用户认证登录返回登录用户，如果没有登录，则返回为空。\n\n可以通过 `getCurrentUser() != null` 来判断当前是否有用户登录\n\n### returns\n* 当前认证用户或者null\n\n\n\n\npublic static WilddogAuth getInstance ()\n\n\n\n 返回初始化之后，可以用本方法获取当前WilddogAuth实例对象\n\n\n\n public static WilddogAuth getInstance(String appId，Context context)\n \n  返回初始化WilddogAuth 实例对象。\n \n\n \n public void removeAuthStateListener (WilddogAuth.AuthStateListener listener)\n \n 注销认证状态的监听\n \n \n \n public Task<Void> sendPasswordResetEmail (String email)\n \n  给当前应用中现有的绑定当前email的用户发送密码重置邮件.\n  \n  \n  返回当前操作结果的Task对象\n  \n\n  \n  public Task<```AuthResult```> signInAnonymously ()\n  \n   使用匿名方法登录，不需要凭据，可以绑定其他认证方式.\n   \n   这个操作将在Wilddog创建一个匿名的用户账号，其中通过`getCurrentUser()`获取用户信息包含uid。\n   \n一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n   \n   \n  \n   \n  **注意:** 你必须在Wilddog控制面板中打开这种登录认证方式。\n    \n    \n\npublic Task<AuthResult> signInWithCredential (AuthCredential credential)\n\n通过给定的`AuthCredential`对象进行相应的认证登录。其中包含QQ，微信，新浪微博和密码认证登录。\n\n所有`AuthCredential`都会创建一个用户账号。\n\n**注意:** 你必须在Wilddog控制面板中打开相应的登录认证方式。\n    \n ### returns\n\n返回带有AuthResult的操作结果对象Task    \n\n\npublic Task<`AuthResult`> signInWithCustomToken (String token)\n\n通过用户自定义的token进行用户认证。\n\n  从用户服务器首先获取到Wilddog Custom Token,然后登录到Wilddog服务器，进行数据操作，可以通过getCurrentUser获取当前登录认证用户信息。\n  \n  一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n  \n  阅读[自定义Token]()\n  \n### returns\n\n返回带有AuthResult的操作结果对象Task   \n\npublic Task<AuthResult> signInWithEmailAndPassword (String email, String password)\n\n通过邮箱和密码进行登录认证。\n\n可以通过getCurrentUser获取当前登录认证用户信息。\n\n  一旦登录成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n  \n  **注意:** 你必须在Wilddog控制面板中打开这种登录认证方式。\n  \n  这个方法和`signInWithCredential（）`的`EmailAuthCredential`登录认证方式是等效的。\n  \n### returns\n\n返回带有AuthResult的操作结果对象Task\n\n\npublic void signOut ()\n\n登出当前用户，清除登录数据\n\n一旦登出成功，就会回调所有的注册的`WilddogAuth.AuthStateListener`的`onAuthStateChanged(WilddogAuth)`方法.\n\n\n----\n\n# WilddogUser\n\npublic abstract class WilddogUser extends Object\nimplements UserInfo\n\n获取用户在Wilddog Auth的个人资料信息。它还有辅助方法进行用户信息的修改和查询，以及管理用户的身份验证方式。\n\n## Public Constructor Summary\nWilddogUser（）\n\n## Public Method Summary\n\nTask<Void> delete()\n\n从Wilddog Auth 系统中删除用户.\n\n\n\nabstract String\tgetDisplayName()\n\n获取在Wilddog Auth 系统中的用户的昵称.\n\n\n\nabstract String\tgetEmail()\n\n获取在Wilddog Auth 系统中的用户的邮箱.\n\n\nabstract Uri\tgetPhotoUrl()\n\n获取在Wilddog Auth 系统中的用户的头像的URL.\n\n\n\nabstract List<? extends UserInfo>\tgetProviderData()\n\n获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.\n\n\n\nabstract String\tgetProviderId()\n\n返回PROVIDER_ID，例如 \"qq\",\"weixin\".\n\n\n\nTask<`GetTokenResult`>\tgetToken(boolean forceRefresh)\n\n获取Wilddog ID Token\n\n\n\nabstract String\tgetUid()\n\n获取在Wilddog Auth 系统中的用户的唯一标识.\n\n\n\nabstract boolean\tisAnonymous()\n\n判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。\n\n\n\nTask<`AuthResult`>\tlinkWithCredential(AuthCredential credential)\n\n将当前用户与给定的登录认证方式绑定。\n\n\n\nTask<`Void`>\treauthenticate(AuthCredential credential)\n\n用给定的登录认证方式重新认证。\n\n\nTask<`Void`>\treload()\n\n手动刷新当前用户的数据。（连接提供者，显示名称等等）\n\n\n\nTask<`AuthResult`>\tunlink(String provider)\n\n将给定的登录认证类型从当前用户绑定列表中解除绑定.\n\n\n\nTask<`Void`>\tupdateEmail(String email)\n\n更新当前登录认证用户的邮箱信息.\n\n\n\nTask<`Void`>\tupdatePassword(String password)\n\n更新当前登录认证用户的密码信息.\n\n\n\nTask<`Void`>\tupdateProfile(UserProfileChangeRequest request)\n\n更新当前用户的昵称信息和头像URL\n\n\n\n## Public Constructors\n\npublic WilddogUser ()\n\n\n\n\n## Public Methods\n\n\n  public Task<`Void`> delete ()\n  \n  从Wilddog Auth 系统中删除用户.\n  如果操作成功，用户将从登录系统中登出。\n  这个是一个安全敏感操作，需要用户用户最近登录过才能操作成功，如果失败，请先使用`reauthenticate(AuthCredential)`方法.\n  \n\n  \n  public abstract String getDisplayName ()\n  \n    获取当前用户的昵称，如果是第三方登录方式，不能修改昵称信息，因此不会第三方登录平台昵称不会受到影响。使用`updateProfile(UserProfileChangeRequest)`方法会更新这个属性。\n\n如果使用`signInWithCredential （ AuthCredential ）`登录的时候包含这个属性，将在登录时候自动创建填充属性。\n  \n\n  \n  public abstract String getEmail ()\n  \n  \n  返回当前用户设置的邮箱地址，如果第三方登录中含有这个属性，将不能被修改。\n  其他情况下可以通过`updateProfile(UserProfileChangeRequest)`方法会更新这个属性.\n  \n  这个属性将会在`signInWithCredential(AuthCredential)`的`EmailAuthCredential`或者`createUserWithEmailAndPassword(String, String)`填充这个属性.\n  \n\n  \n  public abstract Uri getPhotoUrl ()\n  \n  返回当前用户的头像的url，如果第三方登录中含有这个属性，将不能被修改。\n   其他情况下可以通过`updateProfile(UserProfileChangeRequest)`方法会更新这个属性.\n   \n   如果使用`signInWithCredential （ AuthCredential ）`登录的时候包含这个属性，将在登录时候自动创建填充属性。\n   \n\n   \n  abstract List<? extends UserInfo>\tgetProviderData()\n\n获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.\n\n\n\n\nabstract String\tgetProviderId()\n\n返回PROVIDER_ID，例如 \"qq\",\"weixin\"，\"weibo\"，\"password\"。\n\n\npublic Task<`GetTokenResult`> getToken (boolean forceRefresh)\n\n获取Wilddog ID Token，使用我们的服务器SDK或按照官方文件安全地验证此token的完整性和有效性。\n\n\n### returns\n\n返回一个带有`GetTokenResult`信息的Task对象.\n\n\n\n\npublic abstract String getUid ()\n\n获取在Wilddog Auth 系统中的用户的唯一标识.\n   \n该标识符是不透明的，不一定对应于用户的电子邮件地址或任何其它属性.\n\n  \n\n\npublic abstract boolean isAnonymous ()\n\n判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。\n\n\n\npublic Task<`AuthResult`> linkWithCredential (AuthCredential credential)\n\n将当前用户与给定的登录认证方式绑定。之后支持绑定的所有登录认证方式。\n\n\npublic Task<`Void`> reauthenticate (AuthCredential credential)\n\n用给定的登录认证方式重新认证。\n\n\n\nTask<`Void`>\treload()\n\n手动刷新当前用户的数据。（连接提供者，显示名称等等）\n\n\nTask<`AuthResult`>\tunlink(String provider)\n\n将给定的登录认证类型从当前用户绑定列表中解除绑定.\n\n\n\n\nTask<`Void`>\tupdateEmail(String email)\n\n更新当前登录认证用户的邮箱信息.\n\n\n\nTask<`Void`>\tupdatePassword(String password)\n\n更新当前登录认证用户的密码信息.\n\n\n\nTask<`Void`>\tupdateProfile(UserProfileChangeRequest request)\n\n更新当前用户的昵称信息和头像URL\n\n----\n\n","date":"2016-09-06T03:38:22.513Z","updated":"2016-09-06T03:38:22.513Z","path":"api/auth/android.html","comments":1,"layout":"page","_id":"cisswi9j20006z4fwbaw5lkn5","content":"<h1 id=\"AuthResult\"><a href=\"#AuthResult\" class=\"headerlink\" title=\"AuthResult\"></a>AuthResult</h1><p>public interface <strong>AuthResult</strong></p>\n<p>结果对象获得的操作会影响认证状态。包含一个方法,在操作完成后返回当前登录用户。</p>\n<h2 id=\"Public-Method-Summary\"><a href=\"#Public-Method-Summary\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>WilddogUser  abstract  getUser() </p>\n<h2 id=\"Public-Methods\"><a href=\"#Public-Methods\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract FirebaseUser getUser ()</p>\n<h3 id=\"returns\"><a href=\"#returns\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>当前帐号WilddogUser,如果没有则为null(即用户登出)。</p>\n<hr>\n<h1 id=\"WilddogAuth-AuthStateListener\"><a href=\"#WilddogAuth-AuthStateListener\" class=\"headerlink\" title=\"WilddogAuth.AuthStateListener\"></a>WilddogAuth.AuthStateListener</h1><p>public static interface <strong>WilddogAuth.AuthStateListener</strong></p>\n<p>当身份验证状态有一个变化的时候调用。</p>\n<p>使用<code>addAuthStateListener(AuthStateListener)</code>和<code>removeAuthStateListener(AuthStateListener)</code>来注册或者注销监听</p>\n<h2 id=\"Public-Method-Summary-1\"><a href=\"#Public-Method-Summary-1\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>void    abstract      onAuthStateChanged(WilddogAuth auth)</p>\n<pre><code>当状态发生变化的时候，这个方法在UI线程中调用\n\n      * 注册监听的时候\n      * 用户登录的时候\n      * 用户登出的时候\n      * 当前用户改变的时候\n      * 当前用户的token改变的时候\n</code></pre><h2 id=\"Public-Methods-1\"><a href=\"#Public-Methods-1\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract void onAuthStateChanged (WilddogAuth auth)</p>\n<p> 当状态发生变化的时候，这个方法在UI线程中调用：</p>\n<pre><code>* 注册监听的时候\n* 用户登录的时候\n* 用户登出的时候\n* 当前用户改变的时候\n* 当前用户的token改变的时候\n</code></pre><h3 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h3><p>auth  当前WilddogAuth 对象，用来进行Auth相关操作。  </p>\n<hr>\n<h1 id=\"WilddogAuthProvider\"><a href=\"#WilddogAuthProvider\" class=\"headerlink\" title=\"WilddogAuthProvider\"></a>WilddogAuthProvider</h1><p>public interface <strong>WilddogAuthProvider</strong></p>\n<p>提供Auth身份验证类型</p>\n<h2 id=\"Constant-Summary\"><a href=\"#Constant-Summary\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String  PROVIDER_ID      身份验证类型唯一字符标识。</p>\n<h2 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong><br>Unique string identifier for this provider type.</p>\n<p>Constant Value: “wilddog”    </p>\n<hr>\n<h1 id=\"UserInfo\"><a href=\"#UserInfo\" class=\"headerlink\" title=\"UserInfo\"></a>UserInfo</h1><p>public interface <strong>UserInfo</strong></p>\n<p>已知直接子类</p>\n<p>WilddogUser</p>\n<p>  获取一个用户的标准用户配置信息。可用于身份验证提供者返回的用户配置信息，例如QQ登录或者微信登录。</p>\n<h2 id=\"Public-Method-Summary-2\"><a href=\"#Public-Method-Summary-2\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>  abstract String getDisplayName()</p>\n<p>  如果可用，返回用户昵称。</p>\n<p>  abstract String getEmail()</p>\n<p>  如果可用，返回指定认证提供类型的电子邮箱地址</p>\n<p>  abstract Uri    getPhotoUrl()</p>\n<p>  如果可用，返回用户设置的形象照片的URL</p>\n<p>  abstract String getProviderId()</p>\n<p> 返回提供者类型实例的唯一标识符</p>\n<p>  abstract String    getUid()</p>\n<p>  返回一个身份验证提供者指定的用户标识符。</p>\n<h2 id=\"Public-Methods-2\"><a href=\"#Public-Methods-2\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract String getDisplayName ()</p>\n<p>如果可用，返回用户昵称。</p>\n<p>public abstract String getEmail ()</p>\n<p>返回对应于指定提供者的用户帐户的电子邮件地址，包含可选。</p>\n<p>public abstract Uri getPhotoUrl ()</p>\n<p>如果可用，返回用户形象照片。</p>\n<p>public abstract String getProviderId ()</p>\n<p>返回提供者类型实例的唯一标识符，例如QQ，weixin。</p>\n<p>public abstract String getUid ()</p>\n<p>返回一个身份验证提供者指定的用户标识符。例如，如果是qq返回qq的uid，如果是微博，返回微博的openId。</p>\n<hr>\n<h1 id=\"AuthCredential\"><a href=\"#AuthCredential\" class=\"headerlink\" title=\"AuthCredential\"></a>AuthCredential</h1><p>public abstract class <strong>AuthCredential</strong> extends Object</p>\n<p>已知直接子类<br>EmailAuthCredential，QQAuthCredential，WeiboAuthCredential，WeiXinAuthCredential</p>\n<p>代表Wilddog支持的身份认证的方式的认证凭据。</p>\n<h2 id=\"Public-Method-Summary-3\"><a href=\"#Public-Method-Summary-3\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>abstract String    getProvider()</p>\n<p>返回使用的认证方式的类型唯一标识。</p>\n<h2 id=\"Public-Methods-3\"><a href=\"#Public-Methods-3\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract String getProvider ()</p>\n<p>返回使用的认证方式的类型唯一标识。例如：”weixin”，”qq”，”weibo”，”password”</p>\n<hr>\n<h1 id=\"EmailAuthCredential\"><a href=\"#EmailAuthCredential\" class=\"headerlink\" title=\"EmailAuthCredential\"></a>EmailAuthCredential</h1><p>public class <strong>EmailAuthCredential</strong> extends AuthCredential</p>\n<p>包含邮箱和密码的身份认证方式</p>\n<h2 id=\"Public-Method-Summary-4\"><a href=\"#Public-Method-Summary-4\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回使用的认证方式的类型唯一标识。</p>\n<h2 id=\"public-String-getProvider\"><a href=\"#public-String-getProvider\" class=\"headerlink\" title=\"public String getProvider ()\"></a>public String getProvider ()</h2><p>返回类型为”password”类型的认证方式唯一标识。</p>\n<hr>\n<h1 id=\"EmailAuthProvider\"><a href=\"#EmailAuthProvider\" class=\"headerlink\" title=\"EmailAuthProvider\"></a>EmailAuthProvider</h1><p>public class <strong>EmailAuthProvider</strong> extends Object</p>\n<p>代表了电子邮件和密码身份验证机制，使用这个类来获取EmailAuthCredential。</p>\n<h2 id=\"Constant-Summary-1\"><a href=\"#Constant-Summary-1\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-5\"><a href=\"#Public-Method-Summary-5\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>static AuthCredential    getCredential(String email, String password)</p>\n<p>返回一个带有用户名和密码的用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-1\"><a href=\"#Constants-1\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “password”</p>\n<h2 id=\"Public-Methods-4\"><a href=\"#Public-Methods-4\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential (String email, String password)</p>\n<p>返回一个带有用户名和密码的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"QQAuthCredential\"><a href=\"#QQAuthCredential\" class=\"headerlink\" title=\"QQAuthCredential\"></a>QQAuthCredential</h1><p>public class QQAuthCredential extends AuthCredential</p>\n<p>包含qq accessToken的认证凭据</p>\n<h2 id=\"Public-Method-Summary-6\"><a href=\"#Public-Method-Summary-6\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回身份认证的唯一标识 “qq”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<h2 id=\"Public-Methods-5\"><a href=\"#Public-Methods-5\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getProvider ()</p>\n<p>返回身份认证的唯一标识 “qq”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<hr>\n<h1 id=\"QQAuthProvider\"><a href=\"#QQAuthProvider\" class=\"headerlink\" title=\"QQAuthProvider\"></a>QQAuthProvider</h1><p>public class <strong>QQAuthProvider</strong> extends Object</p>\n<p>代表了QQ身份认证机制，使用这个类来获取QQAuthCredential。</p>\n<h2 id=\"Constant-Summary-2\"><a href=\"#Constant-Summary-2\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-7\"><a href=\"#Public-Method-Summary-7\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>static AuthCredential    getCredential(String token)</p>\n<p>返回一个带有accessToken的QQ用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-2\"><a href=\"#Constants-2\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “qq”</p>\n<h2 id=\"Public-Methods-6\"><a href=\"#Public-Methods-6\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential (String token)</p>\n<p>返回一个带有用户名和密码的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"WeiboAuthCredential\"><a href=\"#WeiboAuthCredential\" class=\"headerlink\" title=\"WeiboAuthCredential\"></a>WeiboAuthCredential</h1><p>public class WeiboAuthCredential extends AuthCredential</p>\n<p>包含微博 accessToken和uid的认证凭据</p>\n<h2 id=\"Public-Method-Summary-8\"><a href=\"#Public-Method-Summary-8\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回身份认证的唯一标识 “weibo”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<p> public String getUid()</p>\n<p> 返回要上传的微博平台唯一标识uid。</p>\n<h2 id=\"Public-Methods-7\"><a href=\"#Public-Methods-7\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getProvider ()</p>\n<p>返回身份认证的唯一标识 “weibo”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<p>public String getUid()</p>\n<p>返回要上传的微博平台唯一标识uid。</p>\n<hr>\n<h1 id=\"WeiboAuthProvider\"><a href=\"#WeiboAuthProvider\" class=\"headerlink\" title=\"WeiboAuthProvider\"></a>WeiboAuthProvider</h1><p>public class <strong>WeiboAuthProvider</strong> extends Object</p>\n<p>代表了新浪微博身份认证机制，使用这个类来获取WeiboAuthCredential。</p>\n<h2 id=\"Constant-Summary-3\"><a href=\"#Constant-Summary-3\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-9\"><a href=\"#Public-Method-Summary-9\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p> static AuthCredential getCredential( String token,String openId) </p>\n<p>返回一个带有token和openId的用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-3\"><a href=\"#Constants-3\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “weibo”</p>\n<h2 id=\"Public-Methods-8\"><a href=\"#Public-Methods-8\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential (String token,String openId)</p>\n<p>返回一个带有用户名和密码的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"WeiXinAuthCredential\"><a href=\"#WeiXinAuthCredential\" class=\"headerlink\" title=\"WeiXinAuthCredential\"></a>WeiXinAuthCredential</h1><p>public class WeiboAuthCredential extends AuthCredential</p>\n<p>包含微信code的认证凭据</p>\n<h2 id=\"Public-Method-Summary-10\"><a href=\"#Public-Method-Summary-10\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回身份认证的唯一标识 “weixin”</p>\n<p>public String getCode()</p>\n<p>返回微信授权认证返回的code。</p>\n<h2 id=\"Public-Methods-9\"><a href=\"#Public-Methods-9\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getProvider ()</p>\n<p>返回身份认证的唯一标识 “weixin”</p>\n<p>public String getCode()</p>\n<p>返回微信授权认证返回的code。</p>\n<hr>\n<h1 id=\"WeiXinAuthProvider\"><a href=\"#WeiXinAuthProvider\" class=\"headerlink\" title=\"WeiXinAuthProvider\"></a>WeiXinAuthProvider</h1><p>public class <strong>WeiXinAuthProvider</strong> extends Object</p>\n<p>代表了微信身份认证机制，使用这个类来获取WeiXinAuthCredential。</p>\n<h2 id=\"Constant-Summary-4\"><a href=\"#Constant-Summary-4\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-11\"><a href=\"#Public-Method-Summary-11\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p> static AuthCredential getCredential( String code) </p>\n<p>返回一个带有code的用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-4\"><a href=\"#Constants-4\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “weixin”</p>\n<h2 id=\"Public-Methods-10\"><a href=\"#Public-Methods-10\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential ( String code)</p>\n<p>返回一个带有code的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"GetTokenResult\"><a href=\"#GetTokenResult\" class=\"headerlink\" title=\"GetTokenResult\"></a>GetTokenResult</h1><p>public class GetTokenResult extends Object</p>\n<p>返回WilddogIdToken结果对象</p>\n<h2 id=\"Public-Method-Summary-12\"><a href=\"#Public-Method-Summary-12\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getToken()</p>\n<p>Wilddog ID Token.</p>\n<h2 id=\"Public-Methods-11\"><a href=\"#Public-Methods-11\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getToken ()</p>\n<p>Wilddog ID Token. 身份认证成功后返回的Wilddog Id token字符串。用于验证之后操作的身份完整性和安全性。</p>\n<hr>\n<h1 id=\"UserProfileChangeRequest\"><a href=\"#UserProfileChangeRequest\" class=\"headerlink\" title=\"UserProfileChangeRequest\"></a>UserProfileChangeRequest</h1><p>public class UserProfileChangeRequest extends Object<br>implements SafeParcelable</p>\n<p>用来更新用户信息的请求对象</p>\n<h2 id=\"Nested-Class-Summary\"><a href=\"#Nested-Class-Summary\" class=\"headerlink\" title=\"Nested Class Summary\"></a>Nested Class Summary</h2><p>class    UserProfileChangeRequest.Builder    </p>\n<p>构建请求的内部类</p>\n<h2 id=\"Public-Method-Summary-13\"><a href=\"#Public-Method-Summary-13\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getDisplayName()</p>\n<p>返回要修改的昵称信息</p>\n<p>Uri    getPhotoUri()</p>\n<p>返回要修改的头像URL</p>\n<h2 id=\"Public-Methods-12\"><a href=\"#Public-Methods-12\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getDisplayName ()</p>\n<p>返回要修改的昵称信息</p>\n<p>public Uri getPhotoUri ()</p>\n<p>返回要修改的头像URL</p>\n<hr>\n<h1 id=\"UserProfileChangeRequest-Builder\"><a href=\"#UserProfileChangeRequest-Builder\" class=\"headerlink\" title=\"UserProfileChangeRequest.Builder\"></a>UserProfileChangeRequest.Builder</h1><p>public static class UserProfileChangeRequest.Builder extends Object</p>\n<p>请求构建器</p>\n<h2 id=\"Public-Constructor-Summary\"><a href=\"#Public-Constructor-Summary\" class=\"headerlink\" title=\"Public Constructor Summary\"></a>Public Constructor Summary</h2><p>UserProfileChangeRequest.Builder()</p>\n<h2 id=\"Public-Method-Summary-14\"><a href=\"#Public-Method-Summary-14\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>UserProfileChangeRequest    build()</p>\n<p>构建一个修改用户信息的请求对象</p>\n<p>UserProfileChangeRequest.Builder setDisplayName(String displayName)</p>\n<p>设置要更新的昵称</p>\n<p>UserProfileChangeRequest.Builder setPhotoUri(Uri photoUri)</p>\n<p>设置要更新头像的URL.</p>\n<h2 id=\"Public-Constructors\"><a href=\"#Public-Constructors\" class=\"headerlink\" title=\"Public Constructors\"></a>Public Constructors</h2><p>public UserProfileChangeRequest.Builder ()</p>\n<h2 id=\"Public-Methods-13\"><a href=\"#Public-Methods-13\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public UserProfileChangeRequest build ()</p>\n<h3 id=\"returns-1\"><a href=\"#returns-1\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>一个UserProfileChangeRequest实例</li>\n</ul>\n<p>public UserProfileChangeRequest.Builder setDisplayName (String displayName)</p>\n<p>设置要修改的昵称。</p>\n<h3 id=\"returns-2\"><a href=\"#returns-2\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>一个可以链式调用的UserProfileChangeRequest.Builder对象</li>\n</ul>\n<p>public UserProfileChangeRequest.Builder setPhotoUri (Uri photoUri)</p>\n<p>设置要修改的头像的URL。</p>\n<h3 id=\"returns-3\"><a href=\"#returns-3\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>一个可以链式调用的UserProfileChangeRequest.Builder对象</li>\n</ul>\n<hr>\n<h1 id=\"WilddogAuth\"><a href=\"#WilddogAuth\" class=\"headerlink\" title=\"WilddogAuth\"></a>WilddogAuth</h1><p>public abstract class WilddogAuth extends Object</p>\n<p>WilddogAuth SDK入口对象。</p>\n<p>首先通过调用 getInstance(“appId”,context)获取一个WilddogAuth实例对象。<br>接着，可以使用一下方法进行用户登录认证：</p>\n<ul>\n<li>createUserWithEmailAndPassword(String, String)</li>\n<li>signInWithEmailAndPassword(String, String)</li>\n<li>signInWithCredential(AuthCredential)</li>\n<li>signInAnonymously()</li>\n<li>signInWithCustomToken(String)</li>\n</ul>\n<p>最后，调用 <code>getCurrentUser()</code>获取包含用户信息的WilddogUser对象.</p>\n<h2 id=\"Nested-Class-Summary-1\"><a href=\"#Nested-Class-Summary-1\" class=\"headerlink\" title=\"Nested Class Summary\"></a>Nested Class Summary</h2><p>interface    WilddogAuth.AuthStateListener<br>    当认证状态发生变化的时候调用</p>\n<h2 id=\"Public-Method-Summary-15\"><a href=\"#Public-Method-Summary-15\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p> void    addAuthStateListener(FirebaseAuth.AuthStateListener listener)</p>\n<p> 注册认证状态改变的监听.</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    createUserWithEmailAndPassword(String email, String password)</p>\n<p> 试图去创建一个新的邮箱密码的用户账号。</p>\n<p> Task&lt;<code>ProviderQueryResult</code>&gt;    fetchProvidersForEmail(String email)</p>\n<p> 如果存在，则通过邮箱获取所有的认证类型。</p>\n<p> WilddogUser    getCurrentUser()</p>\n<p> 返回当前认证的用户信息，如果未认证返回null.</p>\n<p> static WilddogAuth    getInstance()</p>\n<p> 返回初始化之后，可以用本方法获取WilddogAuth实例对象</p>\n<p> static WilddogAuth    getInstance(String appId，Context context)</p>\n<p> 返回初始化WilddogAuth 实例对象。</p>\n<p> void    removeAuthStateListener(WilddogAuth.AuthStateListener listener)</p>\n<p> 注销曾经认证状态监听对象</p>\n<p> Task<void>    sendPasswordResetEmail(String email)</void></p>\n<p> 给当前应用中现有的绑定当前email的用户发送密码重置邮件.</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInAnonymously()</p>\n<p> 使用匿名方法登录，不需要凭据，可以绑定其他认证方式.</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInWithCredential(AuthCredential credential)</p>\n<p> 通过AuthCredential进行用户认证，支持的认证方式：qq，微博，微信，密码</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInWithCustomToken(String token)</p>\n<p> 通过用户自定义的token进行用户认证。</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInWithEmailAndPassword(String email, String password)</p>\n<p> 通过用户邮箱密码的方式进行用户认证</p>\n<p> void    signOut()</p>\n<p> 登出当前用户，清除登录数据</p>\n<h2 id=\"Public-Methods-14\"><a href=\"#Public-Methods-14\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p> public void addAuthStateListener (FirebaseAuth.AuthStateListener listener)</p>\n<p> 注册一个认证状态的监听。一个WilddogAuth对象可以设置多个监听对象，也可以为不同的WilddogAuth添加监听对象。</p>\n<p>   当以下情况出现，会在UI线程中触发回调：</p>\n<ul>\n<li>在监听对象注册的时候</li>\n<li>在用户登录认证的时候</li>\n<li>在当前用户登出的时候</li>\n<li>在当前用户改变的时候</li>\n<li><p>在当前用户的Wilddog Id token 改变的时候</p>\n<p>推荐的做法总是监听注销事件，因为你可能要提示用户再次登录并且可能限制用户获取信息或者操作.</p>\n<p>可以使用<code>removeAuthStateListener(AuthStateListener)</code>注销监听.</p>\n</li>\n</ul>\n<p>  public Task&lt;<code>AuthResult</code>&gt; createUserWithEmailAndPassword (String email, String password)<br>  试图用给定的邮箱和密码创建一个用户账号，如果成功，这个用户也将登录成功。</p>\n<p>  然后可以通过<code>getCurrentUser()</code>访问用户信息和进行用户操作.</p>\n<p>  一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法</p>\n<p>  <strong>注意:</strong> 你必须在Wilddog控制面板中打开这种登录认证方式。</p>\n<h3 id=\"returns-4\"><a href=\"#returns-4\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task</p>\n<p>public Task&lt;<code>ProviderQueryResult</code>&gt; fetchProvidersForEmail (String email)</p>\n<p>  返回通过绑定的主邮箱获取当前用户的认证方式列表</p>\n<p>当你绑定多种认证机制的时候，这个方法将会返回所有的认证方式列表。</p>\n<h3 id=\"Parameters-1\"><a href=\"#Parameters-1\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h3><p>email</p>\n<p>用户返回登录认证方式列表的邮箱地址</p>\n<h3 id=\"returns-5\"><a href=\"#returns-5\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task</p>\n<p>public WilddogUser getCurrentUser ()</p>\n<p>如果有用户认证登录返回登录用户，如果没有登录，则返回为空。</p>\n<p>可以通过 <code>getCurrentUser() != null</code> 来判断当前是否有用户登录</p>\n<h3 id=\"returns-6\"><a href=\"#returns-6\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>当前认证用户或者null</li>\n</ul>\n<p>public static WilddogAuth getInstance ()</p>\n<p> 返回初始化之后，可以用本方法获取当前WilddogAuth实例对象</p>\n<p> public static WilddogAuth getInstance(String appId，Context context)</p>\n<p>  返回初始化WilddogAuth 实例对象。</p>\n<p> public void removeAuthStateListener (WilddogAuth.AuthStateListener listener)</p>\n<p> 注销认证状态的监听</p>\n<p> public Task<void> sendPasswordResetEmail (String email)</void></p>\n<p>  给当前应用中现有的绑定当前email的用户发送密码重置邮件.</p>\n<p>  返回当前操作结果的Task对象</p>\n<p>  public Task&lt;<code>AuthResult</code>&gt; signInAnonymously ()</p>\n<p>   使用匿名方法登录，不需要凭据，可以绑定其他认证方式.</p>\n<p>   这个操作将在Wilddog创建一个匿名的用户账号，其中通过<code>getCurrentUser()</code>获取用户信息包含uid。</p>\n<p>一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<p>  <strong>注意:</strong> 你必须在Wilddog控制面板中打开这种登录认证方式。</p>\n<p>public Task<authresult> signInWithCredential (AuthCredential credential)</authresult></p>\n<p>通过给定的<code>AuthCredential</code>对象进行相应的认证登录。其中包含QQ，微信，新浪微博和密码认证登录。</p>\n<p>所有<code>AuthCredential</code>都会创建一个用户账号。</p>\n<p><strong>注意:</strong> 你必须在Wilddog控制面板中打开相应的登录认证方式。</p>\n<h3 id=\"returns-7\"><a href=\"#returns-7\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task    </p>\n<p>public Task&lt;<code>AuthResult</code>&gt; signInWithCustomToken (String token)</p>\n<p>通过用户自定义的token进行用户认证。</p>\n<p>  从用户服务器首先获取到Wilddog Custom Token,然后登录到Wilddog服务器，进行数据操作，可以通过getCurrentUser获取当前登录认证用户信息。</p>\n<p>  一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<p>  阅读<a href=\"\">自定义Token</a></p>\n<h3 id=\"returns-8\"><a href=\"#returns-8\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task   </p>\n<p>public Task<authresult> signInWithEmailAndPassword (String email, String password)</authresult></p>\n<p>通过邮箱和密码进行登录认证。</p>\n<p>可以通过getCurrentUser获取当前登录认证用户信息。</p>\n<p>  一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<p>  <strong>注意:</strong> 你必须在Wilddog控制面板中打开这种登录认证方式。</p>\n<p>  这个方法和<code>signInWithCredential（）</code>的<code>EmailAuthCredential</code>登录认证方式是等效的。</p>\n<h3 id=\"returns-9\"><a href=\"#returns-9\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task</p>\n<p>public void signOut ()</p>\n<p>登出当前用户，清除登录数据</p>\n<p>一旦登出成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<hr>\n<h1 id=\"WilddogUser\"><a href=\"#WilddogUser\" class=\"headerlink\" title=\"WilddogUser\"></a>WilddogUser</h1><p>public abstract class WilddogUser extends Object<br>implements UserInfo</p>\n<p>获取用户在Wilddog Auth的个人资料信息。它还有辅助方法进行用户信息的修改和查询，以及管理用户的身份验证方式。</p>\n<h2 id=\"Public-Constructor-Summary-1\"><a href=\"#Public-Constructor-Summary-1\" class=\"headerlink\" title=\"Public Constructor Summary\"></a>Public Constructor Summary</h2><p>WilddogUser（）</p>\n<h2 id=\"Public-Method-Summary-16\"><a href=\"#Public-Method-Summary-16\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>Task<void> delete()</void></p>\n<p>从Wilddog Auth 系统中删除用户.</p>\n<p>abstract String    getDisplayName()</p>\n<p>获取在Wilddog Auth 系统中的用户的昵称.</p>\n<p>abstract String    getEmail()</p>\n<p>获取在Wilddog Auth 系统中的用户的邮箱.</p>\n<p>abstract Uri    getPhotoUrl()</p>\n<p>获取在Wilddog Auth 系统中的用户的头像的URL.</p>\n<p>abstract List&lt;? extends UserInfo&gt;    getProviderData()</p>\n<p>获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.</p>\n<p>abstract String    getProviderId()</p>\n<p>返回PROVIDER_ID，例如 “qq”,”weixin”.</p>\n<p>Task&lt;<code>GetTokenResult</code>&gt;    getToken(boolean forceRefresh)</p>\n<p>获取Wilddog ID Token</p>\n<p>abstract String    getUid()</p>\n<p>获取在Wilddog Auth 系统中的用户的唯一标识.</p>\n<p>abstract boolean    isAnonymous()</p>\n<p>判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。</p>\n<p>Task&lt;<code>AuthResult</code>&gt;    linkWithCredential(AuthCredential credential)</p>\n<p>将当前用户与给定的登录认证方式绑定。</p>\n<p>Task&lt;<code>Void</code>&gt;    reauthenticate(AuthCredential credential)</p>\n<p>用给定的登录认证方式重新认证。</p>\n<p>Task&lt;<code>Void</code>&gt;    reload()</p>\n<p>手动刷新当前用户的数据。（连接提供者，显示名称等等）</p>\n<p>Task&lt;<code>AuthResult</code>&gt;    unlink(String provider)</p>\n<p>将给定的登录认证类型从当前用户绑定列表中解除绑定.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateEmail(String email)</p>\n<p>更新当前登录认证用户的邮箱信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updatePassword(String password)</p>\n<p>更新当前登录认证用户的密码信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateProfile(UserProfileChangeRequest request)</p>\n<p>更新当前用户的昵称信息和头像URL</p>\n<h2 id=\"Public-Constructors-1\"><a href=\"#Public-Constructors-1\" class=\"headerlink\" title=\"Public Constructors\"></a>Public Constructors</h2><p>public WilddogUser ()</p>\n<h2 id=\"Public-Methods-15\"><a href=\"#Public-Methods-15\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>  public Task&lt;<code>Void</code>&gt; delete ()</p>\n<p>  从Wilddog Auth 系统中删除用户.<br>  如果操作成功，用户将从登录系统中登出。<br>  这个是一个安全敏感操作，需要用户用户最近登录过才能操作成功，如果失败，请先使用<code>reauthenticate(AuthCredential)</code>方法.</p>\n<p>  public abstract String getDisplayName ()</p>\n<pre><code>获取当前用户的昵称，如果是第三方登录方式，不能修改昵称信息，因此不会第三方登录平台昵称不会受到影响。使用`updateProfile(UserProfileChangeRequest)`方法会更新这个属性。\n</code></pre><p>如果使用<code>signInWithCredential （ AuthCredential ）</code>登录的时候包含这个属性，将在登录时候自动创建填充属性。</p>\n<p>  public abstract String getEmail ()</p>\n<p>  返回当前用户设置的邮箱地址，如果第三方登录中含有这个属性，将不能被修改。<br>  其他情况下可以通过<code>updateProfile(UserProfileChangeRequest)</code>方法会更新这个属性.</p>\n<p>  这个属性将会在<code>signInWithCredential(AuthCredential)</code>的<code>EmailAuthCredential</code>或者<code>createUserWithEmailAndPassword(String, String)</code>填充这个属性.</p>\n<p>  public abstract Uri getPhotoUrl ()</p>\n<p>  返回当前用户的头像的url，如果第三方登录中含有这个属性，将不能被修改。<br>   其他情况下可以通过<code>updateProfile(UserProfileChangeRequest)</code>方法会更新这个属性.</p>\n<p>   如果使用<code>signInWithCredential （ AuthCredential ）</code>登录的时候包含这个属性，将在登录时候自动创建填充属性。</p>\n<p>  abstract List&lt;? extends UserInfo&gt;    getProviderData()</p>\n<p>获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.</p>\n<p>abstract String    getProviderId()</p>\n<p>返回PROVIDER_ID，例如 “qq”,”weixin”，”weibo”，”password”。</p>\n<p>public Task&lt;<code>GetTokenResult</code>&gt; getToken (boolean forceRefresh)</p>\n<p>获取Wilddog ID Token，使用我们的服务器SDK或按照官方文件安全地验证此token的完整性和有效性。</p>\n<h3 id=\"returns-10\"><a href=\"#returns-10\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回一个带有<code>GetTokenResult</code>信息的Task对象.</p>\n<p>public abstract String getUid ()</p>\n<p>获取在Wilddog Auth 系统中的用户的唯一标识.</p>\n<p>该标识符是不透明的，不一定对应于用户的电子邮件地址或任何其它属性.</p>\n<p>public abstract boolean isAnonymous ()</p>\n<p>判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。</p>\n<p>public Task&lt;<code>AuthResult</code>&gt; linkWithCredential (AuthCredential credential)</p>\n<p>将当前用户与给定的登录认证方式绑定。之后支持绑定的所有登录认证方式。</p>\n<p>public Task&lt;<code>Void</code>&gt; reauthenticate (AuthCredential credential)</p>\n<p>用给定的登录认证方式重新认证。</p>\n<p>Task&lt;<code>Void</code>&gt;    reload()</p>\n<p>手动刷新当前用户的数据。（连接提供者，显示名称等等）</p>\n<p>Task&lt;<code>AuthResult</code>&gt;    unlink(String provider)</p>\n<p>将给定的登录认证类型从当前用户绑定列表中解除绑定.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateEmail(String email)</p>\n<p>更新当前登录认证用户的邮箱信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updatePassword(String password)</p>\n<p>更新当前登录认证用户的密码信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateProfile(UserProfileChangeRequest request)</p>\n<p>更新当前用户的昵称信息和头像URL</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"AuthResult\"><a href=\"#AuthResult\" class=\"headerlink\" title=\"AuthResult\"></a>AuthResult</h1><p>public interface <strong>AuthResult</strong></p>\n<p>结果对象获得的操作会影响认证状态。包含一个方法,在操作完成后返回当前登录用户。</p>\n<h2 id=\"Public-Method-Summary\"><a href=\"#Public-Method-Summary\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>WilddogUser  abstract  getUser() </p>\n<h2 id=\"Public-Methods\"><a href=\"#Public-Methods\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract FirebaseUser getUser ()</p>\n<h3 id=\"returns\"><a href=\"#returns\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>当前帐号WilddogUser,如果没有则为null(即用户登出)。</p>\n<hr>\n<h1 id=\"WilddogAuth-AuthStateListener\"><a href=\"#WilddogAuth-AuthStateListener\" class=\"headerlink\" title=\"WilddogAuth.AuthStateListener\"></a>WilddogAuth.AuthStateListener</h1><p>public static interface <strong>WilddogAuth.AuthStateListener</strong></p>\n<p>当身份验证状态有一个变化的时候调用。</p>\n<p>使用<code>addAuthStateListener(AuthStateListener)</code>和<code>removeAuthStateListener(AuthStateListener)</code>来注册或者注销监听</p>\n<h2 id=\"Public-Method-Summary-1\"><a href=\"#Public-Method-Summary-1\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>void    abstract      onAuthStateChanged(WilddogAuth auth)</p>\n<pre><code>当状态发生变化的时候，这个方法在UI线程中调用\n\n      * 注册监听的时候\n      * 用户登录的时候\n      * 用户登出的时候\n      * 当前用户改变的时候\n      * 当前用户的token改变的时候\n</code></pre><h2 id=\"Public-Methods-1\"><a href=\"#Public-Methods-1\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract void onAuthStateChanged (WilddogAuth auth)</p>\n<p> 当状态发生变化的时候，这个方法在UI线程中调用：</p>\n<pre><code>* 注册监听的时候\n* 用户登录的时候\n* 用户登出的时候\n* 当前用户改变的时候\n* 当前用户的token改变的时候\n</code></pre><h3 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h3><p>auth  当前WilddogAuth 对象，用来进行Auth相关操作。  </p>\n<hr>\n<h1 id=\"WilddogAuthProvider\"><a href=\"#WilddogAuthProvider\" class=\"headerlink\" title=\"WilddogAuthProvider\"></a>WilddogAuthProvider</h1><p>public interface <strong>WilddogAuthProvider</strong></p>\n<p>提供Auth身份验证类型</p>\n<h2 id=\"Constant-Summary\"><a href=\"#Constant-Summary\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String  PROVIDER_ID      身份验证类型唯一字符标识。</p>\n<h2 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong><br>Unique string identifier for this provider type.</p>\n<p>Constant Value: “wilddog”    </p>\n<hr>\n<h1 id=\"UserInfo\"><a href=\"#UserInfo\" class=\"headerlink\" title=\"UserInfo\"></a>UserInfo</h1><p>public interface <strong>UserInfo</strong></p>\n<p>已知直接子类</p>\n<p>WilddogUser</p>\n<p>  获取一个用户的标准用户配置信息。可用于身份验证提供者返回的用户配置信息，例如QQ登录或者微信登录。</p>\n<h2 id=\"Public-Method-Summary-2\"><a href=\"#Public-Method-Summary-2\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>  abstract String getDisplayName()</p>\n<p>  如果可用，返回用户昵称。</p>\n<p>  abstract String getEmail()</p>\n<p>  如果可用，返回指定认证提供类型的电子邮箱地址</p>\n<p>  abstract Uri    getPhotoUrl()</p>\n<p>  如果可用，返回用户设置的形象照片的URL</p>\n<p>  abstract String getProviderId()</p>\n<p> 返回提供者类型实例的唯一标识符</p>\n<p>  abstract String    getUid()</p>\n<p>  返回一个身份验证提供者指定的用户标识符。</p>\n<h2 id=\"Public-Methods-2\"><a href=\"#Public-Methods-2\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract String getDisplayName ()</p>\n<p>如果可用，返回用户昵称。</p>\n<p>public abstract String getEmail ()</p>\n<p>返回对应于指定提供者的用户帐户的电子邮件地址，包含可选。</p>\n<p>public abstract Uri getPhotoUrl ()</p>\n<p>如果可用，返回用户形象照片。</p>\n<p>public abstract String getProviderId ()</p>\n<p>返回提供者类型实例的唯一标识符，例如QQ，weixin。</p>\n<p>public abstract String getUid ()</p>\n<p>返回一个身份验证提供者指定的用户标识符。例如，如果是qq返回qq的uid，如果是微博，返回微博的openId。</p>\n<hr>\n<h1 id=\"AuthCredential\"><a href=\"#AuthCredential\" class=\"headerlink\" title=\"AuthCredential\"></a>AuthCredential</h1><p>public abstract class <strong>AuthCredential</strong> extends Object</p>\n<p>已知直接子类<br>EmailAuthCredential，QQAuthCredential，WeiboAuthCredential，WeiXinAuthCredential</p>\n<p>代表Wilddog支持的身份认证的方式的认证凭据。</p>\n<h2 id=\"Public-Method-Summary-3\"><a href=\"#Public-Method-Summary-3\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>abstract String    getProvider()</p>\n<p>返回使用的认证方式的类型唯一标识。</p>\n<h2 id=\"Public-Methods-3\"><a href=\"#Public-Methods-3\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public abstract String getProvider ()</p>\n<p>返回使用的认证方式的类型唯一标识。例如：”weixin”，”qq”，”weibo”，”password”</p>\n<hr>\n<h1 id=\"EmailAuthCredential\"><a href=\"#EmailAuthCredential\" class=\"headerlink\" title=\"EmailAuthCredential\"></a>EmailAuthCredential</h1><p>public class <strong>EmailAuthCredential</strong> extends AuthCredential</p>\n<p>包含邮箱和密码的身份认证方式</p>\n<h2 id=\"Public-Method-Summary-4\"><a href=\"#Public-Method-Summary-4\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回使用的认证方式的类型唯一标识。</p>\n<h2 id=\"public-String-getProvider\"><a href=\"#public-String-getProvider\" class=\"headerlink\" title=\"public String getProvider ()\"></a>public String getProvider ()</h2><p>返回类型为”password”类型的认证方式唯一标识。</p>\n<hr>\n<h1 id=\"EmailAuthProvider\"><a href=\"#EmailAuthProvider\" class=\"headerlink\" title=\"EmailAuthProvider\"></a>EmailAuthProvider</h1><p>public class <strong>EmailAuthProvider</strong> extends Object</p>\n<p>代表了电子邮件和密码身份验证机制，使用这个类来获取EmailAuthCredential。</p>\n<h2 id=\"Constant-Summary-1\"><a href=\"#Constant-Summary-1\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-5\"><a href=\"#Public-Method-Summary-5\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>static AuthCredential    getCredential(String email, String password)</p>\n<p>返回一个带有用户名和密码的用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-1\"><a href=\"#Constants-1\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “password”</p>\n<h2 id=\"Public-Methods-4\"><a href=\"#Public-Methods-4\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential (String email, String password)</p>\n<p>返回一个带有用户名和密码的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"QQAuthCredential\"><a href=\"#QQAuthCredential\" class=\"headerlink\" title=\"QQAuthCredential\"></a>QQAuthCredential</h1><p>public class QQAuthCredential extends AuthCredential</p>\n<p>包含qq accessToken的认证凭据</p>\n<h2 id=\"Public-Method-Summary-6\"><a href=\"#Public-Method-Summary-6\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回身份认证的唯一标识 “qq”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<h2 id=\"Public-Methods-5\"><a href=\"#Public-Methods-5\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getProvider ()</p>\n<p>返回身份认证的唯一标识 “qq”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<hr>\n<h1 id=\"QQAuthProvider\"><a href=\"#QQAuthProvider\" class=\"headerlink\" title=\"QQAuthProvider\"></a>QQAuthProvider</h1><p>public class <strong>QQAuthProvider</strong> extends Object</p>\n<p>代表了QQ身份认证机制，使用这个类来获取QQAuthCredential。</p>\n<h2 id=\"Constant-Summary-2\"><a href=\"#Constant-Summary-2\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-7\"><a href=\"#Public-Method-Summary-7\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>static AuthCredential    getCredential(String token)</p>\n<p>返回一个带有accessToken的QQ用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-2\"><a href=\"#Constants-2\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “qq”</p>\n<h2 id=\"Public-Methods-6\"><a href=\"#Public-Methods-6\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential (String token)</p>\n<p>返回一个带有用户名和密码的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"WeiboAuthCredential\"><a href=\"#WeiboAuthCredential\" class=\"headerlink\" title=\"WeiboAuthCredential\"></a>WeiboAuthCredential</h1><p>public class WeiboAuthCredential extends AuthCredential</p>\n<p>包含微博 accessToken和uid的认证凭据</p>\n<h2 id=\"Public-Method-Summary-8\"><a href=\"#Public-Method-Summary-8\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回身份认证的唯一标识 “weibo”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<p> public String getUid()</p>\n<p> 返回要上传的微博平台唯一标识uid。</p>\n<h2 id=\"Public-Methods-7\"><a href=\"#Public-Methods-7\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getProvider ()</p>\n<p>返回身份认证的唯一标识 “weibo”</p>\n<p>public String getAccessToken()</p>\n<p>返回要上传的token信息</p>\n<p>public String getUid()</p>\n<p>返回要上传的微博平台唯一标识uid。</p>\n<hr>\n<h1 id=\"WeiboAuthProvider\"><a href=\"#WeiboAuthProvider\" class=\"headerlink\" title=\"WeiboAuthProvider\"></a>WeiboAuthProvider</h1><p>public class <strong>WeiboAuthProvider</strong> extends Object</p>\n<p>代表了新浪微博身份认证机制，使用这个类来获取WeiboAuthCredential。</p>\n<h2 id=\"Constant-Summary-3\"><a href=\"#Constant-Summary-3\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-9\"><a href=\"#Public-Method-Summary-9\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p> static AuthCredential getCredential( String token,String openId) </p>\n<p>返回一个带有token和openId的用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-3\"><a href=\"#Constants-3\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “weibo”</p>\n<h2 id=\"Public-Methods-8\"><a href=\"#Public-Methods-8\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential (String token,String openId)</p>\n<p>返回一个带有用户名和密码的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"WeiXinAuthCredential\"><a href=\"#WeiXinAuthCredential\" class=\"headerlink\" title=\"WeiXinAuthCredential\"></a>WeiXinAuthCredential</h1><p>public class WeiboAuthCredential extends AuthCredential</p>\n<p>包含微信code的认证凭据</p>\n<h2 id=\"Public-Method-Summary-10\"><a href=\"#Public-Method-Summary-10\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getProvider()</p>\n<p>返回身份认证的唯一标识 “weixin”</p>\n<p>public String getCode()</p>\n<p>返回微信授权认证返回的code。</p>\n<h2 id=\"Public-Methods-9\"><a href=\"#Public-Methods-9\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getProvider ()</p>\n<p>返回身份认证的唯一标识 “weixin”</p>\n<p>public String getCode()</p>\n<p>返回微信授权认证返回的code。</p>\n<hr>\n<h1 id=\"WeiXinAuthProvider\"><a href=\"#WeiXinAuthProvider\" class=\"headerlink\" title=\"WeiXinAuthProvider\"></a>WeiXinAuthProvider</h1><p>public class <strong>WeiXinAuthProvider</strong> extends Object</p>\n<p>代表了微信身份认证机制，使用这个类来获取WeiXinAuthCredential。</p>\n<h2 id=\"Constant-Summary-4\"><a href=\"#Constant-Summary-4\" class=\"headerlink\" title=\"Constant Summary\"></a>Constant Summary</h2><p>String    PROVIDER_ID    认证类型的唯一字符串标识。</p>\n<h2 id=\"Public-Method-Summary-11\"><a href=\"#Public-Method-Summary-11\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p> static AuthCredential getCredential( String code) </p>\n<p>返回一个带有code的用户凭证，用于后续的登录或者绑定邮箱认证方式。</p>\n<h2 id=\"Constants-4\"><a href=\"#Constants-4\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>public static final String <strong>PROVIDER_ID</strong></p>\n<p>认证方式的唯一字符串标识</p>\n<p>常量值: “weixin”</p>\n<h2 id=\"Public-Methods-10\"><a href=\"#Public-Methods-10\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public static AuthCredential getCredential ( String code)</p>\n<p>返回一个带有code的用户凭证，当调用<code>signInWithCredential(AuthCredential)</code>或者<code>linkWithCredential(AuthCredential)</code>时候使用</p>\n<hr>\n<h1 id=\"GetTokenResult\"><a href=\"#GetTokenResult\" class=\"headerlink\" title=\"GetTokenResult\"></a>GetTokenResult</h1><p>public class GetTokenResult extends Object</p>\n<p>返回WilddogIdToken结果对象</p>\n<h2 id=\"Public-Method-Summary-12\"><a href=\"#Public-Method-Summary-12\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getToken()</p>\n<p>Wilddog ID Token.</p>\n<h2 id=\"Public-Methods-11\"><a href=\"#Public-Methods-11\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getToken ()</p>\n<p>Wilddog ID Token. 身份认证成功后返回的Wilddog Id token字符串。用于验证之后操作的身份完整性和安全性。</p>\n<hr>\n<h1 id=\"UserProfileChangeRequest\"><a href=\"#UserProfileChangeRequest\" class=\"headerlink\" title=\"UserProfileChangeRequest\"></a>UserProfileChangeRequest</h1><p>public class UserProfileChangeRequest extends Object<br>implements SafeParcelable</p>\n<p>用来更新用户信息的请求对象</p>\n<h2 id=\"Nested-Class-Summary\"><a href=\"#Nested-Class-Summary\" class=\"headerlink\" title=\"Nested Class Summary\"></a>Nested Class Summary</h2><p>class    UserProfileChangeRequest.Builder    </p>\n<p>构建请求的内部类</p>\n<h2 id=\"Public-Method-Summary-13\"><a href=\"#Public-Method-Summary-13\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>String    getDisplayName()</p>\n<p>返回要修改的昵称信息</p>\n<p>Uri    getPhotoUri()</p>\n<p>返回要修改的头像URL</p>\n<h2 id=\"Public-Methods-12\"><a href=\"#Public-Methods-12\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public String getDisplayName ()</p>\n<p>返回要修改的昵称信息</p>\n<p>public Uri getPhotoUri ()</p>\n<p>返回要修改的头像URL</p>\n<hr>\n<h1 id=\"UserProfileChangeRequest-Builder\"><a href=\"#UserProfileChangeRequest-Builder\" class=\"headerlink\" title=\"UserProfileChangeRequest.Builder\"></a>UserProfileChangeRequest.Builder</h1><p>public static class UserProfileChangeRequest.Builder extends Object</p>\n<p>请求构建器</p>\n<h2 id=\"Public-Constructor-Summary\"><a href=\"#Public-Constructor-Summary\" class=\"headerlink\" title=\"Public Constructor Summary\"></a>Public Constructor Summary</h2><p>UserProfileChangeRequest.Builder()</p>\n<h2 id=\"Public-Method-Summary-14\"><a href=\"#Public-Method-Summary-14\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>UserProfileChangeRequest    build()</p>\n<p>构建一个修改用户信息的请求对象</p>\n<p>UserProfileChangeRequest.Builder setDisplayName(String displayName)</p>\n<p>设置要更新的昵称</p>\n<p>UserProfileChangeRequest.Builder setPhotoUri(Uri photoUri)</p>\n<p>设置要更新头像的URL.</p>\n<h2 id=\"Public-Constructors\"><a href=\"#Public-Constructors\" class=\"headerlink\" title=\"Public Constructors\"></a>Public Constructors</h2><p>public UserProfileChangeRequest.Builder ()</p>\n<h2 id=\"Public-Methods-13\"><a href=\"#Public-Methods-13\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>public UserProfileChangeRequest build ()</p>\n<h3 id=\"returns-1\"><a href=\"#returns-1\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>一个UserProfileChangeRequest实例</li>\n</ul>\n<p>public UserProfileChangeRequest.Builder setDisplayName (String displayName)</p>\n<p>设置要修改的昵称。</p>\n<h3 id=\"returns-2\"><a href=\"#returns-2\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>一个可以链式调用的UserProfileChangeRequest.Builder对象</li>\n</ul>\n<p>public UserProfileChangeRequest.Builder setPhotoUri (Uri photoUri)</p>\n<p>设置要修改的头像的URL。</p>\n<h3 id=\"returns-3\"><a href=\"#returns-3\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>一个可以链式调用的UserProfileChangeRequest.Builder对象</li>\n</ul>\n<hr>\n<h1 id=\"WilddogAuth\"><a href=\"#WilddogAuth\" class=\"headerlink\" title=\"WilddogAuth\"></a>WilddogAuth</h1><p>public abstract class WilddogAuth extends Object</p>\n<p>WilddogAuth SDK入口对象。</p>\n<p>首先通过调用 getInstance(“appId”,context)获取一个WilddogAuth实例对象。<br>接着，可以使用一下方法进行用户登录认证：</p>\n<ul>\n<li>createUserWithEmailAndPassword(String, String)</li>\n<li>signInWithEmailAndPassword(String, String)</li>\n<li>signInWithCredential(AuthCredential)</li>\n<li>signInAnonymously()</li>\n<li>signInWithCustomToken(String)</li>\n</ul>\n<p>最后，调用 <code>getCurrentUser()</code>获取包含用户信息的WilddogUser对象.</p>\n<h2 id=\"Nested-Class-Summary-1\"><a href=\"#Nested-Class-Summary-1\" class=\"headerlink\" title=\"Nested Class Summary\"></a>Nested Class Summary</h2><p>interface    WilddogAuth.AuthStateListener<br>    当认证状态发生变化的时候调用</p>\n<h2 id=\"Public-Method-Summary-15\"><a href=\"#Public-Method-Summary-15\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p> void    addAuthStateListener(FirebaseAuth.AuthStateListener listener)</p>\n<p> 注册认证状态改变的监听.</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    createUserWithEmailAndPassword(String email, String password)</p>\n<p> 试图去创建一个新的邮箱密码的用户账号。</p>\n<p> Task&lt;<code>ProviderQueryResult</code>&gt;    fetchProvidersForEmail(String email)</p>\n<p> 如果存在，则通过邮箱获取所有的认证类型。</p>\n<p> WilddogUser    getCurrentUser()</p>\n<p> 返回当前认证的用户信息，如果未认证返回null.</p>\n<p> static WilddogAuth    getInstance()</p>\n<p> 返回初始化之后，可以用本方法获取WilddogAuth实例对象</p>\n<p> static WilddogAuth    getInstance(String appId，Context context)</p>\n<p> 返回初始化WilddogAuth 实例对象。</p>\n<p> void    removeAuthStateListener(WilddogAuth.AuthStateListener listener)</p>\n<p> 注销曾经认证状态监听对象</p>\n<p> Task<Void>    sendPasswordResetEmail(String email)</p>\n<p> 给当前应用中现有的绑定当前email的用户发送密码重置邮件.</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInAnonymously()</p>\n<p> 使用匿名方法登录，不需要凭据，可以绑定其他认证方式.</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInWithCredential(AuthCredential credential)</p>\n<p> 通过AuthCredential进行用户认证，支持的认证方式：qq，微博，微信，密码</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInWithCustomToken(String token)</p>\n<p> 通过用户自定义的token进行用户认证。</p>\n<p> Task&lt;<code>AuthResult</code>&gt;    signInWithEmailAndPassword(String email, String password)</p>\n<p> 通过用户邮箱密码的方式进行用户认证</p>\n<p> void    signOut()</p>\n<p> 登出当前用户，清除登录数据</p>\n<h2 id=\"Public-Methods-14\"><a href=\"#Public-Methods-14\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p> public void addAuthStateListener (FirebaseAuth.AuthStateListener listener)</p>\n<p> 注册一个认证状态的监听。一个WilddogAuth对象可以设置多个监听对象，也可以为不同的WilddogAuth添加监听对象。</p>\n<p>   当以下情况出现，会在UI线程中触发回调：</p>\n<ul>\n<li>在监听对象注册的时候</li>\n<li>在用户登录认证的时候</li>\n<li>在当前用户登出的时候</li>\n<li>在当前用户改变的时候</li>\n<li><p>在当前用户的Wilddog Id token 改变的时候</p>\n<p>推荐的做法总是监听注销事件，因为你可能要提示用户再次登录并且可能限制用户获取信息或者操作.</p>\n<p>可以使用<code>removeAuthStateListener(AuthStateListener)</code>注销监听.</p>\n</li>\n</ul>\n<p>  public Task&lt;<code>AuthResult</code>&gt; createUserWithEmailAndPassword (String email, String password)<br>  试图用给定的邮箱和密码创建一个用户账号，如果成功，这个用户也将登录成功。</p>\n<p>  然后可以通过<code>getCurrentUser()</code>访问用户信息和进行用户操作.</p>\n<p>  一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法</p>\n<p>  <strong>注意:</strong> 你必须在Wilddog控制面板中打开这种登录认证方式。</p>\n<h3 id=\"returns-4\"><a href=\"#returns-4\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task</p>\n<p>public Task&lt;<code>ProviderQueryResult</code>&gt; fetchProvidersForEmail (String email)</p>\n<p>  返回通过绑定的主邮箱获取当前用户的认证方式列表</p>\n<p>当你绑定多种认证机制的时候，这个方法将会返回所有的认证方式列表。</p>\n<h3 id=\"Parameters-1\"><a href=\"#Parameters-1\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h3><p>email</p>\n<p>用户返回登录认证方式列表的邮箱地址</p>\n<h3 id=\"returns-5\"><a href=\"#returns-5\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task</p>\n<p>public WilddogUser getCurrentUser ()</p>\n<p>如果有用户认证登录返回登录用户，如果没有登录，则返回为空。</p>\n<p>可以通过 <code>getCurrentUser() != null</code> 来判断当前是否有用户登录</p>\n<h3 id=\"returns-6\"><a href=\"#returns-6\" class=\"headerlink\" title=\"returns\"></a>returns</h3><ul>\n<li>当前认证用户或者null</li>\n</ul>\n<p>public static WilddogAuth getInstance ()</p>\n<p> 返回初始化之后，可以用本方法获取当前WilddogAuth实例对象</p>\n<p> public static WilddogAuth getInstance(String appId，Context context)</p>\n<p>  返回初始化WilddogAuth 实例对象。</p>\n<p> public void removeAuthStateListener (WilddogAuth.AuthStateListener listener)</p>\n<p> 注销认证状态的监听</p>\n<p> public Task<Void> sendPasswordResetEmail (String email)</p>\n<p>  给当前应用中现有的绑定当前email的用户发送密码重置邮件.</p>\n<p>  返回当前操作结果的Task对象</p>\n<p>  public Task&lt;<code>AuthResult</code>&gt; signInAnonymously ()</p>\n<p>   使用匿名方法登录，不需要凭据，可以绑定其他认证方式.</p>\n<p>   这个操作将在Wilddog创建一个匿名的用户账号，其中通过<code>getCurrentUser()</code>获取用户信息包含uid。</p>\n<p>一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<p>  <strong>注意:</strong> 你必须在Wilddog控制面板中打开这种登录认证方式。</p>\n<p>public Task<AuthResult> signInWithCredential (AuthCredential credential)</p>\n<p>通过给定的<code>AuthCredential</code>对象进行相应的认证登录。其中包含QQ，微信，新浪微博和密码认证登录。</p>\n<p>所有<code>AuthCredential</code>都会创建一个用户账号。</p>\n<p><strong>注意:</strong> 你必须在Wilddog控制面板中打开相应的登录认证方式。</p>\n<h3 id=\"returns-7\"><a href=\"#returns-7\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task    </p>\n<p>public Task&lt;<code>AuthResult</code>&gt; signInWithCustomToken (String token)</p>\n<p>通过用户自定义的token进行用户认证。</p>\n<p>  从用户服务器首先获取到Wilddog Custom Token,然后登录到Wilddog服务器，进行数据操作，可以通过getCurrentUser获取当前登录认证用户信息。</p>\n<p>  一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<p>  阅读<a href=\"\">自定义Token</a></p>\n<h3 id=\"returns-8\"><a href=\"#returns-8\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task   </p>\n<p>public Task<AuthResult> signInWithEmailAndPassword (String email, String password)</p>\n<p>通过邮箱和密码进行登录认证。</p>\n<p>可以通过getCurrentUser获取当前登录认证用户信息。</p>\n<p>  一旦登录成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<p>  <strong>注意:</strong> 你必须在Wilddog控制面板中打开这种登录认证方式。</p>\n<p>  这个方法和<code>signInWithCredential（）</code>的<code>EmailAuthCredential</code>登录认证方式是等效的。</p>\n<h3 id=\"returns-9\"><a href=\"#returns-9\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回带有AuthResult的操作结果对象Task</p>\n<p>public void signOut ()</p>\n<p>登出当前用户，清除登录数据</p>\n<p>一旦登出成功，就会回调所有的注册的<code>WilddogAuth.AuthStateListener</code>的<code>onAuthStateChanged(WilddogAuth)</code>方法.</p>\n<hr>\n<h1 id=\"WilddogUser\"><a href=\"#WilddogUser\" class=\"headerlink\" title=\"WilddogUser\"></a>WilddogUser</h1><p>public abstract class WilddogUser extends Object<br>implements UserInfo</p>\n<p>获取用户在Wilddog Auth的个人资料信息。它还有辅助方法进行用户信息的修改和查询，以及管理用户的身份验证方式。</p>\n<h2 id=\"Public-Constructor-Summary-1\"><a href=\"#Public-Constructor-Summary-1\" class=\"headerlink\" title=\"Public Constructor Summary\"></a>Public Constructor Summary</h2><p>WilddogUser（）</p>\n<h2 id=\"Public-Method-Summary-16\"><a href=\"#Public-Method-Summary-16\" class=\"headerlink\" title=\"Public Method Summary\"></a>Public Method Summary</h2><p>Task<Void> delete()</p>\n<p>从Wilddog Auth 系统中删除用户.</p>\n<p>abstract String    getDisplayName()</p>\n<p>获取在Wilddog Auth 系统中的用户的昵称.</p>\n<p>abstract String    getEmail()</p>\n<p>获取在Wilddog Auth 系统中的用户的邮箱.</p>\n<p>abstract Uri    getPhotoUrl()</p>\n<p>获取在Wilddog Auth 系统中的用户的头像的URL.</p>\n<p>abstract List&lt;? extends UserInfo&gt;    getProviderData()</p>\n<p>获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.</p>\n<p>abstract String    getProviderId()</p>\n<p>返回PROVIDER_ID，例如 “qq”,”weixin”.</p>\n<p>Task&lt;<code>GetTokenResult</code>&gt;    getToken(boolean forceRefresh)</p>\n<p>获取Wilddog ID Token</p>\n<p>abstract String    getUid()</p>\n<p>获取在Wilddog Auth 系统中的用户的唯一标识.</p>\n<p>abstract boolean    isAnonymous()</p>\n<p>判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。</p>\n<p>Task&lt;<code>AuthResult</code>&gt;    linkWithCredential(AuthCredential credential)</p>\n<p>将当前用户与给定的登录认证方式绑定。</p>\n<p>Task&lt;<code>Void</code>&gt;    reauthenticate(AuthCredential credential)</p>\n<p>用给定的登录认证方式重新认证。</p>\n<p>Task&lt;<code>Void</code>&gt;    reload()</p>\n<p>手动刷新当前用户的数据。（连接提供者，显示名称等等）</p>\n<p>Task&lt;<code>AuthResult</code>&gt;    unlink(String provider)</p>\n<p>将给定的登录认证类型从当前用户绑定列表中解除绑定.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateEmail(String email)</p>\n<p>更新当前登录认证用户的邮箱信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updatePassword(String password)</p>\n<p>更新当前登录认证用户的密码信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateProfile(UserProfileChangeRequest request)</p>\n<p>更新当前用户的昵称信息和头像URL</p>\n<h2 id=\"Public-Constructors-1\"><a href=\"#Public-Constructors-1\" class=\"headerlink\" title=\"Public Constructors\"></a>Public Constructors</h2><p>public WilddogUser ()</p>\n<h2 id=\"Public-Methods-15\"><a href=\"#Public-Methods-15\" class=\"headerlink\" title=\"Public Methods\"></a>Public Methods</h2><p>  public Task&lt;<code>Void</code>&gt; delete ()</p>\n<p>  从Wilddog Auth 系统中删除用户.<br>  如果操作成功，用户将从登录系统中登出。<br>  这个是一个安全敏感操作，需要用户用户最近登录过才能操作成功，如果失败，请先使用<code>reauthenticate(AuthCredential)</code>方法.</p>\n<p>  public abstract String getDisplayName ()</p>\n<pre><code>获取当前用户的昵称，如果是第三方登录方式，不能修改昵称信息，因此不会第三方登录平台昵称不会受到影响。使用`updateProfile(UserProfileChangeRequest)`方法会更新这个属性。\n</code></pre><p>如果使用<code>signInWithCredential （ AuthCredential ）</code>登录的时候包含这个属性，将在登录时候自动创建填充属性。</p>\n<p>  public abstract String getEmail ()</p>\n<p>  返回当前用户设置的邮箱地址，如果第三方登录中含有这个属性，将不能被修改。<br>  其他情况下可以通过<code>updateProfile(UserProfileChangeRequest)</code>方法会更新这个属性.</p>\n<p>  这个属性将会在<code>signInWithCredential(AuthCredential)</code>的<code>EmailAuthCredential</code>或者<code>createUserWithEmailAndPassword(String, String)</code>填充这个属性.</p>\n<p>  public abstract Uri getPhotoUrl ()</p>\n<p>  返回当前用户的头像的url，如果第三方登录中含有这个属性，将不能被修改。<br>   其他情况下可以通过<code>updateProfile(UserProfileChangeRequest)</code>方法会更新这个属性.</p>\n<p>   如果使用<code>signInWithCredential （ AuthCredential ）</code>登录的时候包含这个属性，将在登录时候自动创建填充属性。</p>\n<p>  abstract List&lt;? extends UserInfo&gt;    getProviderData()</p>\n<p>获取在Wilddog Auth 系统中用户绑定的所有认证类型的用户信息列表.</p>\n<p>abstract String    getProviderId()</p>\n<p>返回PROVIDER_ID，例如 “qq”,”weixin”，”weibo”，”password”。</p>\n<p>public Task&lt;<code>GetTokenResult</code>&gt; getToken (boolean forceRefresh)</p>\n<p>获取Wilddog ID Token，使用我们的服务器SDK或按照官方文件安全地验证此token的完整性和有效性。</p>\n<h3 id=\"returns-10\"><a href=\"#returns-10\" class=\"headerlink\" title=\"returns\"></a>returns</h3><p>返回一个带有<code>GetTokenResult</code>信息的Task对象.</p>\n<p>public abstract String getUid ()</p>\n<p>获取在Wilddog Auth 系统中的用户的唯一标识.</p>\n<p>该标识符是不透明的，不一定对应于用户的电子邮件地址或任何其它属性.</p>\n<p>public abstract boolean isAnonymous ()</p>\n<p>判断当前用户是否是匿名登录，表示当前未绑定其他登录认证方式。</p>\n<p>public Task&lt;<code>AuthResult</code>&gt; linkWithCredential (AuthCredential credential)</p>\n<p>将当前用户与给定的登录认证方式绑定。之后支持绑定的所有登录认证方式。</p>\n<p>public Task&lt;<code>Void</code>&gt; reauthenticate (AuthCredential credential)</p>\n<p>用给定的登录认证方式重新认证。</p>\n<p>Task&lt;<code>Void</code>&gt;    reload()</p>\n<p>手动刷新当前用户的数据。（连接提供者，显示名称等等）</p>\n<p>Task&lt;<code>AuthResult</code>&gt;    unlink(String provider)</p>\n<p>将给定的登录认证类型从当前用户绑定列表中解除绑定.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateEmail(String email)</p>\n<p>更新当前登录认证用户的邮箱信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updatePassword(String password)</p>\n<p>更新当前登录认证用户的密码信息.</p>\n<p>Task&lt;<code>Void</code>&gt;    updateProfile(UserProfileChangeRequest request)</p>\n<p>更新当前用户的昵称信息和头像URL</p>\n<hr>\n"},{"title":"完整 API 文档","_content":"\n# WDGAuth (*Methods*)\n\n## + authWithApp:\n\n 定义\n\n`+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))`\n\n 说明\n\n以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。\n\n 参数\n\nappID 应用的 appID。\n\n 描述\n\n能确保线程安全。\n\n----\n## currentUser\n \n 定义\n\n`@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser`\n\n 说明\n\n同步的获取当前缓存的用户，如果没有登录用户则为 null。\n\n----\n## - fetchProvidersForEmail:completion:\n\n 定义\n\n`- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion`\n\n 说明\n\n通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。\n\n 参数\n\nemail 用户的邮箱。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - signInWithEmail:password:completion:\n\n 定义\n\n`- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以邮箱和密码的方式登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户的登录密码。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## - signInWithCredential:completion:\n\n 定义\n\n`- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）\n\n 参数\n\ncredential 第三方提供的凭证。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。\n - WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示账号被禁用。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - signInAnonymouslyWithCompletion:\n\n 定义\n\n`- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n匿名登录方式。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。  \n可能发生的错误：\n \n -  WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n---- \n## - signInWithCustomToken:completion:\n\n 定义\n\n`- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以自定义 token 的方式登录。\n\n 参数\n\ntoken 自定义的 token。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。\n - WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key\n belong to different projects.\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - createUserWithEmail:password:completion:\n\n 定义\n`- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n创建一个新用户，创建成功后会自动登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户指定的密码。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。\n - WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。\n - WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - WDGAuthErrorCodeWeakPassword 密码不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## - sendPasswordResetWithEmail:completion:\n\n 定义\n\n`- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion`\n\n 说明\n\n通过邮箱找回密码。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n- See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - signOut:\n\n 定义\n\n`- (BOOL)signOut:(NSError *_Nullable *_Nullable)error`\n\n 说明\n\n退出登录。\n\n 参数\n\nerror 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。\n\n 返回值\n\nYES 表示退出登录成功。NO 表示失败\n\n----\n## - addAuthStateDidChangeListener:\n\n 定义\n\n`- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener`\n\n 说明\n\n监听用户 auth 状态。发生以下条件时会被调用：\n \n - 第一次调用时，\n - 当前用户切换时，\n - 或者当前用户的 idToken 变化时。\n\n 参数\n\nlistener 状态变化时调用的 block。异步等待，会在主线程中回调。\n\n 返回值\n\n返回这个 block 的唯一标示，用于移除这个 block。\n\n 描述\n\n这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。\n\n----\n## - removeAuthStateDidChangeListener:\n\n 定义\n\n`- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle`\n\n 说明\n\n移除 auth 状态变更监听。\n\n 参数\n\nlistenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。\n\n----\n# WDGAuthCredential (*Methods*)\n\n## provider\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *provider`\n\n 说明\n\n获取凭证的 id 名。\n\n----\n# WDGEmailPasswordAuthProvider (*Methods*)\n\n## + credentialWithEmail: password:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password`\n\n 说明\n\n创建一个 email & password 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\nemail 用户的 email 地址。  \npassword 用户的登录密码。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 email & password 登录方式凭证。\n\n----\n# WDGQQAuthProvider (*Methods*)\n\n## + credentialWithAccessToken:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken`\n\n 说明\n\n创建一个 qq 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken QQ OAuth access token.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 qq 登录凭证。\n\n----\n# WDGSinaAuthProvider (*Methods*)\n\n## + credentialWithAccessToken: userID:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID`\n\n 说明\n\n创建一个 Sina 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken Sina OAuth access token.\nuserID Sina OAuth 的 userID。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 Sina 登录凭证。\n\n----\n# WDGWeiXinAuthProvider (*Methods*)\n\n## + credentialWithCode:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithCode:(NSString *)code`\n\n 说明\n\n创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\ncode Weixin OAuth code.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 WeiXin 登录凭证。\n\n----\n# WDGUser (*Methods*)\n\n## anonymous\n\n 定义\n\n`@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous`\n\n 说明\n\n如果为 YES 则表明为匿名用户。\n\n----\n## emailVerified\n \n 定义\n\n`@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified`\n\n 说明\n\n如果为 YES 则表示和这个帐号关联的邮箱已经验证过。\n\n----\n## providerData\n \n 定义\n\n`@property(nonatomic, readonly, nonnull) NSArray<id<WDGUserInfo>> *providerData`\n\n 说明\n\n所有登录方式的用户信息。\n\n 描述\n\n不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号\n\n----\n## - updateEmail:completion:\n\n 定义\n\n`- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n更新帐号邮箱。如果更新成功，本地缓存也会刷新。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n如果这个邮箱已经创建过用户，则会更新失败。\n可能发生的错误：\n \n - WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。\n - WDGAuthErrorCodeInvalidEmail 邮箱格式错误。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - updatePassword:completion:\n\n 定义\n\n`- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n修改用户密码。如果成功，本地缓存也会被刷新。\n\n 参数\n  \npassword 用户设置的新密码。   \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - WDGAuthErrorCodeWeakPassword 密码设置不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## profileChangeRequest\n\n 定义\n\n`- (WDGUserProfileChangeRequest *)profileChangeRequest`\n\n 说明\n\n创建一个可以改变用户信息的对象。\n\n 描述\n\n修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。\n\n 返回值\n\n返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。\n\n----\n## - reloadWithCompletion:\n\n 定义\n\n`- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n从服务器上获取最新的用户信息。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。\n \n可能发生的错误：  \n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## - reauthenticateWithCredential:completion:\n\n 定义\n\n`- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n重新登录，刷新本地 idToken。\n\n 参数\n\ncredential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。\ncompletion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。\n\n 描述\n \n如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。\n可能发生的错误：\n\n- WDGAuthErrorCodeInvalidCredential 无效的凭证。\n - WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。\n - WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。\n - WDGAuthErrorCodeUserDisabled 用户帐号被禁用。\n - WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。\n - WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - getTokenWithCompletion:\n\n 定义\n`- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion`\n\n 说明\n\n获取用户 token。\n\n 参数\n \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n---- \n## - linkWithCredential:completion:\n\n 定义\n\n`- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。\n\n 参数\n\ncredential 一种登录方式的凭证。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。\n - WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。\n - WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。\n - 这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。\n - See 更多错误请参考 WDGAuthErrors。\n\n----\n## - unlinkFromProvider:completion:\n\n 定义\n\n`- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n解绑第三方帐号。\n\n 参数\n\nprovider 需要解绑的登录方式，可能为 qq、weixin、weibo。  \ncompletion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。\n - See 更多错误请参考 WDGAuthErrors。\n\n----\n## - sendEmailVerificationWithCompletion:\n\n 定义\n\n`- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion`\n\n 说明\n\n发送邮箱验证。\n\n 参数\n\ncompletion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeUserNotFound 没有这个帐号。\n - See 更多错误请参考 WDGAuthErrors。\n \n----\n## - deleteWithCompletion:\n\n 定义\n\n`- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n删除这个帐号（如果是当前用户，则退出登录）。\n\n 参数\n\ncompletion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:\n - See 更多错误请参考 WDGAuthErrors。\n \n----\n# WDGUserProfileChangeRequest (*Methods*)\n\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSString *displayName`\n\n 说明\n\n用户名\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n----\n## photoURL\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n----\n## - commitChangesWithCompletion:\n\n 定义\n\n`- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n提交更改\n\n 参数\n\ncompletion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。\n\n 描述\n\n修改属性必须在这个方法调用之前。\n\n----\n# WDGUserInfo (*protocol*)\n\n## providerID\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *providerID`\n\n 说明\n\n用户登录方式。\n\n----\n## uid\n \n 定义\n\n`@property(nonatomic, copy, readonly) NSString *uid`\n\n 说明\n\n用户 id。\n\n----\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *displayName`\n\n 说明\n\n用户名。\n\n----\n## photoURL\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像。\n\n----\n## email\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *email`\n\n 说明\n\n用户邮箱地址。\n\n----\n# WDGAuthErrors (*Methods*)\n\n## WDGAuthErrorCode\n\n 定义\n\n```\ntypedef NS_ENUM(NSInteger, WDGAuthErrorCode) {\n\n    WDGAuthErrorCodeInvalidCustomToken = 17000,\n\n    WDGAuthErrorCodeCustomTokenMismatch = 17002,\n\n    WDGAuthErrorCodeInvalidCredential = 17004,\n\n    WDGAuthErrorCodeUserDisabled = 17005,\n\n    WDGAuthErrorCodeOperationNotAllowed = 17006,\n\n    WDGAuthErrorCodeEmailAlreadyInUse = 17007,\n\n    WDGAuthErrorCodeInvalidEmail = 17008,\n\n    WDGAuthErrorCodeWrongPassword = 17009,\n\n    WDGAuthErrorCodeTooManyRequests = 17010,\n\n    WDGAuthErrorCodeUserNotFound = 17011,\n\n    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrorCodeRequiresRecentLogin = 17014,\n\n    WDGAuthErrorCodeProviderAlreadyLinked = 17015,\n\n    WDGAuthErrorCodeNoSuchProvider = 17016,\n\n    WDGAuthErrorCodeInvalidUserToken = 17017,\n\n    WDGAuthErrorCodeNetworkError = 17020,\n\n    WDGAuthErrorCodeUserTokenExpired = 17021,\n\n    WDGAuthErrorCodeInvalidAPIKey = 17023,\n\n    WDGAuthErrorCodeUserMismatch = 17024,\n\n    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,\n\n    WDGAuthErrorCodeWeakPassword = 17026,\n\n    WDGAuthErrorCodeAppNotAuthorized = 17028,\n    \n    WDGAuthErrorCodeKeychainError = 17995,\n\n    WDGAuthErrorCodeInternalError = 17999,\n};\n\n```\n\n\n 说明\n\nWilddog iOS 身份认证错误。\n\n 参数\n\nWDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误\n\nWDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程\n\nWDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误\n\nWDGAuthErrorCodeUserDisabled 表示用户的帐户已停用\n\nWDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用\n\nWDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用\n\nWDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确\n\nWDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录\n\nWDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试\n\nWDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误\n\nWDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接\n\nWDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于`WDGAuthErrorCodeAccountExistsWithDifferentCredential`，只是拼写错误，只存在向后兼容性\n\nWDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过\n\nWDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户\n\nWDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户\n\nWDGAuthErrorCodeInvalidUserToken 表示 token 失效，您必须提示该用户在此设备重新登录\n\nWDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误\n\nWDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期\n\nWDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效\n\nWDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户\n\nWDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联\n\nWDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱\n\nWDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时\n    \nWDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错\n\nWDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误","source":"api/auth/ios.md","raw":"title:  完整 API 文档\n---\n\n# WDGAuth (*Methods*)\n\n## + authWithApp:\n\n 定义\n\n`+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))`\n\n 说明\n\n以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。\n\n 参数\n\nappID 应用的 appID。\n\n 描述\n\n能确保线程安全。\n\n----\n## currentUser\n \n 定义\n\n`@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser`\n\n 说明\n\n同步的获取当前缓存的用户，如果没有登录用户则为 null。\n\n----\n## - fetchProvidersForEmail:completion:\n\n 定义\n\n`- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion`\n\n 说明\n\n通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。\n\n 参数\n\nemail 用户的邮箱。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - signInWithEmail:password:completion:\n\n 定义\n\n`- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以邮箱和密码的方式登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户的登录密码。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## - signInWithCredential:completion:\n\n 定义\n\n`- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）\n\n 参数\n\ncredential 第三方提供的凭证。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。\n - WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示账号被禁用。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - signInAnonymouslyWithCompletion:\n\n 定义\n\n`- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n匿名登录方式。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。  \n可能发生的错误：\n \n -  WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n---- \n## - signInWithCustomToken:completion:\n\n 定义\n\n`- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以自定义 token 的方式登录。\n\n 参数\n\ntoken 自定义的 token。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。\n - WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key\n belong to different projects.\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - createUserWithEmail:password:completion:\n\n 定义\n`- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n创建一个新用户，创建成功后会自动登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户指定的密码。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。\n - WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。\n - WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - WDGAuthErrorCodeWeakPassword 密码不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## - sendPasswordResetWithEmail:completion:\n\n 定义\n\n`- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion`\n\n 说明\n\n通过邮箱找回密码。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n- See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - signOut:\n\n 定义\n\n`- (BOOL)signOut:(NSError *_Nullable *_Nullable)error`\n\n 说明\n\n退出登录。\n\n 参数\n\nerror 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。\n\n 返回值\n\nYES 表示退出登录成功。NO 表示失败\n\n----\n## - addAuthStateDidChangeListener:\n\n 定义\n\n`- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener`\n\n 说明\n\n监听用户 auth 状态。发生以下条件时会被调用：\n \n - 第一次调用时，\n - 当前用户切换时，\n - 或者当前用户的 idToken 变化时。\n\n 参数\n\nlistener 状态变化时调用的 block。异步等待，会在主线程中回调。\n\n 返回值\n\n返回这个 block 的唯一标示，用于移除这个 block。\n\n 描述\n\n这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。\n\n----\n## - removeAuthStateDidChangeListener:\n\n 定义\n\n`- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle`\n\n 说明\n\n移除 auth 状态变更监听。\n\n 参数\n\nlistenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。\n\n----\n# WDGAuthCredential (*Methods*)\n\n## provider\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *provider`\n\n 说明\n\n获取凭证的 id 名。\n\n----\n# WDGEmailPasswordAuthProvider (*Methods*)\n\n## + credentialWithEmail: password:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password`\n\n 说明\n\n创建一个 email & password 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\nemail 用户的 email 地址。  \npassword 用户的登录密码。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 email & password 登录方式凭证。\n\n----\n# WDGQQAuthProvider (*Methods*)\n\n## + credentialWithAccessToken:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken`\n\n 说明\n\n创建一个 qq 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken QQ OAuth access token.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 qq 登录凭证。\n\n----\n# WDGSinaAuthProvider (*Methods*)\n\n## + credentialWithAccessToken: userID:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID`\n\n 说明\n\n创建一个 Sina 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken Sina OAuth access token.\nuserID Sina OAuth 的 userID。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 Sina 登录凭证。\n\n----\n# WDGWeiXinAuthProvider (*Methods*)\n\n## + credentialWithCode:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithCode:(NSString *)code`\n\n 说明\n\n创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\ncode Weixin OAuth code.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 WeiXin 登录凭证。\n\n----\n# WDGUser (*Methods*)\n\n## anonymous\n\n 定义\n\n`@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous`\n\n 说明\n\n如果为 YES 则表明为匿名用户。\n\n----\n## emailVerified\n \n 定义\n\n`@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified`\n\n 说明\n\n如果为 YES 则表示和这个帐号关联的邮箱已经验证过。\n\n----\n## providerData\n \n 定义\n\n`@property(nonatomic, readonly, nonnull) NSArray<id<WDGUserInfo>> *providerData`\n\n 说明\n\n所有登录方式的用户信息。\n\n 描述\n\n不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号\n\n----\n## - updateEmail:completion:\n\n 定义\n\n`- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n更新帐号邮箱。如果更新成功，本地缓存也会刷新。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n如果这个邮箱已经创建过用户，则会更新失败。\n可能发生的错误：\n \n - WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。\n - WDGAuthErrorCodeInvalidEmail 邮箱格式错误。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - updatePassword:completion:\n\n 定义\n\n`- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n修改用户密码。如果成功，本地缓存也会被刷新。\n\n 参数\n  \npassword 用户设置的新密码。   \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - WDGAuthErrorCodeWeakPassword 密码设置不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## profileChangeRequest\n\n 定义\n\n`- (WDGUserProfileChangeRequest *)profileChangeRequest`\n\n 说明\n\n创建一个可以改变用户信息的对象。\n\n 描述\n\n修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。\n\n 返回值\n\n返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。\n\n----\n## - reloadWithCompletion:\n\n 定义\n\n`- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n从服务器上获取最新的用户信息。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。\n \n可能发生的错误：  \n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n----\n## - reauthenticateWithCredential:completion:\n\n 定义\n\n`- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n重新登录，刷新本地 idToken。\n\n 参数\n\ncredential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。\ncompletion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。\n\n 描述\n \n如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。\n可能发生的错误：\n\n- WDGAuthErrorCodeInvalidCredential 无效的凭证。\n - WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。\n - WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。\n - WDGAuthErrorCodeUserDisabled 用户帐号被禁用。\n - WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。\n - WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n----\n## - getTokenWithCompletion:\n\n 定义\n`- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion`\n\n 说明\n\n获取用户 token。\n\n 参数\n \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n---- \n## - linkWithCredential:completion:\n\n 定义\n\n`- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。\n\n 参数\n\ncredential 一种登录方式的凭证。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。\n - WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。\n - WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。\n - 这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。\n - See 更多错误请参考 WDGAuthErrors。\n\n----\n## - unlinkFromProvider:completion:\n\n 定义\n\n`- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n解绑第三方帐号。\n\n 参数\n\nprovider 需要解绑的登录方式，可能为 qq、weixin、weibo。  \ncompletion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。\n - See 更多错误请参考 WDGAuthErrors。\n\n----\n## - sendEmailVerificationWithCompletion:\n\n 定义\n\n`- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion`\n\n 说明\n\n发送邮箱验证。\n\n 参数\n\ncompletion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeUserNotFound 没有这个帐号。\n - See 更多错误请参考 WDGAuthErrors。\n \n----\n## - deleteWithCompletion:\n\n 定义\n\n`- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n删除这个帐号（如果是当前用户，则退出登录）。\n\n 参数\n\ncompletion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:\n - See 更多错误请参考 WDGAuthErrors。\n \n----\n# WDGUserProfileChangeRequest (*Methods*)\n\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSString *displayName`\n\n 说明\n\n用户名\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n----\n## photoURL\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n----\n## - commitChangesWithCompletion:\n\n 定义\n\n`- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n提交更改\n\n 参数\n\ncompletion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。\n\n 描述\n\n修改属性必须在这个方法调用之前。\n\n----\n# WDGUserInfo (*protocol*)\n\n## providerID\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *providerID`\n\n 说明\n\n用户登录方式。\n\n----\n## uid\n \n 定义\n\n`@property(nonatomic, copy, readonly) NSString *uid`\n\n 说明\n\n用户 id。\n\n----\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *displayName`\n\n 说明\n\n用户名。\n\n----\n## photoURL\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像。\n\n----\n## email\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *email`\n\n 说明\n\n用户邮箱地址。\n\n----\n# WDGAuthErrors (*Methods*)\n\n## WDGAuthErrorCode\n\n 定义\n\n```\ntypedef NS_ENUM(NSInteger, WDGAuthErrorCode) {\n\n    WDGAuthErrorCodeInvalidCustomToken = 17000,\n\n    WDGAuthErrorCodeCustomTokenMismatch = 17002,\n\n    WDGAuthErrorCodeInvalidCredential = 17004,\n\n    WDGAuthErrorCodeUserDisabled = 17005,\n\n    WDGAuthErrorCodeOperationNotAllowed = 17006,\n\n    WDGAuthErrorCodeEmailAlreadyInUse = 17007,\n\n    WDGAuthErrorCodeInvalidEmail = 17008,\n\n    WDGAuthErrorCodeWrongPassword = 17009,\n\n    WDGAuthErrorCodeTooManyRequests = 17010,\n\n    WDGAuthErrorCodeUserNotFound = 17011,\n\n    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrorCodeRequiresRecentLogin = 17014,\n\n    WDGAuthErrorCodeProviderAlreadyLinked = 17015,\n\n    WDGAuthErrorCodeNoSuchProvider = 17016,\n\n    WDGAuthErrorCodeInvalidUserToken = 17017,\n\n    WDGAuthErrorCodeNetworkError = 17020,\n\n    WDGAuthErrorCodeUserTokenExpired = 17021,\n\n    WDGAuthErrorCodeInvalidAPIKey = 17023,\n\n    WDGAuthErrorCodeUserMismatch = 17024,\n\n    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,\n\n    WDGAuthErrorCodeWeakPassword = 17026,\n\n    WDGAuthErrorCodeAppNotAuthorized = 17028,\n    \n    WDGAuthErrorCodeKeychainError = 17995,\n\n    WDGAuthErrorCodeInternalError = 17999,\n};\n\n```\n\n\n 说明\n\nWilddog iOS 身份认证错误。\n\n 参数\n\nWDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误\n\nWDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程\n\nWDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误\n\nWDGAuthErrorCodeUserDisabled 表示用户的帐户已停用\n\nWDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用\n\nWDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用\n\nWDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确\n\nWDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录\n\nWDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试\n\nWDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误\n\nWDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接\n\nWDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于`WDGAuthErrorCodeAccountExistsWithDifferentCredential`，只是拼写错误，只存在向后兼容性\n\nWDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过\n\nWDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户\n\nWDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户\n\nWDGAuthErrorCodeInvalidUserToken 表示 token 失效，您必须提示该用户在此设备重新登录\n\nWDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误\n\nWDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期\n\nWDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效\n\nWDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户\n\nWDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联\n\nWDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱\n\nWDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时\n    \nWDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错\n\nWDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误","date":"2016-09-06T03:38:22.513Z","updated":"2016-09-06T03:38:22.513Z","path":"api/auth/ios.html","comments":1,"layout":"page","_id":"cisswi9j30007z4fwprl3r5p4","content":"<h1 id=\"WDGAuth-Methods\"><a href=\"#WDGAuth-Methods\" class=\"headerlink\" title=\"WDGAuth (Methods)\"></a>WDGAuth (<em>Methods</em>)</h1><h2 id=\"authWithApp\"><a href=\"#authWithApp\" class=\"headerlink\" title=\"+ authWithApp:\"></a>+ authWithApp:</h2><p> 定义</p>\n<p><code>+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))</code></p>\n<p> 说明</p>\n<p>以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。</p>\n<p> 参数</p>\n<p>appID 应用的 appID。</p>\n<p> 描述</p>\n<p>能确保线程安全。</p>\n<hr>\n<h2 id=\"currentUser\"><a href=\"#currentUser\" class=\"headerlink\" title=\"currentUser\"></a>currentUser</h2><p> 定义</p>\n<p><code>@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser</code></p>\n<p> 说明</p>\n<p>同步的获取当前缓存的用户，如果没有登录用户则为 null。</p>\n<hr>\n<h2 id=\"fetchProvidersForEmail-completion\"><a href=\"#fetchProvidersForEmail-completion\" class=\"headerlink\" title=\"- fetchProvidersForEmail:completion:\"></a>- fetchProvidersForEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。</p>\n<p> 参数</p>\n<p>email 用户的邮箱。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInWithEmail-password-completion\"><a href=\"#signInWithEmail-password-completion\" class=\"headerlink\" title=\"- signInWithEmail:password:completion:\"></a>- signInWithEmail:password:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以邮箱和密码的方式登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户的登录密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInWithCredential-completion\"><a href=\"#signInWithCredential-completion\" class=\"headerlink\" title=\"- signInWithCredential:completion:\"></a>- signInWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）</p>\n<p> 参数</p>\n<p>credential 第三方提供的凭证。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示账号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInAnonymouslyWithCompletion\"><a href=\"#signInAnonymouslyWithCompletion\" class=\"headerlink\" title=\"- signInAnonymouslyWithCompletion:\"></a>- signInAnonymouslyWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>匿名登录方式。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInWithCustomToken-completion\"><a href=\"#signInWithCustomToken-completion\" class=\"headerlink\" title=\"- signInWithCustomToken:completion:\"></a>- signInWithCustomToken:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以自定义 token 的方式登录。</p>\n<p> 参数</p>\n<p>token 自定义的 token。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。</li>\n<li>WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key<br>belong to different projects.</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"createUserWithEmail-password-completion\"><a href=\"#createUserWithEmail-password-completion\" class=\"headerlink\" title=\"- createUserWithEmail:password:completion:\"></a>- createUserWithEmail:password:completion:</h2><p> 定义<br><code>- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>创建一个新用户，创建成功后会自动登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户指定的密码。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"sendPasswordResetWithEmail-completion\"><a href=\"#sendPasswordResetWithEmail-completion\" class=\"headerlink\" title=\"- sendPasswordResetWithEmail:completion:\"></a>- sendPasswordResetWithEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱找回密码。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signOut\"><a href=\"#signOut\" class=\"headerlink\" title=\"- signOut:\"></a>- signOut:</h2><p> 定义</p>\n<p><code>- (BOOL)signOut:(NSError *_Nullable *_Nullable)error</code></p>\n<p> 说明</p>\n<p>退出登录。</p>\n<p> 参数</p>\n<p>error 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。</p>\n<p> 返回值</p>\n<p>YES 表示退出登录成功。NO 表示失败</p>\n<hr>\n<h2 id=\"addAuthStateDidChangeListener\"><a href=\"#addAuthStateDidChangeListener\" class=\"headerlink\" title=\"- addAuthStateDidChangeListener:\"></a>- addAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener</code></p>\n<p> 说明</p>\n<p>监听用户 auth 状态。发生以下条件时会被调用：</p>\n<ul>\n<li>第一次调用时，</li>\n<li>当前用户切换时，</li>\n<li><p>或者当前用户的 idToken 变化时。</p>\n<p>参数</p>\n</li>\n</ul>\n<p>listener 状态变化时调用的 block。异步等待，会在主线程中回调。</p>\n<p> 返回值</p>\n<p>返回这个 block 的唯一标示，用于移除这个 block。</p>\n<p> 描述</p>\n<p>这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。</p>\n<hr>\n<h2 id=\"removeAuthStateDidChangeListener\"><a href=\"#removeAuthStateDidChangeListener\" class=\"headerlink\" title=\"- removeAuthStateDidChangeListener:\"></a>- removeAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle</code></p>\n<p> 说明</p>\n<p>移除 auth 状态变更监听。</p>\n<p> 参数</p>\n<p>listenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。</p>\n<hr>\n<h1 id=\"WDGAuthCredential-Methods\"><a href=\"#WDGAuthCredential-Methods\" class=\"headerlink\" title=\"WDGAuthCredential (Methods)\"></a>WDGAuthCredential (<em>Methods</em>)</h1><h2 id=\"provider\"><a href=\"#provider\" class=\"headerlink\" title=\"provider\"></a>provider</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *provider</code></p>\n<p> 说明</p>\n<p>获取凭证的 id 名。</p>\n<hr>\n<h1 id=\"WDGEmailPasswordAuthProvider-Methods\"><a href=\"#WDGEmailPasswordAuthProvider-Methods\" class=\"headerlink\" title=\"WDGEmailPasswordAuthProvider (Methods)\"></a>WDGEmailPasswordAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithEmail-password\"><a href=\"#credentialWithEmail-password\" class=\"headerlink\" title=\"+ credentialWithEmail: password:\"></a>+ credentialWithEmail: password:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password</code></p>\n<p> 说明</p>\n<p>创建一个 email &amp; password 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>email 用户的 email 地址。<br>password 用户的登录密码。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 email &amp; password 登录方式凭证。</p>\n<hr>\n<h1 id=\"WDGQQAuthProvider-Methods\"><a href=\"#WDGQQAuthProvider-Methods\" class=\"headerlink\" title=\"WDGQQAuthProvider (Methods)\"></a>WDGQQAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken\"><a href=\"#credentialWithAccessToken\" class=\"headerlink\" title=\"+ credentialWithAccessToken:\"></a>+ credentialWithAccessToken:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken</code></p>\n<p> 说明</p>\n<p>创建一个 qq 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken QQ OAuth access token.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 qq 登录凭证。</p>\n<hr>\n<h1 id=\"WDGSinaAuthProvider-Methods\"><a href=\"#WDGSinaAuthProvider-Methods\" class=\"headerlink\" title=\"WDGSinaAuthProvider (Methods)\"></a>WDGSinaAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken-userID\"><a href=\"#credentialWithAccessToken-userID\" class=\"headerlink\" title=\"+ credentialWithAccessToken: userID:\"></a>+ credentialWithAccessToken: userID:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID</code></p>\n<p> 说明</p>\n<p>创建一个 Sina 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken Sina OAuth access token.<br>userID Sina OAuth 的 userID。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 Sina 登录凭证。</p>\n<hr>\n<h1 id=\"WDGWeiXinAuthProvider-Methods\"><a href=\"#WDGWeiXinAuthProvider-Methods\" class=\"headerlink\" title=\"WDGWeiXinAuthProvider (Methods)\"></a>WDGWeiXinAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithCode\"><a href=\"#credentialWithCode\" class=\"headerlink\" title=\"+ credentialWithCode:\"></a>+ credentialWithCode:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithCode:(NSString *)code</code></p>\n<p> 说明</p>\n<p>创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>code Weixin OAuth code.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 WeiXin 登录凭证。</p>\n<hr>\n<h1 id=\"WDGUser-Methods\"><a href=\"#WDGUser-Methods\" class=\"headerlink\" title=\"WDGUser (Methods)\"></a>WDGUser (<em>Methods</em>)</h1><h2 id=\"anonymous\"><a href=\"#anonymous\" class=\"headerlink\" title=\"anonymous\"></a>anonymous</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表明为匿名用户。</p>\n<hr>\n<h2 id=\"emailVerified\"><a href=\"#emailVerified\" class=\"headerlink\" title=\"emailVerified\"></a>emailVerified</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表示和这个帐号关联的邮箱已经验证过。</p>\n<hr>\n<h2 id=\"providerData\"><a href=\"#providerData\" class=\"headerlink\" title=\"providerData\"></a>providerData</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, nonnull) NSArray&lt;id&lt;WDGUserInfo&gt;&gt; *providerData</code></p>\n<p> 说明</p>\n<p>所有登录方式的用户信息。</p>\n<p> 描述</p>\n<p>不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号</p>\n<hr>\n<h2 id=\"updateEmail-completion\"><a href=\"#updateEmail-completion\" class=\"headerlink\" title=\"- updateEmail:completion:\"></a>- updateEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>更新帐号邮箱。如果更新成功，本地缓存也会刷新。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果这个邮箱已经创建过用户，则会更新失败。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。</li>\n<li>WDGAuthErrorCodeInvalidEmail 邮箱格式错误。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"updatePassword-completion\"><a href=\"#updatePassword-completion\" class=\"headerlink\" title=\"- updatePassword:completion:\"></a>- updatePassword:completion:</h2><p> 定义</p>\n<p><code>- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>修改用户密码。如果成功，本地缓存也会被刷新。</p>\n<p> 参数</p>\n<p>password 用户设置的新密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码设置不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"profileChangeRequest\"><a href=\"#profileChangeRequest\" class=\"headerlink\" title=\"profileChangeRequest\"></a>profileChangeRequest</h2><p> 定义</p>\n<p><code>- (WDGUserProfileChangeRequest *)profileChangeRequest</code></p>\n<p> 说明</p>\n<p>创建一个可以改变用户信息的对象。</p>\n<p> 描述</p>\n<p>修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。</p>\n<p> 返回值</p>\n<p>返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。</p>\n<hr>\n<h2 id=\"reloadWithCompletion\"><a href=\"#reloadWithCompletion\" class=\"headerlink\" title=\"- reloadWithCompletion:\"></a>- reloadWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>从服务器上获取最新的用户信息。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。</p>\n<p>可能发生的错误：  </p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"reauthenticateWithCredential-completion\"><a href=\"#reauthenticateWithCredential-completion\" class=\"headerlink\" title=\"- reauthenticateWithCredential:completion:\"></a>- reauthenticateWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>重新登录，刷新本地 idToken。</p>\n<p> 参数</p>\n<p>credential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。<br>completion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 无效的凭证。<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。</li>\n<li>WDGAuthErrorCodeUserDisabled 用户帐号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。</li>\n<li>WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"getTokenWithCompletion\"><a href=\"#getTokenWithCompletion\" class=\"headerlink\" title=\"- getTokenWithCompletion:\"></a>- getTokenWithCompletion:</h2><p> 定义<br><code>- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion</code></p>\n<p> 说明</p>\n<p>获取用户 token。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"linkWithCredential-completion\"><a href=\"#linkWithCredential-completion\" class=\"headerlink\" title=\"- linkWithCredential:completion:\"></a>- linkWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。</p>\n<p> 参数</p>\n<p>credential 一种登录方式的凭证。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。</li>\n<li>WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。</li>\n<li>这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h2 id=\"unlinkFromProvider-completion\"><a href=\"#unlinkFromProvider-completion\" class=\"headerlink\" title=\"- unlinkFromProvider:completion:\"></a>- unlinkFromProvider:completion:</h2><p> 定义</p>\n<p><code>- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>解绑第三方帐号。</p>\n<p> 参数</p>\n<p>provider 需要解绑的登录方式，可能为 qq、weixin、weibo。<br>completion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h2 id=\"sendEmailVerificationWithCompletion\"><a href=\"#sendEmailVerificationWithCompletion\" class=\"headerlink\" title=\"- sendEmailVerificationWithCompletion:\"></a>- sendEmailVerificationWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion</code></p>\n<p> 说明</p>\n<p>发送邮箱验证。</p>\n<p> 参数</p>\n<p>completion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeUserNotFound 没有这个帐号。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h2 id=\"deleteWithCompletion\"><a href=\"#deleteWithCompletion\" class=\"headerlink\" title=\"- deleteWithCompletion:\"></a>- deleteWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>删除这个帐号（如果是当前用户，则退出登录）。</p>\n<p> 参数</p>\n<p>completion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h1 id=\"WDGUserProfileChangeRequest-Methods\"><a href=\"#WDGUserProfileChangeRequest-Methods\" class=\"headerlink\" title=\"WDGUserProfileChangeRequest (Methods)\"></a>WDGUserProfileChangeRequest (<em>Methods</em>)</h1><h2 id=\"displayName\"><a href=\"#displayName\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<hr>\n<h2 id=\"photoURL\"><a href=\"#photoURL\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<hr>\n<h2 id=\"commitChangesWithCompletion\"><a href=\"#commitChangesWithCompletion\" class=\"headerlink\" title=\"- commitChangesWithCompletion:\"></a>- commitChangesWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>提交更改</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>修改属性必须在这个方法调用之前。</p>\n<hr>\n<h1 id=\"WDGUserInfo-protocol\"><a href=\"#WDGUserInfo-protocol\" class=\"headerlink\" title=\"WDGUserInfo (protocol)\"></a>WDGUserInfo (<em>protocol</em>)</h1><h2 id=\"providerID\"><a href=\"#providerID\" class=\"headerlink\" title=\"providerID\"></a>providerID</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *providerID</code></p>\n<p> 说明</p>\n<p>用户登录方式。</p>\n<hr>\n<h2 id=\"uid\"><a href=\"#uid\" class=\"headerlink\" title=\"uid\"></a>uid</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *uid</code></p>\n<p> 说明</p>\n<p>用户 id。</p>\n<hr>\n<h2 id=\"displayName-1\"><a href=\"#displayName-1\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名。</p>\n<hr>\n<h2 id=\"photoURL-1\"><a href=\"#photoURL-1\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像。</p>\n<hr>\n<h2 id=\"email\"><a href=\"#email\" class=\"headerlink\" title=\"email\"></a>email</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *email</code></p>\n<p> 说明</p>\n<p>用户邮箱地址。</p>\n<hr>\n<h1 id=\"WDGAuthErrors-Methods\"><a href=\"#WDGAuthErrors-Methods\" class=\"headerlink\" title=\"WDGAuthErrors (Methods)\"></a>WDGAuthErrors (<em>Methods</em>)</h1><h2 id=\"WDGAuthErrorCode\"><a href=\"#WDGAuthErrorCode\" class=\"headerlink\" title=\"WDGAuthErrorCode\"></a>WDGAuthErrorCode</h2><p> 定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, WDGAuthErrorCode) &#123;</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCustomToken = 17000,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCustomTokenMismatch = 17002,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCredential = 17004,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserDisabled = 17005,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeOperationNotAllowed = 17006,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeEmailAlreadyInUse = 17007,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidEmail = 17008,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWrongPassword = 17009,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeTooManyRequests = 17010,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserNotFound = 17011,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeRequiresRecentLogin = 17014,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeProviderAlreadyLinked = 17015,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNoSuchProvider = 17016,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidUserToken = 17017,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNetworkError = 17020,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserTokenExpired = 17021,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidAPIKey = 17023,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserMismatch = 17024,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWeakPassword = 17026,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAppNotAuthorized = 17028,</div><div class=\"line\">    </div><div class=\"line\">    WDGAuthErrorCodeKeychainError = 17995,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInternalError = 17999,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p> 说明</p>\n<p>Wilddog iOS 身份认证错误。</p>\n<p> 参数</p>\n<p>WDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误</p>\n<p>WDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程</p>\n<p>WDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误</p>\n<p>WDGAuthErrorCodeUserDisabled 表示用户的帐户已停用</p>\n<p>WDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用</p>\n<p>WDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用</p>\n<p>WDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确</p>\n<p>WDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录</p>\n<p>WDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试</p>\n<p>WDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误</p>\n<p>WDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接</p>\n<p>WDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于<code>WDGAuthErrorCodeAccountExistsWithDifferentCredential</code>，只是拼写错误，只存在向后兼容性</p>\n<p>WDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过</p>\n<p>WDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户</p>\n<p>WDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户</p>\n<p>WDGAuthErrorCodeInvalidUserToken 表示 token 失效，您必须提示该用户在此设备重新登录</p>\n<p>WDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误</p>\n<p>WDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期</p>\n<p>WDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效</p>\n<p>WDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户</p>\n<p>WDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联</p>\n<p>WDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱</p>\n<p>WDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时</p>\n<p>WDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错</p>\n<p>WDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误</p>\n","excerpt":"","more":"<h1 id=\"WDGAuth-Methods\"><a href=\"#WDGAuth-Methods\" class=\"headerlink\" title=\"WDGAuth (Methods)\"></a>WDGAuth (<em>Methods</em>)</h1><h2 id=\"authWithApp\"><a href=\"#authWithApp\" class=\"headerlink\" title=\"+ authWithApp:\"></a>+ authWithApp:</h2><p> 定义</p>\n<p><code>+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))</code></p>\n<p> 说明</p>\n<p>以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。</p>\n<p> 参数</p>\n<p>appID 应用的 appID。</p>\n<p> 描述</p>\n<p>能确保线程安全。</p>\n<hr>\n<h2 id=\"currentUser\"><a href=\"#currentUser\" class=\"headerlink\" title=\"currentUser\"></a>currentUser</h2><p> 定义</p>\n<p><code>@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser</code></p>\n<p> 说明</p>\n<p>同步的获取当前缓存的用户，如果没有登录用户则为 null。</p>\n<hr>\n<h2 id=\"fetchProvidersForEmail-completion\"><a href=\"#fetchProvidersForEmail-completion\" class=\"headerlink\" title=\"- fetchProvidersForEmail:completion:\"></a>- fetchProvidersForEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。</p>\n<p> 参数</p>\n<p>email 用户的邮箱。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInWithEmail-password-completion\"><a href=\"#signInWithEmail-password-completion\" class=\"headerlink\" title=\"- signInWithEmail:password:completion:\"></a>- signInWithEmail:password:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以邮箱和密码的方式登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户的登录密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInWithCredential-completion\"><a href=\"#signInWithCredential-completion\" class=\"headerlink\" title=\"- signInWithCredential:completion:\"></a>- signInWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）</p>\n<p> 参数</p>\n<p>credential 第三方提供的凭证。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示账号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInAnonymouslyWithCompletion\"><a href=\"#signInAnonymouslyWithCompletion\" class=\"headerlink\" title=\"- signInAnonymouslyWithCompletion:\"></a>- signInAnonymouslyWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>匿名登录方式。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signInWithCustomToken-completion\"><a href=\"#signInWithCustomToken-completion\" class=\"headerlink\" title=\"- signInWithCustomToken:completion:\"></a>- signInWithCustomToken:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以自定义 token 的方式登录。</p>\n<p> 参数</p>\n<p>token 自定义的 token。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。</li>\n<li>WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key<br>belong to different projects.</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"createUserWithEmail-password-completion\"><a href=\"#createUserWithEmail-password-completion\" class=\"headerlink\" title=\"- createUserWithEmail:password:completion:\"></a>- createUserWithEmail:password:completion:</h2><p> 定义<br><code>- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>创建一个新用户，创建成功后会自动登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户指定的密码。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"sendPasswordResetWithEmail-completion\"><a href=\"#sendPasswordResetWithEmail-completion\" class=\"headerlink\" title=\"- sendPasswordResetWithEmail:completion:\"></a>- sendPasswordResetWithEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱找回密码。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"signOut\"><a href=\"#signOut\" class=\"headerlink\" title=\"- signOut:\"></a>- signOut:</h2><p> 定义</p>\n<p><code>- (BOOL)signOut:(NSError *_Nullable *_Nullable)error</code></p>\n<p> 说明</p>\n<p>退出登录。</p>\n<p> 参数</p>\n<p>error 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。</p>\n<p> 返回值</p>\n<p>YES 表示退出登录成功。NO 表示失败</p>\n<hr>\n<h2 id=\"addAuthStateDidChangeListener\"><a href=\"#addAuthStateDidChangeListener\" class=\"headerlink\" title=\"- addAuthStateDidChangeListener:\"></a>- addAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener</code></p>\n<p> 说明</p>\n<p>监听用户 auth 状态。发生以下条件时会被调用：</p>\n<ul>\n<li>第一次调用时，</li>\n<li>当前用户切换时，</li>\n<li><p>或者当前用户的 idToken 变化时。</p>\n<p>参数</p>\n</li>\n</ul>\n<p>listener 状态变化时调用的 block。异步等待，会在主线程中回调。</p>\n<p> 返回值</p>\n<p>返回这个 block 的唯一标示，用于移除这个 block。</p>\n<p> 描述</p>\n<p>这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。</p>\n<hr>\n<h2 id=\"removeAuthStateDidChangeListener\"><a href=\"#removeAuthStateDidChangeListener\" class=\"headerlink\" title=\"- removeAuthStateDidChangeListener:\"></a>- removeAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle</code></p>\n<p> 说明</p>\n<p>移除 auth 状态变更监听。</p>\n<p> 参数</p>\n<p>listenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。</p>\n<hr>\n<h1 id=\"WDGAuthCredential-Methods\"><a href=\"#WDGAuthCredential-Methods\" class=\"headerlink\" title=\"WDGAuthCredential (Methods)\"></a>WDGAuthCredential (<em>Methods</em>)</h1><h2 id=\"provider\"><a href=\"#provider\" class=\"headerlink\" title=\"provider\"></a>provider</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *provider</code></p>\n<p> 说明</p>\n<p>获取凭证的 id 名。</p>\n<hr>\n<h1 id=\"WDGEmailPasswordAuthProvider-Methods\"><a href=\"#WDGEmailPasswordAuthProvider-Methods\" class=\"headerlink\" title=\"WDGEmailPasswordAuthProvider (Methods)\"></a>WDGEmailPasswordAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithEmail-password\"><a href=\"#credentialWithEmail-password\" class=\"headerlink\" title=\"+ credentialWithEmail: password:\"></a>+ credentialWithEmail: password:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password</code></p>\n<p> 说明</p>\n<p>创建一个 email &amp; password 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>email 用户的 email 地址。<br>password 用户的登录密码。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 email &amp; password 登录方式凭证。</p>\n<hr>\n<h1 id=\"WDGQQAuthProvider-Methods\"><a href=\"#WDGQQAuthProvider-Methods\" class=\"headerlink\" title=\"WDGQQAuthProvider (Methods)\"></a>WDGQQAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken\"><a href=\"#credentialWithAccessToken\" class=\"headerlink\" title=\"+ credentialWithAccessToken:\"></a>+ credentialWithAccessToken:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken</code></p>\n<p> 说明</p>\n<p>创建一个 qq 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken QQ OAuth access token.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 qq 登录凭证。</p>\n<hr>\n<h1 id=\"WDGSinaAuthProvider-Methods\"><a href=\"#WDGSinaAuthProvider-Methods\" class=\"headerlink\" title=\"WDGSinaAuthProvider (Methods)\"></a>WDGSinaAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken-userID\"><a href=\"#credentialWithAccessToken-userID\" class=\"headerlink\" title=\"+ credentialWithAccessToken: userID:\"></a>+ credentialWithAccessToken: userID:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID</code></p>\n<p> 说明</p>\n<p>创建一个 Sina 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken Sina OAuth access token.<br>userID Sina OAuth 的 userID。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 Sina 登录凭证。</p>\n<hr>\n<h1 id=\"WDGWeiXinAuthProvider-Methods\"><a href=\"#WDGWeiXinAuthProvider-Methods\" class=\"headerlink\" title=\"WDGWeiXinAuthProvider (Methods)\"></a>WDGWeiXinAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithCode\"><a href=\"#credentialWithCode\" class=\"headerlink\" title=\"+ credentialWithCode:\"></a>+ credentialWithCode:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithCode:(NSString *)code</code></p>\n<p> 说明</p>\n<p>创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>code Weixin OAuth code.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 WeiXin 登录凭证。</p>\n<hr>\n<h1 id=\"WDGUser-Methods\"><a href=\"#WDGUser-Methods\" class=\"headerlink\" title=\"WDGUser (Methods)\"></a>WDGUser (<em>Methods</em>)</h1><h2 id=\"anonymous\"><a href=\"#anonymous\" class=\"headerlink\" title=\"anonymous\"></a>anonymous</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表明为匿名用户。</p>\n<hr>\n<h2 id=\"emailVerified\"><a href=\"#emailVerified\" class=\"headerlink\" title=\"emailVerified\"></a>emailVerified</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表示和这个帐号关联的邮箱已经验证过。</p>\n<hr>\n<h2 id=\"providerData\"><a href=\"#providerData\" class=\"headerlink\" title=\"providerData\"></a>providerData</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, nonnull) NSArray&lt;id&lt;WDGUserInfo&gt;&gt; *providerData</code></p>\n<p> 说明</p>\n<p>所有登录方式的用户信息。</p>\n<p> 描述</p>\n<p>不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号</p>\n<hr>\n<h2 id=\"updateEmail-completion\"><a href=\"#updateEmail-completion\" class=\"headerlink\" title=\"- updateEmail:completion:\"></a>- updateEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>更新帐号邮箱。如果更新成功，本地缓存也会刷新。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果这个邮箱已经创建过用户，则会更新失败。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。</li>\n<li>WDGAuthErrorCodeInvalidEmail 邮箱格式错误。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"updatePassword-completion\"><a href=\"#updatePassword-completion\" class=\"headerlink\" title=\"- updatePassword:completion:\"></a>- updatePassword:completion:</h2><p> 定义</p>\n<p><code>- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>修改用户密码。如果成功，本地缓存也会被刷新。</p>\n<p> 参数</p>\n<p>password 用户设置的新密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码设置不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"profileChangeRequest\"><a href=\"#profileChangeRequest\" class=\"headerlink\" title=\"profileChangeRequest\"></a>profileChangeRequest</h2><p> 定义</p>\n<p><code>- (WDGUserProfileChangeRequest *)profileChangeRequest</code></p>\n<p> 说明</p>\n<p>创建一个可以改变用户信息的对象。</p>\n<p> 描述</p>\n<p>修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。</p>\n<p> 返回值</p>\n<p>返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。</p>\n<hr>\n<h2 id=\"reloadWithCompletion\"><a href=\"#reloadWithCompletion\" class=\"headerlink\" title=\"- reloadWithCompletion:\"></a>- reloadWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>从服务器上获取最新的用户信息。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。</p>\n<p>可能发生的错误：  </p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"reauthenticateWithCredential-completion\"><a href=\"#reauthenticateWithCredential-completion\" class=\"headerlink\" title=\"- reauthenticateWithCredential:completion:\"></a>- reauthenticateWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>重新登录，刷新本地 idToken。</p>\n<p> 参数</p>\n<p>credential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。<br>completion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 无效的凭证。<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。</li>\n<li>WDGAuthErrorCodeUserDisabled 用户帐号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。</li>\n<li>WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"getTokenWithCompletion\"><a href=\"#getTokenWithCompletion\" class=\"headerlink\" title=\"- getTokenWithCompletion:\"></a>- getTokenWithCompletion:</h2><p> 定义<br><code>- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion</code></p>\n<p> 说明</p>\n<p>获取用户 token。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<hr>\n<h2 id=\"linkWithCredential-completion\"><a href=\"#linkWithCredential-completion\" class=\"headerlink\" title=\"- linkWithCredential:completion:\"></a>- linkWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。</p>\n<p> 参数</p>\n<p>credential 一种登录方式的凭证。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。</li>\n<li>WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。</li>\n<li>这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h2 id=\"unlinkFromProvider-completion\"><a href=\"#unlinkFromProvider-completion\" class=\"headerlink\" title=\"- unlinkFromProvider:completion:\"></a>- unlinkFromProvider:completion:</h2><p> 定义</p>\n<p><code>- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>解绑第三方帐号。</p>\n<p> 参数</p>\n<p>provider 需要解绑的登录方式，可能为 qq、weixin、weibo。<br>completion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h2 id=\"sendEmailVerificationWithCompletion\"><a href=\"#sendEmailVerificationWithCompletion\" class=\"headerlink\" title=\"- sendEmailVerificationWithCompletion:\"></a>- sendEmailVerificationWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion</code></p>\n<p> 说明</p>\n<p>发送邮箱验证。</p>\n<p> 参数</p>\n<p>completion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeUserNotFound 没有这个帐号。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h2 id=\"deleteWithCompletion\"><a href=\"#deleteWithCompletion\" class=\"headerlink\" title=\"- deleteWithCompletion:\"></a>- deleteWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>删除这个帐号（如果是当前用户，则退出登录）。</p>\n<p> 参数</p>\n<p>completion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<hr>\n<h1 id=\"WDGUserProfileChangeRequest-Methods\"><a href=\"#WDGUserProfileChangeRequest-Methods\" class=\"headerlink\" title=\"WDGUserProfileChangeRequest (Methods)\"></a>WDGUserProfileChangeRequest (<em>Methods</em>)</h1><h2 id=\"displayName\"><a href=\"#displayName\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<hr>\n<h2 id=\"photoURL\"><a href=\"#photoURL\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<hr>\n<h2 id=\"commitChangesWithCompletion\"><a href=\"#commitChangesWithCompletion\" class=\"headerlink\" title=\"- commitChangesWithCompletion:\"></a>- commitChangesWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>提交更改</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>修改属性必须在这个方法调用之前。</p>\n<hr>\n<h1 id=\"WDGUserInfo-protocol\"><a href=\"#WDGUserInfo-protocol\" class=\"headerlink\" title=\"WDGUserInfo (protocol)\"></a>WDGUserInfo (<em>protocol</em>)</h1><h2 id=\"providerID\"><a href=\"#providerID\" class=\"headerlink\" title=\"providerID\"></a>providerID</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *providerID</code></p>\n<p> 说明</p>\n<p>用户登录方式。</p>\n<hr>\n<h2 id=\"uid\"><a href=\"#uid\" class=\"headerlink\" title=\"uid\"></a>uid</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *uid</code></p>\n<p> 说明</p>\n<p>用户 id。</p>\n<hr>\n<h2 id=\"displayName-1\"><a href=\"#displayName-1\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名。</p>\n<hr>\n<h2 id=\"photoURL-1\"><a href=\"#photoURL-1\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像。</p>\n<hr>\n<h2 id=\"email\"><a href=\"#email\" class=\"headerlink\" title=\"email\"></a>email</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *email</code></p>\n<p> 说明</p>\n<p>用户邮箱地址。</p>\n<hr>\n<h1 id=\"WDGAuthErrors-Methods\"><a href=\"#WDGAuthErrors-Methods\" class=\"headerlink\" title=\"WDGAuthErrors (Methods)\"></a>WDGAuthErrors (<em>Methods</em>)</h1><h2 id=\"WDGAuthErrorCode\"><a href=\"#WDGAuthErrorCode\" class=\"headerlink\" title=\"WDGAuthErrorCode\"></a>WDGAuthErrorCode</h2><p> 定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, WDGAuthErrorCode) &#123;</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCustomToken = 17000,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCustomTokenMismatch = 17002,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCredential = 17004,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserDisabled = 17005,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeOperationNotAllowed = 17006,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeEmailAlreadyInUse = 17007,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidEmail = 17008,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWrongPassword = 17009,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeTooManyRequests = 17010,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserNotFound = 17011,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeRequiresRecentLogin = 17014,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeProviderAlreadyLinked = 17015,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNoSuchProvider = 17016,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidUserToken = 17017,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNetworkError = 17020,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserTokenExpired = 17021,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidAPIKey = 17023,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserMismatch = 17024,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWeakPassword = 17026,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAppNotAuthorized = 17028,</div><div class=\"line\">    </div><div class=\"line\">    WDGAuthErrorCodeKeychainError = 17995,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInternalError = 17999,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p> 说明</p>\n<p>Wilddog iOS 身份认证错误。</p>\n<p> 参数</p>\n<p>WDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误</p>\n<p>WDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程</p>\n<p>WDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误</p>\n<p>WDGAuthErrorCodeUserDisabled 表示用户的帐户已停用</p>\n<p>WDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用</p>\n<p>WDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用</p>\n<p>WDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确</p>\n<p>WDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录</p>\n<p>WDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试</p>\n<p>WDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误</p>\n<p>WDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接</p>\n<p>WDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于<code>WDGAuthErrorCodeAccountExistsWithDifferentCredential</code>，只是拼写错误，只存在向后兼容性</p>\n<p>WDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过</p>\n<p>WDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户</p>\n<p>WDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户</p>\n<p>WDGAuthErrorCodeInvalidUserToken 表示 token 失效，您必须提示该用户在此设备重新登录</p>\n<p>WDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误</p>\n<p>WDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期</p>\n<p>WDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效</p>\n<p>WDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户</p>\n<p>WDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联</p>\n<p>WDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱</p>\n<p>WDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时</p>\n<p>WDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错</p>\n<p>WDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误</p>\n"},{"title":"完整 API 文档","_content":"\n# Auth\n\n## createUserWithEmailAndPassword()\n\n创建邮箱密码登录\n\n`wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\nwilddog.auth().createUserWithEmailAndPassword(email, pwd).then(function (user) {\n     console.info(\"user created.\", user);\n }).catch(function (err, more) { \n     console.info(\"create user failed.\", err, more);\n });\n```\n\n## signInAnonymously()\n\n匿名用户登录\n\n`wilddog.auth().signInAnonymously() returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\n    wilddog.auth().signInAnonymously().then(function (result){\n            console.info(\"signInAnouymously success\", result)\n        }).catch(function(err){\n            console.info(\"signInAnouymously failed\",err)\n        })\n    }\n```\n\n## signInWithEmailAndPassword()\n\n邮箱密码登录 \n\n`wilddog.auth().signInWithEmailAndPassword(email, pwd) returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\nfor example:\nwilddog.auth().signInWithEmailAndPassword(email,pwd).then(function (a, b) { \n    console.info(\"login success->\", a, b);    \n    console.info(\"currentUser->\",wilddog.auth().currentUser);\n}).catch(function (a, b) {\n    console.info('login failed ->', a, b);\n});\n```\n\n## signInWithPopup()\n\nOAuth登录\\(popup\\)\n\n`wilddog.auth().signInWithPopup(provider) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例:\n\n```js\n//for example: weibo OAuth\n\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithPopup(weiboProvider).then(function () {\n\n });\n```\n## signInWithRedirect()\n\nOAuth登录\\(redirect\\)\n\n`wilddog.auth().signInWithRedirect(provider) return `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\n//for example : weibo OAuth\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithRedirect(weiboProvider).then(function () {\n console.info(\"signInWithRedirect success.\")\n });\n\n```\n\n## signInWithCustomToken()\n\n通过customToken登录\n\n`wilddog.auth().signInWithCustomToken(token) return` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n* 监听用户状态\n\n`wilddog.auth().onAuthStateChanged`\n\n示例：\n\n```js\n//for example: \n\nwilddog.auth().onAuthStateChanged(function (user) {\n console.info(\"onAuthStateChanged\",user);\n });\n\n```\n\n## sendPasswordResetEmail()\n\n重置密码\n\n`wilddog.auth().sendPasswordResetEmail(email) returns ` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n## signInWithCredential()\n\n通过[credential](/api/auth/web.html#Credential)登录\n\n`wilddog.auth().signInWithCredential(credential) returns`\n[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\ncredential为用户凭证,是使用的凭证\n目前有两种凭证:\n\n    1:账号密码登录方式中的账号和密码\n    2:OAuth登录中的accessToken\n\n示例：\n\n```js\n\n//for example : \nvar credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);\nwilddog.auth().signInWithCredential(credential)\n\n```\n## signOut()\n\n登出\n\n```js\nwilddog.auth().signOut();\n```\n示例:\n\n```js\nif (wilddog.auth().currentUser) {\n     wilddog.auth().signOut();\n}\n```\n\n# auth().currentUser\n\n\n## currentUser.link()\n\n通过credential关联登录方式\n\n`wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)`\n\n示例：\n\n```js\nwilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(function (user) { \n    console.info(\"link email.\", user);\n}).catch(function (err, more) {\n    console.info(\"link email failed.\", err.code, err, user);\n});\n\n```\n## currentUser.linkWithPopup()\n\n通过Oauth的popup关联登录方式\n\n`wilddog.auth().currentUser.linkWithPopup(provider)`\n\n示例：\n\n```js\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n\n```\n## currentUser.linkWithRedirect()\n\n通过Oauth的redirect关联登录方式\n\n`wilddog.auth().currentUser.linkWithRedirect(provider)`\n\n示例：\n\n```js\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n\n## currentUser.unlink()\n\n取消账户的登录方式\n\n`wilddog.auth().currentUser.unlink(providerId)`\n\n示例：\n\n```js\nproviderId目前一共有5种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp\nwilddog.auth().currentUser.unlink('weibo').then(function (res) {\n console.info(\"unlink weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n## currentUser.delete() \n\n删除用户\n\n`wilddog.auth().currentUser.delete()`\n\n- 更新账户信息\n\n`wilddog.auth().currentUser.updateProfile();`\n\n示例：\n\n```js\n//修改用户的属性,目前包括displayName和photoUrl\n//for example :\nwilddog.auth().currentUser.updateProfile({\n 'photoURL': photoUrl,\n 'displayName': displayName,\n}).then(function (res) {\n console.info('update user ->', res);\n}).catch(function (err) {\n console.info(\"update user info failed.\", err);\n});\n\n```\n## currentUser.updateEmail()\n\n更新邮箱\n\n`wilddog.auth().currentUser.updateEmail(email);`\n\n## currentUser.updatePassword()\n\n更新密码\n\n`wilddog.auth().currentUser.updatePassword(password)`\n\n## currentUser.reauthenticate()\n\n更新认证\n\n`wilddog.auth().currentUser.reauthenticate(credential)`\n\n## currentUser.sendEmailVerification()\n\n发送邮箱确认邮件\n\n`wilddog.auth().currentUser.sendEmailVerification()`\n\n## wilddog.Promise\n\n*class static*\n  ```A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.```\n\nConstructor    \n- new Promise(resolver)\n\nMain Methods\n- catch\n    Assign a callback when the Promise rejects.\n- then\n    Assign callback functions called where the Promise eather resolves, or is reject.\n\n## Credential\n\n本次Auth增加Credential的概念\n\ncredential有两种形式\n- 账号密码\n- OAuth\n\n例如email登录方式\n\n`var credential = wilddog.auth.EmailAuthProvider.credential(email,password)`\n\n例如微博登录方式\n\n`var credential = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token,Weibo.uid)`","source":"api/auth/web.md","raw":"title:  完整 API 文档\n---\n\n# Auth\n\n## createUserWithEmailAndPassword()\n\n创建邮箱密码登录\n\n`wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\nwilddog.auth().createUserWithEmailAndPassword(email, pwd).then(function (user) {\n     console.info(\"user created.\", user);\n }).catch(function (err, more) { \n     console.info(\"create user failed.\", err, more);\n });\n```\n\n## signInAnonymously()\n\n匿名用户登录\n\n`wilddog.auth().signInAnonymously() returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\n    wilddog.auth().signInAnonymously().then(function (result){\n            console.info(\"signInAnouymously success\", result)\n        }).catch(function(err){\n            console.info(\"signInAnouymously failed\",err)\n        })\n    }\n```\n\n## signInWithEmailAndPassword()\n\n邮箱密码登录 \n\n`wilddog.auth().signInWithEmailAndPassword(email, pwd) returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\nfor example:\nwilddog.auth().signInWithEmailAndPassword(email,pwd).then(function (a, b) { \n    console.info(\"login success->\", a, b);    \n    console.info(\"currentUser->\",wilddog.auth().currentUser);\n}).catch(function (a, b) {\n    console.info('login failed ->', a, b);\n});\n```\n\n## signInWithPopup()\n\nOAuth登录\\(popup\\)\n\n`wilddog.auth().signInWithPopup(provider) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例:\n\n```js\n//for example: weibo OAuth\n\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithPopup(weiboProvider).then(function () {\n\n });\n```\n## signInWithRedirect()\n\nOAuth登录\\(redirect\\)\n\n`wilddog.auth().signInWithRedirect(provider) return `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n示例：\n\n```js\n//for example : weibo OAuth\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithRedirect(weiboProvider).then(function () {\n console.info(\"signInWithRedirect success.\")\n });\n\n```\n\n## signInWithCustomToken()\n\n通过customToken登录\n\n`wilddog.auth().signInWithCustomToken(token) return` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n* 监听用户状态\n\n`wilddog.auth().onAuthStateChanged`\n\n示例：\n\n```js\n//for example: \n\nwilddog.auth().onAuthStateChanged(function (user) {\n console.info(\"onAuthStateChanged\",user);\n });\n\n```\n\n## sendPasswordResetEmail()\n\n重置密码\n\n`wilddog.auth().sendPasswordResetEmail(email) returns ` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n## signInWithCredential()\n\n通过[credential](/api/auth/web.html#Credential)登录\n\n`wilddog.auth().signInWithCredential(credential) returns`\n[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\ncredential为用户凭证,是使用的凭证\n目前有两种凭证:\n\n    1:账号密码登录方式中的账号和密码\n    2:OAuth登录中的accessToken\n\n示例：\n\n```js\n\n//for example : \nvar credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);\nwilddog.auth().signInWithCredential(credential)\n\n```\n## signOut()\n\n登出\n\n```js\nwilddog.auth().signOut();\n```\n示例:\n\n```js\nif (wilddog.auth().currentUser) {\n     wilddog.auth().signOut();\n}\n```\n\n# auth().currentUser\n\n\n## currentUser.link()\n\n通过credential关联登录方式\n\n`wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)`\n\n示例：\n\n```js\nwilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(function (user) { \n    console.info(\"link email.\", user);\n}).catch(function (err, more) {\n    console.info(\"link email failed.\", err.code, err, user);\n});\n\n```\n## currentUser.linkWithPopup()\n\n通过Oauth的popup关联登录方式\n\n`wilddog.auth().currentUser.linkWithPopup(provider)`\n\n示例：\n\n```js\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n\n```\n## currentUser.linkWithRedirect()\n\n通过Oauth的redirect关联登录方式\n\n`wilddog.auth().currentUser.linkWithRedirect(provider)`\n\n示例：\n\n```js\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n\n## currentUser.unlink()\n\n取消账户的登录方式\n\n`wilddog.auth().currentUser.unlink(providerId)`\n\n示例：\n\n```js\nproviderId目前一共有5种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp\nwilddog.auth().currentUser.unlink('weibo').then(function (res) {\n console.info(\"unlink weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n## currentUser.delete() \n\n删除用户\n\n`wilddog.auth().currentUser.delete()`\n\n- 更新账户信息\n\n`wilddog.auth().currentUser.updateProfile();`\n\n示例：\n\n```js\n//修改用户的属性,目前包括displayName和photoUrl\n//for example :\nwilddog.auth().currentUser.updateProfile({\n 'photoURL': photoUrl,\n 'displayName': displayName,\n}).then(function (res) {\n console.info('update user ->', res);\n}).catch(function (err) {\n console.info(\"update user info failed.\", err);\n});\n\n```\n## currentUser.updateEmail()\n\n更新邮箱\n\n`wilddog.auth().currentUser.updateEmail(email);`\n\n## currentUser.updatePassword()\n\n更新密码\n\n`wilddog.auth().currentUser.updatePassword(password)`\n\n## currentUser.reauthenticate()\n\n更新认证\n\n`wilddog.auth().currentUser.reauthenticate(credential)`\n\n## currentUser.sendEmailVerification()\n\n发送邮箱确认邮件\n\n`wilddog.auth().currentUser.sendEmailVerification()`\n\n## wilddog.Promise\n\n*class static*\n  ```A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.```\n\nConstructor    \n- new Promise(resolver)\n\nMain Methods\n- catch\n    Assign a callback when the Promise rejects.\n- then\n    Assign callback functions called where the Promise eather resolves, or is reject.\n\n## Credential\n\n本次Auth增加Credential的概念\n\ncredential有两种形式\n- 账号密码\n- OAuth\n\n例如email登录方式\n\n`var credential = wilddog.auth.EmailAuthProvider.credential(email,password)`\n\n例如微博登录方式\n\n`var credential = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token,Weibo.uid)`","date":"2016-09-07T13:24:23.096Z","updated":"2016-09-07T13:24:23.096Z","path":"api/auth/web.html","_id":"cisswi9j30008z4fwxho5h78g","comments":1,"layout":"page","content":"<h1 id=\"Auth\"><a href=\"#Auth\" class=\"headerlink\" title=\"Auth\"></a>Auth</h1><h2 id=\"createUserWithEmailAndPassword\"><a href=\"#createUserWithEmailAndPassword\" class=\"headerlink\" title=\"createUserWithEmailAndPassword()\"></a>createUserWithEmailAndPassword()</h2><p>创建邮箱密码登录</p>\n<p><code>wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().createUserWithEmailAndPassword(email, pwd).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.info(<span class=\"string\">\"user created.\"</span>, user);</div><div class=\"line\"> &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, more</span>) </span>&#123; </div><div class=\"line\">     <span class=\"built_in\">console</span>.info(<span class=\"string\">\"create user failed.\"</span>, err, more);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInAnonymously\"><a href=\"#signInAnonymously\" class=\"headerlink\" title=\"signInAnonymously()\"></a>signInAnonymously()</h2><p>匿名用户登录</p>\n<p><code>wilddog.auth().signInAnonymously() returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInAnonymously().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.info(<span class=\"string\">\"signInAnouymously success\"</span>, result)</div><div class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.info(<span class=\"string\">\"signInAnouymously failed\"</span>,err)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithEmailAndPassword\"><a href=\"#signInWithEmailAndPassword\" class=\"headerlink\" title=\"signInWithEmailAndPassword()\"></a>signInWithEmailAndPassword()</h2><p>邮箱密码登录 </p>\n<p><code>wilddog.auth().signInWithEmailAndPassword(email, pwd) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> example:</div><div class=\"line\">wilddog.auth().signInWithEmailAndPassword(email,pwd).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123; </div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"login success-&gt;\"</span>, a, b);    </div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"currentUser-&gt;\"</span>,wilddog.auth().currentUser);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">'login failed -&gt;'</span>, a, b);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithPopup\"><a href=\"#signInWithPopup\" class=\"headerlink\" title=\"signInWithPopup()\"></a>signInWithPopup()</h2><p>OAuth登录(popup)</p>\n<p><code>wilddog.auth().signInWithPopup(provider) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//for example: weibo OAuth</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> weiboProvider = <span class=\"keyword\">new</span> wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithPopup(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithRedirect\"><a href=\"#signInWithRedirect\" class=\"headerlink\" title=\"signInWithRedirect()\"></a>signInWithRedirect()</h2><p>OAuth登录(redirect)</p>\n<p><code>wilddog.auth().signInWithRedirect(provider) return</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//for example : weibo OAuth</span></div><div class=\"line\"><span class=\"keyword\">var</span> weiboProvider = <span class=\"keyword\">new</span> wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithRedirect(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"signInWithRedirect success.\"</span>)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithCustomToken\"><a href=\"#signInWithCustomToken\" class=\"headerlink\" title=\"signInWithCustomToken()\"></a>signInWithCustomToken()</h2><p>通过customToken登录</p>\n<p><code>wilddog.auth().signInWithCustomToken(token) return</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<ul>\n<li>监听用户状态</li>\n</ul>\n<p><code>wilddog.auth().onAuthStateChanged</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//for example: </span></div><div class=\"line\"></div><div class=\"line\">wilddog.auth().onAuthStateChanged(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"onAuthStateChanged\"</span>,user);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"sendPasswordResetEmail\"><a href=\"#sendPasswordResetEmail\" class=\"headerlink\" title=\"sendPasswordResetEmail()\"></a>sendPasswordResetEmail()</h2><p>重置密码</p>\n<p><code>wilddog.auth().sendPasswordResetEmail(email) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<h2 id=\"signInWithCredential\"><a href=\"#signInWithCredential\" class=\"headerlink\" title=\"signInWithCredential()\"></a>signInWithCredential()</h2><p>通过<a href=\"/api/auth/web.html#Credential\">credential</a>登录</p>\n<p><code>wilddog.auth().signInWithCredential(credential) returns</code><br><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>credential为用户凭证,是使用的凭证<br>目前有两种凭证:</p>\n<pre><code>1:账号密码登录方式中的账号和密码\n2:OAuth登录中的accessToken\n</code></pre><p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//for example : </span></div><div class=\"line\"><span class=\"keyword\">var</span> credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);</div><div class=\"line\">wilddog.auth().signInWithCredential(credential)</div></pre></td></tr></table></figure>\n<h2 id=\"signOut\"><a href=\"#signOut\" class=\"headerlink\" title=\"signOut()\"></a>signOut()</h2><p>登出</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut();</div></pre></td></tr></table></figure>\n<p>示例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (wilddog.auth().currentUser) &#123;</div><div class=\"line\">     wilddog.auth().signOut();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"auth-currentUser\"><a href=\"#auth-currentUser\" class=\"headerlink\" title=\"auth().currentUser\"></a>auth().currentUser</h1><h2 id=\"currentUser-link\"><a href=\"#currentUser-link\" class=\"headerlink\" title=\"currentUser.link()\"></a>currentUser.link()</h2><p>通过credential关联登录方式</p>\n<p><code>wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123; </div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link email.\"</span>, user);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, more</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link email failed.\"</span>, err.code, err, user);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-linkWithPopup\"><a href=\"#currentUser-linkWithPopup\" class=\"headerlink\" title=\"currentUser.linkWithPopup()\"></a>currentUser.linkWithPopup()</h2><p>通过Oauth的popup关联登录方式</p>\n<p><code>wilddog.auth().currentUser.linkWithPopup(provider)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link weibo-&gt;\"</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-linkWithRedirect\"><a href=\"#currentUser-linkWithRedirect\" class=\"headerlink\" title=\"currentUser.linkWithRedirect()\"></a>currentUser.linkWithRedirect()</h2><p>通过Oauth的redirect关联登录方式</p>\n<p><code>wilddog.auth().currentUser.linkWithRedirect(provider)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link weibo-&gt;\"</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-unlink\"><a href=\"#currentUser-unlink\" class=\"headerlink\" title=\"currentUser.unlink()\"></a>currentUser.unlink()</h2><p>取消账户的登录方式</p>\n<p><code>wilddog.auth().currentUser.unlink(providerId)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">providerId目前一共有<span class=\"number\">5</span>种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp</div><div class=\"line\">wilddog.auth().currentUser.unlink(<span class=\"string\">'weibo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"unlink weibo-&gt;\"</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-delete\"><a href=\"#currentUser-delete\" class=\"headerlink\" title=\"currentUser.delete()\"></a>currentUser.delete()</h2><p>删除用户</p>\n<p><code>wilddog.auth().currentUser.delete()</code></p>\n<ul>\n<li>更新账户信息</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updateProfile();</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//修改用户的属性,目前包括displayName和photoUrl</span></div><div class=\"line\"><span class=\"comment\">//for example :</span></div><div class=\"line\">wilddog.auth().currentUser.updateProfile(&#123;</div><div class=\"line\"> <span class=\"string\">'photoURL'</span>: photoUrl,</div><div class=\"line\"> <span class=\"string\">'displayName'</span>: displayName,</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">'update user -&gt;'</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"update user info failed.\"</span>, err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-updateEmail\"><a href=\"#currentUser-updateEmail\" class=\"headerlink\" title=\"currentUser.updateEmail()\"></a>currentUser.updateEmail()</h2><p>更新邮箱</p>\n<p><code>wilddog.auth().currentUser.updateEmail(email);</code></p>\n<h2 id=\"currentUser-updatePassword\"><a href=\"#currentUser-updatePassword\" class=\"headerlink\" title=\"currentUser.updatePassword()\"></a>currentUser.updatePassword()</h2><p>更新密码</p>\n<p><code>wilddog.auth().currentUser.updatePassword(password)</code></p>\n<h2 id=\"currentUser-reauthenticate\"><a href=\"#currentUser-reauthenticate\" class=\"headerlink\" title=\"currentUser.reauthenticate()\"></a>currentUser.reauthenticate()</h2><p>更新认证</p>\n<p><code>wilddog.auth().currentUser.reauthenticate(credential)</code></p>\n<h2 id=\"currentUser-sendEmailVerification\"><a href=\"#currentUser-sendEmailVerification\" class=\"headerlink\" title=\"currentUser.sendEmailVerification()\"></a>currentUser.sendEmailVerification()</h2><p>发送邮箱确认邮件</p>\n<p><code>wilddog.auth().currentUser.sendEmailVerification()</code></p>\n<h2 id=\"wilddog-Promise\"><a href=\"#wilddog-Promise\" class=\"headerlink\" title=\"wilddog.Promise\"></a>wilddog.Promise</h2><p><em>class static</em><br>  <code>A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.</code></p>\n<p>Constructor    </p>\n<ul>\n<li>new Promise(resolver)</li>\n</ul>\n<p>Main Methods</p>\n<ul>\n<li>catch<br>  Assign a callback when the Promise rejects.</li>\n<li>then<br>  Assign callback functions called where the Promise eather resolves, or is reject.</li>\n</ul>\n<h2 id=\"Credential\"><a href=\"#Credential\" class=\"headerlink\" title=\"Credential\"></a>Credential</h2><p>本次Auth增加Credential的概念</p>\n<p>credential有两种形式</p>\n<ul>\n<li>账号密码</li>\n<li>OAuth</li>\n</ul>\n<p>例如email登录方式</p>\n<p><code>var credential = wilddog.auth.EmailAuthProvider.credential(email,password)</code></p>\n<p>例如微博登录方式</p>\n<p><code>var credential = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token,Weibo.uid)</code></p>\n","excerpt":"","more":"<h1 id=\"Auth\"><a href=\"#Auth\" class=\"headerlink\" title=\"Auth\"></a>Auth</h1><h2 id=\"createUserWithEmailAndPassword\"><a href=\"#createUserWithEmailAndPassword\" class=\"headerlink\" title=\"createUserWithEmailAndPassword()\"></a>createUserWithEmailAndPassword()</h2><p>创建邮箱密码登录</p>\n<p><code>wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().createUserWithEmailAndPassword(email, pwd).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.info(<span class=\"string\">\"user created.\"</span>, user);</div><div class=\"line\"> &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, more</span>) </span>&#123; </div><div class=\"line\">     <span class=\"built_in\">console</span>.info(<span class=\"string\">\"create user failed.\"</span>, err, more);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInAnonymously\"><a href=\"#signInAnonymously\" class=\"headerlink\" title=\"signInAnonymously()\"></a>signInAnonymously()</h2><p>匿名用户登录</p>\n<p><code>wilddog.auth().signInAnonymously() returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInAnonymously().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.info(<span class=\"string\">\"signInAnouymously success\"</span>, result)</div><div class=\"line\">    &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.info(<span class=\"string\">\"signInAnouymously failed\"</span>,err)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithEmailAndPassword\"><a href=\"#signInWithEmailAndPassword\" class=\"headerlink\" title=\"signInWithEmailAndPassword()\"></a>signInWithEmailAndPassword()</h2><p>邮箱密码登录 </p>\n<p><code>wilddog.auth().signInWithEmailAndPassword(email, pwd) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> example:</div><div class=\"line\">wilddog.auth().signInWithEmailAndPassword(email,pwd).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123; </div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"login success-&gt;\"</span>, a, b);    </div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"currentUser-&gt;\"</span>,wilddog.auth().currentUser);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">'login failed -&gt;'</span>, a, b);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithPopup\"><a href=\"#signInWithPopup\" class=\"headerlink\" title=\"signInWithPopup()\"></a>signInWithPopup()</h2><p>OAuth登录(popup)</p>\n<p><code>wilddog.auth().signInWithPopup(provider) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//for example: weibo OAuth</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> weiboProvider = <span class=\"keyword\">new</span> wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithPopup(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithRedirect\"><a href=\"#signInWithRedirect\" class=\"headerlink\" title=\"signInWithRedirect()\"></a>signInWithRedirect()</h2><p>OAuth登录(redirect)</p>\n<p><code>wilddog.auth().signInWithRedirect(provider) return</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//for example : weibo OAuth</span></div><div class=\"line\"><span class=\"keyword\">var</span> weiboProvider = <span class=\"keyword\">new</span> wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithRedirect(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"signInWithRedirect success.\"</span>)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"signInWithCustomToken\"><a href=\"#signInWithCustomToken\" class=\"headerlink\" title=\"signInWithCustomToken()\"></a>signInWithCustomToken()</h2><p>通过customToken登录</p>\n<p><code>wilddog.auth().signInWithCustomToken(token) return</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<ul>\n<li>监听用户状态</li>\n</ul>\n<p><code>wilddog.auth().onAuthStateChanged</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//for example: </span></div><div class=\"line\"></div><div class=\"line\">wilddog.auth().onAuthStateChanged(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"onAuthStateChanged\"</span>,user);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"sendPasswordResetEmail\"><a href=\"#sendPasswordResetEmail\" class=\"headerlink\" title=\"sendPasswordResetEmail()\"></a>sendPasswordResetEmail()</h2><p>重置密码</p>\n<p><code>wilddog.auth().sendPasswordResetEmail(email) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<h2 id=\"signInWithCredential\"><a href=\"#signInWithCredential\" class=\"headerlink\" title=\"signInWithCredential()\"></a>signInWithCredential()</h2><p>通过<a href=\"/api/auth/web.html#Credential\">credential</a>登录</p>\n<p><code>wilddog.auth().signInWithCredential(credential) returns</code><br><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<p>credential为用户凭证,是使用的凭证<br>目前有两种凭证:</p>\n<pre><code>1:账号密码登录方式中的账号和密码\n2:OAuth登录中的accessToken\n</code></pre><p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//for example : </span></div><div class=\"line\"><span class=\"keyword\">var</span> credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);</div><div class=\"line\">wilddog.auth().signInWithCredential(credential)</div></pre></td></tr></table></figure>\n<h2 id=\"signOut\"><a href=\"#signOut\" class=\"headerlink\" title=\"signOut()\"></a>signOut()</h2><p>登出</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut();</div></pre></td></tr></table></figure>\n<p>示例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (wilddog.auth().currentUser) &#123;</div><div class=\"line\">     wilddog.auth().signOut();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"auth-currentUser\"><a href=\"#auth-currentUser\" class=\"headerlink\" title=\"auth().currentUser\"></a>auth().currentUser</h1><h2 id=\"currentUser-link\"><a href=\"#currentUser-link\" class=\"headerlink\" title=\"currentUser.link()\"></a>currentUser.link()</h2><p>通过credential关联登录方式</p>\n<p><code>wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123; </div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link email.\"</span>, user);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, more</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link email failed.\"</span>, err.code, err, user);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-linkWithPopup\"><a href=\"#currentUser-linkWithPopup\" class=\"headerlink\" title=\"currentUser.linkWithPopup()\"></a>currentUser.linkWithPopup()</h2><p>通过Oauth的popup关联登录方式</p>\n<p><code>wilddog.auth().currentUser.linkWithPopup(provider)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link weibo-&gt;\"</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-linkWithRedirect\"><a href=\"#currentUser-linkWithRedirect\" class=\"headerlink\" title=\"currentUser.linkWithRedirect()\"></a>currentUser.linkWithRedirect()</h2><p>通过Oauth的redirect关联登录方式</p>\n<p><code>wilddog.auth().currentUser.linkWithRedirect(provider)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"link weibo-&gt;\"</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-unlink\"><a href=\"#currentUser-unlink\" class=\"headerlink\" title=\"currentUser.unlink()\"></a>currentUser.unlink()</h2><p>取消账户的登录方式</p>\n<p><code>wilddog.auth().currentUser.unlink(providerId)</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">providerId目前一共有<span class=\"number\">5</span>种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp</div><div class=\"line\">wilddog.auth().currentUser.unlink(<span class=\"string\">'weibo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"unlink weibo-&gt;\"</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-delete\"><a href=\"#currentUser-delete\" class=\"headerlink\" title=\"currentUser.delete()\"></a>currentUser.delete()</h2><p>删除用户</p>\n<p><code>wilddog.auth().currentUser.delete()</code></p>\n<ul>\n<li>更新账户信息</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updateProfile();</code></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//修改用户的属性,目前包括displayName和photoUrl</span></div><div class=\"line\"><span class=\"comment\">//for example :</span></div><div class=\"line\">wilddog.auth().currentUser.updateProfile(&#123;</div><div class=\"line\"> <span class=\"string\">'photoURL'</span>: photoUrl,</div><div class=\"line\"> <span class=\"string\">'displayName'</span>: displayName,</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">'update user -&gt;'</span>, res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\"> <span class=\"built_in\">console</span>.info(<span class=\"string\">\"update user info failed.\"</span>, err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"currentUser-updateEmail\"><a href=\"#currentUser-updateEmail\" class=\"headerlink\" title=\"currentUser.updateEmail()\"></a>currentUser.updateEmail()</h2><p>更新邮箱</p>\n<p><code>wilddog.auth().currentUser.updateEmail(email);</code></p>\n<h2 id=\"currentUser-updatePassword\"><a href=\"#currentUser-updatePassword\" class=\"headerlink\" title=\"currentUser.updatePassword()\"></a>currentUser.updatePassword()</h2><p>更新密码</p>\n<p><code>wilddog.auth().currentUser.updatePassword(password)</code></p>\n<h2 id=\"currentUser-reauthenticate\"><a href=\"#currentUser-reauthenticate\" class=\"headerlink\" title=\"currentUser.reauthenticate()\"></a>currentUser.reauthenticate()</h2><p>更新认证</p>\n<p><code>wilddog.auth().currentUser.reauthenticate(credential)</code></p>\n<h2 id=\"currentUser-sendEmailVerification\"><a href=\"#currentUser-sendEmailVerification\" class=\"headerlink\" title=\"currentUser.sendEmailVerification()\"></a>currentUser.sendEmailVerification()</h2><p>发送邮箱确认邮件</p>\n<p><code>wilddog.auth().currentUser.sendEmailVerification()</code></p>\n<h2 id=\"wilddog-Promise\"><a href=\"#wilddog-Promise\" class=\"headerlink\" title=\"wilddog.Promise\"></a>wilddog.Promise</h2><p><em>class static</em><br>  <code>A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.</code></p>\n<p>Constructor    </p>\n<ul>\n<li>new Promise(resolver)</li>\n</ul>\n<p>Main Methods</p>\n<ul>\n<li>catch<br>  Assign a callback when the Promise rejects.</li>\n<li>then<br>  Assign callback functions called where the Promise eather resolves, or is reject.</li>\n</ul>\n<h2 id=\"Credential\"><a href=\"#Credential\" class=\"headerlink\" title=\"Credential\"></a>Credential</h2><p>本次Auth增加Credential的概念</p>\n<p>credential有两种形式</p>\n<ul>\n<li>账号密码</li>\n<li>OAuth</li>\n</ul>\n<p>例如email登录方式</p>\n<p><code>var credential = wilddog.auth.EmailAuthProvider.credential(email,password)</code></p>\n<p>例如微博登录方式</p>\n<p><code>var credential = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token,Weibo.uid)</code></p>\n"},{"title":"完整 API 文档","_content":"\n# Wilddog (*Methods*)\n\n##  setAndroidContext()\n\n定义\n\nstatic void setAndroidContext(android.content.Context context)\n\n说明 \n\nWilddog在Android初始化需要配置Android Context， 且必须要在new Wilddog()之前配置。你可以在 `android.app.Application` 或者 `Activity`的`onCreate` 方法中设置 Android Context。\n\n参数\n\ncontext `android.content.Context`  在Android中使用Wilddog需要一个Android Context。\n\n返回值\n\nvoid\n\n----\n\n##  setDefaultConfig()\n\n定义\nstatic void setDefaultConfig(Config config)\n\n说明 \nWilddog的默认配置对象，在调用new Wilddog之前必须调用此方法。\n\n参数\nconfig `Config` 新的config参数\n\n返回值\nvoid\n\n---\n\n## getDefaultConfig()\n\n定义\nstatic Config getDefaultConfig()\n\n说明 \n获取Wilddog的默认配置对象。\n\n返回值\n\n\n<!-- Js通过方法前面的两个“#”抽取目录，为识别注释多加一个“#”\n### getApp()\n\n定义\nWilddogApp getApp()\n\n说明 \n获取与引用关联的WilddogApp实例\n\n返回值\n对应于引用的WilddogApp对象\n-->\n\n----\n\n## child()\n\n定义\nWilddog child(String path)\n\n说明\n根据相对路径，来获取当前节点下子节点的引用。\n\n参数\npath `String` path 为相对路径，多层级间需要使用\"/\"分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。\n\n返回值\n`Wilddog` 子节点引用。\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 定位到 '/test/a'\nWilddog ref2 = ref.child(\"a\");\n\n// 定位到 '/test/a/b'\nWilddog ref3 = ref.child(\"a/b\");\nWilddog ref4 = ref.child(\"a\").child(\"b\");\n\n```\n----\n\n## push()\n\n定义\nWilddog push()\n\n说明\n在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。\n\n返回值\n`Wilddog` 新生成子节点的引用对象。\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 添加一个数值，将生成一个新ID，操作结果为{\"-JmpzI81egafHZo5\":100}， 返回的path为“/test/a/b/-JmpzI81egafHZo5”\nWilddog  newRef = ref.child(\"a/b\").push();\nnewRef.setValue(100);\n\n// 添加一个实体\nDOTAHero hero = new DOTAHero();\nhero.setName(\"Nevermore\");\nhero.setHp(435);\nhero.setMp(234);\nref.child(\"heros\").push().setValue(hero);\n\n```\n----\n\n\n\n## setValue(Object)\n\n定义\nvoid setValue(Object value)\n\n说明\n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\nvalue `Object`\nvalue的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。\n当value为String、Number、Boolean时，等价于当前节点的`updateChildren()`操作。\n当value为null时，等价于当前节点的`removeValue()`操作。\n当value为Map或JavaBean时，将value转为一颗子树替换当前value。\n\n返回值\nvoid\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 等价 update(100);\nref.child(\"a/b\").setValue(100);\n\n// 等价 remove();\nref.child(\"a/b\").setValue(null);\n\n// 设置子树\nMap<String, String> children = new HashMap<String, String>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").setValue(children);\n\n// 自定义Entity\nDOTAHero hero = new DOTAHero();\nhero.setName(\"Nevermore\");\nhero.setHp(435);\nhero.setMp(234);\nref.child(\"dota/heros/SF\").setValue(hero);\n\n```\n----\n\n## setValue(Object, CompletionListener)\n\n定义\nvoid setValue(Object value, Wilddog.CompletionListener listener)\n\n说明\n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\nvalue `Object` value的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。\n当value为String、Number、Boolean时，等价于Path对应的Node的`updateChildren()`操作。\n当value为null时，等价于Path对应的Node的`removeValue()`操作。\n当value为Map或JavaBean时，将value转为一颗子树替换当前value。\n\nlistener `CompletionListener` listener包含一个callback函数，用户可以实现`onComplete`函数，如果某个callback函数没有响应的处理，接口实现为`{}`函数即可。`setValue(value)`等价于`setValue(value, null)`。\n\n返回值\nvoid\n\n示例\n自定义CompletionListener\n```java\npublic class MyHandler implements Wilddog.CompletionListener {\n      public void onComplete(WilddogError error, Wilddog ref) {\n          if(error != null){\n              System.out.println(error.getCode());\n          }\n      }\n  }\n\n```\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nCompletionListener listener = new MyHandler();\n\n// 等价 update(100);\nref.child(\"a/b\").setValue(100, listener);\n\n// 等价 remove();\nref.child(\"a/b\").setValue(null, listener);\n\n// 设置子树\nMap<String, String> children = new HashMap<String, String>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").setValue(children, listener);\n\n// 自定义Entity\nDOTAHero hero = new DOTAHero();\nhero.setName(\"Nevermore\");\nhero.setHp(435);\nhero.setMp(234);\n\nref.child(\"dota/heros/SF\").setValue(hero, new Wilddog.CompletionListener() {\n  public void onComplete(WilddogError error, Wilddog ref) {\n    if(error != null) {\n      System.out.println(error.getCode());\n      return;\n    }\n    System.out.println(\"Good!\");\n  }\n});\n\n```\n\n----\n\n##  setPriority()\n\n定义\nvoid setPriority(Object)\n\n说明 \n设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。\n你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。\n\n节点按照如下规则排序：\n- 没有priority的排最先。\n- 有数字priority的次之，按照数值排序。\n- 有字符串 priority的排最后，按照字母表的顺序排列。\n- 当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。\n<br>\n<br>\n注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。\n\n参数\npriority `Object` 指定节点的优先级。\n\n返回值\nvoid\n\n----\n\n##  setPriority(Object, CompletionListener)\n\n定义\nvoid setPriority(Object, Wilddog.CompletionListener)\n\n说明 \n设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。\n你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。\n\n节点按照如下规则排序：\n- 没有priority的排最先。\n- 有数字priority的次之，按照数值排序。\n- 有字符串 priority的排最后，按照字母表的顺序排列。\n- 当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。\n<br>\n<br>\n注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。\n\n参数\n* priority `Object` 指定节点的优先级。\n* listener `CompletionListener`。\n\n返回值\nvoid\n\n----\n\n## updateChildren()\n\n定义\nvoid updateChildren(Map value)\n\n说明\n对子节点进行合并操作。不存在的子节点将会被新增，存在子节点将会被替换。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\nvalue `Map<String, Object>` 当value为null时，等价于`removeValue()`操作。\n\n\n返回值\nvoid\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 更新子树\nMap<String, String> children = new HashMap<String, String>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").updateChildren(children);\n```\n\n----\n\n## updateChildren(Map, CompletionListener)\n\n定义\nvoid updateChildren(Map children, Wilddog.CompletionListener listener)\n\n说明\n对子节点进行更新操作。不存在的子节点将会被新增，存在子节点将会被替换。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\n* value `Map<String, Object>` 当value为null时，等价于`removeValue()`操作。\n* listener `CompletionListener` listener包含一个回调函数`onComplete`，如果执行完成，`onComplete`函数将会被调用。\n\n返回值\nvoid\n\n示例\n自定义CompletionListener\n```java\npublic class MyHandler implements Wilddog.CompletionListener {\n  public void onComplete(WilddogError error, Wilddog ref){\n    if(error != null){\n      System.out.println(error.getCode());\n    }\n  }\n}\n```\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nCompletionListener handler = new MyHandler();\n\n// 更新子树\nMap<String, Object> children = new HashMap<String, Object>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").updateChildren(children, handler);\n```\n\n----\n\n## removeValue()\n\n定义\nvoid removeValue()\n\n说明\n删除当前节点。 删除成功后将触发Change，ChildRemoved事件。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n返回值\nvoid\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nref.child(\"a/b\").removeValue();\n```\n----\n\n## removeValue(CompletionListener)\n\n定义\nvoid removeValue(CompletionListener listener)\n\n说明\n删除当前节点。 删除成功后将触发Change，ChildRemoved事件。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\n* listener `CompletionListener`\nlistener包含一个回调函数`onComplete`，如果执行完成，`onComplete`函数将会被调用。\n\n返回值\nvoid\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nResultHandler handler = new MyHandler();\nref.child(\"a/b\").removeValue(handler);\n\n```\n\n----\n\n## runTransaction(Transaction.Handler)\n\n定义\nvoid runTransaction(Transaction.Handler handler)\n\n说明\n在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，runTransaction() 能够确保不同客户端同时修改，没有冲突。\n\n参数\n* handler `Transaction.Handler` \n\n返回值\nvoid\n\n示例\n\n```java\nWilddog upvotesRef = new Wilddog(\"https://<appId>.wilddogio.com/android/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\");\n\nupvotesRef.runTransaction(new Transaction.Handler() {\n    public Transaction.Result doTransaction(MutableData currentData) {\n        if(currentData.getValue() == null) {\n            currentData.setValue(1);\n        } else {\n            currentData.setValue((Long) currentData.getValue() + 1);\n        }\n        \n        return Transaction.success(currentData); // 我们可以调用 Transaction.abort() 中止事务\n    }\n\n    public void onComplete(WilddogError wilddogError, boolean committed, DataSnapshot currentData) {\n        // 事务完成后调用一次，获取事务完成的结果\n    }\n});\n```\n____\n\n##  onDisconnect()\n\n定义\nOnDisconnect onDisconnect()\n\n说明 \n当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。\n\n返回值\n当前节点执行断开连接操作的对象。\n\n----\n\n##  goOffline()\n\n定义\nstatic void goOffline()\n\n说明 \n手动关闭连接，关闭自动连接。\n注意：调用此方法会影响到所有Wilddog连接。\n\n返回值\nvoid\n\n----\n\n##  goOnline()\n\n定义\nstatic void goOnline()\n\n说明 \n手动建立连接，开启自动重连。\n注意：调用此方法会影响到所有Wilddog连接。\n返回值\nvoid\n\n----\n\n## getKey()\n\n定义\nString getKey()\n\n说明\n获取当前节点的名称。\n\n返回值\n`String` 节点名称。 \n\n----\n\n## getParent()\n\n定义\nWilddog getParent()\n\n说明 \n获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。\n\n返回值\n`Wilddog` 父节点的引用。\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test/a\");\n\n// 获得'/test' 路径的引用\nWilddog ref2 = ref.getParent();\n\n// 到达root\nWilddog ref3 = ref.getParent().getParent();\n\n```\n\n----\n\n##  getRoot()\n\n定义\nWilddog getRoot()\n\n说明 \n获取根节点的引用。\n返回值\n根节点的引用。\n\n----\n\n## getSdkVersion()\n\n定义\nstatic String getSdkVersion()\n\n说明 \n获取SDK版本。\n\n返回值\nSDK版本。\n\n----\n\n# Wilddog.CompletionListener (*Methods*)\n\n##  onComplete()\n\n定义\nvoid onComplete(WilddogError error,\n                Wilddog ref)\n\n说明 \n当操作成功或者失败的时候触发这个方法。如果操作失败，会给出一个error,如果操作成功，error为null。\n参数\n* error `WilddogError` 错误描述。\n* ref `Wilddog` 到指定Wilddog节点的引用。\n\n返回值\nvoid\n\n----\n\n# Wilddog.AuthStateListener (*Methods*)\n\n## onAuthStateChanged()\n\n定义\nvoid onAuthStateChanged(AuthData authData)\n\n说明\n当登录认证状态发生改变的时候，此方法将被调用。authData包含当前登录认证的信息，如果当前的连接没有登录认证，authData为null。\n\n参数\nauthData `AuthData` 当前登录认证的信息，未登录认证时为null。\n\n返回值\nvoid\n\n----\n\n# Wilddog.AuthResultHandler (*Methods*)\n\n## onAuthenticated()\n\n定义\nvoid onAuthenticated(AuthData authData)\n\n说明 \n当登录认证成功时这个方法被调用。\n\n参数\nauthData `AuthData` 当前用户或者Token的信息。\n\n返回值\nvoid\n\n----\n\n##  onAuthenticationError()\n\n定义\nvoid onAuthenticationError(WilddogError error)\n\n说明 \n当登录认证失败时这个方法被调用。\n\n参数\nerror `WilddogError` 登录认证失败的原因和附加的详细信息。\n\n返回值\nvoid\n\n----\n\n# Wilddog.ResultHandler (*Methods*)\n\n##  onError()\n\n定义\nvoid onError(WilddogError error)\n\n说明 \n如果操作失败此方法被调用。\n\n参数\nerror `WilddogError` 包含失败原因和附加的详情。\n\n返回值\nvoid\n\n----\n\n##  onSuccess()\n\n定义\nvoid onSuccess()\n\n说明 \n如果操作成功此方法被调用。\n\n返回值\nvoid\n\n----\n\n# ChildEventListener (*Methods*)\n\n##  onCancelled()\n\n定义\nvoid onCancelled(WilddogError error)\n\n说明 \n当listener在服务端失败，或者被删除的时候调用该方法。\n\n参数\nerror `WilddogError` 发生错误的描述。\n\n返回值\nvoid\n\n----\n\n##  onChildAdded()\n\n定义\nvoid onChildAdded(DataSnapshot snapshot,\n                  String previousChildName)\n\n说明 \n一个添加了listener的节点，当有子节点被添加时触发此方法。\n\n参数\n* snapshot `DataSnapshot` 新添加的子节点数据快照。\n* previousChildName `String` 排在被添加的新子节点前面的兄弟节点的key值。如果被添加的是当前节点的第一个子节点，该值为null。\n\n返回值\nvoid\n\n----\n\n##  onChildChanged()\n\n定义\nvoid onChildChanged(DataSnapshot snapshot,\n                    String previousChildName)\n\n说明 \n当前节点的子节点发生改变的时候触发此方法。\n\n参数\n* snapshot `DataSnapshot` 新子节点数据的快照。\n* previousChildName `String` 排在被修改的新子节点前面的兄弟节点的key值。如果改变的是当前节点的第一个子节点，该值为null。\n\n返回值\nvoid\n\n----\n\n##  onChildMoved()\n\n定义\nvoid onChildMoved(DataSnapshot snapshot,\n                  String previousChildName)\n\n说明 \n当一个子节点的优先级发生变化时，该方法将被调用。参考Wilddog.setPriority(Object)和数据排序了解更多关于优先级和数据排序的信息。\n\n参数\n* `DataSnapshot` 节点排序发生变化时的数据快照。\n* `String` 排在当前子节点前面的兄弟子节点的key名称，如果当前节点位置最先，此值为null。\n\n返回值\nvoid\n\n----\n\n## onChildRemoved()\n\n定义\nvoid onChildRemoved(DataSnapshot snapshot)\n\n说明 \n当一个添加了listener的节点有子节点被删除的时候触发这个方法。\n\n参数\nsnapshot `DataSnapshot` 被删除子节点的数据快照。\n\n返回值\nvoid\n\n----\n\n# ValueEventListener (*Methods*)\n\n##  onCancelled()\n\n定义\nvoid onCancelled(WilddogError error)\n\n说明 \n当listener在服务端失败，或者被删除的时候调用该方法。\n\n参数\nerror `DataSnapshot` 发生错误的描述。\n\n返回值\nvoid\n\n----\n\n##  onDataChange()\n\n定义\nvoid onDataChange(DataSnapshot snapshot)\n\n说明 \n一个添加了 listener 的节点，当有节点改变时触发此方法。\n参数\nsnapshot `DataSnapshot` 新添加的子节点的数据快照\n\n返回值\nvoid\n\n----\n\n# Query (*Methods*)\n\n## addValueEventListener()\n\n定义\nvoid addValueEventListener(ValueEventListener listener)\n\n说明\n为当前节点绑定监听事件，监听该节点数据的变化。用户需要实现ValueEventListener接口。\n\n参数\nlistener `ValueEventListener` listener将监听Change事件。\n\n返回值\n`ValueEventListener` 返回监听事件的引用，可用于删除此事件。\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\nValueEventListener listener = ref.addValueEventListener(new ValueEventListener(){\n     public void onDataChange(DataSnapshot snapshot) {\n          System.out.println(snapshot.getValue());\n          // DataSnapshot to json string\n          try {\n          JSONObject json = new JSONObject();\n          json.put(dataSnapshot.getKey(), new JSONObject(dataSnapshot.getValue()));\n          System.out.println(json.toString());\n      } catch (JSONException e) {\n          e.printStackTrace();\n     }\n     }\n\n     public void onCancelled(WilddogError error) {\n          if(error != null){\n               System.out.println(error.getCode());\n          }\n\n  }\n\n});\n```\n\n----\n\n## addChildEventListener()\n\n定义\nvoid addChildEventListener(ChildEventListener listener)\n\n说明\n为子节点绑定监听事件，监听该子节点数据的变化。用户需要实现ValueEventListener接口。\n\n参数\n* listener `ChildEventListener`\n`onChildAdded()` 监听子节点的添加事件。\n`onChildRemoved()` 监听子节点的删除事件。\n`onChildChanged()` 监听子节点的变化事件。\n\n返回值\n`ChildEventListener` 返回监听事件的引用，可用于删除此事件。\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\nChildEventListener listener = ref.addChildEventListener(new ChildEventListener() {\n  public void onChildAdded(DataSnapshot snapshot, String s) {\n    System.out.println(snapshot.getValue());\n        // DataSnapshot to json string\n        try {\n          JSONObject json = new JSONObject();\n          json.put(dataSnapshot.getKey(), new JSONObject(dataSnapshot.getValue()));\n          System.out.println(json.toString());\n    } catch (JSONException e) {\n          e.printStackTrace();\n    }\n\n  }\n\n  public void onChildChanged(DataSnapshot snapshot, String s) {\n    System.out.println(snapshot.getValue());\n  }\n\n  public void onChildRemoved(DataSnapshot snapshot) {\n    System.out.println(snapshot.getValue());\n  }\n\n  public void onChildMoved(DataSnapshot snapshot, String s) {\n    System.out.println(snapshot.getValue());\n  }\n\n  public void onCancelled(WilddogError error) {\n    if(error != null){\n      System.out.println(error.getCode());\n    }\n  }\n});\n\n```\n----\n\n##  addListenerForSingleValueEvent()\n\n定义\nvoid addListenerForSingleValueEvent(ValueEventListener listener)\n\n说明 \n为当前节点单次数据获取绑定监听事件，此监听器只被触发一次，以获取当前节点下的所有数据。\n\n参数\nlistener `ValueEventListener` 节点绑定的监听事件。\n\n返回值\nvoid\n\n----\n\n## removeEventListener(ValueEventListener)\n\n定义\nvoid removeEventListener(ValueEventListener listener)\n\n说明\n删除已绑定的监听事件。\n\n参数\nlistener `ValueEventListener` 要删除的监听事件。\n\n返回值\nvoid\n\n----\n\n## removeEventListener(ChildEventListener)\n\n定义\nvoid removeEventListener(ChildEventListener listener)\n\n说明\n删除已绑定的监听事件。\n\n参数\nlistener `ChildEventListener` 要删除的监听事件。\n\n返回值\nvoid\n\n---\n\n## orderByChild()\n\n定义\nQuery orderByChild(String childKey)\n\n说明\n使用指定的子节点的值进行排序。\n\n参数\nchildKey `String` 子节点属性。\n\n返回值\nQuery 查询器类。\n\n----\n\n## orderByKey()\n\n定义\nQuery orderByKey()\n\n说明\n使用子节点的key进行排序。\n\n返回值\nQuery 查询器类\n\n---\n\n## orderByValue()\n\n定义\nQuery orderByValue()\n\n说明\n使用子节点的值进行排序。\n\n返回值\nQuery 查询器类。\n\n\n----\n\n## orderByPriority()\n\n定义\nQuery orderByPriority()\n\n说明\n根据子节点的优先级进行排序。\n\n返回值\nQuery 查询器类。\n\n----\n\n## startAt()\n\n定义\nObject startAt(String value), Object startAt(double value), Object startAt(boolean value)\n\n说明\n创建一个大于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object startAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。\n\n参数\nvalue `String` `double` `boolean`。\n\n返回值\nQuery 查询器类。\n\n----\n\n## endAt()\n\n定义\nObject endAt(String value)，Object endAt(double value)，Object endAt(boolean value)\n\n说明\n创建一个小于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object endAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。\n\n参数\nvalue `String` `double` `boolean`。\n\n返回值\nQuery 查询器类。\n\n----\n## equalTo()\n\n定义\nObject equalTo(String value)，Object equalTo(double value)，Object equalTo(boolean value)\n\n说明\n创建一个等于的精确查询。\n\n参数\nvalue `String` `double` `boolean`。\n\n返回值\nQuery 查询器类。\n\n----\n\n## limitToFirst()\n\n定义\nQuery limitToFirst(int count)\n\n说明\n创建一个limit查询。从第一条开始获取指定数量的数据。\n\n参数\ncount `int` 数量。\n\n返回值\nQuery 查询器类。\n\n----\n\n## limitToLast()\n\n定义\nQuery limitToLast(int count)\n\n说明\n创建一个limit查询。从最后一条开始获取指定数量的数据。\n\n参数\ncount `int` 数量。\n\n返回值\nQuery 查询器类。\n\n----\n\n## getRef()\n\n定义\nWilddog getRef()\n\n说明\n获得当前的引用。\n\n返回值\n`Wilddog` 节点引用。\n\n----\n\n# DataSnapshot (*Methods*)\n\n## child()\n\n定义\nWilddog child(String node)\n\n说明\n根据相对路径，来获取当前节点下子节点的快照。\n\n参数\nnode `String`  子节点名称。\n\n返回值\n`Snapshot` \n\n----\n\n## exists()\n\n定义\nboolean exists()\n\n说明\n在快照中，判断当前节点是否包含数据。相当于`snapshot.getValue()!=null` 。\n\n返回值\n`boolean` \n\n----\n\n## getChildren()\n\n定义\nIterable<DataSnapshot> getChildren()\n\n说明\n获取当前快照中，所有子节点的迭代器。\n\n返回值\n`Iterable<DataSnapshot>` 子节点的迭代器。 \n\n----\n\n## getChildrenCount()\n\n定义\nlong getChildrenCount()\n\n说明\n获得子节点的总数。\n\n返回值\n`long` 子节点总数 。\n\n----\n\n## getKey()\n\n定义\nString getKey()\n\n说明\n从快照中，获取当前节点的名称。\n\n返回值\n`String` 节点名称 。\n\n----\n\n## getPriority()\n\n定义\nObject getPriority()\n\n说明\n获取当前节点的优先级。\n\n返回值\n`Object`   `Stirng` , `Double` , `Null`。\n\n----\n\n## getRef()\n\n定义\nWilddog getRef()。\n\n说明\n从快照中，获得当前节点的引用。\n\n返回值\n`Wilddog` 节点引用。\n\n----\n\n## getValue()\n\n定义\nObject getValue()\n\n说明\n从快照中获得当前节点的数据。\n\n返回值\n`Object` 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 `Map<String, Object>`。\n\n----\n\n## hasChild()\n\n定义\nboolean hasChild(String key)\n\n说明\n判断在当前快照中，是否包含指定子节点。\n\n参数\n* key `String` 子节点名称。\n\n返回值\n`boolean` true为包含，false为不包含。\n\n----\n\n## hasChildren()\n\n定义\nboolean hasChildren()\n\n说明\n判断在当前快照中，是否存在子节点。\n\n返回值\n`boolean` true为存在子节点，false为不存在。\n\n<!--\n\n!#MutableData (*Methods*)\n\n\n!## child()\n\n!定义\nMutableData child(String node)\n\n!说明\n根据相对路径，来获取当前节点下子节点的快照。\n\n!参数\n* node `String` 子节点名称。\n\n!返回值\n`MutableData`\n\n\n!## getChildren()\n\n!定义\nIterator<MutableData> getChildren()\n\n!说明\n用于对当前节点的即时子节点进行迭代。\n!返回值\n当前节点的即时子节点。\n\n\n!## getChildrenCount()\n\n!定义\nlong getChildrenCount()\n\n!说明\n获得子节点的总数。\n\n!返回值\n`long` 子节点总数 。\n\n\n!## getKey()\n\n!定义\nString getKey()\n\n!说明\n获取当前节点的名称。\n\n!返回值\n`String` 节点名称 。\n\n\n!## getParent()\n\n!定义\nMutableData getParent()\n\n!说明 \n获取一个节点的父节点数据，如果本身就是最顶端的节点，返回null。\n!返回值\nMutableData\n\n\n!## getPriority()\n\n!定义\nObject getPriority()\n\n!说明 \n获得当前节点的优先级。\n!返回值\n`Object`   `Stirng` , `Double` , `Null`。\n\n!## getValue()\n\n!定义\nObject getValue()\n\n!说明\n获得当前节点的数据。\n\n!返回值\n`Object` 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 `Map<String, Object>`。\n\n\n!## hasChild()\n\n!定义\nboolean hasChild(String key)\n\n!说明\n判断是否包含指定子节点。\n\n!参数\n* key `String` 子节点名称。\n\n!返回值\n`boolean` true为包含，false为不包含。\n\n\n!## hasChildren()\n\n!定义\nboolean hasChildren()\n\n!说明\n判断在当前快照中，是否存在子节点。\n\n!返回值\n`boolean` true为存在子节点，false为不存在。\n\n\n!## setPriority(Object)\n\n!定义\nvoid setPriority(Object)\n\n!说明 \n设置当前节点的优先级。\n\n!参数\n* priority `Object`。\n\n!返回值\nvoid\n\n\n!## setValue()\n\n!定义\nvoid setValue(Object value)\n\n!说明 \n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n!参数\n* value `Object`。\n\n!返回值\nvoid\n-->\n----\n\n# AuthData (*Methods*)\n\n## getAuth()\n\n定义\nMap getAuth()\n\n说明 \n同步返回Token Auth状态,如果使用secret登录，返回null。\n\n返回值\n返回Token Auth状态,如果使用secret登录，返回null。\n\n----\n\n##  getExpires()\n\n定义\nlong getExpires()\n\n说明 \n取得token的过期时间。\n\n返回值\ntoken的过期时间。\n\n----\n\n##  getProvider()\n\n定义\nString getProvider()\n\n说明 \n获取第三方平台认证的支持方式，如果没有，返回null。\n\n返回值\n返回第三方OAuth平台或者null。\n\n----\n\n##  getProviderData()\n\n定义\nMap<String,Object> getProviderData()\n\n说明 \n获取认证服务器返回的第三方平台数据。内容取决于支持方式，参考文档获取更多信息。\n返回值\n一个包含第三方OAuth平台信息的Map。\n\n----\n\n##  getToken()\n\n定义\nString getToken()\n\n说明 \n获取登录认证的Token,如果是通过secret登录，得到null。\n返回值\n登录认证的Token,如果是通过secret登录，返回null。\n\n----\n\n##  getUid()\n\n定义\nString getUid()\n\n说明 \n获取登录用户的uid，如果是以secret登录或者用没有uid的Token登录，返回null。\n返回值\nuid或者null。\n\n----\n\n# WilddogError (*Constants*)\n\n## AUTHENTICATION_PROVIDER_DISABLED\n\n说明 \n要求的第三方OAuth平台认证方式不被当前app支持。\n\n----\n\n## DATA_STALE\n\n说明 \n内部使用。\n\n----\n\n## DENIED_BY_USER\n\n说明 \n用户不能登录认证应用。当用户取消OAuth认证请求时会造成这个错误。\n\n----\n\n## DISCONNECTED\n\n说明 \n因为网络连接失败导致操作不能执行。\n\n----\n\n## EMAIL_TAKEN\n\n说明 \n由于指定的邮箱地址已经被使用而不能建立新用户。\n\n----\n\n## EXPIRED_TOKEN\n\n说明 \n提供的auth Token已经过期。\n\n----\n\n## INVALID_AUTH_ARGUMENTS\n\n说明 \n指定的凭证不符合标准或者不完整。请参考错误信息，错误详情和Wilddog文档获得支持方auth登录认证的正确参数。\n\n----\n\n## INVALID_CONFIGURATION\n\n说明 \n被申请的登录认证提供方式没有配置，请求无法完成。请完成应用配置。\n\n----\n\n## INVALID_CREDENTIALS\n\n说明 \n指定的登录认证凭证不可用。当凭证不符合标准或者过期时会引发这个错误。\n\n----\n\n## INVALID_EMAIL\n\n说明\n 指定的邮箱不可用。\n\n----\n\n## INVALID_PASSWORD\n\n说明 \n指定的用户帐号密码不正确。\n\n----\n\n## INVALID_PROVIDER\n\n说明 \n申请的第三方OAuth平台认证方式不存在。请参阅Wilddog认证的相关文档获得支持的方式列表。\n\n----\n\n## INVALID_TOKEN\n\n说明 \n指定的登录认证Token不可用。如果token变形，过期或者用于生成token的secret已经被撤销，会引发此错误。\n\n----\n\n## LIMITS_EXCEEDED\n\n说明 \n超过限制，如果遇到此错误码，请联系support@Wilddog.com。\n\n----\n\n## MAX_RETRIES\n\n说明 \n事务有太多的重试。\n\n----\n\n## NETWORK_ERROR\n\n说明 \n因为网络原因导致操作不能执行。\n\n----\n\n## OPERATION_FAILED\n\n说明 \n服务器标示操作失败。\n\n----\n\n## OVERRIDDEN_BY_SET\n\n说明 \n事务被随后的集合覆盖。\n\n----\n\n## PERMISSION_DENIED\n\n说明 \n客户端不被许可执行此操作。\n\n----\n\n## PREEMPTED\n\n说明 \n活动的或者即将发生的auth登录认证被另一个auth登录取代。\n\n----\n\n## PROVIDER_ERROR\n\n说明 \n第三方OAuth平台错误。\n\n----\n\n## UNKNOWN_ERROR\n\n说明 \n未知的错误。\n\n----\n\n## USER_CODE_EXCEPTION\n\n说明 \n用户代码中发生的异常。\n\n----\n\n## USER_DOES_NOT_EXIST\n\n说明 \n指定的用户账户不存在。\n\n----\n\n# WilddogError (*Methods*)\n\n## fromException()\n\n定义\nWilddogException fromException(Throwable e)\n\n说明 \n新建一个WilddogException异常。\n\n返回值\nWilddogException\n\n----\n\n## fromStatus()\n\n定义\nWilddogError fromStatus(String)\n\n说明 \n用WilddogError常量新建一个WilddogError实例。\n\n参数\nstatus `WilddogError` The status string。\n\n返回值\nvoid\n\n----\n\n## getCode()\n\n定义\nint getCode()\n\n说明 \n一个明确的状态码，取决于错误。\n返回值\nint。\n\n----\n\n## getMessage()\n\n定义\nString getMessage()\n\n说明 \n获取错误原因。\n\n返回值\nString\n\n----\n\n## getDetails()\n\n定义\nString getDetails()\n\n说明\n获取错误细节。\n\n返回值\n错误的细节。\n\n----\n\n## toException()\n\n定义\nWilddogExcepton toException()\n\n说明 \n如果第三方需要一个来自wilddog的异常，出于整合的目的可以使用此方法。\n\n返回值\n一个封装了error的异常类，包含了适当的信息，没有栈信息。\n\n----\n\n# Config (*Methods*)\n\n## setLogger()\n\n定义\nvoid setLogger(Logger logger)\n\n说明 \n如果你想提供一个定制的日志，传递一个继承了Logger接口的对象。\n\n参数\nlogger `Logger` 定制的日志。\n\n返回值\nvoid\n\n----\n\n## setEventTarget()\n\n定义\nvoid setEventTarget(EventTarget eventTarget)\n\n说明 \n在默认设置中，Wilddog库会创建一个线程来处理所有的回调。在安卓中，将试图采用main Looper。如果你想对如何触发回调有更多控制权，你可以提供一个对象，让他继承EventTarget，它将为每一个回调传递一个Runnable。\n\n参数\neventTarget `EventTarget`  负责触发回调的对象。\n\n返回值\nvoid\n\n----\n\n## setLogLevel()\n\n定义\nvoid setLogLevel(Logger.Level logLevel)\n说明 \n默认的，这会被设置为INFO。log等级包括内部错误（ERROR）和任何客户端接收到的安全性debug信息（INFO），设置为DEBUG将会打开诊断日志，设置为NONE禁止所有日志。\n\n参数\nlogLevel `Logger.Level` 所需最低的日志等级。\n\n返回值\nvoid\n\n----\n\n## setDebugLogComponents()\n\n定义\nvoid setDebugLogComponents(List<String> debugComponents)\n\n说明 \n主要用于debug调试.限制debug输出到指定组件。默认为null，允许所有组建的日志;  显式设置也会把等级设置为DEBUG。\n参数\ndebugComponents `List<String> ` 一系列日志需要的组件，或者设置为null使所有组件可行。\n\n返回值\nvoid\n\n----\n\n## setAuthenticationServer()\n\n定义\nvoid setAuthenticationServer(String host)\n\n说明 \n设置主机可以被用户登录认证。如果你不确定，不要使用此设置。\n参数\nhost `String` 用于认证的server。\n\n返回值\nvoid\n\n----\n\n## setSessionPersistenceKey()\n\n定义\nvoid setSessionPersistenceKey(String sessionKey)\n\n说明 \n为Ｗilddog连接设置session的标识符，使用session标识符可以使多个认证会话在一个设备上共存。如果一个设备上只有一个用户没有必要使用此方法。\n\n参数\nsessionKey `String` 用于标识session的标识符名称。\n\n返回值\nvoid\n\n\n\n\n","source":"api/sync/android.md","raw":"title:  完整 API 文档\n---\n\n# Wilddog (*Methods*)\n\n##  setAndroidContext()\n\n定义\n\nstatic void setAndroidContext(android.content.Context context)\n\n说明 \n\nWilddog在Android初始化需要配置Android Context， 且必须要在new Wilddog()之前配置。你可以在 `android.app.Application` 或者 `Activity`的`onCreate` 方法中设置 Android Context。\n\n参数\n\ncontext `android.content.Context`  在Android中使用Wilddog需要一个Android Context。\n\n返回值\n\nvoid\n\n----\n\n##  setDefaultConfig()\n\n定义\nstatic void setDefaultConfig(Config config)\n\n说明 \nWilddog的默认配置对象，在调用new Wilddog之前必须调用此方法。\n\n参数\nconfig `Config` 新的config参数\n\n返回值\nvoid\n\n---\n\n## getDefaultConfig()\n\n定义\nstatic Config getDefaultConfig()\n\n说明 \n获取Wilddog的默认配置对象。\n\n返回值\n\n\n<!-- Js通过方法前面的两个“#”抽取目录，为识别注释多加一个“#”\n### getApp()\n\n定义\nWilddogApp getApp()\n\n说明 \n获取与引用关联的WilddogApp实例\n\n返回值\n对应于引用的WilddogApp对象\n-->\n\n----\n\n## child()\n\n定义\nWilddog child(String path)\n\n说明\n根据相对路径，来获取当前节点下子节点的引用。\n\n参数\npath `String` path 为相对路径，多层级间需要使用\"/\"分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。\n\n返回值\n`Wilddog` 子节点引用。\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 定位到 '/test/a'\nWilddog ref2 = ref.child(\"a\");\n\n// 定位到 '/test/a/b'\nWilddog ref3 = ref.child(\"a/b\");\nWilddog ref4 = ref.child(\"a\").child(\"b\");\n\n```\n----\n\n## push()\n\n定义\nWilddog push()\n\n说明\n在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。\n\n返回值\n`Wilddog` 新生成子节点的引用对象。\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 添加一个数值，将生成一个新ID，操作结果为{\"-JmpzI81egafHZo5\":100}， 返回的path为“/test/a/b/-JmpzI81egafHZo5”\nWilddog  newRef = ref.child(\"a/b\").push();\nnewRef.setValue(100);\n\n// 添加一个实体\nDOTAHero hero = new DOTAHero();\nhero.setName(\"Nevermore\");\nhero.setHp(435);\nhero.setMp(234);\nref.child(\"heros\").push().setValue(hero);\n\n```\n----\n\n\n\n## setValue(Object)\n\n定义\nvoid setValue(Object value)\n\n说明\n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\nvalue `Object`\nvalue的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。\n当value为String、Number、Boolean时，等价于当前节点的`updateChildren()`操作。\n当value为null时，等价于当前节点的`removeValue()`操作。\n当value为Map或JavaBean时，将value转为一颗子树替换当前value。\n\n返回值\nvoid\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 等价 update(100);\nref.child(\"a/b\").setValue(100);\n\n// 等价 remove();\nref.child(\"a/b\").setValue(null);\n\n// 设置子树\nMap<String, String> children = new HashMap<String, String>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").setValue(children);\n\n// 自定义Entity\nDOTAHero hero = new DOTAHero();\nhero.setName(\"Nevermore\");\nhero.setHp(435);\nhero.setMp(234);\nref.child(\"dota/heros/SF\").setValue(hero);\n\n```\n----\n\n## setValue(Object, CompletionListener)\n\n定义\nvoid setValue(Object value, Wilddog.CompletionListener listener)\n\n说明\n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\nvalue `Object` value的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。\n当value为String、Number、Boolean时，等价于Path对应的Node的`updateChildren()`操作。\n当value为null时，等价于Path对应的Node的`removeValue()`操作。\n当value为Map或JavaBean时，将value转为一颗子树替换当前value。\n\nlistener `CompletionListener` listener包含一个callback函数，用户可以实现`onComplete`函数，如果某个callback函数没有响应的处理，接口实现为`{}`函数即可。`setValue(value)`等价于`setValue(value, null)`。\n\n返回值\nvoid\n\n示例\n自定义CompletionListener\n```java\npublic class MyHandler implements Wilddog.CompletionListener {\n      public void onComplete(WilddogError error, Wilddog ref) {\n          if(error != null){\n              System.out.println(error.getCode());\n          }\n      }\n  }\n\n```\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nCompletionListener listener = new MyHandler();\n\n// 等价 update(100);\nref.child(\"a/b\").setValue(100, listener);\n\n// 等价 remove();\nref.child(\"a/b\").setValue(null, listener);\n\n// 设置子树\nMap<String, String> children = new HashMap<String, String>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").setValue(children, listener);\n\n// 自定义Entity\nDOTAHero hero = new DOTAHero();\nhero.setName(\"Nevermore\");\nhero.setHp(435);\nhero.setMp(234);\n\nref.child(\"dota/heros/SF\").setValue(hero, new Wilddog.CompletionListener() {\n  public void onComplete(WilddogError error, Wilddog ref) {\n    if(error != null) {\n      System.out.println(error.getCode());\n      return;\n    }\n    System.out.println(\"Good!\");\n  }\n});\n\n```\n\n----\n\n##  setPriority()\n\n定义\nvoid setPriority(Object)\n\n说明 \n设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。\n你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。\n\n节点按照如下规则排序：\n- 没有priority的排最先。\n- 有数字priority的次之，按照数值排序。\n- 有字符串 priority的排最后，按照字母表的顺序排列。\n- 当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。\n<br>\n<br>\n注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。\n\n参数\npriority `Object` 指定节点的优先级。\n\n返回值\nvoid\n\n----\n\n##  setPriority(Object, CompletionListener)\n\n定义\nvoid setPriority(Object, Wilddog.CompletionListener)\n\n说明 \n设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。\n你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。\n\n节点按照如下规则排序：\n- 没有priority的排最先。\n- 有数字priority的次之，按照数值排序。\n- 有字符串 priority的排最后，按照字母表的顺序排列。\n- 当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。\n<br>\n<br>\n注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。\n\n参数\n* priority `Object` 指定节点的优先级。\n* listener `CompletionListener`。\n\n返回值\nvoid\n\n----\n\n## updateChildren()\n\n定义\nvoid updateChildren(Map value)\n\n说明\n对子节点进行合并操作。不存在的子节点将会被新增，存在子节点将会被替换。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\nvalue `Map<String, Object>` 当value为null时，等价于`removeValue()`操作。\n\n\n返回值\nvoid\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\n// 更新子树\nMap<String, String> children = new HashMap<String, String>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").updateChildren(children);\n```\n\n----\n\n## updateChildren(Map, CompletionListener)\n\n定义\nvoid updateChildren(Map children, Wilddog.CompletionListener listener)\n\n说明\n对子节点进行更新操作。不存在的子节点将会被新增，存在子节点将会被替换。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\n* value `Map<String, Object>` 当value为null时，等价于`removeValue()`操作。\n* listener `CompletionListener` listener包含一个回调函数`onComplete`，如果执行完成，`onComplete`函数将会被调用。\n\n返回值\nvoid\n\n示例\n自定义CompletionListener\n```java\npublic class MyHandler implements Wilddog.CompletionListener {\n  public void onComplete(WilddogError error, Wilddog ref){\n    if(error != null){\n      System.out.println(error.getCode());\n    }\n  }\n}\n```\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nCompletionListener handler = new MyHandler();\n\n// 更新子树\nMap<String, Object> children = new HashMap<String, Object>();\nchildren.put(\"c\", \"cval\");\nref.child(\"a/b\").updateChildren(children, handler);\n```\n\n----\n\n## removeValue()\n\n定义\nvoid removeValue()\n\n说明\n删除当前节点。 删除成功后将触发Change，ChildRemoved事件。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n返回值\nvoid\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nref.child(\"a/b\").removeValue();\n```\n----\n\n## removeValue(CompletionListener)\n\n定义\nvoid removeValue(CompletionListener listener)\n\n说明\n删除当前节点。 删除成功后将触发Change，ChildRemoved事件。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n参数\n* listener `CompletionListener`\nlistener包含一个回调函数`onComplete`，如果执行完成，`onComplete`函数将会被调用。\n\n返回值\nvoid\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\nResultHandler handler = new MyHandler();\nref.child(\"a/b\").removeValue(handler);\n\n```\n\n----\n\n## runTransaction(Transaction.Handler)\n\n定义\nvoid runTransaction(Transaction.Handler handler)\n\n说明\n在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，runTransaction() 能够确保不同客户端同时修改，没有冲突。\n\n参数\n* handler `Transaction.Handler` \n\n返回值\nvoid\n\n示例\n\n```java\nWilddog upvotesRef = new Wilddog(\"https://<appId>.wilddogio.com/android/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\");\n\nupvotesRef.runTransaction(new Transaction.Handler() {\n    public Transaction.Result doTransaction(MutableData currentData) {\n        if(currentData.getValue() == null) {\n            currentData.setValue(1);\n        } else {\n            currentData.setValue((Long) currentData.getValue() + 1);\n        }\n        \n        return Transaction.success(currentData); // 我们可以调用 Transaction.abort() 中止事务\n    }\n\n    public void onComplete(WilddogError wilddogError, boolean committed, DataSnapshot currentData) {\n        // 事务完成后调用一次，获取事务完成的结果\n    }\n});\n```\n____\n\n##  onDisconnect()\n\n定义\nOnDisconnect onDisconnect()\n\n说明 \n当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。\n\n返回值\n当前节点执行断开连接操作的对象。\n\n----\n\n##  goOffline()\n\n定义\nstatic void goOffline()\n\n说明 \n手动关闭连接，关闭自动连接。\n注意：调用此方法会影响到所有Wilddog连接。\n\n返回值\nvoid\n\n----\n\n##  goOnline()\n\n定义\nstatic void goOnline()\n\n说明 \n手动建立连接，开启自动重连。\n注意：调用此方法会影响到所有Wilddog连接。\n返回值\nvoid\n\n----\n\n## getKey()\n\n定义\nString getKey()\n\n说明\n获取当前节点的名称。\n\n返回值\n`String` 节点名称。 \n\n----\n\n## getParent()\n\n定义\nWilddog getParent()\n\n说明 \n获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。\n\n返回值\n`Wilddog` 父节点的引用。\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test/a\");\n\n// 获得'/test' 路径的引用\nWilddog ref2 = ref.getParent();\n\n// 到达root\nWilddog ref3 = ref.getParent().getParent();\n\n```\n\n----\n\n##  getRoot()\n\n定义\nWilddog getRoot()\n\n说明 \n获取根节点的引用。\n返回值\n根节点的引用。\n\n----\n\n## getSdkVersion()\n\n定义\nstatic String getSdkVersion()\n\n说明 \n获取SDK版本。\n\n返回值\nSDK版本。\n\n----\n\n# Wilddog.CompletionListener (*Methods*)\n\n##  onComplete()\n\n定义\nvoid onComplete(WilddogError error,\n                Wilddog ref)\n\n说明 \n当操作成功或者失败的时候触发这个方法。如果操作失败，会给出一个error,如果操作成功，error为null。\n参数\n* error `WilddogError` 错误描述。\n* ref `Wilddog` 到指定Wilddog节点的引用。\n\n返回值\nvoid\n\n----\n\n# Wilddog.AuthStateListener (*Methods*)\n\n## onAuthStateChanged()\n\n定义\nvoid onAuthStateChanged(AuthData authData)\n\n说明\n当登录认证状态发生改变的时候，此方法将被调用。authData包含当前登录认证的信息，如果当前的连接没有登录认证，authData为null。\n\n参数\nauthData `AuthData` 当前登录认证的信息，未登录认证时为null。\n\n返回值\nvoid\n\n----\n\n# Wilddog.AuthResultHandler (*Methods*)\n\n## onAuthenticated()\n\n定义\nvoid onAuthenticated(AuthData authData)\n\n说明 \n当登录认证成功时这个方法被调用。\n\n参数\nauthData `AuthData` 当前用户或者Token的信息。\n\n返回值\nvoid\n\n----\n\n##  onAuthenticationError()\n\n定义\nvoid onAuthenticationError(WilddogError error)\n\n说明 \n当登录认证失败时这个方法被调用。\n\n参数\nerror `WilddogError` 登录认证失败的原因和附加的详细信息。\n\n返回值\nvoid\n\n----\n\n# Wilddog.ResultHandler (*Methods*)\n\n##  onError()\n\n定义\nvoid onError(WilddogError error)\n\n说明 \n如果操作失败此方法被调用。\n\n参数\nerror `WilddogError` 包含失败原因和附加的详情。\n\n返回值\nvoid\n\n----\n\n##  onSuccess()\n\n定义\nvoid onSuccess()\n\n说明 \n如果操作成功此方法被调用。\n\n返回值\nvoid\n\n----\n\n# ChildEventListener (*Methods*)\n\n##  onCancelled()\n\n定义\nvoid onCancelled(WilddogError error)\n\n说明 \n当listener在服务端失败，或者被删除的时候调用该方法。\n\n参数\nerror `WilddogError` 发生错误的描述。\n\n返回值\nvoid\n\n----\n\n##  onChildAdded()\n\n定义\nvoid onChildAdded(DataSnapshot snapshot,\n                  String previousChildName)\n\n说明 \n一个添加了listener的节点，当有子节点被添加时触发此方法。\n\n参数\n* snapshot `DataSnapshot` 新添加的子节点数据快照。\n* previousChildName `String` 排在被添加的新子节点前面的兄弟节点的key值。如果被添加的是当前节点的第一个子节点，该值为null。\n\n返回值\nvoid\n\n----\n\n##  onChildChanged()\n\n定义\nvoid onChildChanged(DataSnapshot snapshot,\n                    String previousChildName)\n\n说明 \n当前节点的子节点发生改变的时候触发此方法。\n\n参数\n* snapshot `DataSnapshot` 新子节点数据的快照。\n* previousChildName `String` 排在被修改的新子节点前面的兄弟节点的key值。如果改变的是当前节点的第一个子节点，该值为null。\n\n返回值\nvoid\n\n----\n\n##  onChildMoved()\n\n定义\nvoid onChildMoved(DataSnapshot snapshot,\n                  String previousChildName)\n\n说明 \n当一个子节点的优先级发生变化时，该方法将被调用。参考Wilddog.setPriority(Object)和数据排序了解更多关于优先级和数据排序的信息。\n\n参数\n* `DataSnapshot` 节点排序发生变化时的数据快照。\n* `String` 排在当前子节点前面的兄弟子节点的key名称，如果当前节点位置最先，此值为null。\n\n返回值\nvoid\n\n----\n\n## onChildRemoved()\n\n定义\nvoid onChildRemoved(DataSnapshot snapshot)\n\n说明 \n当一个添加了listener的节点有子节点被删除的时候触发这个方法。\n\n参数\nsnapshot `DataSnapshot` 被删除子节点的数据快照。\n\n返回值\nvoid\n\n----\n\n# ValueEventListener (*Methods*)\n\n##  onCancelled()\n\n定义\nvoid onCancelled(WilddogError error)\n\n说明 \n当listener在服务端失败，或者被删除的时候调用该方法。\n\n参数\nerror `DataSnapshot` 发生错误的描述。\n\n返回值\nvoid\n\n----\n\n##  onDataChange()\n\n定义\nvoid onDataChange(DataSnapshot snapshot)\n\n说明 \n一个添加了 listener 的节点，当有节点改变时触发此方法。\n参数\nsnapshot `DataSnapshot` 新添加的子节点的数据快照\n\n返回值\nvoid\n\n----\n\n# Query (*Methods*)\n\n## addValueEventListener()\n\n定义\nvoid addValueEventListener(ValueEventListener listener)\n\n说明\n为当前节点绑定监听事件，监听该节点数据的变化。用户需要实现ValueEventListener接口。\n\n参数\nlistener `ValueEventListener` listener将监听Change事件。\n\n返回值\n`ValueEventListener` 返回监听事件的引用，可用于删除此事件。\n\n示例\n\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\nValueEventListener listener = ref.addValueEventListener(new ValueEventListener(){\n     public void onDataChange(DataSnapshot snapshot) {\n          System.out.println(snapshot.getValue());\n          // DataSnapshot to json string\n          try {\n          JSONObject json = new JSONObject();\n          json.put(dataSnapshot.getKey(), new JSONObject(dataSnapshot.getValue()));\n          System.out.println(json.toString());\n      } catch (JSONException e) {\n          e.printStackTrace();\n     }\n     }\n\n     public void onCancelled(WilddogError error) {\n          if(error != null){\n               System.out.println(error.getCode());\n          }\n\n  }\n\n});\n```\n\n----\n\n## addChildEventListener()\n\n定义\nvoid addChildEventListener(ChildEventListener listener)\n\n说明\n为子节点绑定监听事件，监听该子节点数据的变化。用户需要实现ValueEventListener接口。\n\n参数\n* listener `ChildEventListener`\n`onChildAdded()` 监听子节点的添加事件。\n`onChildRemoved()` 监听子节点的删除事件。\n`onChildChanged()` 监听子节点的变化事件。\n\n返回值\n`ChildEventListener` 返回监听事件的引用，可用于删除此事件。\n\n示例\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/test\");\n\nChildEventListener listener = ref.addChildEventListener(new ChildEventListener() {\n  public void onChildAdded(DataSnapshot snapshot, String s) {\n    System.out.println(snapshot.getValue());\n        // DataSnapshot to json string\n        try {\n          JSONObject json = new JSONObject();\n          json.put(dataSnapshot.getKey(), new JSONObject(dataSnapshot.getValue()));\n          System.out.println(json.toString());\n    } catch (JSONException e) {\n          e.printStackTrace();\n    }\n\n  }\n\n  public void onChildChanged(DataSnapshot snapshot, String s) {\n    System.out.println(snapshot.getValue());\n  }\n\n  public void onChildRemoved(DataSnapshot snapshot) {\n    System.out.println(snapshot.getValue());\n  }\n\n  public void onChildMoved(DataSnapshot snapshot, String s) {\n    System.out.println(snapshot.getValue());\n  }\n\n  public void onCancelled(WilddogError error) {\n    if(error != null){\n      System.out.println(error.getCode());\n    }\n  }\n});\n\n```\n----\n\n##  addListenerForSingleValueEvent()\n\n定义\nvoid addListenerForSingleValueEvent(ValueEventListener listener)\n\n说明 \n为当前节点单次数据获取绑定监听事件，此监听器只被触发一次，以获取当前节点下的所有数据。\n\n参数\nlistener `ValueEventListener` 节点绑定的监听事件。\n\n返回值\nvoid\n\n----\n\n## removeEventListener(ValueEventListener)\n\n定义\nvoid removeEventListener(ValueEventListener listener)\n\n说明\n删除已绑定的监听事件。\n\n参数\nlistener `ValueEventListener` 要删除的监听事件。\n\n返回值\nvoid\n\n----\n\n## removeEventListener(ChildEventListener)\n\n定义\nvoid removeEventListener(ChildEventListener listener)\n\n说明\n删除已绑定的监听事件。\n\n参数\nlistener `ChildEventListener` 要删除的监听事件。\n\n返回值\nvoid\n\n---\n\n## orderByChild()\n\n定义\nQuery orderByChild(String childKey)\n\n说明\n使用指定的子节点的值进行排序。\n\n参数\nchildKey `String` 子节点属性。\n\n返回值\nQuery 查询器类。\n\n----\n\n## orderByKey()\n\n定义\nQuery orderByKey()\n\n说明\n使用子节点的key进行排序。\n\n返回值\nQuery 查询器类\n\n---\n\n## orderByValue()\n\n定义\nQuery orderByValue()\n\n说明\n使用子节点的值进行排序。\n\n返回值\nQuery 查询器类。\n\n\n----\n\n## orderByPriority()\n\n定义\nQuery orderByPriority()\n\n说明\n根据子节点的优先级进行排序。\n\n返回值\nQuery 查询器类。\n\n----\n\n## startAt()\n\n定义\nObject startAt(String value), Object startAt(double value), Object startAt(boolean value)\n\n说明\n创建一个大于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object startAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。\n\n参数\nvalue `String` `double` `boolean`。\n\n返回值\nQuery 查询器类。\n\n----\n\n## endAt()\n\n定义\nObject endAt(String value)，Object endAt(double value)，Object endAt(boolean value)\n\n说明\n创建一个小于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object endAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。\n\n参数\nvalue `String` `double` `boolean`。\n\n返回值\nQuery 查询器类。\n\n----\n## equalTo()\n\n定义\nObject equalTo(String value)，Object equalTo(double value)，Object equalTo(boolean value)\n\n说明\n创建一个等于的精确查询。\n\n参数\nvalue `String` `double` `boolean`。\n\n返回值\nQuery 查询器类。\n\n----\n\n## limitToFirst()\n\n定义\nQuery limitToFirst(int count)\n\n说明\n创建一个limit查询。从第一条开始获取指定数量的数据。\n\n参数\ncount `int` 数量。\n\n返回值\nQuery 查询器类。\n\n----\n\n## limitToLast()\n\n定义\nQuery limitToLast(int count)\n\n说明\n创建一个limit查询。从最后一条开始获取指定数量的数据。\n\n参数\ncount `int` 数量。\n\n返回值\nQuery 查询器类。\n\n----\n\n## getRef()\n\n定义\nWilddog getRef()\n\n说明\n获得当前的引用。\n\n返回值\n`Wilddog` 节点引用。\n\n----\n\n# DataSnapshot (*Methods*)\n\n## child()\n\n定义\nWilddog child(String node)\n\n说明\n根据相对路径，来获取当前节点下子节点的快照。\n\n参数\nnode `String`  子节点名称。\n\n返回值\n`Snapshot` \n\n----\n\n## exists()\n\n定义\nboolean exists()\n\n说明\n在快照中，判断当前节点是否包含数据。相当于`snapshot.getValue()!=null` 。\n\n返回值\n`boolean` \n\n----\n\n## getChildren()\n\n定义\nIterable<DataSnapshot> getChildren()\n\n说明\n获取当前快照中，所有子节点的迭代器。\n\n返回值\n`Iterable<DataSnapshot>` 子节点的迭代器。 \n\n----\n\n## getChildrenCount()\n\n定义\nlong getChildrenCount()\n\n说明\n获得子节点的总数。\n\n返回值\n`long` 子节点总数 。\n\n----\n\n## getKey()\n\n定义\nString getKey()\n\n说明\n从快照中，获取当前节点的名称。\n\n返回值\n`String` 节点名称 。\n\n----\n\n## getPriority()\n\n定义\nObject getPriority()\n\n说明\n获取当前节点的优先级。\n\n返回值\n`Object`   `Stirng` , `Double` , `Null`。\n\n----\n\n## getRef()\n\n定义\nWilddog getRef()。\n\n说明\n从快照中，获得当前节点的引用。\n\n返回值\n`Wilddog` 节点引用。\n\n----\n\n## getValue()\n\n定义\nObject getValue()\n\n说明\n从快照中获得当前节点的数据。\n\n返回值\n`Object` 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 `Map<String, Object>`。\n\n----\n\n## hasChild()\n\n定义\nboolean hasChild(String key)\n\n说明\n判断在当前快照中，是否包含指定子节点。\n\n参数\n* key `String` 子节点名称。\n\n返回值\n`boolean` true为包含，false为不包含。\n\n----\n\n## hasChildren()\n\n定义\nboolean hasChildren()\n\n说明\n判断在当前快照中，是否存在子节点。\n\n返回值\n`boolean` true为存在子节点，false为不存在。\n\n<!--\n\n!#MutableData (*Methods*)\n\n\n!## child()\n\n!定义\nMutableData child(String node)\n\n!说明\n根据相对路径，来获取当前节点下子节点的快照。\n\n!参数\n* node `String` 子节点名称。\n\n!返回值\n`MutableData`\n\n\n!## getChildren()\n\n!定义\nIterator<MutableData> getChildren()\n\n!说明\n用于对当前节点的即时子节点进行迭代。\n!返回值\n当前节点的即时子节点。\n\n\n!## getChildrenCount()\n\n!定义\nlong getChildrenCount()\n\n!说明\n获得子节点的总数。\n\n!返回值\n`long` 子节点总数 。\n\n\n!## getKey()\n\n!定义\nString getKey()\n\n!说明\n获取当前节点的名称。\n\n!返回值\n`String` 节点名称 。\n\n\n!## getParent()\n\n!定义\nMutableData getParent()\n\n!说明 \n获取一个节点的父节点数据，如果本身就是最顶端的节点，返回null。\n!返回值\nMutableData\n\n\n!## getPriority()\n\n!定义\nObject getPriority()\n\n!说明 \n获得当前节点的优先级。\n!返回值\n`Object`   `Stirng` , `Double` , `Null`。\n\n!## getValue()\n\n!定义\nObject getValue()\n\n!说明\n获得当前节点的数据。\n\n!返回值\n`Object` 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 `Map<String, Object>`。\n\n\n!## hasChild()\n\n!定义\nboolean hasChild(String key)\n\n!说明\n判断是否包含指定子节点。\n\n!参数\n* key `String` 子节点名称。\n\n!返回值\n`boolean` true为包含，false为不包含。\n\n\n!## hasChildren()\n\n!定义\nboolean hasChildren()\n\n!说明\n判断在当前快照中，是否存在子节点。\n\n!返回值\n`boolean` true为存在子节点，false为不存在。\n\n\n!## setPriority(Object)\n\n!定义\nvoid setPriority(Object)\n\n!说明 \n设置当前节点的优先级。\n\n!参数\n* priority `Object`。\n\n!返回值\nvoid\n\n\n!## setValue()\n\n!定义\nvoid setValue(Object value)\n\n!说明 \n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n!参数\n* value `Object`。\n\n!返回值\nvoid\n-->\n----\n\n# AuthData (*Methods*)\n\n## getAuth()\n\n定义\nMap getAuth()\n\n说明 \n同步返回Token Auth状态,如果使用secret登录，返回null。\n\n返回值\n返回Token Auth状态,如果使用secret登录，返回null。\n\n----\n\n##  getExpires()\n\n定义\nlong getExpires()\n\n说明 \n取得token的过期时间。\n\n返回值\ntoken的过期时间。\n\n----\n\n##  getProvider()\n\n定义\nString getProvider()\n\n说明 \n获取第三方平台认证的支持方式，如果没有，返回null。\n\n返回值\n返回第三方OAuth平台或者null。\n\n----\n\n##  getProviderData()\n\n定义\nMap<String,Object> getProviderData()\n\n说明 \n获取认证服务器返回的第三方平台数据。内容取决于支持方式，参考文档获取更多信息。\n返回值\n一个包含第三方OAuth平台信息的Map。\n\n----\n\n##  getToken()\n\n定义\nString getToken()\n\n说明 \n获取登录认证的Token,如果是通过secret登录，得到null。\n返回值\n登录认证的Token,如果是通过secret登录，返回null。\n\n----\n\n##  getUid()\n\n定义\nString getUid()\n\n说明 \n获取登录用户的uid，如果是以secret登录或者用没有uid的Token登录，返回null。\n返回值\nuid或者null。\n\n----\n\n# WilddogError (*Constants*)\n\n## AUTHENTICATION_PROVIDER_DISABLED\n\n说明 \n要求的第三方OAuth平台认证方式不被当前app支持。\n\n----\n\n## DATA_STALE\n\n说明 \n内部使用。\n\n----\n\n## DENIED_BY_USER\n\n说明 \n用户不能登录认证应用。当用户取消OAuth认证请求时会造成这个错误。\n\n----\n\n## DISCONNECTED\n\n说明 \n因为网络连接失败导致操作不能执行。\n\n----\n\n## EMAIL_TAKEN\n\n说明 \n由于指定的邮箱地址已经被使用而不能建立新用户。\n\n----\n\n## EXPIRED_TOKEN\n\n说明 \n提供的auth Token已经过期。\n\n----\n\n## INVALID_AUTH_ARGUMENTS\n\n说明 \n指定的凭证不符合标准或者不完整。请参考错误信息，错误详情和Wilddog文档获得支持方auth登录认证的正确参数。\n\n----\n\n## INVALID_CONFIGURATION\n\n说明 \n被申请的登录认证提供方式没有配置，请求无法完成。请完成应用配置。\n\n----\n\n## INVALID_CREDENTIALS\n\n说明 \n指定的登录认证凭证不可用。当凭证不符合标准或者过期时会引发这个错误。\n\n----\n\n## INVALID_EMAIL\n\n说明\n 指定的邮箱不可用。\n\n----\n\n## INVALID_PASSWORD\n\n说明 \n指定的用户帐号密码不正确。\n\n----\n\n## INVALID_PROVIDER\n\n说明 \n申请的第三方OAuth平台认证方式不存在。请参阅Wilddog认证的相关文档获得支持的方式列表。\n\n----\n\n## INVALID_TOKEN\n\n说明 \n指定的登录认证Token不可用。如果token变形，过期或者用于生成token的secret已经被撤销，会引发此错误。\n\n----\n\n## LIMITS_EXCEEDED\n\n说明 \n超过限制，如果遇到此错误码，请联系support@Wilddog.com。\n\n----\n\n## MAX_RETRIES\n\n说明 \n事务有太多的重试。\n\n----\n\n## NETWORK_ERROR\n\n说明 \n因为网络原因导致操作不能执行。\n\n----\n\n## OPERATION_FAILED\n\n说明 \n服务器标示操作失败。\n\n----\n\n## OVERRIDDEN_BY_SET\n\n说明 \n事务被随后的集合覆盖。\n\n----\n\n## PERMISSION_DENIED\n\n说明 \n客户端不被许可执行此操作。\n\n----\n\n## PREEMPTED\n\n说明 \n活动的或者即将发生的auth登录认证被另一个auth登录取代。\n\n----\n\n## PROVIDER_ERROR\n\n说明 \n第三方OAuth平台错误。\n\n----\n\n## UNKNOWN_ERROR\n\n说明 \n未知的错误。\n\n----\n\n## USER_CODE_EXCEPTION\n\n说明 \n用户代码中发生的异常。\n\n----\n\n## USER_DOES_NOT_EXIST\n\n说明 \n指定的用户账户不存在。\n\n----\n\n# WilddogError (*Methods*)\n\n## fromException()\n\n定义\nWilddogException fromException(Throwable e)\n\n说明 \n新建一个WilddogException异常。\n\n返回值\nWilddogException\n\n----\n\n## fromStatus()\n\n定义\nWilddogError fromStatus(String)\n\n说明 \n用WilddogError常量新建一个WilddogError实例。\n\n参数\nstatus `WilddogError` The status string。\n\n返回值\nvoid\n\n----\n\n## getCode()\n\n定义\nint getCode()\n\n说明 \n一个明确的状态码，取决于错误。\n返回值\nint。\n\n----\n\n## getMessage()\n\n定义\nString getMessage()\n\n说明 \n获取错误原因。\n\n返回值\nString\n\n----\n\n## getDetails()\n\n定义\nString getDetails()\n\n说明\n获取错误细节。\n\n返回值\n错误的细节。\n\n----\n\n## toException()\n\n定义\nWilddogExcepton toException()\n\n说明 \n如果第三方需要一个来自wilddog的异常，出于整合的目的可以使用此方法。\n\n返回值\n一个封装了error的异常类，包含了适当的信息，没有栈信息。\n\n----\n\n# Config (*Methods*)\n\n## setLogger()\n\n定义\nvoid setLogger(Logger logger)\n\n说明 \n如果你想提供一个定制的日志，传递一个继承了Logger接口的对象。\n\n参数\nlogger `Logger` 定制的日志。\n\n返回值\nvoid\n\n----\n\n## setEventTarget()\n\n定义\nvoid setEventTarget(EventTarget eventTarget)\n\n说明 \n在默认设置中，Wilddog库会创建一个线程来处理所有的回调。在安卓中，将试图采用main Looper。如果你想对如何触发回调有更多控制权，你可以提供一个对象，让他继承EventTarget，它将为每一个回调传递一个Runnable。\n\n参数\neventTarget `EventTarget`  负责触发回调的对象。\n\n返回值\nvoid\n\n----\n\n## setLogLevel()\n\n定义\nvoid setLogLevel(Logger.Level logLevel)\n说明 \n默认的，这会被设置为INFO。log等级包括内部错误（ERROR）和任何客户端接收到的安全性debug信息（INFO），设置为DEBUG将会打开诊断日志，设置为NONE禁止所有日志。\n\n参数\nlogLevel `Logger.Level` 所需最低的日志等级。\n\n返回值\nvoid\n\n----\n\n## setDebugLogComponents()\n\n定义\nvoid setDebugLogComponents(List<String> debugComponents)\n\n说明 \n主要用于debug调试.限制debug输出到指定组件。默认为null，允许所有组建的日志;  显式设置也会把等级设置为DEBUG。\n参数\ndebugComponents `List<String> ` 一系列日志需要的组件，或者设置为null使所有组件可行。\n\n返回值\nvoid\n\n----\n\n## setAuthenticationServer()\n\n定义\nvoid setAuthenticationServer(String host)\n\n说明 \n设置主机可以被用户登录认证。如果你不确定，不要使用此设置。\n参数\nhost `String` 用于认证的server。\n\n返回值\nvoid\n\n----\n\n## setSessionPersistenceKey()\n\n定义\nvoid setSessionPersistenceKey(String sessionKey)\n\n说明 \n为Ｗilddog连接设置session的标识符，使用session标识符可以使多个认证会话在一个设备上共存。如果一个设备上只有一个用户没有必要使用此方法。\n\n参数\nsessionKey `String` 用于标识session的标识符名称。\n\n返回值\nvoid\n\n\n\n\n","date":"2016-09-06T03:38:22.514Z","updated":"2016-09-06T03:38:22.514Z","path":"api/sync/android.html","comments":1,"layout":"page","_id":"cisswi9j30009z4fwyn15o3ab","content":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"setAndroidContext\"><a href=\"#setAndroidContext\" class=\"headerlink\" title=\"setAndroidContext()\"></a>setAndroidContext()</h2><p>定义</p>\n<p>static void setAndroidContext(android.content.Context context)</p>\n<p>说明 </p>\n<p>Wilddog在Android初始化需要配置Android Context， 且必须要在new Wilddog()之前配置。你可以在 <code>android.app.Application</code> 或者 <code>Activity</code>的<code>onCreate</code> 方法中设置 Android Context。</p>\n<p>参数</p>\n<p>context <code>android.content.Context</code>  在Android中使用Wilddog需要一个Android Context。</p>\n<p>返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"setDefaultConfig\"><a href=\"#setDefaultConfig\" class=\"headerlink\" title=\"setDefaultConfig()\"></a>setDefaultConfig()</h2><p>定义<br>static void setDefaultConfig(Config config)</p>\n<p>说明<br>Wilddog的默认配置对象，在调用new Wilddog之前必须调用此方法。</p>\n<p>参数<br>config <code>Config</code> 新的config参数</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"getDefaultConfig\"><a href=\"#getDefaultConfig\" class=\"headerlink\" title=\"getDefaultConfig()\"></a>getDefaultConfig()</h2><p>定义<br>static Config getDefaultConfig()</p>\n<p>说明<br>获取Wilddog的默认配置对象。</p>\n<p>返回值</p>\n<!-- Js通过方法前面的两个“#”抽取目录，为识别注释多加一个“#”\n### getApp()\n\n定义\nWilddogApp getApp()\n\n说明 \n获取与引用关联的WilddogApp实例\n\n返回值\n对应于引用的WilddogApp对象\n-->\n<hr>\n<h2 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义<br>Wilddog child(String path)</p>\n<p>说明<br>根据相对路径，来获取当前节点下子节点的引用。</p>\n<p>参数<br>path <code>String</code> path 为相对路径，多层级间需要使用”/“分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。</p>\n<p>返回值<br><code>Wilddog</code> 子节点引用。</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定位到 '/test/a'</span></div><div class=\"line\">Wilddog ref2 = ref.child(<span class=\"string\">\"a\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定位到 '/test/a/b'</span></div><div class=\"line\">Wilddog ref3 = ref.child(<span class=\"string\">\"a/b\"</span>);</div><div class=\"line\">Wilddog ref4 = ref.child(<span class=\"string\">\"a\"</span>).child(<span class=\"string\">\"b\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2><p>定义<br>Wilddog push()</p>\n<p>说明<br>在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。</p>\n<p>返回值<br><code>Wilddog</code> 新生成子节点的引用对象。</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加一个数值，将生成一个新ID，操作结果为&#123;\"-JmpzI81egafHZo5\":100&#125;， 返回的path为“/test/a/b/-JmpzI81egafHZo5”</span></div><div class=\"line\">Wilddog  newRef = ref.child(<span class=\"string\">\"a/b\"</span>).push();</div><div class=\"line\">newRef.setValue(<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加一个实体</span></div><div class=\"line\">DOTAHero hero = <span class=\"keyword\">new</span> DOTAHero();</div><div class=\"line\">hero.setName(<span class=\"string\">\"Nevermore\"</span>);</div><div class=\"line\">hero.setHp(<span class=\"number\">435</span>);</div><div class=\"line\">hero.setMp(<span class=\"number\">234</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"heros\"</span>).push().setValue(hero);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setValue-Object\"><a href=\"#setValue-Object\" class=\"headerlink\" title=\"setValue(Object)\"></a>setValue(Object)</h2><p>定义<br>void setValue(Object value)</p>\n<p>说明<br>给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数<br>value <code>Object</code><br>value的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。<br>当value为String、Number、Boolean时，等价于当前节点的<code>updateChildren()</code>操作。<br>当value为null时，等价于当前节点的<code>removeValue()</code>操作。<br>当value为Map或JavaBean时，将value转为一颗子树替换当前value。</p>\n<p>返回值<br>void</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 update(100);</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 remove();</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置子树</span></div><div class=\"line\">Map&lt;String, String&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(children);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 自定义Entity</span></div><div class=\"line\">DOTAHero hero = <span class=\"keyword\">new</span> DOTAHero();</div><div class=\"line\">hero.setName(<span class=\"string\">\"Nevermore\"</span>);</div><div class=\"line\">hero.setHp(<span class=\"number\">435</span>);</div><div class=\"line\">hero.setMp(<span class=\"number\">234</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"dota/heros/SF\"</span>).setValue(hero);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"setValue-Object-CompletionListener\"><a href=\"#setValue-Object-CompletionListener\" class=\"headerlink\" title=\"setValue(Object, CompletionListener)\"></a>setValue(Object, CompletionListener)</h2><p>定义<br>void setValue(Object value, Wilddog.CompletionListener listener)</p>\n<p>说明<br>给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数<br>value <code>Object</code> value的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。<br>当value为String、Number、Boolean时，等价于Path对应的Node的<code>updateChildren()</code>操作。<br>当value为null时，等价于Path对应的Node的<code>removeValue()</code>操作。<br>当value为Map或JavaBean时，将value转为一颗子树替换当前value。</p>\n<p>listener <code>CompletionListener</code> listener包含一个callback函数，用户可以实现<code>onComplete</code>函数，如果某个callback函数没有响应的处理，接口实现为<code>{}</code>函数即可。<code>setValue(value)</code>等价于<code>setValue(value, null)</code>。</p>\n<p>返回值<br>void</p>\n<p>示例<br>自定义CompletionListener<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Wilddog</span>.<span class=\"title\">CompletionListener</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">              System.out.println(error.getCode());</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">CompletionListener listener = <span class=\"keyword\">new</span> MyHandler();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 update(100);</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"number\">100</span>, listener);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 remove();</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"keyword\">null</span>, listener);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置子树</span></div><div class=\"line\">Map&lt;String, String&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(children, listener);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 自定义Entity</span></div><div class=\"line\">DOTAHero hero = <span class=\"keyword\">new</span> DOTAHero();</div><div class=\"line\">hero.setName(<span class=\"string\">\"Nevermore\"</span>);</div><div class=\"line\">hero.setHp(<span class=\"number\">435</span>);</div><div class=\"line\">hero.setMp(<span class=\"number\">234</span>);</div><div class=\"line\"></div><div class=\"line\">ref.child(<span class=\"string\">\"dota/heros/SF\"</span>).setValue(hero, <span class=\"keyword\">new</span> Wilddog.CompletionListener() &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"Good!\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setPriority\"><a href=\"#setPriority\" class=\"headerlink\" title=\"setPriority()\"></a>setPriority()</h2><p>定义<br>void setPriority(Object)</p>\n<p>说明<br>设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。<br>你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。</p>\n<p>节点按照如下规则排序：</p>\n<ul>\n<li>没有priority的排最先。</li>\n<li>有数字priority的次之，按照数值排序。</li>\n<li>有字符串 priority的排最后，按照字母表的顺序排列。</li>\n<li>当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。<br><br><br><br><br>注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。</li>\n</ul>\n<p>参数<br>priority <code>Object</code> 指定节点的优先级。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setPriority-Object-CompletionListener\"><a href=\"#setPriority-Object-CompletionListener\" class=\"headerlink\" title=\"setPriority(Object, CompletionListener)\"></a>setPriority(Object, CompletionListener)</h2><p>定义<br>void setPriority(Object, Wilddog.CompletionListener)</p>\n<p>说明<br>设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。<br>你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。</p>\n<p>节点按照如下规则排序：</p>\n<ul>\n<li>没有priority的排最先。</li>\n<li>有数字priority的次之，按照数值排序。</li>\n<li>有字符串 priority的排最后，按照字母表的顺序排列。</li>\n<li>当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。<br><br><br><br><br>注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。</li>\n</ul>\n<p>参数</p>\n<ul>\n<li>priority <code>Object</code> 指定节点的优先级。</li>\n<li>listener <code>CompletionListener</code>。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren()\"></a>updateChildren()</h2><p>定义<br>void updateChildren(Map value)</p>\n<p>说明<br>对子节点进行合并操作。不存在的子节点将会被新增，存在子节点将会被替换。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数<br>value <code>Map&lt;String, Object&gt;</code> 当value为null时，等价于<code>removeValue()</code>操作。</p>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 更新子树</span></div><div class=\"line\">Map&lt;String, String&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).updateChildren(children);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"updateChildren-Map-CompletionListener\"><a href=\"#updateChildren-Map-CompletionListener\" class=\"headerlink\" title=\"updateChildren(Map, CompletionListener)\"></a>updateChildren(Map, CompletionListener)</h2><p>定义<br>void updateChildren(Map children, Wilddog.CompletionListener listener)</p>\n<p>说明<br>对子节点进行更新操作。不存在的子节点将会被新增，存在子节点将会被替换。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Map&lt;String, Object&gt;</code> 当value为null时，等价于<code>removeValue()</code>操作。</li>\n<li>listener <code>CompletionListener</code> listener包含一个回调函数<code>onComplete</code>，如果执行完成，<code>onComplete</code>函数将会被调用。</li>\n</ul>\n<p>返回值<br>void</p>\n<p>示例<br>自定义CompletionListener<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Wilddog</span>.<span class=\"title\">CompletionListener</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">CompletionListener handler = <span class=\"keyword\">new</span> MyHandler();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 更新子树</span></div><div class=\"line\">Map&lt;String, Object&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).updateChildren(children, handler);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"removeValue\"><a href=\"#removeValue\" class=\"headerlink\" title=\"removeValue()\"></a>removeValue()</h2><p>定义<br>void removeValue()</p>\n<p>说明<br>删除当前节点。 删除成功后将触发Change，ChildRemoved事件。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).removeValue();</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"removeValue-CompletionListener\"><a href=\"#removeValue-CompletionListener\" class=\"headerlink\" title=\"removeValue(CompletionListener)\"></a>removeValue(CompletionListener)</h2><p>定义<br>void removeValue(CompletionListener listener)</p>\n<p>说明<br>删除当前节点。 删除成功后将触发Change，ChildRemoved事件。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数</p>\n<ul>\n<li>listener <code>CompletionListener</code><br>listener包含一个回调函数<code>onComplete</code>，如果执行完成，<code>onComplete</code>函数将会被调用。</li>\n</ul>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">ResultHandler handler = <span class=\"keyword\">new</span> MyHandler();</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).removeValue(handler);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"runTransaction-Transaction-Handler\"><a href=\"#runTransaction-Transaction-Handler\" class=\"headerlink\" title=\"runTransaction(Transaction.Handler)\"></a>runTransaction(Transaction.Handler)</h2><p>定义<br>void runTransaction(Transaction.Handler handler)</p>\n<p>说明<br>在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，runTransaction() 能够确保不同客户端同时修改，没有冲突。</p>\n<p>参数</p>\n<ul>\n<li>handler <code>Transaction.Handler</code> </li>\n</ul>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog upvotesRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/android/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>);</div><div class=\"line\"></div><div class=\"line\">upvotesRef.runTransaction(<span class=\"keyword\">new</span> Transaction.Handler() &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> Transaction.<span class=\"function\">Result <span class=\"title\">doTransaction</span><span class=\"params\">(MutableData currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(currentData.getValue() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            currentData.setValue(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            currentData.setValue((Long) currentData.getValue() + <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> Transaction.success(currentData); <span class=\"comment\">// 我们可以调用 Transaction.abort() 中止事务</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError wilddogError, <span class=\"keyword\">boolean</span> committed, DataSnapshot currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 事务完成后调用一次，获取事务完成的结果</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"onDisconnect\"><a href=\"#onDisconnect\" class=\"headerlink\" title=\"onDisconnect()\"></a>onDisconnect()</h2><p>定义<br>OnDisconnect onDisconnect()</p>\n<p>说明<br>当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。</p>\n<p>返回值<br>当前节点执行断开连接操作的对象。</p>\n<hr>\n<h2 id=\"goOffline\"><a href=\"#goOffline\" class=\"headerlink\" title=\"goOffline()\"></a>goOffline()</h2><p>定义<br>static void goOffline()</p>\n<p>说明<br>手动关闭连接，关闭自动连接。<br>注意：调用此方法会影响到所有Wilddog连接。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"goOnline\"><a href=\"#goOnline\" class=\"headerlink\" title=\"goOnline()\"></a>goOnline()</h2><p>定义<br>static void goOnline()</p>\n<p>说明<br>手动建立连接，开启自动重连。<br>注意：调用此方法会影响到所有Wilddog连接。<br>返回值<br>void</p>\n<hr>\n<h2 id=\"getKey\"><a href=\"#getKey\" class=\"headerlink\" title=\"getKey()\"></a>getKey()</h2><p>定义<br>String getKey()</p>\n<p>说明<br>获取当前节点的名称。</p>\n<p>返回值<br><code>String</code> 节点名称。 </p>\n<hr>\n<h2 id=\"getParent\"><a href=\"#getParent\" class=\"headerlink\" title=\"getParent()\"></a>getParent()</h2><p>定义<br>Wilddog getParent()</p>\n<p>说明<br>获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。</p>\n<p>返回值<br><code>Wilddog</code> 父节点的引用。</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test/a\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获得'/test' 路径的引用</span></div><div class=\"line\">Wilddog ref2 = ref.getParent();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 到达root</span></div><div class=\"line\">Wilddog ref3 = ref.getParent().getParent();</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"getRoot\"><a href=\"#getRoot\" class=\"headerlink\" title=\"getRoot()\"></a>getRoot()</h2><p>定义<br>Wilddog getRoot()</p>\n<p>说明<br>获取根节点的引用。<br>返回值<br>根节点的引用。</p>\n<hr>\n<h2 id=\"getSdkVersion\"><a href=\"#getSdkVersion\" class=\"headerlink\" title=\"getSdkVersion()\"></a>getSdkVersion()</h2><p>定义<br>static String getSdkVersion()</p>\n<p>说明<br>获取SDK版本。</p>\n<p>返回值<br>SDK版本。</p>\n<hr>\n<h1 id=\"Wilddog-CompletionListener-Methods\"><a href=\"#Wilddog-CompletionListener-Methods\" class=\"headerlink\" title=\"Wilddog.CompletionListener (Methods)\"></a>Wilddog.CompletionListener (<em>Methods</em>)</h1><h2 id=\"onComplete\"><a href=\"#onComplete\" class=\"headerlink\" title=\"onComplete()\"></a>onComplete()</h2><p>定义<br>void onComplete(WilddogError error,<br>                Wilddog ref)</p>\n<p>说明<br>当操作成功或者失败的时候触发这个方法。如果操作失败，会给出一个error,如果操作成功，error为null。<br>参数</p>\n<ul>\n<li>error <code>WilddogError</code> 错误描述。</li>\n<li>ref <code>Wilddog</code> 到指定Wilddog节点的引用。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Wilddog-AuthStateListener-Methods\"><a href=\"#Wilddog-AuthStateListener-Methods\" class=\"headerlink\" title=\"Wilddog.AuthStateListener (Methods)\"></a>Wilddog.AuthStateListener (<em>Methods</em>)</h1><h2 id=\"onAuthStateChanged\"><a href=\"#onAuthStateChanged\" class=\"headerlink\" title=\"onAuthStateChanged()\"></a>onAuthStateChanged()</h2><p>定义<br>void onAuthStateChanged(AuthData authData)</p>\n<p>说明<br>当登录认证状态发生改变的时候，此方法将被调用。authData包含当前登录认证的信息，如果当前的连接没有登录认证，authData为null。</p>\n<p>参数<br>authData <code>AuthData</code> 当前登录认证的信息，未登录认证时为null。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Wilddog-AuthResultHandler-Methods\"><a href=\"#Wilddog-AuthResultHandler-Methods\" class=\"headerlink\" title=\"Wilddog.AuthResultHandler (Methods)\"></a>Wilddog.AuthResultHandler (<em>Methods</em>)</h1><h2 id=\"onAuthenticated\"><a href=\"#onAuthenticated\" class=\"headerlink\" title=\"onAuthenticated()\"></a>onAuthenticated()</h2><p>定义<br>void onAuthenticated(AuthData authData)</p>\n<p>说明<br>当登录认证成功时这个方法被调用。</p>\n<p>参数<br>authData <code>AuthData</code> 当前用户或者Token的信息。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onAuthenticationError\"><a href=\"#onAuthenticationError\" class=\"headerlink\" title=\"onAuthenticationError()\"></a>onAuthenticationError()</h2><p>定义<br>void onAuthenticationError(WilddogError error)</p>\n<p>说明<br>当登录认证失败时这个方法被调用。</p>\n<p>参数<br>error <code>WilddogError</code> 登录认证失败的原因和附加的详细信息。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Wilddog-ResultHandler-Methods\"><a href=\"#Wilddog-ResultHandler-Methods\" class=\"headerlink\" title=\"Wilddog.ResultHandler (Methods)\"></a>Wilddog.ResultHandler (<em>Methods</em>)</h1><h2 id=\"onError\"><a href=\"#onError\" class=\"headerlink\" title=\"onError()\"></a>onError()</h2><p>定义<br>void onError(WilddogError error)</p>\n<p>说明<br>如果操作失败此方法被调用。</p>\n<p>参数<br>error <code>WilddogError</code> 包含失败原因和附加的详情。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onSuccess\"><a href=\"#onSuccess\" class=\"headerlink\" title=\"onSuccess()\"></a>onSuccess()</h2><p>定义<br>void onSuccess()</p>\n<p>说明<br>如果操作成功此方法被调用。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"ChildEventListener-Methods\"><a href=\"#ChildEventListener-Methods\" class=\"headerlink\" title=\"ChildEventListener (Methods)\"></a>ChildEventListener (<em>Methods</em>)</h1><h2 id=\"onCancelled\"><a href=\"#onCancelled\" class=\"headerlink\" title=\"onCancelled()\"></a>onCancelled()</h2><p>定义<br>void onCancelled(WilddogError error)</p>\n<p>说明<br>当listener在服务端失败，或者被删除的时候调用该方法。</p>\n<p>参数<br>error <code>WilddogError</code> 发生错误的描述。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildAdded\"><a href=\"#onChildAdded\" class=\"headerlink\" title=\"onChildAdded()\"></a>onChildAdded()</h2><p>定义<br>void onChildAdded(DataSnapshot snapshot,<br>                  String previousChildName)</p>\n<p>说明<br>一个添加了listener的节点，当有子节点被添加时触发此方法。</p>\n<p>参数</p>\n<ul>\n<li>snapshot <code>DataSnapshot</code> 新添加的子节点数据快照。</li>\n<li>previousChildName <code>String</code> 排在被添加的新子节点前面的兄弟节点的key值。如果被添加的是当前节点的第一个子节点，该值为null。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildChanged\"><a href=\"#onChildChanged\" class=\"headerlink\" title=\"onChildChanged()\"></a>onChildChanged()</h2><p>定义<br>void onChildChanged(DataSnapshot snapshot,<br>                    String previousChildName)</p>\n<p>说明<br>当前节点的子节点发生改变的时候触发此方法。</p>\n<p>参数</p>\n<ul>\n<li>snapshot <code>DataSnapshot</code> 新子节点数据的快照。</li>\n<li>previousChildName <code>String</code> 排在被修改的新子节点前面的兄弟节点的key值。如果改变的是当前节点的第一个子节点，该值为null。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildMoved\"><a href=\"#onChildMoved\" class=\"headerlink\" title=\"onChildMoved()\"></a>onChildMoved()</h2><p>定义<br>void onChildMoved(DataSnapshot snapshot,<br>                  String previousChildName)</p>\n<p>说明<br>当一个子节点的优先级发生变化时，该方法将被调用。参考Wilddog.setPriority(Object)和数据排序了解更多关于优先级和数据排序的信息。</p>\n<p>参数</p>\n<ul>\n<li><code>DataSnapshot</code> 节点排序发生变化时的数据快照。</li>\n<li><code>String</code> 排在当前子节点前面的兄弟子节点的key名称，如果当前节点位置最先，此值为null。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildRemoved\"><a href=\"#onChildRemoved\" class=\"headerlink\" title=\"onChildRemoved()\"></a>onChildRemoved()</h2><p>定义<br>void onChildRemoved(DataSnapshot snapshot)</p>\n<p>说明<br>当一个添加了listener的节点有子节点被删除的时候触发这个方法。</p>\n<p>参数<br>snapshot <code>DataSnapshot</code> 被删除子节点的数据快照。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"ValueEventListener-Methods\"><a href=\"#ValueEventListener-Methods\" class=\"headerlink\" title=\"ValueEventListener (Methods)\"></a>ValueEventListener (<em>Methods</em>)</h1><h2 id=\"onCancelled-1\"><a href=\"#onCancelled-1\" class=\"headerlink\" title=\"onCancelled()\"></a>onCancelled()</h2><p>定义<br>void onCancelled(WilddogError error)</p>\n<p>说明<br>当listener在服务端失败，或者被删除的时候调用该方法。</p>\n<p>参数<br>error <code>DataSnapshot</code> 发生错误的描述。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onDataChange\"><a href=\"#onDataChange\" class=\"headerlink\" title=\"onDataChange()\"></a>onDataChange()</h2><p>定义<br>void onDataChange(DataSnapshot snapshot)</p>\n<p>说明<br>一个添加了 listener 的节点，当有节点改变时触发此方法。<br>参数<br>snapshot <code>DataSnapshot</code> 新添加的子节点的数据快照</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Query-Methods\"><a href=\"#Query-Methods\" class=\"headerlink\" title=\"Query (Methods)\"></a>Query (<em>Methods</em>)</h1><h2 id=\"addValueEventListener\"><a href=\"#addValueEventListener\" class=\"headerlink\" title=\"addValueEventListener()\"></a>addValueEventListener()</h2><p>定义<br>void addValueEventListener(ValueEventListener listener)</p>\n<p>说明<br>为当前节点绑定监听事件，监听该节点数据的变化。用户需要实现ValueEventListener接口。</p>\n<p>参数<br>listener <code>ValueEventListener</code> listener将监听Change事件。</p>\n<p>返回值<br><code>ValueEventListener</code> 返回监听事件的引用，可用于删除此事件。</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\">ValueEventListener listener = ref.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener()&#123;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">          System.out.println(snapshot.getValue());</div><div class=\"line\">          <span class=\"comment\">// DataSnapshot to json string</span></div><div class=\"line\">          <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          JSONObject json = <span class=\"keyword\">new</span> JSONObject();</div><div class=\"line\">          json.put(dataSnapshot.getKey(), <span class=\"keyword\">new</span> JSONObject(dataSnapshot.getValue()));</div><div class=\"line\">          System.out.println(json.toString());</div><div class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">          e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">               System.out.println(error.getCode());</div><div class=\"line\">          &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"addChildEventListener\"><a href=\"#addChildEventListener\" class=\"headerlink\" title=\"addChildEventListener()\"></a>addChildEventListener()</h2><p>定义<br>void addChildEventListener(ChildEventListener listener)</p>\n<p>说明<br>为子节点绑定监听事件，监听该子节点数据的变化。用户需要实现ValueEventListener接口。</p>\n<p>参数</p>\n<ul>\n<li>listener <code>ChildEventListener</code><br><code>onChildAdded()</code> 监听子节点的添加事件。<br><code>onChildRemoved()</code> 监听子节点的删除事件。<br><code>onChildChanged()</code> 监听子节点的变化事件。</li>\n</ul>\n<p>返回值<br><code>ChildEventListener</code> 返回监听事件的引用，可用于删除此事件。</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\">ChildEventListener listener = ref.addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String s)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">        <span class=\"comment\">// DataSnapshot to json string</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          JSONObject json = <span class=\"keyword\">new</span> JSONObject();</div><div class=\"line\">          json.put(dataSnapshot.getKey(), <span class=\"keyword\">new</span> JSONObject(dataSnapshot.getValue()));</div><div class=\"line\">          System.out.println(json.toString());</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">          e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot snapshot, String s)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot snapshot, String s)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"addListenerForSingleValueEvent\"><a href=\"#addListenerForSingleValueEvent\" class=\"headerlink\" title=\"addListenerForSingleValueEvent()\"></a>addListenerForSingleValueEvent()</h2><p>定义<br>void addListenerForSingleValueEvent(ValueEventListener listener)</p>\n<p>说明<br>为当前节点单次数据获取绑定监听事件，此监听器只被触发一次，以获取当前节点下的所有数据。</p>\n<p>参数<br>listener <code>ValueEventListener</code> 节点绑定的监听事件。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"removeEventListener-ValueEventListener\"><a href=\"#removeEventListener-ValueEventListener\" class=\"headerlink\" title=\"removeEventListener(ValueEventListener)\"></a>removeEventListener(ValueEventListener)</h2><p>定义<br>void removeEventListener(ValueEventListener listener)</p>\n<p>说明<br>删除已绑定的监听事件。</p>\n<p>参数<br>listener <code>ValueEventListener</code> 要删除的监听事件。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"removeEventListener-ChildEventListener\"><a href=\"#removeEventListener-ChildEventListener\" class=\"headerlink\" title=\"removeEventListener(ChildEventListener)\"></a>removeEventListener(ChildEventListener)</h2><p>定义<br>void removeEventListener(ChildEventListener listener)</p>\n<p>说明<br>删除已绑定的监听事件。</p>\n<p>参数<br>listener <code>ChildEventListener</code> 要删除的监听事件。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"orderByChild\"><a href=\"#orderByChild\" class=\"headerlink\" title=\"orderByChild()\"></a>orderByChild()</h2><p>定义<br>Query orderByChild(String childKey)</p>\n<p>说明<br>使用指定的子节点的值进行排序。</p>\n<p>参数<br>childKey <code>String</code> 子节点属性。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"orderByKey\"><a href=\"#orderByKey\" class=\"headerlink\" title=\"orderByKey()\"></a>orderByKey()</h2><p>定义<br>Query orderByKey()</p>\n<p>说明<br>使用子节点的key进行排序。</p>\n<p>返回值<br>Query 查询器类</p>\n<hr>\n<h2 id=\"orderByValue\"><a href=\"#orderByValue\" class=\"headerlink\" title=\"orderByValue()\"></a>orderByValue()</h2><p>定义<br>Query orderByValue()</p>\n<p>说明<br>使用子节点的值进行排序。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"orderByPriority\"><a href=\"#orderByPriority\" class=\"headerlink\" title=\"orderByPriority()\"></a>orderByPriority()</h2><p>定义<br>Query orderByPriority()</p>\n<p>说明<br>根据子节点的优先级进行排序。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"startAt\"><a href=\"#startAt\" class=\"headerlink\" title=\"startAt()\"></a>startAt()</h2><p>定义<br>Object startAt(String value), Object startAt(double value), Object startAt(boolean value)</p>\n<p>说明<br>创建一个大于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object startAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。</p>\n<p>参数<br>value <code>String</code> <code>double</code> <code>boolean</code>。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"endAt\"><a href=\"#endAt\" class=\"headerlink\" title=\"endAt()\"></a>endAt()</h2><p>定义<br>Object endAt(String value)，Object endAt(double value)，Object endAt(boolean value)</p>\n<p>说明<br>创建一个小于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object endAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。</p>\n<p>参数<br>value <code>String</code> <code>double</code> <code>boolean</code>。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"equalTo\"><a href=\"#equalTo\" class=\"headerlink\" title=\"equalTo()\"></a>equalTo()</h2><p>定义<br>Object equalTo(String value)，Object equalTo(double value)，Object equalTo(boolean value)</p>\n<p>说明<br>创建一个等于的精确查询。</p>\n<p>参数<br>value <code>String</code> <code>double</code> <code>boolean</code>。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"limitToFirst\"><a href=\"#limitToFirst\" class=\"headerlink\" title=\"limitToFirst()\"></a>limitToFirst()</h2><p>定义<br>Query limitToFirst(int count)</p>\n<p>说明<br>创建一个limit查询。从第一条开始获取指定数量的数据。</p>\n<p>参数<br>count <code>int</code> 数量。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"limitToLast\"><a href=\"#limitToLast\" class=\"headerlink\" title=\"limitToLast()\"></a>limitToLast()</h2><p>定义<br>Query limitToLast(int count)</p>\n<p>说明<br>创建一个limit查询。从最后一条开始获取指定数量的数据。</p>\n<p>参数<br>count <code>int</code> 数量。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"getRef\"><a href=\"#getRef\" class=\"headerlink\" title=\"getRef()\"></a>getRef()</h2><p>定义<br>Wilddog getRef()</p>\n<p>说明<br>获得当前的引用。</p>\n<p>返回值<br><code>Wilddog</code> 节点引用。</p>\n<hr>\n<h1 id=\"DataSnapshot-Methods\"><a href=\"#DataSnapshot-Methods\" class=\"headerlink\" title=\"DataSnapshot (Methods)\"></a>DataSnapshot (<em>Methods</em>)</h1><h2 id=\"child-1\"><a href=\"#child-1\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义<br>Wilddog child(String node)</p>\n<p>说明<br>根据相对路径，来获取当前节点下子节点的快照。</p>\n<p>参数<br>node <code>String</code>  子节点名称。</p>\n<p>返回值<br><code>Snapshot</code> </p>\n<hr>\n<h2 id=\"exists\"><a href=\"#exists\" class=\"headerlink\" title=\"exists()\"></a>exists()</h2><p>定义<br>boolean exists()</p>\n<p>说明<br>在快照中，判断当前节点是否包含数据。相当于<code>snapshot.getValue()!=null</code> 。</p>\n<p>返回值<br><code>boolean</code> </p>\n<hr>\n<h2 id=\"getChildren\"><a href=\"#getChildren\" class=\"headerlink\" title=\"getChildren()\"></a>getChildren()</h2><p>定义<br>Iterable<datasnapshot> getChildren()</datasnapshot></p>\n<p>说明<br>获取当前快照中，所有子节点的迭代器。</p>\n<p>返回值<br><code>Iterable&lt;DataSnapshot&gt;</code> 子节点的迭代器。 </p>\n<hr>\n<h2 id=\"getChildrenCount\"><a href=\"#getChildrenCount\" class=\"headerlink\" title=\"getChildrenCount()\"></a>getChildrenCount()</h2><p>定义<br>long getChildrenCount()</p>\n<p>说明<br>获得子节点的总数。</p>\n<p>返回值<br><code>long</code> 子节点总数 。</p>\n<hr>\n<h2 id=\"getKey-1\"><a href=\"#getKey-1\" class=\"headerlink\" title=\"getKey()\"></a>getKey()</h2><p>定义<br>String getKey()</p>\n<p>说明<br>从快照中，获取当前节点的名称。</p>\n<p>返回值<br><code>String</code> 节点名称 。</p>\n<hr>\n<h2 id=\"getPriority\"><a href=\"#getPriority\" class=\"headerlink\" title=\"getPriority()\"></a>getPriority()</h2><p>定义<br>Object getPriority()</p>\n<p>说明<br>获取当前节点的优先级。</p>\n<p>返回值<br><code>Object</code>   <code>Stirng</code> , <code>Double</code> , <code>Null</code>。</p>\n<hr>\n<h2 id=\"getRef-1\"><a href=\"#getRef-1\" class=\"headerlink\" title=\"getRef()\"></a>getRef()</h2><p>定义<br>Wilddog getRef()。</p>\n<p>说明<br>从快照中，获得当前节点的引用。</p>\n<p>返回值<br><code>Wilddog</code> 节点引用。</p>\n<hr>\n<h2 id=\"getValue\"><a href=\"#getValue\" class=\"headerlink\" title=\"getValue()\"></a>getValue()</h2><p>定义<br>Object getValue()</p>\n<p>说明<br>从快照中获得当前节点的数据。</p>\n<p>返回值<br><code>Object</code> 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 <code>Map&lt;String, Object&gt;</code>。</p>\n<hr>\n<h2 id=\"hasChild\"><a href=\"#hasChild\" class=\"headerlink\" title=\"hasChild()\"></a>hasChild()</h2><p>定义<br>boolean hasChild(String key)</p>\n<p>说明<br>判断在当前快照中，是否包含指定子节点。</p>\n<p>参数</p>\n<ul>\n<li>key <code>String</code> 子节点名称。</li>\n</ul>\n<p>返回值<br><code>boolean</code> true为包含，false为不包含。</p>\n<hr>\n<h2 id=\"hasChildren\"><a href=\"#hasChildren\" class=\"headerlink\" title=\"hasChildren()\"></a>hasChildren()</h2><p>定义<br>boolean hasChildren()</p>\n<p>说明<br>判断在当前快照中，是否存在子节点。</p>\n<p>返回值<br><code>boolean</code> true为存在子节点，false为不存在。</p>\n<!--\n\n!#MutableData (*Methods*)\n\n\n!## child()\n\n!定义\nMutableData child(String node)\n\n!说明\n根据相对路径，来获取当前节点下子节点的快照。\n\n!参数\n* node `String` 子节点名称。\n\n!返回值\n`MutableData`\n\n\n!## getChildren()\n\n!定义\nIterator<MutableData> getChildren()\n\n!说明\n用于对当前节点的即时子节点进行迭代。\n!返回值\n当前节点的即时子节点。\n\n\n!## getChildrenCount()\n\n!定义\nlong getChildrenCount()\n\n!说明\n获得子节点的总数。\n\n!返回值\n`long` 子节点总数 。\n\n\n!## getKey()\n\n!定义\nString getKey()\n\n!说明\n获取当前节点的名称。\n\n!返回值\n`String` 节点名称 。\n\n\n!## getParent()\n\n!定义\nMutableData getParent()\n\n!说明 \n获取一个节点的父节点数据，如果本身就是最顶端的节点，返回null。\n!返回值\nMutableData\n\n\n!## getPriority()\n\n!定义\nObject getPriority()\n\n!说明 \n获得当前节点的优先级。\n!返回值\n`Object`   `Stirng` , `Double` , `Null`。\n\n!## getValue()\n\n!定义\nObject getValue()\n\n!说明\n获得当前节点的数据。\n\n!返回值\n`Object` 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 `Map<String, Object>`。\n\n\n!## hasChild()\n\n!定义\nboolean hasChild(String key)\n\n!说明\n判断是否包含指定子节点。\n\n!参数\n* key `String` 子节点名称。\n\n!返回值\n`boolean` true为包含，false为不包含。\n\n\n!## hasChildren()\n\n!定义\nboolean hasChildren()\n\n!说明\n判断在当前快照中，是否存在子节点。\n\n!返回值\n`boolean` true为存在子节点，false为不存在。\n\n\n!## setPriority(Object)\n\n!定义\nvoid setPriority(Object)\n\n!说明 \n设置当前节点的优先级。\n\n!参数\n* priority `Object`。\n\n!返回值\nvoid\n\n\n!## setValue()\n\n!定义\nvoid setValue(Object value)\n\n!说明 \n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n!参数\n* value `Object`。\n\n!返回值\nvoid\n-->\n<hr>\n<h1 id=\"AuthData-Methods\"><a href=\"#AuthData-Methods\" class=\"headerlink\" title=\"AuthData (Methods)\"></a>AuthData (<em>Methods</em>)</h1><h2 id=\"getAuth\"><a href=\"#getAuth\" class=\"headerlink\" title=\"getAuth()\"></a>getAuth()</h2><p>定义<br>Map getAuth()</p>\n<p>说明<br>同步返回Token Auth状态,如果使用secret登录，返回null。</p>\n<p>返回值<br>返回Token Auth状态,如果使用secret登录，返回null。</p>\n<hr>\n<h2 id=\"getExpires\"><a href=\"#getExpires\" class=\"headerlink\" title=\"getExpires()\"></a>getExpires()</h2><p>定义<br>long getExpires()</p>\n<p>说明<br>取得token的过期时间。</p>\n<p>返回值<br>token的过期时间。</p>\n<hr>\n<h2 id=\"getProvider\"><a href=\"#getProvider\" class=\"headerlink\" title=\"getProvider()\"></a>getProvider()</h2><p>定义<br>String getProvider()</p>\n<p>说明<br>获取第三方平台认证的支持方式，如果没有，返回null。</p>\n<p>返回值<br>返回第三方OAuth平台或者null。</p>\n<hr>\n<h2 id=\"getProviderData\"><a href=\"#getProviderData\" class=\"headerlink\" title=\"getProviderData()\"></a>getProviderData()</h2><p>定义<br>Map<string,object> getProviderData()</string,object></p>\n<p>说明<br>获取认证服务器返回的第三方平台数据。内容取决于支持方式，参考文档获取更多信息。<br>返回值<br>一个包含第三方OAuth平台信息的Map。</p>\n<hr>\n<h2 id=\"getToken\"><a href=\"#getToken\" class=\"headerlink\" title=\"getToken()\"></a>getToken()</h2><p>定义<br>String getToken()</p>\n<p>说明<br>获取登录认证的Token,如果是通过secret登录，得到null。<br>返回值<br>登录认证的Token,如果是通过secret登录，返回null。</p>\n<hr>\n<h2 id=\"getUid\"><a href=\"#getUid\" class=\"headerlink\" title=\"getUid()\"></a>getUid()</h2><p>定义<br>String getUid()</p>\n<p>说明<br>获取登录用户的uid，如果是以secret登录或者用没有uid的Token登录，返回null。<br>返回值<br>uid或者null。</p>\n<hr>\n<h1 id=\"WilddogError-Constants\"><a href=\"#WilddogError-Constants\" class=\"headerlink\" title=\"WilddogError (Constants)\"></a>WilddogError (<em>Constants</em>)</h1><h2 id=\"AUTHENTICATION-PROVIDER-DISABLED\"><a href=\"#AUTHENTICATION-PROVIDER-DISABLED\" class=\"headerlink\" title=\"AUTHENTICATION_PROVIDER_DISABLED\"></a>AUTHENTICATION_PROVIDER_DISABLED</h2><p>说明<br>要求的第三方OAuth平台认证方式不被当前app支持。</p>\n<hr>\n<h2 id=\"DATA-STALE\"><a href=\"#DATA-STALE\" class=\"headerlink\" title=\"DATA_STALE\"></a>DATA_STALE</h2><p>说明<br>内部使用。</p>\n<hr>\n<h2 id=\"DENIED-BY-USER\"><a href=\"#DENIED-BY-USER\" class=\"headerlink\" title=\"DENIED_BY_USER\"></a>DENIED_BY_USER</h2><p>说明<br>用户不能登录认证应用。当用户取消OAuth认证请求时会造成这个错误。</p>\n<hr>\n<h2 id=\"DISCONNECTED\"><a href=\"#DISCONNECTED\" class=\"headerlink\" title=\"DISCONNECTED\"></a>DISCONNECTED</h2><p>说明<br>因为网络连接失败导致操作不能执行。</p>\n<hr>\n<h2 id=\"EMAIL-TAKEN\"><a href=\"#EMAIL-TAKEN\" class=\"headerlink\" title=\"EMAIL_TAKEN\"></a>EMAIL_TAKEN</h2><p>说明<br>由于指定的邮箱地址已经被使用而不能建立新用户。</p>\n<hr>\n<h2 id=\"EXPIRED-TOKEN\"><a href=\"#EXPIRED-TOKEN\" class=\"headerlink\" title=\"EXPIRED_TOKEN\"></a>EXPIRED_TOKEN</h2><p>说明<br>提供的auth Token已经过期。</p>\n<hr>\n<h2 id=\"INVALID-AUTH-ARGUMENTS\"><a href=\"#INVALID-AUTH-ARGUMENTS\" class=\"headerlink\" title=\"INVALID_AUTH_ARGUMENTS\"></a>INVALID_AUTH_ARGUMENTS</h2><p>说明<br>指定的凭证不符合标准或者不完整。请参考错误信息，错误详情和Wilddog文档获得支持方auth登录认证的正确参数。</p>\n<hr>\n<h2 id=\"INVALID-CONFIGURATION\"><a href=\"#INVALID-CONFIGURATION\" class=\"headerlink\" title=\"INVALID_CONFIGURATION\"></a>INVALID_CONFIGURATION</h2><p>说明<br>被申请的登录认证提供方式没有配置，请求无法完成。请完成应用配置。</p>\n<hr>\n<h2 id=\"INVALID-CREDENTIALS\"><a href=\"#INVALID-CREDENTIALS\" class=\"headerlink\" title=\"INVALID_CREDENTIALS\"></a>INVALID_CREDENTIALS</h2><p>说明<br>指定的登录认证凭证不可用。当凭证不符合标准或者过期时会引发这个错误。</p>\n<hr>\n<h2 id=\"INVALID-EMAIL\"><a href=\"#INVALID-EMAIL\" class=\"headerlink\" title=\"INVALID_EMAIL\"></a>INVALID_EMAIL</h2><p>说明<br> 指定的邮箱不可用。</p>\n<hr>\n<h2 id=\"INVALID-PASSWORD\"><a href=\"#INVALID-PASSWORD\" class=\"headerlink\" title=\"INVALID_PASSWORD\"></a>INVALID_PASSWORD</h2><p>说明<br>指定的用户帐号密码不正确。</p>\n<hr>\n<h2 id=\"INVALID-PROVIDER\"><a href=\"#INVALID-PROVIDER\" class=\"headerlink\" title=\"INVALID_PROVIDER\"></a>INVALID_PROVIDER</h2><p>说明<br>申请的第三方OAuth平台认证方式不存在。请参阅Wilddog认证的相关文档获得支持的方式列表。</p>\n<hr>\n<h2 id=\"INVALID-TOKEN\"><a href=\"#INVALID-TOKEN\" class=\"headerlink\" title=\"INVALID_TOKEN\"></a>INVALID_TOKEN</h2><p>说明<br>指定的登录认证Token不可用。如果token变形，过期或者用于生成token的secret已经被撤销，会引发此错误。</p>\n<hr>\n<h2 id=\"LIMITS-EXCEEDED\"><a href=\"#LIMITS-EXCEEDED\" class=\"headerlink\" title=\"LIMITS_EXCEEDED\"></a>LIMITS_EXCEEDED</h2><p>说明<br>超过限制，如果遇到此错误码，请联系support@Wilddog.com。</p>\n<hr>\n<h2 id=\"MAX-RETRIES\"><a href=\"#MAX-RETRIES\" class=\"headerlink\" title=\"MAX_RETRIES\"></a>MAX_RETRIES</h2><p>说明<br>事务有太多的重试。</p>\n<hr>\n<h2 id=\"NETWORK-ERROR\"><a href=\"#NETWORK-ERROR\" class=\"headerlink\" title=\"NETWORK_ERROR\"></a>NETWORK_ERROR</h2><p>说明<br>因为网络原因导致操作不能执行。</p>\n<hr>\n<h2 id=\"OPERATION-FAILED\"><a href=\"#OPERATION-FAILED\" class=\"headerlink\" title=\"OPERATION_FAILED\"></a>OPERATION_FAILED</h2><p>说明<br>服务器标示操作失败。</p>\n<hr>\n<h2 id=\"OVERRIDDEN-BY-SET\"><a href=\"#OVERRIDDEN-BY-SET\" class=\"headerlink\" title=\"OVERRIDDEN_BY_SET\"></a>OVERRIDDEN_BY_SET</h2><p>说明<br>事务被随后的集合覆盖。</p>\n<hr>\n<h2 id=\"PERMISSION-DENIED\"><a href=\"#PERMISSION-DENIED\" class=\"headerlink\" title=\"PERMISSION_DENIED\"></a>PERMISSION_DENIED</h2><p>说明<br>客户端不被许可执行此操作。</p>\n<hr>\n<h2 id=\"PREEMPTED\"><a href=\"#PREEMPTED\" class=\"headerlink\" title=\"PREEMPTED\"></a>PREEMPTED</h2><p>说明<br>活动的或者即将发生的auth登录认证被另一个auth登录取代。</p>\n<hr>\n<h2 id=\"PROVIDER-ERROR\"><a href=\"#PROVIDER-ERROR\" class=\"headerlink\" title=\"PROVIDER_ERROR\"></a>PROVIDER_ERROR</h2><p>说明<br>第三方OAuth平台错误。</p>\n<hr>\n<h2 id=\"UNKNOWN-ERROR\"><a href=\"#UNKNOWN-ERROR\" class=\"headerlink\" title=\"UNKNOWN_ERROR\"></a>UNKNOWN_ERROR</h2><p>说明<br>未知的错误。</p>\n<hr>\n<h2 id=\"USER-CODE-EXCEPTION\"><a href=\"#USER-CODE-EXCEPTION\" class=\"headerlink\" title=\"USER_CODE_EXCEPTION\"></a>USER_CODE_EXCEPTION</h2><p>说明<br>用户代码中发生的异常。</p>\n<hr>\n<h2 id=\"USER-DOES-NOT-EXIST\"><a href=\"#USER-DOES-NOT-EXIST\" class=\"headerlink\" title=\"USER_DOES_NOT_EXIST\"></a>USER_DOES_NOT_EXIST</h2><p>说明<br>指定的用户账户不存在。</p>\n<hr>\n<h1 id=\"WilddogError-Methods\"><a href=\"#WilddogError-Methods\" class=\"headerlink\" title=\"WilddogError (Methods)\"></a>WilddogError (<em>Methods</em>)</h1><h2 id=\"fromException\"><a href=\"#fromException\" class=\"headerlink\" title=\"fromException()\"></a>fromException()</h2><p>定义<br>WilddogException fromException(Throwable e)</p>\n<p>说明<br>新建一个WilddogException异常。</p>\n<p>返回值<br>WilddogException</p>\n<hr>\n<h2 id=\"fromStatus\"><a href=\"#fromStatus\" class=\"headerlink\" title=\"fromStatus()\"></a>fromStatus()</h2><p>定义<br>WilddogError fromStatus(String)</p>\n<p>说明<br>用WilddogError常量新建一个WilddogError实例。</p>\n<p>参数<br>status <code>WilddogError</code> The status string。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"getCode\"><a href=\"#getCode\" class=\"headerlink\" title=\"getCode()\"></a>getCode()</h2><p>定义<br>int getCode()</p>\n<p>说明<br>一个明确的状态码，取决于错误。<br>返回值<br>int。</p>\n<hr>\n<h2 id=\"getMessage\"><a href=\"#getMessage\" class=\"headerlink\" title=\"getMessage()\"></a>getMessage()</h2><p>定义<br>String getMessage()</p>\n<p>说明<br>获取错误原因。</p>\n<p>返回值<br>String</p>\n<hr>\n<h2 id=\"getDetails\"><a href=\"#getDetails\" class=\"headerlink\" title=\"getDetails()\"></a>getDetails()</h2><p>定义<br>String getDetails()</p>\n<p>说明<br>获取错误细节。</p>\n<p>返回值<br>错误的细节。</p>\n<hr>\n<h2 id=\"toException\"><a href=\"#toException\" class=\"headerlink\" title=\"toException()\"></a>toException()</h2><p>定义<br>WilddogExcepton toException()</p>\n<p>说明<br>如果第三方需要一个来自wilddog的异常，出于整合的目的可以使用此方法。</p>\n<p>返回值<br>一个封装了error的异常类，包含了适当的信息，没有栈信息。</p>\n<hr>\n<h1 id=\"Config-Methods\"><a href=\"#Config-Methods\" class=\"headerlink\" title=\"Config (Methods)\"></a>Config (<em>Methods</em>)</h1><h2 id=\"setLogger\"><a href=\"#setLogger\" class=\"headerlink\" title=\"setLogger()\"></a>setLogger()</h2><p>定义<br>void setLogger(Logger logger)</p>\n<p>说明<br>如果你想提供一个定制的日志，传递一个继承了Logger接口的对象。</p>\n<p>参数<br>logger <code>Logger</code> 定制的日志。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setEventTarget\"><a href=\"#setEventTarget\" class=\"headerlink\" title=\"setEventTarget()\"></a>setEventTarget()</h2><p>定义<br>void setEventTarget(EventTarget eventTarget)</p>\n<p>说明<br>在默认设置中，Wilddog库会创建一个线程来处理所有的回调。在安卓中，将试图采用main Looper。如果你想对如何触发回调有更多控制权，你可以提供一个对象，让他继承EventTarget，它将为每一个回调传递一个Runnable。</p>\n<p>参数<br>eventTarget <code>EventTarget</code>  负责触发回调的对象。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setLogLevel\"><a href=\"#setLogLevel\" class=\"headerlink\" title=\"setLogLevel()\"></a>setLogLevel()</h2><p>定义<br>void setLogLevel(Logger.Level logLevel)<br>说明<br>默认的，这会被设置为INFO。log等级包括内部错误（ERROR）和任何客户端接收到的安全性debug信息（INFO），设置为DEBUG将会打开诊断日志，设置为NONE禁止所有日志。</p>\n<p>参数<br>logLevel <code>Logger.Level</code> 所需最低的日志等级。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setDebugLogComponents\"><a href=\"#setDebugLogComponents\" class=\"headerlink\" title=\"setDebugLogComponents()\"></a>setDebugLogComponents()</h2><p>定义<br>void setDebugLogComponents(List<string> debugComponents)</string></p>\n<p>说明<br>主要用于debug调试.限制debug输出到指定组件。默认为null，允许所有组建的日志;  显式设置也会把等级设置为DEBUG。<br>参数<br>debugComponents <code>List&lt;String&gt;</code> 一系列日志需要的组件，或者设置为null使所有组件可行。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setAuthenticationServer\"><a href=\"#setAuthenticationServer\" class=\"headerlink\" title=\"setAuthenticationServer()\"></a>setAuthenticationServer()</h2><p>定义<br>void setAuthenticationServer(String host)</p>\n<p>说明<br>设置主机可以被用户登录认证。如果你不确定，不要使用此设置。<br>参数<br>host <code>String</code> 用于认证的server。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setSessionPersistenceKey\"><a href=\"#setSessionPersistenceKey\" class=\"headerlink\" title=\"setSessionPersistenceKey()\"></a>setSessionPersistenceKey()</h2><p>定义<br>void setSessionPersistenceKey(String sessionKey)</p>\n<p>说明<br>为Ｗilddog连接设置session的标识符，使用session标识符可以使多个认证会话在一个设备上共存。如果一个设备上只有一个用户没有必要使用此方法。</p>\n<p>参数<br>sessionKey <code>String</code> 用于标识session的标识符名称。</p>\n<p>返回值<br>void</p>\n","excerpt":"","more":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"setAndroidContext\"><a href=\"#setAndroidContext\" class=\"headerlink\" title=\"setAndroidContext()\"></a>setAndroidContext()</h2><p>定义</p>\n<p>static void setAndroidContext(android.content.Context context)</p>\n<p>说明 </p>\n<p>Wilddog在Android初始化需要配置Android Context， 且必须要在new Wilddog()之前配置。你可以在 <code>android.app.Application</code> 或者 <code>Activity</code>的<code>onCreate</code> 方法中设置 Android Context。</p>\n<p>参数</p>\n<p>context <code>android.content.Context</code>  在Android中使用Wilddog需要一个Android Context。</p>\n<p>返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"setDefaultConfig\"><a href=\"#setDefaultConfig\" class=\"headerlink\" title=\"setDefaultConfig()\"></a>setDefaultConfig()</h2><p>定义<br>static void setDefaultConfig(Config config)</p>\n<p>说明<br>Wilddog的默认配置对象，在调用new Wilddog之前必须调用此方法。</p>\n<p>参数<br>config <code>Config</code> 新的config参数</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"getDefaultConfig\"><a href=\"#getDefaultConfig\" class=\"headerlink\" title=\"getDefaultConfig()\"></a>getDefaultConfig()</h2><p>定义<br>static Config getDefaultConfig()</p>\n<p>说明<br>获取Wilddog的默认配置对象。</p>\n<p>返回值</p>\n<!-- Js通过方法前面的两个“#”抽取目录，为识别注释多加一个“#”\n### getApp()\n\n定义\nWilddogApp getApp()\n\n说明 \n获取与引用关联的WilddogApp实例\n\n返回值\n对应于引用的WilddogApp对象\n-->\n<hr>\n<h2 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义<br>Wilddog child(String path)</p>\n<p>说明<br>根据相对路径，来获取当前节点下子节点的引用。</p>\n<p>参数<br>path <code>String</code> path 为相对路径，多层级间需要使用”/“分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。</p>\n<p>返回值<br><code>Wilddog</code> 子节点引用。</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定位到 '/test/a'</span></div><div class=\"line\">Wilddog ref2 = ref.child(<span class=\"string\">\"a\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定位到 '/test/a/b'</span></div><div class=\"line\">Wilddog ref3 = ref.child(<span class=\"string\">\"a/b\"</span>);</div><div class=\"line\">Wilddog ref4 = ref.child(<span class=\"string\">\"a\"</span>).child(<span class=\"string\">\"b\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2><p>定义<br>Wilddog push()</p>\n<p>说明<br>在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。</p>\n<p>返回值<br><code>Wilddog</code> 新生成子节点的引用对象。</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加一个数值，将生成一个新ID，操作结果为&#123;\"-JmpzI81egafHZo5\":100&#125;， 返回的path为“/test/a/b/-JmpzI81egafHZo5”</span></div><div class=\"line\">Wilddog  newRef = ref.child(<span class=\"string\">\"a/b\"</span>).push();</div><div class=\"line\">newRef.setValue(<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加一个实体</span></div><div class=\"line\">DOTAHero hero = <span class=\"keyword\">new</span> DOTAHero();</div><div class=\"line\">hero.setName(<span class=\"string\">\"Nevermore\"</span>);</div><div class=\"line\">hero.setHp(<span class=\"number\">435</span>);</div><div class=\"line\">hero.setMp(<span class=\"number\">234</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"heros\"</span>).push().setValue(hero);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setValue-Object\"><a href=\"#setValue-Object\" class=\"headerlink\" title=\"setValue(Object)\"></a>setValue(Object)</h2><p>定义<br>void setValue(Object value)</p>\n<p>说明<br>给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数<br>value <code>Object</code><br>value的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。<br>当value为String、Number、Boolean时，等价于当前节点的<code>updateChildren()</code>操作。<br>当value为null时，等价于当前节点的<code>removeValue()</code>操作。<br>当value为Map或JavaBean时，将value转为一颗子树替换当前value。</p>\n<p>返回值<br>void</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 update(100);</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 remove();</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置子树</span></div><div class=\"line\">Map&lt;String, String&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(children);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 自定义Entity</span></div><div class=\"line\">DOTAHero hero = <span class=\"keyword\">new</span> DOTAHero();</div><div class=\"line\">hero.setName(<span class=\"string\">\"Nevermore\"</span>);</div><div class=\"line\">hero.setHp(<span class=\"number\">435</span>);</div><div class=\"line\">hero.setMp(<span class=\"number\">234</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"dota/heros/SF\"</span>).setValue(hero);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"setValue-Object-CompletionListener\"><a href=\"#setValue-Object-CompletionListener\" class=\"headerlink\" title=\"setValue(Object, CompletionListener)\"></a>setValue(Object, CompletionListener)</h2><p>定义<br>void setValue(Object value, Wilddog.CompletionListener listener)</p>\n<p>说明<br>给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数<br>value <code>Object</code> value的类型可以为String、Number、Boolean、null、Map或满足JavaBean规范的实体。<br>当value为String、Number、Boolean时，等价于Path对应的Node的<code>updateChildren()</code>操作。<br>当value为null时，等价于Path对应的Node的<code>removeValue()</code>操作。<br>当value为Map或JavaBean时，将value转为一颗子树替换当前value。</p>\n<p>listener <code>CompletionListener</code> listener包含一个callback函数，用户可以实现<code>onComplete</code>函数，如果某个callback函数没有响应的处理，接口实现为<code>{}</code>函数即可。<code>setValue(value)</code>等价于<code>setValue(value, null)</code>。</p>\n<p>返回值<br>void</p>\n<p>示例<br>自定义CompletionListener<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Wilddog</span>.<span class=\"title\">CompletionListener</span> </span>&#123;</div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">              System.out.println(error.getCode());</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">CompletionListener listener = <span class=\"keyword\">new</span> MyHandler();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 update(100);</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"number\">100</span>, listener);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等价 remove();</span></div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(<span class=\"keyword\">null</span>, listener);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置子树</span></div><div class=\"line\">Map&lt;String, String&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).setValue(children, listener);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 自定义Entity</span></div><div class=\"line\">DOTAHero hero = <span class=\"keyword\">new</span> DOTAHero();</div><div class=\"line\">hero.setName(<span class=\"string\">\"Nevermore\"</span>);</div><div class=\"line\">hero.setHp(<span class=\"number\">435</span>);</div><div class=\"line\">hero.setMp(<span class=\"number\">234</span>);</div><div class=\"line\"></div><div class=\"line\">ref.child(<span class=\"string\">\"dota/heros/SF\"</span>).setValue(hero, <span class=\"keyword\">new</span> Wilddog.CompletionListener() &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"Good!\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setPriority\"><a href=\"#setPriority\" class=\"headerlink\" title=\"setPriority()\"></a>setPriority()</h2><p>定义<br>void setPriority(Object)</p>\n<p>说明<br>设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。<br>你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。</p>\n<p>节点按照如下规则排序：</p>\n<ul>\n<li>没有priority的排最先。</li>\n<li>有数字priority的次之，按照数值排序。</li>\n<li>有字符串 priority的排最后，按照字母表的顺序排列。</li>\n<li>当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。<br><br><br><br><br>注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。</li>\n</ul>\n<p>参数<br>priority <code>Object</code> 指定节点的优先级。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setPriority-Object-CompletionListener\"><a href=\"#setPriority-Object-CompletionListener\" class=\"headerlink\" title=\"setPriority(Object, CompletionListener)\"></a>setPriority(Object, CompletionListener)</h2><p>定义<br>void setPriority(Object, Wilddog.CompletionListener)</p>\n<p>说明<br>设置Wilddog当前节点的优先级。优先级被用来排序（如果没有指定优先级，子节点按照key排序）。<br>你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用setValue(data, priority)； 当为已存在的数据指定优先级的时候，使用setPriority。</p>\n<p>节点按照如下规则排序：</p>\n<ul>\n<li>没有priority的排最先。</li>\n<li>有数字priority的次之，按照数值排序。</li>\n<li>有字符串 priority的排最后，按照字母表的顺序排列。</li>\n<li>当两个子节点有相同的 priority（包括没有priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。<br><br><br><br><br>注意：数值优先级被作为IEEE 754双精度浮点型数字进行解析和排序，Key以String类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。</li>\n</ul>\n<p>参数</p>\n<ul>\n<li>priority <code>Object</code> 指定节点的优先级。</li>\n<li>listener <code>CompletionListener</code>。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"updateChildren\"><a href=\"#updateChildren\" class=\"headerlink\" title=\"updateChildren()\"></a>updateChildren()</h2><p>定义<br>void updateChildren(Map value)</p>\n<p>说明<br>对子节点进行合并操作。不存在的子节点将会被新增，存在子节点将会被替换。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数<br>value <code>Map&lt;String, Object&gt;</code> 当value为null时，等价于<code>removeValue()</code>操作。</p>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 更新子树</span></div><div class=\"line\">Map&lt;String, String&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).updateChildren(children);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"updateChildren-Map-CompletionListener\"><a href=\"#updateChildren-Map-CompletionListener\" class=\"headerlink\" title=\"updateChildren(Map, CompletionListener)\"></a>updateChildren(Map, CompletionListener)</h2><p>定义<br>void updateChildren(Map children, Wilddog.CompletionListener listener)</p>\n<p>说明<br>对子节点进行更新操作。不存在的子节点将会被新增，存在子节点将会被替换。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Map&lt;String, Object&gt;</code> 当value为null时，等价于<code>removeValue()</code>操作。</li>\n<li>listener <code>CompletionListener</code> listener包含一个回调函数<code>onComplete</code>，如果执行完成，<code>onComplete</code>函数将会被调用。</li>\n</ul>\n<p>返回值<br>void</p>\n<p>示例<br>自定义CompletionListener<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Wilddog</span>.<span class=\"title\">CompletionListener</span> </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">CompletionListener handler = <span class=\"keyword\">new</span> MyHandler();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 更新子树</span></div><div class=\"line\">Map&lt;String, Object&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"c\"</span>, <span class=\"string\">\"cval\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).updateChildren(children, handler);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"removeValue\"><a href=\"#removeValue\" class=\"headerlink\" title=\"removeValue()\"></a>removeValue()</h2><p>定义<br>void removeValue()</p>\n<p>说明<br>删除当前节点。 删除成功后将触发Change，ChildRemoved事件。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).removeValue();</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"removeValue-CompletionListener\"><a href=\"#removeValue-CompletionListener\" class=\"headerlink\" title=\"removeValue(CompletionListener)\"></a>removeValue(CompletionListener)</h2><p>定义<br>void removeValue(CompletionListener listener)</p>\n<p>说明<br>删除当前节点。 删除成功后将触发Change，ChildRemoved事件。<br>该函数是线程安全的，将阻塞其他的本地数据操作。</p>\n<p>参数</p>\n<ul>\n<li>listener <code>CompletionListener</code><br>listener包含一个回调函数<code>onComplete</code>，如果执行完成，<code>onComplete</code>函数将会被调用。</li>\n</ul>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\">ResultHandler handler = <span class=\"keyword\">new</span> MyHandler();</div><div class=\"line\">ref.child(<span class=\"string\">\"a/b\"</span>).removeValue(handler);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"runTransaction-Transaction-Handler\"><a href=\"#runTransaction-Transaction-Handler\" class=\"headerlink\" title=\"runTransaction(Transaction.Handler)\"></a>runTransaction(Transaction.Handler)</h2><p>定义<br>void runTransaction(Transaction.Handler handler)</p>\n<p>说明<br>在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，runTransaction() 能够确保不同客户端同时修改，没有冲突。</p>\n<p>参数</p>\n<ul>\n<li>handler <code>Transaction.Handler</code> </li>\n</ul>\n<p>返回值<br>void</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog upvotesRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/android/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>);</div><div class=\"line\"></div><div class=\"line\">upvotesRef.runTransaction(<span class=\"keyword\">new</span> Transaction.Handler() &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> Transaction.<span class=\"function\">Result <span class=\"title\">doTransaction</span><span class=\"params\">(MutableData currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(currentData.getValue() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            currentData.setValue(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            currentData.setValue((Long) currentData.getValue() + <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> Transaction.success(currentData); <span class=\"comment\">// 我们可以调用 Transaction.abort() 中止事务</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError wilddogError, <span class=\"keyword\">boolean</span> committed, DataSnapshot currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 事务完成后调用一次，获取事务完成的结果</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"onDisconnect\"><a href=\"#onDisconnect\" class=\"headerlink\" title=\"onDisconnect()\"></a>onDisconnect()</h2><p>定义<br>OnDisconnect onDisconnect()</p>\n<p>说明<br>当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。</p>\n<p>返回值<br>当前节点执行断开连接操作的对象。</p>\n<hr>\n<h2 id=\"goOffline\"><a href=\"#goOffline\" class=\"headerlink\" title=\"goOffline()\"></a>goOffline()</h2><p>定义<br>static void goOffline()</p>\n<p>说明<br>手动关闭连接，关闭自动连接。<br>注意：调用此方法会影响到所有Wilddog连接。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"goOnline\"><a href=\"#goOnline\" class=\"headerlink\" title=\"goOnline()\"></a>goOnline()</h2><p>定义<br>static void goOnline()</p>\n<p>说明<br>手动建立连接，开启自动重连。<br>注意：调用此方法会影响到所有Wilddog连接。<br>返回值<br>void</p>\n<hr>\n<h2 id=\"getKey\"><a href=\"#getKey\" class=\"headerlink\" title=\"getKey()\"></a>getKey()</h2><p>定义<br>String getKey()</p>\n<p>说明<br>获取当前节点的名称。</p>\n<p>返回值<br><code>String</code> 节点名称。 </p>\n<hr>\n<h2 id=\"getParent\"><a href=\"#getParent\" class=\"headerlink\" title=\"getParent()\"></a>getParent()</h2><p>定义<br>Wilddog getParent()</p>\n<p>说明<br>获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。</p>\n<p>返回值<br><code>Wilddog</code> 父节点的引用。</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test/a\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获得'/test' 路径的引用</span></div><div class=\"line\">Wilddog ref2 = ref.getParent();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 到达root</span></div><div class=\"line\">Wilddog ref3 = ref.getParent().getParent();</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"getRoot\"><a href=\"#getRoot\" class=\"headerlink\" title=\"getRoot()\"></a>getRoot()</h2><p>定义<br>Wilddog getRoot()</p>\n<p>说明<br>获取根节点的引用。<br>返回值<br>根节点的引用。</p>\n<hr>\n<h2 id=\"getSdkVersion\"><a href=\"#getSdkVersion\" class=\"headerlink\" title=\"getSdkVersion()\"></a>getSdkVersion()</h2><p>定义<br>static String getSdkVersion()</p>\n<p>说明<br>获取SDK版本。</p>\n<p>返回值<br>SDK版本。</p>\n<hr>\n<h1 id=\"Wilddog-CompletionListener-Methods\"><a href=\"#Wilddog-CompletionListener-Methods\" class=\"headerlink\" title=\"Wilddog.CompletionListener (Methods)\"></a>Wilddog.CompletionListener (<em>Methods</em>)</h1><h2 id=\"onComplete\"><a href=\"#onComplete\" class=\"headerlink\" title=\"onComplete()\"></a>onComplete()</h2><p>定义<br>void onComplete(WilddogError error,<br>                Wilddog ref)</p>\n<p>说明<br>当操作成功或者失败的时候触发这个方法。如果操作失败，会给出一个error,如果操作成功，error为null。<br>参数</p>\n<ul>\n<li>error <code>WilddogError</code> 错误描述。</li>\n<li>ref <code>Wilddog</code> 到指定Wilddog节点的引用。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Wilddog-AuthStateListener-Methods\"><a href=\"#Wilddog-AuthStateListener-Methods\" class=\"headerlink\" title=\"Wilddog.AuthStateListener (Methods)\"></a>Wilddog.AuthStateListener (<em>Methods</em>)</h1><h2 id=\"onAuthStateChanged\"><a href=\"#onAuthStateChanged\" class=\"headerlink\" title=\"onAuthStateChanged()\"></a>onAuthStateChanged()</h2><p>定义<br>void onAuthStateChanged(AuthData authData)</p>\n<p>说明<br>当登录认证状态发生改变的时候，此方法将被调用。authData包含当前登录认证的信息，如果当前的连接没有登录认证，authData为null。</p>\n<p>参数<br>authData <code>AuthData</code> 当前登录认证的信息，未登录认证时为null。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Wilddog-AuthResultHandler-Methods\"><a href=\"#Wilddog-AuthResultHandler-Methods\" class=\"headerlink\" title=\"Wilddog.AuthResultHandler (Methods)\"></a>Wilddog.AuthResultHandler (<em>Methods</em>)</h1><h2 id=\"onAuthenticated\"><a href=\"#onAuthenticated\" class=\"headerlink\" title=\"onAuthenticated()\"></a>onAuthenticated()</h2><p>定义<br>void onAuthenticated(AuthData authData)</p>\n<p>说明<br>当登录认证成功时这个方法被调用。</p>\n<p>参数<br>authData <code>AuthData</code> 当前用户或者Token的信息。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onAuthenticationError\"><a href=\"#onAuthenticationError\" class=\"headerlink\" title=\"onAuthenticationError()\"></a>onAuthenticationError()</h2><p>定义<br>void onAuthenticationError(WilddogError error)</p>\n<p>说明<br>当登录认证失败时这个方法被调用。</p>\n<p>参数<br>error <code>WilddogError</code> 登录认证失败的原因和附加的详细信息。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Wilddog-ResultHandler-Methods\"><a href=\"#Wilddog-ResultHandler-Methods\" class=\"headerlink\" title=\"Wilddog.ResultHandler (Methods)\"></a>Wilddog.ResultHandler (<em>Methods</em>)</h1><h2 id=\"onError\"><a href=\"#onError\" class=\"headerlink\" title=\"onError()\"></a>onError()</h2><p>定义<br>void onError(WilddogError error)</p>\n<p>说明<br>如果操作失败此方法被调用。</p>\n<p>参数<br>error <code>WilddogError</code> 包含失败原因和附加的详情。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onSuccess\"><a href=\"#onSuccess\" class=\"headerlink\" title=\"onSuccess()\"></a>onSuccess()</h2><p>定义<br>void onSuccess()</p>\n<p>说明<br>如果操作成功此方法被调用。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"ChildEventListener-Methods\"><a href=\"#ChildEventListener-Methods\" class=\"headerlink\" title=\"ChildEventListener (Methods)\"></a>ChildEventListener (<em>Methods</em>)</h1><h2 id=\"onCancelled\"><a href=\"#onCancelled\" class=\"headerlink\" title=\"onCancelled()\"></a>onCancelled()</h2><p>定义<br>void onCancelled(WilddogError error)</p>\n<p>说明<br>当listener在服务端失败，或者被删除的时候调用该方法。</p>\n<p>参数<br>error <code>WilddogError</code> 发生错误的描述。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildAdded\"><a href=\"#onChildAdded\" class=\"headerlink\" title=\"onChildAdded()\"></a>onChildAdded()</h2><p>定义<br>void onChildAdded(DataSnapshot snapshot,<br>                  String previousChildName)</p>\n<p>说明<br>一个添加了listener的节点，当有子节点被添加时触发此方法。</p>\n<p>参数</p>\n<ul>\n<li>snapshot <code>DataSnapshot</code> 新添加的子节点数据快照。</li>\n<li>previousChildName <code>String</code> 排在被添加的新子节点前面的兄弟节点的key值。如果被添加的是当前节点的第一个子节点，该值为null。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildChanged\"><a href=\"#onChildChanged\" class=\"headerlink\" title=\"onChildChanged()\"></a>onChildChanged()</h2><p>定义<br>void onChildChanged(DataSnapshot snapshot,<br>                    String previousChildName)</p>\n<p>说明<br>当前节点的子节点发生改变的时候触发此方法。</p>\n<p>参数</p>\n<ul>\n<li>snapshot <code>DataSnapshot</code> 新子节点数据的快照。</li>\n<li>previousChildName <code>String</code> 排在被修改的新子节点前面的兄弟节点的key值。如果改变的是当前节点的第一个子节点，该值为null。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildMoved\"><a href=\"#onChildMoved\" class=\"headerlink\" title=\"onChildMoved()\"></a>onChildMoved()</h2><p>定义<br>void onChildMoved(DataSnapshot snapshot,<br>                  String previousChildName)</p>\n<p>说明<br>当一个子节点的优先级发生变化时，该方法将被调用。参考Wilddog.setPriority(Object)和数据排序了解更多关于优先级和数据排序的信息。</p>\n<p>参数</p>\n<ul>\n<li><code>DataSnapshot</code> 节点排序发生变化时的数据快照。</li>\n<li><code>String</code> 排在当前子节点前面的兄弟子节点的key名称，如果当前节点位置最先，此值为null。</li>\n</ul>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onChildRemoved\"><a href=\"#onChildRemoved\" class=\"headerlink\" title=\"onChildRemoved()\"></a>onChildRemoved()</h2><p>定义<br>void onChildRemoved(DataSnapshot snapshot)</p>\n<p>说明<br>当一个添加了listener的节点有子节点被删除的时候触发这个方法。</p>\n<p>参数<br>snapshot <code>DataSnapshot</code> 被删除子节点的数据快照。</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"ValueEventListener-Methods\"><a href=\"#ValueEventListener-Methods\" class=\"headerlink\" title=\"ValueEventListener (Methods)\"></a>ValueEventListener (<em>Methods</em>)</h1><h2 id=\"onCancelled-1\"><a href=\"#onCancelled-1\" class=\"headerlink\" title=\"onCancelled()\"></a>onCancelled()</h2><p>定义<br>void onCancelled(WilddogError error)</p>\n<p>说明<br>当listener在服务端失败，或者被删除的时候调用该方法。</p>\n<p>参数<br>error <code>DataSnapshot</code> 发生错误的描述。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"onDataChange\"><a href=\"#onDataChange\" class=\"headerlink\" title=\"onDataChange()\"></a>onDataChange()</h2><p>定义<br>void onDataChange(DataSnapshot snapshot)</p>\n<p>说明<br>一个添加了 listener 的节点，当有节点改变时触发此方法。<br>参数<br>snapshot <code>DataSnapshot</code> 新添加的子节点的数据快照</p>\n<p>返回值<br>void</p>\n<hr>\n<h1 id=\"Query-Methods\"><a href=\"#Query-Methods\" class=\"headerlink\" title=\"Query (Methods)\"></a>Query (<em>Methods</em>)</h1><h2 id=\"addValueEventListener\"><a href=\"#addValueEventListener\" class=\"headerlink\" title=\"addValueEventListener()\"></a>addValueEventListener()</h2><p>定义<br>void addValueEventListener(ValueEventListener listener)</p>\n<p>说明<br>为当前节点绑定监听事件，监听该节点数据的变化。用户需要实现ValueEventListener接口。</p>\n<p>参数<br>listener <code>ValueEventListener</code> listener将监听Change事件。</p>\n<p>返回值<br><code>ValueEventListener</code> 返回监听事件的引用，可用于删除此事件。</p>\n<p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\">ValueEventListener listener = ref.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener()&#123;</div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">          System.out.println(snapshot.getValue());</div><div class=\"line\">          <span class=\"comment\">// DataSnapshot to json string</span></div><div class=\"line\">          <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          JSONObject json = <span class=\"keyword\">new</span> JSONObject();</div><div class=\"line\">          json.put(dataSnapshot.getKey(), <span class=\"keyword\">new</span> JSONObject(dataSnapshot.getValue()));</div><div class=\"line\">          System.out.println(json.toString());</div><div class=\"line\">      &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">          e.printStackTrace();</div><div class=\"line\">     &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">               System.out.println(error.getCode());</div><div class=\"line\">          &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"addChildEventListener\"><a href=\"#addChildEventListener\" class=\"headerlink\" title=\"addChildEventListener()\"></a>addChildEventListener()</h2><p>定义<br>void addChildEventListener(ChildEventListener listener)</p>\n<p>说明<br>为子节点绑定监听事件，监听该子节点数据的变化。用户需要实现ValueEventListener接口。</p>\n<p>参数</p>\n<ul>\n<li>listener <code>ChildEventListener</code><br><code>onChildAdded()</code> 监听子节点的添加事件。<br><code>onChildRemoved()</code> 监听子节点的删除事件。<br><code>onChildChanged()</code> 监听子节点的变化事件。</li>\n</ul>\n<p>返回值<br><code>ChildEventListener</code> 返回监听事件的引用，可用于删除此事件。</p>\n<p>示例<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/test\"</span>);</div><div class=\"line\"></div><div class=\"line\">ChildEventListener listener = ref.addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String s)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">        <span class=\"comment\">// DataSnapshot to json string</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          JSONObject json = <span class=\"keyword\">new</span> JSONObject();</div><div class=\"line\">          json.put(dataSnapshot.getKey(), <span class=\"keyword\">new</span> JSONObject(dataSnapshot.getValue()));</div><div class=\"line\">          System.out.println(json.toString());</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (JSONException e) &#123;</div><div class=\"line\">          e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot snapshot, String s)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot snapshot, String s)</span> </span>&#123;</div><div class=\"line\">    System.out.println(snapshot.getValue());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"addListenerForSingleValueEvent\"><a href=\"#addListenerForSingleValueEvent\" class=\"headerlink\" title=\"addListenerForSingleValueEvent()\"></a>addListenerForSingleValueEvent()</h2><p>定义<br>void addListenerForSingleValueEvent(ValueEventListener listener)</p>\n<p>说明<br>为当前节点单次数据获取绑定监听事件，此监听器只被触发一次，以获取当前节点下的所有数据。</p>\n<p>参数<br>listener <code>ValueEventListener</code> 节点绑定的监听事件。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"removeEventListener-ValueEventListener\"><a href=\"#removeEventListener-ValueEventListener\" class=\"headerlink\" title=\"removeEventListener(ValueEventListener)\"></a>removeEventListener(ValueEventListener)</h2><p>定义<br>void removeEventListener(ValueEventListener listener)</p>\n<p>说明<br>删除已绑定的监听事件。</p>\n<p>参数<br>listener <code>ValueEventListener</code> 要删除的监听事件。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"removeEventListener-ChildEventListener\"><a href=\"#removeEventListener-ChildEventListener\" class=\"headerlink\" title=\"removeEventListener(ChildEventListener)\"></a>removeEventListener(ChildEventListener)</h2><p>定义<br>void removeEventListener(ChildEventListener listener)</p>\n<p>说明<br>删除已绑定的监听事件。</p>\n<p>参数<br>listener <code>ChildEventListener</code> 要删除的监听事件。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"orderByChild\"><a href=\"#orderByChild\" class=\"headerlink\" title=\"orderByChild()\"></a>orderByChild()</h2><p>定义<br>Query orderByChild(String childKey)</p>\n<p>说明<br>使用指定的子节点的值进行排序。</p>\n<p>参数<br>childKey <code>String</code> 子节点属性。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"orderByKey\"><a href=\"#orderByKey\" class=\"headerlink\" title=\"orderByKey()\"></a>orderByKey()</h2><p>定义<br>Query orderByKey()</p>\n<p>说明<br>使用子节点的key进行排序。</p>\n<p>返回值<br>Query 查询器类</p>\n<hr>\n<h2 id=\"orderByValue\"><a href=\"#orderByValue\" class=\"headerlink\" title=\"orderByValue()\"></a>orderByValue()</h2><p>定义<br>Query orderByValue()</p>\n<p>说明<br>使用子节点的值进行排序。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"orderByPriority\"><a href=\"#orderByPriority\" class=\"headerlink\" title=\"orderByPriority()\"></a>orderByPriority()</h2><p>定义<br>Query orderByPriority()</p>\n<p>说明<br>根据子节点的优先级进行排序。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"startAt\"><a href=\"#startAt\" class=\"headerlink\" title=\"startAt()\"></a>startAt()</h2><p>定义<br>Object startAt(String value), Object startAt(double value), Object startAt(boolean value)</p>\n<p>说明<br>创建一个大于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object startAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。</p>\n<p>参数<br>value <code>String</code> <code>double</code> <code>boolean</code>。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"endAt\"><a href=\"#endAt\" class=\"headerlink\" title=\"endAt()\"></a>endAt()</h2><p>定义<br>Object endAt(String value)，Object endAt(double value)，Object endAt(boolean value)</p>\n<p>说明<br>创建一个小于等于的范围查询，可配合orderBy方式使用。注意 : 对于使用Object endAt(String value)进行查询时,查询方式是通过将字符进行unicode编码后进行排序。</p>\n<p>参数<br>value <code>String</code> <code>double</code> <code>boolean</code>。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"equalTo\"><a href=\"#equalTo\" class=\"headerlink\" title=\"equalTo()\"></a>equalTo()</h2><p>定义<br>Object equalTo(String value)，Object equalTo(double value)，Object equalTo(boolean value)</p>\n<p>说明<br>创建一个等于的精确查询。</p>\n<p>参数<br>value <code>String</code> <code>double</code> <code>boolean</code>。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"limitToFirst\"><a href=\"#limitToFirst\" class=\"headerlink\" title=\"limitToFirst()\"></a>limitToFirst()</h2><p>定义<br>Query limitToFirst(int count)</p>\n<p>说明<br>创建一个limit查询。从第一条开始获取指定数量的数据。</p>\n<p>参数<br>count <code>int</code> 数量。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"limitToLast\"><a href=\"#limitToLast\" class=\"headerlink\" title=\"limitToLast()\"></a>limitToLast()</h2><p>定义<br>Query limitToLast(int count)</p>\n<p>说明<br>创建一个limit查询。从最后一条开始获取指定数量的数据。</p>\n<p>参数<br>count <code>int</code> 数量。</p>\n<p>返回值<br>Query 查询器类。</p>\n<hr>\n<h2 id=\"getRef\"><a href=\"#getRef\" class=\"headerlink\" title=\"getRef()\"></a>getRef()</h2><p>定义<br>Wilddog getRef()</p>\n<p>说明<br>获得当前的引用。</p>\n<p>返回值<br><code>Wilddog</code> 节点引用。</p>\n<hr>\n<h1 id=\"DataSnapshot-Methods\"><a href=\"#DataSnapshot-Methods\" class=\"headerlink\" title=\"DataSnapshot (Methods)\"></a>DataSnapshot (<em>Methods</em>)</h1><h2 id=\"child-1\"><a href=\"#child-1\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义<br>Wilddog child(String node)</p>\n<p>说明<br>根据相对路径，来获取当前节点下子节点的快照。</p>\n<p>参数<br>node <code>String</code>  子节点名称。</p>\n<p>返回值<br><code>Snapshot</code> </p>\n<hr>\n<h2 id=\"exists\"><a href=\"#exists\" class=\"headerlink\" title=\"exists()\"></a>exists()</h2><p>定义<br>boolean exists()</p>\n<p>说明<br>在快照中，判断当前节点是否包含数据。相当于<code>snapshot.getValue()!=null</code> 。</p>\n<p>返回值<br><code>boolean</code> </p>\n<hr>\n<h2 id=\"getChildren\"><a href=\"#getChildren\" class=\"headerlink\" title=\"getChildren()\"></a>getChildren()</h2><p>定义<br>Iterable<DataSnapshot> getChildren()</p>\n<p>说明<br>获取当前快照中，所有子节点的迭代器。</p>\n<p>返回值<br><code>Iterable&lt;DataSnapshot&gt;</code> 子节点的迭代器。 </p>\n<hr>\n<h2 id=\"getChildrenCount\"><a href=\"#getChildrenCount\" class=\"headerlink\" title=\"getChildrenCount()\"></a>getChildrenCount()</h2><p>定义<br>long getChildrenCount()</p>\n<p>说明<br>获得子节点的总数。</p>\n<p>返回值<br><code>long</code> 子节点总数 。</p>\n<hr>\n<h2 id=\"getKey-1\"><a href=\"#getKey-1\" class=\"headerlink\" title=\"getKey()\"></a>getKey()</h2><p>定义<br>String getKey()</p>\n<p>说明<br>从快照中，获取当前节点的名称。</p>\n<p>返回值<br><code>String</code> 节点名称 。</p>\n<hr>\n<h2 id=\"getPriority\"><a href=\"#getPriority\" class=\"headerlink\" title=\"getPriority()\"></a>getPriority()</h2><p>定义<br>Object getPriority()</p>\n<p>说明<br>获取当前节点的优先级。</p>\n<p>返回值<br><code>Object</code>   <code>Stirng</code> , <code>Double</code> , <code>Null</code>。</p>\n<hr>\n<h2 id=\"getRef-1\"><a href=\"#getRef-1\" class=\"headerlink\" title=\"getRef()\"></a>getRef()</h2><p>定义<br>Wilddog getRef()。</p>\n<p>说明<br>从快照中，获得当前节点的引用。</p>\n<p>返回值<br><code>Wilddog</code> 节点引用。</p>\n<hr>\n<h2 id=\"getValue\"><a href=\"#getValue\" class=\"headerlink\" title=\"getValue()\"></a>getValue()</h2><p>定义<br>Object getValue()</p>\n<p>说明<br>从快照中获得当前节点的数据。</p>\n<p>返回值<br><code>Object</code> 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 <code>Map&lt;String, Object&gt;</code>。</p>\n<hr>\n<h2 id=\"hasChild\"><a href=\"#hasChild\" class=\"headerlink\" title=\"hasChild()\"></a>hasChild()</h2><p>定义<br>boolean hasChild(String key)</p>\n<p>说明<br>判断在当前快照中，是否包含指定子节点。</p>\n<p>参数</p>\n<ul>\n<li>key <code>String</code> 子节点名称。</li>\n</ul>\n<p>返回值<br><code>boolean</code> true为包含，false为不包含。</p>\n<hr>\n<h2 id=\"hasChildren\"><a href=\"#hasChildren\" class=\"headerlink\" title=\"hasChildren()\"></a>hasChildren()</h2><p>定义<br>boolean hasChildren()</p>\n<p>说明<br>判断在当前快照中，是否存在子节点。</p>\n<p>返回值<br><code>boolean</code> true为存在子节点，false为不存在。</p>\n<!--\n\n!#MutableData (*Methods*)\n\n\n!## child()\n\n!定义\nMutableData child(String node)\n\n!说明\n根据相对路径，来获取当前节点下子节点的快照。\n\n!参数\n* node `String` 子节点名称。\n\n!返回值\n`MutableData`\n\n\n!## getChildren()\n\n!定义\nIterator<MutableData> getChildren()\n\n!说明\n用于对当前节点的即时子节点进行迭代。\n!返回值\n当前节点的即时子节点。\n\n\n!## getChildrenCount()\n\n!定义\nlong getChildrenCount()\n\n!说明\n获得子节点的总数。\n\n!返回值\n`long` 子节点总数 。\n\n\n!## getKey()\n\n!定义\nString getKey()\n\n!说明\n获取当前节点的名称。\n\n!返回值\n`String` 节点名称 。\n\n\n!## getParent()\n\n!定义\nMutableData getParent()\n\n!说明 \n获取一个节点的父节点数据，如果本身就是最顶端的节点，返回null。\n!返回值\nMutableData\n\n\n!## getPriority()\n\n!定义\nObject getPriority()\n\n!说明 \n获得当前节点的优先级。\n!返回值\n`Object`   `Stirng` , `Double` , `Null`。\n\n!## getValue()\n\n!定义\nObject getValue()\n\n!说明\n获得当前节点的数据。\n\n!返回值\n`Object` 如果是叶子节点，返回String、Boolean、Number类型；如果是非叶子节点，将返回 `Map<String, Object>`。\n\n\n!## hasChild()\n\n!定义\nboolean hasChild(String key)\n\n!说明\n判断是否包含指定子节点。\n\n!参数\n* key `String` 子节点名称。\n\n!返回值\n`boolean` true为包含，false为不包含。\n\n\n!## hasChildren()\n\n!定义\nboolean hasChildren()\n\n!说明\n判断在当前快照中，是否存在子节点。\n\n!返回值\n`boolean` true为存在子节点，false为不存在。\n\n\n!## setPriority(Object)\n\n!定义\nvoid setPriority(Object)\n\n!说明 \n设置当前节点的优先级。\n\n!参数\n* priority `Object`。\n\n!返回值\nvoid\n\n\n!## setValue()\n\n!定义\nvoid setValue(Object value)\n\n!说明 \n给当前节点赋值。如果当前是叶子节点，那么它的值会被改变成value；如果当前是非叶子节点，那么它的子节点将会被删除，当前节点将变成叶子节点，同时被赋值为value。\n该函数是线程安全的，将阻塞其他的本地数据操作。\n\n!参数\n* value `Object`。\n\n!返回值\nvoid\n-->\n<hr>\n<h1 id=\"AuthData-Methods\"><a href=\"#AuthData-Methods\" class=\"headerlink\" title=\"AuthData (Methods)\"></a>AuthData (<em>Methods</em>)</h1><h2 id=\"getAuth\"><a href=\"#getAuth\" class=\"headerlink\" title=\"getAuth()\"></a>getAuth()</h2><p>定义<br>Map getAuth()</p>\n<p>说明<br>同步返回Token Auth状态,如果使用secret登录，返回null。</p>\n<p>返回值<br>返回Token Auth状态,如果使用secret登录，返回null。</p>\n<hr>\n<h2 id=\"getExpires\"><a href=\"#getExpires\" class=\"headerlink\" title=\"getExpires()\"></a>getExpires()</h2><p>定义<br>long getExpires()</p>\n<p>说明<br>取得token的过期时间。</p>\n<p>返回值<br>token的过期时间。</p>\n<hr>\n<h2 id=\"getProvider\"><a href=\"#getProvider\" class=\"headerlink\" title=\"getProvider()\"></a>getProvider()</h2><p>定义<br>String getProvider()</p>\n<p>说明<br>获取第三方平台认证的支持方式，如果没有，返回null。</p>\n<p>返回值<br>返回第三方OAuth平台或者null。</p>\n<hr>\n<h2 id=\"getProviderData\"><a href=\"#getProviderData\" class=\"headerlink\" title=\"getProviderData()\"></a>getProviderData()</h2><p>定义<br>Map<String,Object> getProviderData()</p>\n<p>说明<br>获取认证服务器返回的第三方平台数据。内容取决于支持方式，参考文档获取更多信息。<br>返回值<br>一个包含第三方OAuth平台信息的Map。</p>\n<hr>\n<h2 id=\"getToken\"><a href=\"#getToken\" class=\"headerlink\" title=\"getToken()\"></a>getToken()</h2><p>定义<br>String getToken()</p>\n<p>说明<br>获取登录认证的Token,如果是通过secret登录，得到null。<br>返回值<br>登录认证的Token,如果是通过secret登录，返回null。</p>\n<hr>\n<h2 id=\"getUid\"><a href=\"#getUid\" class=\"headerlink\" title=\"getUid()\"></a>getUid()</h2><p>定义<br>String getUid()</p>\n<p>说明<br>获取登录用户的uid，如果是以secret登录或者用没有uid的Token登录，返回null。<br>返回值<br>uid或者null。</p>\n<hr>\n<h1 id=\"WilddogError-Constants\"><a href=\"#WilddogError-Constants\" class=\"headerlink\" title=\"WilddogError (Constants)\"></a>WilddogError (<em>Constants</em>)</h1><h2 id=\"AUTHENTICATION-PROVIDER-DISABLED\"><a href=\"#AUTHENTICATION-PROVIDER-DISABLED\" class=\"headerlink\" title=\"AUTHENTICATION_PROVIDER_DISABLED\"></a>AUTHENTICATION_PROVIDER_DISABLED</h2><p>说明<br>要求的第三方OAuth平台认证方式不被当前app支持。</p>\n<hr>\n<h2 id=\"DATA-STALE\"><a href=\"#DATA-STALE\" class=\"headerlink\" title=\"DATA_STALE\"></a>DATA_STALE</h2><p>说明<br>内部使用。</p>\n<hr>\n<h2 id=\"DENIED-BY-USER\"><a href=\"#DENIED-BY-USER\" class=\"headerlink\" title=\"DENIED_BY_USER\"></a>DENIED_BY_USER</h2><p>说明<br>用户不能登录认证应用。当用户取消OAuth认证请求时会造成这个错误。</p>\n<hr>\n<h2 id=\"DISCONNECTED\"><a href=\"#DISCONNECTED\" class=\"headerlink\" title=\"DISCONNECTED\"></a>DISCONNECTED</h2><p>说明<br>因为网络连接失败导致操作不能执行。</p>\n<hr>\n<h2 id=\"EMAIL-TAKEN\"><a href=\"#EMAIL-TAKEN\" class=\"headerlink\" title=\"EMAIL_TAKEN\"></a>EMAIL_TAKEN</h2><p>说明<br>由于指定的邮箱地址已经被使用而不能建立新用户。</p>\n<hr>\n<h2 id=\"EXPIRED-TOKEN\"><a href=\"#EXPIRED-TOKEN\" class=\"headerlink\" title=\"EXPIRED_TOKEN\"></a>EXPIRED_TOKEN</h2><p>说明<br>提供的auth Token已经过期。</p>\n<hr>\n<h2 id=\"INVALID-AUTH-ARGUMENTS\"><a href=\"#INVALID-AUTH-ARGUMENTS\" class=\"headerlink\" title=\"INVALID_AUTH_ARGUMENTS\"></a>INVALID_AUTH_ARGUMENTS</h2><p>说明<br>指定的凭证不符合标准或者不完整。请参考错误信息，错误详情和Wilddog文档获得支持方auth登录认证的正确参数。</p>\n<hr>\n<h2 id=\"INVALID-CONFIGURATION\"><a href=\"#INVALID-CONFIGURATION\" class=\"headerlink\" title=\"INVALID_CONFIGURATION\"></a>INVALID_CONFIGURATION</h2><p>说明<br>被申请的登录认证提供方式没有配置，请求无法完成。请完成应用配置。</p>\n<hr>\n<h2 id=\"INVALID-CREDENTIALS\"><a href=\"#INVALID-CREDENTIALS\" class=\"headerlink\" title=\"INVALID_CREDENTIALS\"></a>INVALID_CREDENTIALS</h2><p>说明<br>指定的登录认证凭证不可用。当凭证不符合标准或者过期时会引发这个错误。</p>\n<hr>\n<h2 id=\"INVALID-EMAIL\"><a href=\"#INVALID-EMAIL\" class=\"headerlink\" title=\"INVALID_EMAIL\"></a>INVALID_EMAIL</h2><p>说明<br> 指定的邮箱不可用。</p>\n<hr>\n<h2 id=\"INVALID-PASSWORD\"><a href=\"#INVALID-PASSWORD\" class=\"headerlink\" title=\"INVALID_PASSWORD\"></a>INVALID_PASSWORD</h2><p>说明<br>指定的用户帐号密码不正确。</p>\n<hr>\n<h2 id=\"INVALID-PROVIDER\"><a href=\"#INVALID-PROVIDER\" class=\"headerlink\" title=\"INVALID_PROVIDER\"></a>INVALID_PROVIDER</h2><p>说明<br>申请的第三方OAuth平台认证方式不存在。请参阅Wilddog认证的相关文档获得支持的方式列表。</p>\n<hr>\n<h2 id=\"INVALID-TOKEN\"><a href=\"#INVALID-TOKEN\" class=\"headerlink\" title=\"INVALID_TOKEN\"></a>INVALID_TOKEN</h2><p>说明<br>指定的登录认证Token不可用。如果token变形，过期或者用于生成token的secret已经被撤销，会引发此错误。</p>\n<hr>\n<h2 id=\"LIMITS-EXCEEDED\"><a href=\"#LIMITS-EXCEEDED\" class=\"headerlink\" title=\"LIMITS_EXCEEDED\"></a>LIMITS_EXCEEDED</h2><p>说明<br>超过限制，如果遇到此错误码，请联系support@Wilddog.com。</p>\n<hr>\n<h2 id=\"MAX-RETRIES\"><a href=\"#MAX-RETRIES\" class=\"headerlink\" title=\"MAX_RETRIES\"></a>MAX_RETRIES</h2><p>说明<br>事务有太多的重试。</p>\n<hr>\n<h2 id=\"NETWORK-ERROR\"><a href=\"#NETWORK-ERROR\" class=\"headerlink\" title=\"NETWORK_ERROR\"></a>NETWORK_ERROR</h2><p>说明<br>因为网络原因导致操作不能执行。</p>\n<hr>\n<h2 id=\"OPERATION-FAILED\"><a href=\"#OPERATION-FAILED\" class=\"headerlink\" title=\"OPERATION_FAILED\"></a>OPERATION_FAILED</h2><p>说明<br>服务器标示操作失败。</p>\n<hr>\n<h2 id=\"OVERRIDDEN-BY-SET\"><a href=\"#OVERRIDDEN-BY-SET\" class=\"headerlink\" title=\"OVERRIDDEN_BY_SET\"></a>OVERRIDDEN_BY_SET</h2><p>说明<br>事务被随后的集合覆盖。</p>\n<hr>\n<h2 id=\"PERMISSION-DENIED\"><a href=\"#PERMISSION-DENIED\" class=\"headerlink\" title=\"PERMISSION_DENIED\"></a>PERMISSION_DENIED</h2><p>说明<br>客户端不被许可执行此操作。</p>\n<hr>\n<h2 id=\"PREEMPTED\"><a href=\"#PREEMPTED\" class=\"headerlink\" title=\"PREEMPTED\"></a>PREEMPTED</h2><p>说明<br>活动的或者即将发生的auth登录认证被另一个auth登录取代。</p>\n<hr>\n<h2 id=\"PROVIDER-ERROR\"><a href=\"#PROVIDER-ERROR\" class=\"headerlink\" title=\"PROVIDER_ERROR\"></a>PROVIDER_ERROR</h2><p>说明<br>第三方OAuth平台错误。</p>\n<hr>\n<h2 id=\"UNKNOWN-ERROR\"><a href=\"#UNKNOWN-ERROR\" class=\"headerlink\" title=\"UNKNOWN_ERROR\"></a>UNKNOWN_ERROR</h2><p>说明<br>未知的错误。</p>\n<hr>\n<h2 id=\"USER-CODE-EXCEPTION\"><a href=\"#USER-CODE-EXCEPTION\" class=\"headerlink\" title=\"USER_CODE_EXCEPTION\"></a>USER_CODE_EXCEPTION</h2><p>说明<br>用户代码中发生的异常。</p>\n<hr>\n<h2 id=\"USER-DOES-NOT-EXIST\"><a href=\"#USER-DOES-NOT-EXIST\" class=\"headerlink\" title=\"USER_DOES_NOT_EXIST\"></a>USER_DOES_NOT_EXIST</h2><p>说明<br>指定的用户账户不存在。</p>\n<hr>\n<h1 id=\"WilddogError-Methods\"><a href=\"#WilddogError-Methods\" class=\"headerlink\" title=\"WilddogError (Methods)\"></a>WilddogError (<em>Methods</em>)</h1><h2 id=\"fromException\"><a href=\"#fromException\" class=\"headerlink\" title=\"fromException()\"></a>fromException()</h2><p>定义<br>WilddogException fromException(Throwable e)</p>\n<p>说明<br>新建一个WilddogException异常。</p>\n<p>返回值<br>WilddogException</p>\n<hr>\n<h2 id=\"fromStatus\"><a href=\"#fromStatus\" class=\"headerlink\" title=\"fromStatus()\"></a>fromStatus()</h2><p>定义<br>WilddogError fromStatus(String)</p>\n<p>说明<br>用WilddogError常量新建一个WilddogError实例。</p>\n<p>参数<br>status <code>WilddogError</code> The status string。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"getCode\"><a href=\"#getCode\" class=\"headerlink\" title=\"getCode()\"></a>getCode()</h2><p>定义<br>int getCode()</p>\n<p>说明<br>一个明确的状态码，取决于错误。<br>返回值<br>int。</p>\n<hr>\n<h2 id=\"getMessage\"><a href=\"#getMessage\" class=\"headerlink\" title=\"getMessage()\"></a>getMessage()</h2><p>定义<br>String getMessage()</p>\n<p>说明<br>获取错误原因。</p>\n<p>返回值<br>String</p>\n<hr>\n<h2 id=\"getDetails\"><a href=\"#getDetails\" class=\"headerlink\" title=\"getDetails()\"></a>getDetails()</h2><p>定义<br>String getDetails()</p>\n<p>说明<br>获取错误细节。</p>\n<p>返回值<br>错误的细节。</p>\n<hr>\n<h2 id=\"toException\"><a href=\"#toException\" class=\"headerlink\" title=\"toException()\"></a>toException()</h2><p>定义<br>WilddogExcepton toException()</p>\n<p>说明<br>如果第三方需要一个来自wilddog的异常，出于整合的目的可以使用此方法。</p>\n<p>返回值<br>一个封装了error的异常类，包含了适当的信息，没有栈信息。</p>\n<hr>\n<h1 id=\"Config-Methods\"><a href=\"#Config-Methods\" class=\"headerlink\" title=\"Config (Methods)\"></a>Config (<em>Methods</em>)</h1><h2 id=\"setLogger\"><a href=\"#setLogger\" class=\"headerlink\" title=\"setLogger()\"></a>setLogger()</h2><p>定义<br>void setLogger(Logger logger)</p>\n<p>说明<br>如果你想提供一个定制的日志，传递一个继承了Logger接口的对象。</p>\n<p>参数<br>logger <code>Logger</code> 定制的日志。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setEventTarget\"><a href=\"#setEventTarget\" class=\"headerlink\" title=\"setEventTarget()\"></a>setEventTarget()</h2><p>定义<br>void setEventTarget(EventTarget eventTarget)</p>\n<p>说明<br>在默认设置中，Wilddog库会创建一个线程来处理所有的回调。在安卓中，将试图采用main Looper。如果你想对如何触发回调有更多控制权，你可以提供一个对象，让他继承EventTarget，它将为每一个回调传递一个Runnable。</p>\n<p>参数<br>eventTarget <code>EventTarget</code>  负责触发回调的对象。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setLogLevel\"><a href=\"#setLogLevel\" class=\"headerlink\" title=\"setLogLevel()\"></a>setLogLevel()</h2><p>定义<br>void setLogLevel(Logger.Level logLevel)<br>说明<br>默认的，这会被设置为INFO。log等级包括内部错误（ERROR）和任何客户端接收到的安全性debug信息（INFO），设置为DEBUG将会打开诊断日志，设置为NONE禁止所有日志。</p>\n<p>参数<br>logLevel <code>Logger.Level</code> 所需最低的日志等级。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setDebugLogComponents\"><a href=\"#setDebugLogComponents\" class=\"headerlink\" title=\"setDebugLogComponents()\"></a>setDebugLogComponents()</h2><p>定义<br>void setDebugLogComponents(List<String> debugComponents)</p>\n<p>说明<br>主要用于debug调试.限制debug输出到指定组件。默认为null，允许所有组建的日志;  显式设置也会把等级设置为DEBUG。<br>参数<br>debugComponents <code>List&lt;String&gt;</code> 一系列日志需要的组件，或者设置为null使所有组件可行。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setAuthenticationServer\"><a href=\"#setAuthenticationServer\" class=\"headerlink\" title=\"setAuthenticationServer()\"></a>setAuthenticationServer()</h2><p>定义<br>void setAuthenticationServer(String host)</p>\n<p>说明<br>设置主机可以被用户登录认证。如果你不确定，不要使用此设置。<br>参数<br>host <code>String</code> 用于认证的server。</p>\n<p>返回值<br>void</p>\n<hr>\n<h2 id=\"setSessionPersistenceKey\"><a href=\"#setSessionPersistenceKey\" class=\"headerlink\" title=\"setSessionPersistenceKey()\"></a>setSessionPersistenceKey()</h2><p>定义<br>void setSessionPersistenceKey(String sessionKey)</p>\n<p>说明<br>为Ｗilddog连接设置session的标识符，使用session标识符可以使多个认证会话在一个设备上共存。如果一个设备上只有一个用户没有必要使用此方法。</p>\n<p>参数<br>sessionKey <code>String</code> 用于标识session的标识符名称。</p>\n<p>返回值<br>void</p>\n"},{"title":"Arduino API 文档","_content":"\n# Wilddog (*Methods*)\n\n## new Wilddog\n\n 定义\n\nnew Wilddog(wilddogUrl)\n\n 说明\n\n初始化URL对应的节点引用。\n\n 参数\n\n* wilddogUrl `string` : 应用URL，如：https://<appId>.wilddogio.com\n\n 返回值\n\nWilddog 对象的引用。\n\n 示例\n```c\nref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n```\n\n----\n\n## getValue()\n\n 定义\n\nint getValue(CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n获取Wilddog引用所对应的节点的值。\n\n 参数\n\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`是返回的数据，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回值\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid getValueCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n get error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n get newest data : \");\n        Serial.print(pdata);\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->getValue(getValueCallBack,(void*)NULL);\n}\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## setValue()\n\n 定义\n\nint setValue(const char \\*p\\_data,CallBackFunc f\\_callback,void \\*arg)\n  \n 说明\n\n设置Wilddog引用所对应的节点的值。\n\n 参数\n\n* p_data `const char*` : 准备设置的节点的值，json字符串格式。\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为NULL，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid setValueCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n set error : \");\n    Serial.print(error);\n    if(error >= 200 && error < 400){\n        Serial.print(\"\\n set data success!\\n\");\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup(){\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->setValue(\"{\\\"pin13\\\":\\\"1\\\"}\", setValueCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## push()\n\n 定义\n\nint push(const char \\*p\\_data,CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n在当前节点下增加一个节点，节点的值由传入的参数决定，设置成功后返回节点的path。节点的key由服务器随机生成。\n\n 参数\n\n* p_data `const char*` : 节点的值，为json字符串。\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为创建的节点的path，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void *` : 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid pushValueCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n push error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n new data path : \");\n        Serial.print(pdata);\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->push(\"{\\\"pin13\\\":\\\"1\\\"}\", pushValueCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## removeValue()\n\n 定义\n\nint removeValue(CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n删除当前节点的值。\n\n 参数\n\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为NULL，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid removeCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n remove error : \");\n    Serial.print(error);\n    if(error >= 200 && error < 400){\n        Serial.print(\"\\n remove success!\\n\");\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->removeValue(removeCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## addObserver()\n\n 定义\n\nint addObserver(Wilddog\\_EventType\\_T event,CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n监听节点下的某个事件（如数据变化）,事件触发后，回调函数会被调用。\n\n 参数\n\n* event `Wilddog_EventType_T` : 事件类型（目前只能设为1）。\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`是返回的数据，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid addObserverCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n observe error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n get newest data : \");\n        Serial.print(pdata);\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## removeObserver()\n\n 定义\n\nint removeObserver(Wilddog\\_EventType\\_T event)\n\n 说明\n\n取消监听事件。\n\n 参数\n\n* event `Wilddog_EventType_T` : 事件类型（目前只能设为1）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nint observed = FALSE;\n\nvoid addObserverCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n observe error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n get newest data : \");\n        Serial.print(pdata);\n\n        //set var observed to TRUE\n        *(int*)arg = TRUE;\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(void*)&observed);\n}\n\nvoid loop(){\n    if(ref){\n        if(observed == TRUE){\n            ref->removeObserver(WD_ET_VALUECHANGE);\n        }\n        ref->trySync();\n    }\n}\n```\n\n----\n\n## trySync()\n\n 定义\n\nvoid trySync()\n\n 说明\n\n通过调用wilddog_trySync来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，以及触发用户注册的回调函数。\n\n 返回值\n\n无。\n\n 示例\n\n见上面示例。\n\n----\n\n# AuthData (*Methods*)\n\n## auth()\n\n 定义\n\nint auth(const char \\*p\\_auth,const char \\*p\\_host,CallBackFunc onAuth,void \\*arg)\n\n 说明\n\n发送auth数据到服务器进行认证。\n\n 参数\n\n* p_auth `const char*` : auth数据，字符串类型。\n* p_host `const char*` : 节点的host（如appid.wilddogio.com）。\n* onAuth `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为NULL，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回值\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid authCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n auth error : \");\n    Serial.print(error);\n    if(error >= 200 && error < 400){\n        Serial.print(\"\\n auth success!\\n\");\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->auth(\"token data\", \"<appId>.wilddogio.com\", authCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n\n","source":"api/sync/arduino.md","raw":"title:  Arduino API 文档\n---\n\n# Wilddog (*Methods*)\n\n## new Wilddog\n\n 定义\n\nnew Wilddog(wilddogUrl)\n\n 说明\n\n初始化URL对应的节点引用。\n\n 参数\n\n* wilddogUrl `string` : 应用URL，如：https://<appId>.wilddogio.com\n\n 返回值\n\nWilddog 对象的引用。\n\n 示例\n```c\nref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n```\n\n----\n\n## getValue()\n\n 定义\n\nint getValue(CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n获取Wilddog引用所对应的节点的值。\n\n 参数\n\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`是返回的数据，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回值\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid getValueCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n get error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n get newest data : \");\n        Serial.print(pdata);\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->getValue(getValueCallBack,(void*)NULL);\n}\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## setValue()\n\n 定义\n\nint setValue(const char \\*p\\_data,CallBackFunc f\\_callback,void \\*arg)\n  \n 说明\n\n设置Wilddog引用所对应的节点的值。\n\n 参数\n\n* p_data `const char*` : 准备设置的节点的值，json字符串格式。\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为NULL，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid setValueCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n set error : \");\n    Serial.print(error);\n    if(error >= 200 && error < 400){\n        Serial.print(\"\\n set data success!\\n\");\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup(){\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->setValue(\"{\\\"pin13\\\":\\\"1\\\"}\", setValueCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## push()\n\n 定义\n\nint push(const char \\*p\\_data,CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n在当前节点下增加一个节点，节点的值由传入的参数决定，设置成功后返回节点的path。节点的key由服务器随机生成。\n\n 参数\n\n* p_data `const char*` : 节点的值，为json字符串。\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为创建的节点的path，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void *` : 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid pushValueCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n push error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n new data path : \");\n        Serial.print(pdata);\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->push(\"{\\\"pin13\\\":\\\"1\\\"}\", pushValueCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## removeValue()\n\n 定义\n\nint removeValue(CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n删除当前节点的值。\n\n 参数\n\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为NULL，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid removeCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n remove error : \");\n    Serial.print(error);\n    if(error >= 200 && error < 400){\n        Serial.print(\"\\n remove success!\\n\");\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->removeValue(removeCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## addObserver()\n\n 定义\n\nint addObserver(Wilddog\\_EventType\\_T event,CallBackFunc f\\_callback,void \\*arg)\n\n 说明\n\n监听节点下的某个事件（如数据变化）,事件触发后，回调函数会被调用。\n\n 参数\n\n* event `Wilddog_EventType_T` : 事件类型（目前只能设为1）。\n* f_callback `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`是返回的数据，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg 用户自定义参数（可为NULL）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid addObserverCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n observe error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n get newest data : \");\n        Serial.print(pdata);\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n----\n\n## removeObserver()\n\n 定义\n\nint removeObserver(Wilddog\\_EventType\\_T event)\n\n 说明\n\n取消监听事件。\n\n 参数\n\n* event `Wilddog_EventType_T` : 事件类型（目前只能设为1）。\n\n 返回\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nint observed = FALSE;\n\nvoid addObserverCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n observe error : \");\n    Serial.print(error);\n    if(pdata){\n        Serial.print(\"\\n get newest data : \");\n        Serial.print(pdata);\n\n        //set var observed to TRUE\n        *(int*)arg = TRUE;\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(void*)&observed);\n}\n\nvoid loop(){\n    if(ref){\n        if(observed == TRUE){\n            ref->removeObserver(WD_ET_VALUECHANGE);\n        }\n        ref->trySync();\n    }\n}\n```\n\n----\n\n## trySync()\n\n 定义\n\nvoid trySync()\n\n 说明\n\n通过调用wilddog_trySync来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，以及触发用户注册的回调函数。\n\n 返回值\n\n无。\n\n 示例\n\n见上面示例。\n\n----\n\n# AuthData (*Methods*)\n\n## auth()\n\n 定义\n\nint auth(const char \\*p\\_auth,const char \\*p\\_host,CallBackFunc onAuth,void \\*arg)\n\n 说明\n\n发送auth数据到服务器进行认证。\n\n 参数\n\n* p_auth `const char*` : auth数据，字符串类型。\n* p_host `const char*` : 节点的host（如appid.wilddogio.com）。\n* onAuth `CallBackFunc` : 服务端回应数据或者回应超时触发的回调函数, 类型是`void (*CallBackFunc)(const char *pdata, int error, void* arg)`，其中`pdata`为NULL，`error`是返回码，`arg`是用户传入的自定义参数。\n* arg `void*` : 用户自定义参数（可为NULL）。\n\n 返回值\n\n`int` : 返回 0:成功 <0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。\n\n 示例\n```c\nvoid authCallBack(const char *pdata, int error, void* arg){\n    Serial.print(\"\\n auth error : \");\n    Serial.print(error);\n    if(error >= 200 && error < 400){\n        Serial.print(\"\\n auth success!\\n\");\n    }\n    return;\n}\n\nWilddog *ref = NULL;\n\nvoid setup() {\n    ... // other codes, such as serial init, bridge init\n    \n    ref = new Wilddog(\"https://<appId>.wilddogio.com/a/b/c\");\n    ref->auth(\"token data\", \"<appId>.wilddogio.com\", authCallBack,(void*)NULL);\n}\n\nvoid loop(){\n    if(ref)\n        ref->trySync();\n}\n```\n\n\n","date":"2016-09-06T03:38:22.515Z","updated":"2016-09-06T03:38:22.515Z","path":"api/sync/arduino.html","comments":1,"layout":"page","_id":"cisswi9j3000az4fwr0q9l6ev","content":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"new-Wilddog\"><a href=\"#new-Wilddog\" class=\"headerlink\" title=\"new Wilddog\"></a>new Wilddog</h2><p> 定义</p>\n<p>new Wilddog(wilddogUrl)</p>\n<p> 说明</p>\n<p>初始化URL对应的节点引用。</p>\n<p> 参数</p>\n<ul>\n<li><p>wilddogUrl <code>string</code> : 应用URL，如：https://<appid>.wilddogio.com</appid></p>\n<p>返回值</p>\n</li>\n</ul>\n<p>Wilddog 对象的引用。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"getValue\"><a href=\"#getValue\" class=\"headerlink\" title=\"getValue()\"></a>getValue()</h2><p> 定义</p>\n<p>int getValue(CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>获取Wilddog引用所对应的节点的值。</p>\n<p> 参数</p>\n<ul>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>是返回的数据，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getValueCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n get error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n get newest data : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;getValue(getValueCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"setValue\"><a href=\"#setValue\" class=\"headerlink\" title=\"setValue()\"></a>setValue()</h2><p> 定义</p>\n<p>int setValue(const char *p_data,CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>设置Wilddog引用所对应的节点的值。</p>\n<p> 参数</p>\n<ul>\n<li>p_data <code>const char*</code> : 准备设置的节点的值，json字符串格式。</li>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为NULL，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setValueCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n set error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(error &gt;= <span class=\"number\">200</span> &amp;&amp; error &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n set data success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;setValue(<span class=\"string\">\"&#123;\\\"pin13\\\":\\\"1\\\"&#125;\"</span>, setValueCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2><p> 定义</p>\n<p>int push(const char *p_data,CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>在当前节点下增加一个节点，节点的值由传入的参数决定，设置成功后返回节点的path。节点的key由服务器随机生成。</p>\n<p> 参数</p>\n<ul>\n<li>p_data <code>const char*</code> : 节点的值，为json字符串。</li>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为创建的节点的path，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void *</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushValueCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n push error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n new data path : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;push(<span class=\"string\">\"&#123;\\\"pin13\\\":\\\"1\\\"&#125;\"</span>, pushValueCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"removeValue\"><a href=\"#removeValue\" class=\"headerlink\" title=\"removeValue()\"></a>removeValue()</h2><p> 定义</p>\n<p>int removeValue(CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>删除当前节点的值。</p>\n<p> 参数</p>\n<ul>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为NULL，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n remove error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(error &gt;= <span class=\"number\">200</span> &amp;&amp; error &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n remove success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;removeValue(removeCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"addObserver\"><a href=\"#addObserver\" class=\"headerlink\" title=\"addObserver()\"></a>addObserver()</h2><p> 定义</p>\n<p>int addObserver(Wilddog_EventType_T event,CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>监听节点下的某个事件（如数据变化）,事件触发后，回调函数会被调用。</p>\n<p> 参数</p>\n<ul>\n<li>event <code>Wilddog_EventType_T</code> : 事件类型（目前只能设为1）。</li>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>是返回的数据，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserverCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n observe error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n get newest data : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver()\"></a>removeObserver()</h2><p> 定义</p>\n<p>int removeObserver(Wilddog_EventType_T event)</p>\n<p> 说明</p>\n<p>取消监听事件。</p>\n<p> 参数</p>\n<ul>\n<li><p>event <code>Wilddog_EventType_T</code> : 事件类型（目前只能设为1）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> observed = FALSE;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserverCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n observe error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n get newest data : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//set var observed to TRUE</span></div><div class=\"line\">        *(<span class=\"keyword\">int</span>*)arg = TRUE;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(<span class=\"keyword\">void</span>*)&amp;observed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(observed == TRUE)&#123;</div><div class=\"line\">            ref-&gt;removeObserver(WD_ET_VALUECHANGE);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"trySync\"><a href=\"#trySync\" class=\"headerlink\" title=\"trySync()\"></a>trySync()</h2><p> 定义</p>\n<p>void trySync()</p>\n<p> 说明</p>\n<p>通过调用wilddog_trySync来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，以及触发用户注册的回调函数。</p>\n<p> 返回值</p>\n<p>无。</p>\n<p> 示例</p>\n<p>见上面示例。</p>\n<hr>\n<h1 id=\"AuthData-Methods\"><a href=\"#AuthData-Methods\" class=\"headerlink\" title=\"AuthData (Methods)\"></a>AuthData (<em>Methods</em>)</h1><h2 id=\"auth\"><a href=\"#auth\" class=\"headerlink\" title=\"auth()\"></a>auth()</h2><p> 定义</p>\n<p>int auth(const char *p_auth,const char *p_host,CallBackFunc onAuth,void *arg)</p>\n<p> 说明</p>\n<p>发送auth数据到服务器进行认证。</p>\n<p> 参数</p>\n<ul>\n<li>p_auth <code>const char*</code> : auth数据，字符串类型。</li>\n<li>p_host <code>const char*</code> : 节点的host（如appid.wilddogio.com）。</li>\n<li>onAuth <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为NULL，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">authCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n auth error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(error &gt;= <span class=\"number\">200</span> &amp;&amp; error &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n auth success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;auth(<span class=\"string\">\"token data\"</span>, <span class=\"string\">\"&lt;appId&gt;.wilddogio.com\"</span>, authCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"new-Wilddog\"><a href=\"#new-Wilddog\" class=\"headerlink\" title=\"new Wilddog\"></a>new Wilddog</h2><p> 定义</p>\n<p>new Wilddog(wilddogUrl)</p>\n<p> 说明</p>\n<p>初始化URL对应的节点引用。</p>\n<p> 参数</p>\n<ul>\n<li><p>wilddogUrl <code>string</code> : 应用URL，如：https://<appId>.wilddogio.com</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>Wilddog 对象的引用。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"getValue\"><a href=\"#getValue\" class=\"headerlink\" title=\"getValue()\"></a>getValue()</h2><p> 定义</p>\n<p>int getValue(CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>获取Wilddog引用所对应的节点的值。</p>\n<p> 参数</p>\n<ul>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>是返回的数据，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getValueCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n get error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n get newest data : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;getValue(getValueCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"setValue\"><a href=\"#setValue\" class=\"headerlink\" title=\"setValue()\"></a>setValue()</h2><p> 定义</p>\n<p>int setValue(const char *p_data,CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>设置Wilddog引用所对应的节点的值。</p>\n<p> 参数</p>\n<ul>\n<li>p_data <code>const char*</code> : 准备设置的节点的值，json字符串格式。</li>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为NULL，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setValueCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n set error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(error &gt;= <span class=\"number\">200</span> &amp;&amp; error &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n set data success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;setValue(<span class=\"string\">\"&#123;\\\"pin13\\\":\\\"1\\\"&#125;\"</span>, setValueCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2><p> 定义</p>\n<p>int push(const char *p_data,CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>在当前节点下增加一个节点，节点的值由传入的参数决定，设置成功后返回节点的path。节点的key由服务器随机生成。</p>\n<p> 参数</p>\n<ul>\n<li>p_data <code>const char*</code> : 节点的值，为json字符串。</li>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为创建的节点的path，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void *</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushValueCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n push error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n new data path : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;push(<span class=\"string\">\"&#123;\\\"pin13\\\":\\\"1\\\"&#125;\"</span>, pushValueCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"removeValue\"><a href=\"#removeValue\" class=\"headerlink\" title=\"removeValue()\"></a>removeValue()</h2><p> 定义</p>\n<p>int removeValue(CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>删除当前节点的值。</p>\n<p> 参数</p>\n<ul>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为NULL，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n remove error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(error &gt;= <span class=\"number\">200</span> &amp;&amp; error &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n remove success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;removeValue(removeCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"addObserver\"><a href=\"#addObserver\" class=\"headerlink\" title=\"addObserver()\"></a>addObserver()</h2><p> 定义</p>\n<p>int addObserver(Wilddog_EventType_T event,CallBackFunc f_callback,void *arg)</p>\n<p> 说明</p>\n<p>监听节点下的某个事件（如数据变化）,事件触发后，回调函数会被调用。</p>\n<p> 参数</p>\n<ul>\n<li>event <code>Wilddog_EventType_T</code> : 事件类型（目前只能设为1）。</li>\n<li>f_callback <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>是返回的数据，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg 用户自定义参数（可为NULL）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserverCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n observe error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n get newest data : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver()\"></a>removeObserver()</h2><p> 定义</p>\n<p>int removeObserver(Wilddog_EventType_T event)</p>\n<p> 说明</p>\n<p>取消监听事件。</p>\n<p> 参数</p>\n<ul>\n<li><p>event <code>Wilddog_EventType_T</code> : 事件类型（目前只能设为1）。</p>\n<p>返回</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> observed = FALSE;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserverCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n observe error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(pdata)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n get newest data : \"</span>);</div><div class=\"line\">        Serial.print(pdata);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//set var observed to TRUE</span></div><div class=\"line\">        *(<span class=\"keyword\">int</span>*)arg = TRUE;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;addObserver(WD_ET_VALUECHANGE,addObserverCallBack,(<span class=\"keyword\">void</span>*)&amp;observed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(observed == TRUE)&#123;</div><div class=\"line\">            ref-&gt;removeObserver(WD_ET_VALUECHANGE);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"trySync\"><a href=\"#trySync\" class=\"headerlink\" title=\"trySync()\"></a>trySync()</h2><p> 定义</p>\n<p>void trySync()</p>\n<p> 说明</p>\n<p>通过调用wilddog_trySync来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，以及触发用户注册的回调函数。</p>\n<p> 返回值</p>\n<p>无。</p>\n<p> 示例</p>\n<p>见上面示例。</p>\n<hr>\n<h1 id=\"AuthData-Methods\"><a href=\"#AuthData-Methods\" class=\"headerlink\" title=\"AuthData (Methods)\"></a>AuthData (<em>Methods</em>)</h1><h2 id=\"auth\"><a href=\"#auth\" class=\"headerlink\" title=\"auth()\"></a>auth()</h2><p> 定义</p>\n<p>int auth(const char *p_auth,const char *p_host,CallBackFunc onAuth,void *arg)</p>\n<p> 说明</p>\n<p>发送auth数据到服务器进行认证。</p>\n<p> 参数</p>\n<ul>\n<li>p_auth <code>const char*</code> : auth数据，字符串类型。</li>\n<li>p_host <code>const char*</code> : 节点的host（如appid.wilddogio.com）。</li>\n<li>onAuth <code>CallBackFunc</code> : 服务端回应数据或者回应超时触发的回调函数, 类型是<code>void (*CallBackFunc)(const char *pdata, int error, void* arg)</code>，其中<code>pdata</code>为NULL，<code>error</code>是返回码，<code>arg</code>是用户传入的自定义参数。</li>\n<li><p>arg <code>void*</code> : 用户自定义参数（可为NULL）。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>int</code> : 返回 0:成功 &lt;0:失败，注意，这里指的成功失败仅指是否成功加入发送队列。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">authCallBack</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pdata, <span class=\"keyword\">int</span> error, <span class=\"keyword\">void</span>* arg)</span></span>&#123;</div><div class=\"line\">    Serial.print(<span class=\"string\">\"\\n auth error : \"</span>);</div><div class=\"line\">    Serial.print(error);</div><div class=\"line\">    <span class=\"keyword\">if</span>(error &gt;= <span class=\"number\">200</span> &amp;&amp; error &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        Serial.print(<span class=\"string\">\"\\n auth success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Wilddog *ref = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ... <span class=\"comment\">// other codes, such as serial init, bridge init</span></div><div class=\"line\">    </div><div class=\"line\">    ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a/b/c\"</span>);</div><div class=\"line\">    ref-&gt;auth(<span class=\"string\">\"token data\"</span>, <span class=\"string\">\"&lt;appId&gt;.wilddogio.com\"</span>, authCallBack,(<span class=\"keyword\">void</span>*)<span class=\"literal\">NULL</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ref)</div><div class=\"line\">        ref-&gt;trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"C/OpenWRT API 文档","_content":"\n# Wilddog (*Methods*)\n\n## wilddog\\_initWithUrl()\n\n定义\n\nWilddog\\_T wilddog\\_initWithUrl(Wilddog\\_Str\\_T \\*url)\n\n说明\n\n初始化应用 URL 对应的 Wilddog 引用。\n\n参数\n* Wilddog\\_Str\\_T *`url` : 应用URL。Wilddog 中任何数据都能够通过一个URL来进行访问，如`coap[s]://<appId>.wilddogio.com/<path>` \n其中<appId\\>为开发者在 Wilddog 平台申请的应用id。\n<path\\>为客户端关注的路径。\n\n返回值\n\n`Wilddog_T` 类型Wilddog引用的id，如果创建失败，返回0。\n\n示例\n```c \nint main(){\n    //初始化引用\n    Wilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy/device/light/10abcde\");\n\n    //do something\n    ...\n\n    //销毁引用\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_destroy()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_destroy(Wilddog\\_T \\*p\\_wilddog)\n\n说明\n\n销毁一个引用并回收内存。\n \n参数\n\n* p_wilddog `Wilddog_T* ` : 当前节点引用id的地址。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败。\n\n示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//销毁引用\nwilddog_destroy(&wilddog);\n```\n----\n\n## wilddog\\_getValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_getValue(Wilddog\\_T wilddog, onQueryFunc callback, void* arg)\n\n说明\n\n获取当前节点的数据,数据格式为`Wilddog_Node_T`(类似JSON)。\n \n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onQueryFunc` : 服务端回应数据或者回应超时触发的回调函数,类型是`void (*onQueryFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)`,其中`p_snapshot`是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, `arg`为用户传递的值, `err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n \n示例\n```c\nSTATIC void onQueryCallback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    if(err != WILDDOG_HTTP_OK){\n        wilddog_debug(\"query error!\");\n        return;\n    }\n    wilddog_debug(\"query success!\");\n    if(p_snapshot){\n        *(Wilddog_Node_T**)arg = wilddog_node_clone(p_snapshot);\n    }\n    return;\n}\nint main(void){\n    Wilddog_T wilddog = 0;\n\n    //用户自定义参数，这里的用途为：将云端发回的数据clone到本地\n    Wilddog_Node_T * p_node = NULL;\n\n    //<url>即希望获取数据的url，如https://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_getValue返回值的检查\n    wilddog_getValue(wilddog, onQueryCallback, (void*)(&p_node));\n\n    while(1){\n        if(p_node){\n\n            //打印得到的节点数据\n            _wilddog_debug_printnode(p_node);\n            ...\n            wilddog_node_delete(p_node);\n        }\n        wilddog_trySync();\n    }\n    ...\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog\\_setValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_setValue(Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onSetFunc callback, void \\*arg)\n\n 说明\n\n设置当前节点的数据,数据格式为`Wilddog_Node_T`。\n \n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T` : 指向节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onSetFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`void (*onSetFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"set error!\");\n        return;\n    }\n    wilddog_debug(\"set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL;\n\n    /* create a node to \"wilddog\", value is \"123456\" */\n    p_node = wilddog_node_createUString(NULL,\"123456\");\n\n    //<url>即希望设置数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_setValue返回值的检查\n    wilddog_setValue(wilddog, p_node, onSetCallback, (void*)&isFinish);\n\n    //数据已经设置到云端，删除刚才建立的节点\n    wilddog_node_delete(p_node);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            ...\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog\\_push()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_push( Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onPushFunc callback, void \\*arg)\n说明\n\n在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成。\n\n参数 \n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T*` : 指向新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onPushFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onPushFunc)(Wilddog_Str_T * p_newPath, void* arg, Wilddog_Return_T err)`,其中 `p_newPath` 是新增节点的完整路径,`arg` 为用户传递的值,`err` 为状态码。 \n* arg `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n```c\nSTATIC void onPushCallback(u8 *p_path,void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"push failed\");\n        return;\n    }\n    wilddog_debug(\"new path is %s\", p_path);\n    *(BOOL*)arg = TRUE;\n    return;\n}\n\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL, *p_head = NULL;\n\n    //建立一个object节点，即类似json中的{}\n    p_head = wilddog_node_createObject(NULL);\n\n    //建立一个key为2，value为数字1234的节点\n    p_node = wilddog_node_createNum(\"2\",1234);\n\n    //将节点p_node添加到object中\n    wilddog_node_addChild(p_head, p_node);\n    \n    //<url>即希望推送数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //把新的object推送到云端\n    //注意，这里省略了对wilddog_push返回值的检查\n    wilddog_push(wilddog, p_head, onPushCallback, (void *)&isFinish);\n\n    //数据已经推送，删除刚才建立的节点\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(isFinish){\n            wilddog_debug(\"push success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_removeValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_removeValue(Wilddog\\_T wilddog, onRemoveFunc callback, void \\*arg)\n\n说明\n\n删除当前节点及节点下所有数据。\n\n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onRemoveFunc` : 服务器回应或者回应超时触发的回调函数，类型是`void (*onRemoveFunc)(void* arg, Wilddog_Return_T err)`,其中`arg` 为用户传递的值,`err` 为状态码。\n* arg `void*` : 用户传给回调函数的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onDeleteCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"delete failed!\");\n        return;\n    }\n    wilddog_debug(\"delete success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog;\n\n    //<url>即希望删除数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_removeValue返回值的检查\n    wilddog_removeValue(wilddog, onDeleteCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"remove success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_addObserver()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_addObserver(Wilddog\\_T wilddog, Wilddog\\_EventType\\_T event, onEventFunc onDataChange, void \\*dataChangeArg)\n\n说明\n\n监听某节点的数据变化。一旦该数据发生改变, `onDataChange`函数将被调用。\n\n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* event `Wilddog\\_EventType\\_T ` : 关注的事件类型，见`Wilddog_EventType_T`定义。\n* onDataChange `onEventFunc` : 数据变化所触发的回调函数，类型是`(*onEventFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)`,其中`p_snapshot`是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, `arg`为用户传递的值, `err`为状态码。 \n* dataChangeArg `void*` : 传给回调函数的`arg`。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n```c\nSTATIC void onObserverCallback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    if(err != WILDDOG_HTTP_OK){\n        wilddog_debug(\"observe failed!\");\n        return;\n    }\n    wilddog_debug(\"observe data!\");\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog = 0;\n    STATIC int count = 0;\n\n    //<url>即希望订阅数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_addObserver返回值的检查\n    wilddog_addObserver(wilddog, WD_ET_VALUECHANGE, onObserverCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            //每次接收到推送count + 1\n            wilddog_debug(\"get new data %d times!\", count++);\n\n            //重新设置接收状态为FALSE\n            isFinished = FALSE;\n\n            //count 超过10时，调用wilddog_removeObserver取消订阅，并退出\n            if(count > 10){\n                wilddog_debug(\"off the data!\");\n                wilddog_removeObserver(wilddog, WD_ET_VALUECHANGE);\n                break;\n            }\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_removeObserver()\n定义\n\nWilddog\\_Return\\_T wilddog\\_removeObserver(Wilddog\\_T \\*p\\_wilddog, Wilddog\\_EventType\\_T event)\n\n说明\n\n取消对某节点的监听(对应于on)。\n\n参数\n\n* p_wilddog `Wilddog_T*` : 当前节点引用的id。\n* event `Wilddog_EventType_T` : 取消的事件类型。\n\n返回值\n\n`Wilddog_Return_T`返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n\n见wilddog\\_addObserver的示例。\n\n----\n\n## wilddog\\_onDisconnectSetValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_onDisconnectSetValue(Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n当该客户端离线时，云端自动执行该操作，设置当前节点的数据，数据格式为`Wilddog_Node_T`。\n \n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T` : 指向离线时设置的节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`void (*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline set error!\");\n        return;\n    }\n    wilddog_debug(\"offline set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL;\n\n    /* create a node to \"wilddog\", value is \"123456\" */\n    p_node = wilddog_node_createUString(NULL,\"123456\");\n\n    //<url>即希望设置数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查\n    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (void*)&isFinish);\n    wilddog_node_delete(p_node);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            ...\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog\\_onDisconnectPush()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_onDisconnectPush( Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n当该客户端离线时，云端自动执行该操作，在当前节点下生成一个子节点。子节点的key利用服务端的当前时间生成。\n\n参数 \n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T*` : 指向离线时新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onPushCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline push failed\");\n        return;\n    }\n    wilddog_debug(\"offline push success\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL, *p_head = NULL;\n    p_head = wilddog_node_createObject(NULL);\n    p_node = wilddog_node_createNum(\"2\",1234);\n    wilddog_node_addChild(p_head, p_node);\n    \n    //<url>即希望推送数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_onDisconnectPush返回值的检查\n    wilddog_onDisconnectPush(wilddog, p_head, onPushCallback, (void *)&isFinish);\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(isFinish){\n            wilddog_debug(\"push success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_onDisconnectRemoveValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_onDisconnectRemoveValue(Wilddog\\_T wilddog, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n当该客户端离线时，云端自动执行该操作，删除当前节点及节点下所有数据。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onDeleteCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline delete failed!\");\n        return;\n    }\n    wilddog_debug(\"offline delete success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog = 0;\n\n    //<url>即希望删除数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_onDisconnectRemoveValue返回值的检查\n    wilddog_onDisconnectRemoveValue(wilddog, onDeleteCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"remove success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_cancelDisconnectOperations()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_cancelDisconnectOperations(Wilddog\\_T wilddog, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n取消之前设置的离线事件。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onCancelCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline operation cancel failed!\");\n        return;\n    }\n    wilddog_debug(\"offline operation cancel success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog = 0;\n\n    //<url>即希望删除数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_cancelDisconnectOperations返回值的检查\n    wilddog_cancelDisconnectOperations(wilddog, onCancelCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"operation cancel success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog_goOffline()\n\n 定义\n\nvoid wilddog_goOffline(void)\n\n说明\n\n通过调用`wilddog_goOffline` 断开客户端和云端的连接，之前若注册了离线事件则云端会触发断线事件。\n\n 返回值\n\nvoid\n\n----\n## wilddog_goOnline()\n\n 定义\n\nvoid wilddog_goOnline(void)\n\n说明\n\n通过调用`wilddog_goOnline` 若客户端处于离线状态，则重新连接云端服务，之前若注册了监听事件，则 SDK 回重新发送监听请求，这时候需要注意监听回调的触发并非代表云端数据有修改，而重连时获取的数据。\n\n 返回值\n\nvoid\n\n----\n\n## wilddog\\_trySync()\n\n 定义\n\nvoid wilddog\\_trySync(void)\n\n说明\n\n通过调用`wilddog_trySync`来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，触发用户注册的回调函数。\n\n 返回值\n\nvoid\n\n----\n\n## wilddog\\_increaseTime()\n\n定义\n\nvoid wilddog\\_increaseTime(u32 ms)。\n\n 说明\n\n用于校准 Wilddog 的时钟(可以在定时器中调用)。一般情况下 Wilddog 会根据自己推算的时间执行业务操作，这个时间的推算会有偏差，我们可以通过传入一个时间增量来校准 Wilddog 时钟。\n\n 参数\n\n* ms `u32 ` : 增加的时间(单位为毫秒)。\n\n 返回值\n\nvoid\n\n 示例\n```c\nvoid timer_isr()\n{\n    //this isr is been called per ms。\n\n    wilddog_increaseTime(1);\n}\n```\n----\n# Wilddog(*Properties*)\n\n## wilddog\\_getParent()\n\n 定义\n\nWilddog\\_T wilddog\\_getParent(Wilddog\\_T wilddog)\n\n 说明\n\n获取父节点引用的id。如果当前节点是root节点，创建失败，返回0。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n\n 返回值\n\n返回父节点引用的id，如果创建失败，返回0。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//定位到user\nWilddog_T parent = wilddog_getParent(wilddog);\n```\n----\n## wilddog\\_getRoot()\n\n 定义\n\nWilddog\\_T wilddog\\_getRoot(Wilddog\\_T wilddog)\n\n 说明\n\n获取根节点引用的id。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n\n 返回值\n\nWilddog\\_T `root` : 根节点引用的id，如果失败，返回0。 \n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//定位到root(\"/\")\nWilddog_T root = wilddog_getRoot(wilddog);\n```\n----\n\n## wilddog\\_getChild()\n\n 定义\n\nWilddog\\_T wilddog\\_getChild(Wilddog\\_T wilddog, Wilddog\\_Str\\_T \\*childName)\n\n 说明\n\n获取当前引用下名字为childName的子节点引用的id。\n\n 参数\n\nwilddog `Wilddog_T` : 当前引用的id。\n\nchildName `Wilddog_Str_T*` : 子节点的相对路径，多级子节点需用'/'隔开，即使子节点不存在也能创建。\n\n 返回值\n\n`Wilddog_T` 子节点引用的id，如果创建失败，返回0。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//定位到user/jackxy/aaa\nWilddog_T child = wilddog_getChild(wilddog, \"aaa\");\n```\n----\n\n## wilddog\\_getKey()\n\n 定义\n\nWilddog\\_Str\\_T \\*wilddog\\_getKey(Wilddog\\_T wilddog)\n\n 说明\n\n获取当前引用的key。\n\n 参数\n\nwilddog `Wilddog_T` : 当前引用的id。\n\n 返回值\n\n`Wilddog_Str_T` 当前引用的key值，如果获取失败，返回NULL。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//获取Key值（即jackxy）\nWilddog_Str_T *key = wilddog_getKey(wilddog);\n```\n----\n\n## wilddog\\_getHost()\n\n 定义\n\nWilddog\\_Str\\_T \\*wilddog\\_getHost(Wilddog\\_T wilddog)\n\n 说明\n\n获取当前引用的host。\n\n 参数\n\nwilddog `Wilddog_T` : 当前引用的id。\n\n 返回值\n\n`Wilddog_Str_T` 当前引用的host，如果获取失败，返回NULL。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//获取host（即<appId>.wilddogio.com）\nWilddog_Str_T *host = wilddog_getHost(wilddog);\n```\n----\n\n## wilddog\\_getPath()\n\n 定义\n\nWilddog\\_Str\\_T \\*wilddog\\_getPath(Wilddog\\_T wilddog)\n\n 说明\n\n 获取当前节点的path。\n\n 参数\n\nwilddog `Wilddog_T` : 当前节点的引用id。\n\n 返回值\n\n`Wilddog_Str_T` 当前引用的path，如果获取失败，返回NULL。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//获取path（即/user/jackxy）\nWilddog_Str_T *path = wilddog_getPath(wilddog);\n```\n----\n\n# Node(*Methods*)\n\n##wilddog\\_node\\_createObject()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createObject(Wilddog_Str\\_T \\*key)\n\n 说明\n\n创建一个 Object 类型的节点，Object 类型的节点，通俗的来说就是非叶子节点，这种类型的节点的子节点就是它们的值。\n\n 参数\n\n* key `Wilddog_Str_T* ` : 节点的key值。\n\n 返回值\n\n创建成功则返回该节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\n```\n\n----\n\n## wilddog\\_node\\_createUString()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createUString(Wilddog\\_Str\\_T \\*key, Wilddog\\_Str\\_T \\*value)\n\n 说明\n\n创建一个字符串类型节点。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n* value `Wilddog_Str_T*` : 指向utf-8字符串的指针。\n\n 返回值\n\n`Wilddog_Node_T` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createUString((Wilddog_Str_T *)\"this is key\",(Wilddog_Str_T *)\"this is value\");\n```\n\n----\n\n##wilddog\\_node\\_createBString()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createBString(Wilddog\\_Str\\_T \\*key, u8 \\*value, int len)\n\n 说明\n\n创建一个二进制数组类型节点。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n* value `u8*` : 二进制数组的指针。\n* len `int` : 数据的长度(字节)。\n\n 返回值\n\n`Wilddog_Node_T*` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nu8 data[8] = {0};\n...\nWilddog_Node_T *p_node = wilddog_node_createBString((Wilddog_Str_T *)\"this is key\", data, 8);\n```\n\n----\n\n## wilddog\\_node\\_createFloat()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createFloat(Wilddog\\_Str\\_T \\*key, wFloat num)\n\n 说明\n\n创建一个浮点类型的节点。\n\n 参数\n\n* key `Wilddog_Str_T *` : 节点的key值。\n* num `wFloat` : 浮点数据(8位机器为32bits, 其他为64bits)。\n\n 返回值\n\n`Wilddog_Node_T *` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nwFloat data = 1.234;\nWilddog_Node_T *p_node = wilddog_node_createFloat((Wilddog_Str_T *)\"this is key\", data);\n```\n\n----\n\n## wilddog\\_node\\_createNum()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createNum(Wilddog\\_Str\\_T \\*key, s32 num)\n\n 说明\n\n创建一个整数类型节点，只支持32位整型。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n* num `s32` : 32位有符号整数。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\ns32 data = 1;\nWilddog_Node_T *p_node = wilddog_node_createNum((Wilddog_Str_T *)\"this is key\", data);\n```\n\n----\n\n## wilddog\\_node\\_createNull()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createNull(Wilddog\\_Str\\_T \\*key)。\n\n 说明\n\n创建一个Null类型节点，对应到JSON中即其值为 null 。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createNull((Wilddog_Str_T *)\"this is key\");\n```\n\n----\n\n## wilddog\\_node\\_createTrue()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createTrue(Wilddog\\_Str\\_T \\*key)。\n\n 说明\n\n创建一个TRUE类型节点，对应到JSON中即其值为 true。\n\n 参数\n\n* key ` Wilddog_Str_T*` : 节点的key值。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createTrue((Wilddog_Str_T *)\"this is key\");\n```\n\n----\n\n## wilddog\\_node\\_createFalse()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createFalse(Wilddog\\_Str\\_T \\*key)。\n\n 说明\n\n创建一个FALSE类型节点，对应到JSON中即其值为 false。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\n```\n\n----\n\n## wilddog\\_node\\_addChild()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_node\\_addChild(Wilddog\\_Node\\_T \\*parent, Wilddog\\_Node\\_T \\*child)。\n\n 说明\n\n向一个节点添加子节点，成功后，child 节点成为父节点 parent 的子节点，parent 节点可以通过`parent->p_wn_child`或者`parent->p_wn_child->p_wn_next`（可能有多次`p_wn_next`，由 parent 节点的组成决定）的链表顺序查找方式找到。\n\n 参数\n\n* parent `Wilddog_Node_T*` : 指向父节点的指针，如果父节点不是 Object 类型，会自动转换为 Object 类型，原有的值会丢失。\n* child `Wilddog_Node_T*` : 指向要添加的子节点的指针。\n\n 返回值\n\n`Wilddog_Return_T` 成功返回 `0`, 失败返回 `<0`的值。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n```\n\n----\n\n## wilddog\\_node\\_delete()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_node\\_delete( Wilddog\\_Node\\_T \\*head)\n\n 说明\n\n删除节点及其所有子节点。\n\n 参数\n\n* head `Wilddog_Node_T*` : 要删除节点的指针。\n\n 返回值\n\n`Wilddog_Return_T` 成功返回 `0`, 失败返回 `<0`的值。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n\nwilddog_node_delete(p_father); //会将 p_father 和子节点 p_child 全部删除\n```\n\n----\n\n## wilddog\\_node\\_clone()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_clone( Wilddog\\_Node\\_T \\*head)\n\n 说明\n\n拷贝当前节点及其下所有子节点。\n\n 参数\n\n* head `Wilddog_Node_T*` : 指向节点的指针。\n\n 返回值\n\n`Wilddog_Node_T` 成功返回当前节点副本的指针, 失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n\nWilddog_Node_T *p_clone = wilddog_node_clone(p_father); //会复制一个一模一样的副本，需要单独调用wilddog_node_delete 释放\n```\n\n----\n\n## wilddog\\_node\\_find()\n\n 定义\n\nWilddog\\_Node\\_T \\*wilddog\\_node\\_find( Wilddog\\_Node\\_T \\*root, char \\*path)\n\n 说明\n\nroot中查找相对路径下的节点。\n\n 参数\n\n* root `Wilddog_Node_T*` : 指向根节点的指针。\n* path `char*` : 指向相对路径的指针。\n\n 返回值\n\n`Wilddog_Node_T` 成功返回节点指针, 失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n\nWilddog_Node_T *p_find = wilddog_node_find(p_father, \"this is key\"); //p_find和p_child是同一个节点\n```\n\n----\n\n## wilddog\\_node\\_getValue()\n\n 定义\n\nWilddog\\_Str\\_T* wilddog\\_node\\_getValue(Wilddog\\_Node\\_T \\*node, int \\*len)\n\n 说明\n\n获取当前节点的value值，其中，值为true，false，null的节点无法通过这种方式获取，而应该直接根据节点的`d_wn_type`得出其类型，类型在`wildog.h`中定义。\n\n 参数\n\n* node `Wilddog_Node_T*` : 指向节点的指针。\n* len `int*` : 输出参数，将存储value值的长度(字节)。\n\n 返回值\n\n`Wilddog_Node_T` 成功返回指向节点value的指针(可根据type和传出的len来转化)，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)\"this is key\",234);\nint len = 0;\ns32 value;\nWilddog_Str_T *p_data = wilddog_node_getValue(p_father, &len); //len 应和sizeof(s32)相同\nvalue = (s32)(*p_data);\n```\n\n----\n\n## wilddog\\_node\\_setValue()\n\n 定义\n\nWilddog\\_Return\\_T (Wilddog\\_Node\\_T \\*node, u8 \\*value, int len)\n\n 说明\n\n设置当前节点的value值,其中，值为true，false，null的节点无法通过这种方式设置，整数类型和浮点类型的节点，len 应该为`sizeof(s32)`和`sizeof(wFloat)`。\n\n 参数\n\n* node `Wilddog_Node_T*` : 指向节点的指针。\n* value `u8*` : 指向新value值的指针。\n* len `int` : 新value的长度。\n\n 返回值\n\n`Wilddog_Return_T` 成功返回 `0`, 失败返回 `<0` 的数。\n\n 示例\n```c\nWilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)\"this is key\",234);\nint len = sizeof(s32);\ns32 value = 456;\nwilddog_node_setValue(p_father, &value, len);\n```\n\n----\n# AuthData (*Methods*)\n\n## wilddog\\_auth()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_auth(Wilddog\\_Str\\_T \\*p\\_host, u8 \\*p\\_auth, int len, onAuthFunc onAuth, void \\*args)\n\n 说明\n\n发送auth数据到服务器进行认证，每个 host 只需要认证一次。\n\n 参数\n\np_host `Wilddog_Str_T` : 进行auth认证的host字符串，如 `\"<appId>.wilddogio.com\"`。\n\np_auth `u8*` : 指向auth数据的指针，auth 数据可以使用其他端 sdk 的 token，或者[通过 wilddog token 生成器生成](https://z.wilddog.com/rule/guide#5-zi-ding-yi-token0)。\n\nint `len` : auth数据的长度。\n\nonAuthFunc `onAuth` : 服务端回应认证或者认证超时触发的回调函数，类型是`void (*onAuthFunc)(void* arg, Wilddog_Return_T err)`，其中`arg`为用户传递的值，（即下面的`args`），`err`为状态码，具体见`Wilddog_Return_T`定义。\n\nargs `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，确认是否在云端认证成功需要在回调函数中判断。\n\n 示例\n```c\nvoid myOnAuthFunc(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_ERR_NOERR || err >= WILDDOG_HTTP_BAD_REQUEST){\n        printf(\"auth fail!\\n\");\n        return;\n    }\n    printf(\"auth success! %d\\n\", *(int*)arg);\n    return;\n}\n\n//aquired a new auth token\nchar* newToken=\"ABCD1234567890\";\n\nwilddog_auth(\"aaa.wilddogio.com\", newToken, strlen(newToken), myOnAuthFunc, NULL);\n...\n```\n----\n\n## wilddog\\_unauth()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_unauth(Wilddog\\_Str\\_T \\*p\\_host, onAuthFunc onAuth, void \\*args)\n\n 说明\n\n取消和服务器的auth认证，，每个 host 只需要取消认证一次。\n\n 参数\n\np_host `Wilddog_Str_T` : 进行auth认证的host字符串，如 `\"<appId>.wilddogio.com\"`。\n\nonAuthFunc `onAuth` : 服务端回应认证或者认证超时触发的回调函数，类型是`void (*onAuthFunc)(void* arg, Wilddog_Return_T err)`，其中`arg`为用户传递的值，（即下面的`args`），`err`为状态码，具体见`Wilddog_Return_T`定义。\n\nargs `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，是否成功取消认证需要在回调函数中判断。\n\n 示例\n```c\nvoid myOnAuthFunc(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_ERR_NOERR || err >= WILDDOG_HTTP_BAD_REQUEST){\n        printf(\"auth fail!\\n\");\n        return;\n    }\n    printf(\"hello world! %d\\n\", (int)arg);\n    return;\n}\n\nwilddog_unauth(\"aaa.wilddogio.com\", myOnAuthFunc, NULL);\n...\n```\n","source":"api/sync/c.md","raw":"title:  C/OpenWRT API 文档\n---\n\n# Wilddog (*Methods*)\n\n## wilddog\\_initWithUrl()\n\n定义\n\nWilddog\\_T wilddog\\_initWithUrl(Wilddog\\_Str\\_T \\*url)\n\n说明\n\n初始化应用 URL 对应的 Wilddog 引用。\n\n参数\n* Wilddog\\_Str\\_T *`url` : 应用URL。Wilddog 中任何数据都能够通过一个URL来进行访问，如`coap[s]://<appId>.wilddogio.com/<path>` \n其中<appId\\>为开发者在 Wilddog 平台申请的应用id。\n<path\\>为客户端关注的路径。\n\n返回值\n\n`Wilddog_T` 类型Wilddog引用的id，如果创建失败，返回0。\n\n示例\n```c \nint main(){\n    //初始化引用\n    Wilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy/device/light/10abcde\");\n\n    //do something\n    ...\n\n    //销毁引用\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_destroy()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_destroy(Wilddog\\_T \\*p\\_wilddog)\n\n说明\n\n销毁一个引用并回收内存。\n \n参数\n\n* p_wilddog `Wilddog_T* ` : 当前节点引用id的地址。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败。\n\n示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//销毁引用\nwilddog_destroy(&wilddog);\n```\n----\n\n## wilddog\\_getValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_getValue(Wilddog\\_T wilddog, onQueryFunc callback, void* arg)\n\n说明\n\n获取当前节点的数据,数据格式为`Wilddog_Node_T`(类似JSON)。\n \n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onQueryFunc` : 服务端回应数据或者回应超时触发的回调函数,类型是`void (*onQueryFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)`,其中`p_snapshot`是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, `arg`为用户传递的值, `err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n \n示例\n```c\nSTATIC void onQueryCallback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    if(err != WILDDOG_HTTP_OK){\n        wilddog_debug(\"query error!\");\n        return;\n    }\n    wilddog_debug(\"query success!\");\n    if(p_snapshot){\n        *(Wilddog_Node_T**)arg = wilddog_node_clone(p_snapshot);\n    }\n    return;\n}\nint main(void){\n    Wilddog_T wilddog = 0;\n\n    //用户自定义参数，这里的用途为：将云端发回的数据clone到本地\n    Wilddog_Node_T * p_node = NULL;\n\n    //<url>即希望获取数据的url，如https://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_getValue返回值的检查\n    wilddog_getValue(wilddog, onQueryCallback, (void*)(&p_node));\n\n    while(1){\n        if(p_node){\n\n            //打印得到的节点数据\n            _wilddog_debug_printnode(p_node);\n            ...\n            wilddog_node_delete(p_node);\n        }\n        wilddog_trySync();\n    }\n    ...\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog\\_setValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_setValue(Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onSetFunc callback, void \\*arg)\n\n 说明\n\n设置当前节点的数据,数据格式为`Wilddog_Node_T`。\n \n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T` : 指向节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onSetFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`void (*onSetFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"set error!\");\n        return;\n    }\n    wilddog_debug(\"set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL;\n\n    /* create a node to \"wilddog\", value is \"123456\" */\n    p_node = wilddog_node_createUString(NULL,\"123456\");\n\n    //<url>即希望设置数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_setValue返回值的检查\n    wilddog_setValue(wilddog, p_node, onSetCallback, (void*)&isFinish);\n\n    //数据已经设置到云端，删除刚才建立的节点\n    wilddog_node_delete(p_node);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            ...\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog\\_push()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_push( Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onPushFunc callback, void \\*arg)\n说明\n\n在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成。\n\n参数 \n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T*` : 指向新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onPushFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onPushFunc)(Wilddog_Str_T * p_newPath, void* arg, Wilddog_Return_T err)`,其中 `p_newPath` 是新增节点的完整路径,`arg` 为用户传递的值,`err` 为状态码。 \n* arg `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n```c\nSTATIC void onPushCallback(u8 *p_path,void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"push failed\");\n        return;\n    }\n    wilddog_debug(\"new path is %s\", p_path);\n    *(BOOL*)arg = TRUE;\n    return;\n}\n\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL, *p_head = NULL;\n\n    //建立一个object节点，即类似json中的{}\n    p_head = wilddog_node_createObject(NULL);\n\n    //建立一个key为2，value为数字1234的节点\n    p_node = wilddog_node_createNum(\"2\",1234);\n\n    //将节点p_node添加到object中\n    wilddog_node_addChild(p_head, p_node);\n    \n    //<url>即希望推送数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //把新的object推送到云端\n    //注意，这里省略了对wilddog_push返回值的检查\n    wilddog_push(wilddog, p_head, onPushCallback, (void *)&isFinish);\n\n    //数据已经推送，删除刚才建立的节点\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(isFinish){\n            wilddog_debug(\"push success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_removeValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_removeValue(Wilddog\\_T wilddog, onRemoveFunc callback, void \\*arg)\n\n说明\n\n删除当前节点及节点下所有数据。\n\n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onRemoveFunc` : 服务器回应或者回应超时触发的回调函数，类型是`void (*onRemoveFunc)(void* arg, Wilddog_Return_T err)`,其中`arg` 为用户传递的值,`err` 为状态码。\n* arg `void*` : 用户传给回调函数的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onDeleteCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"delete failed!\");\n        return;\n    }\n    wilddog_debug(\"delete success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog;\n\n    //<url>即希望删除数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_removeValue返回值的检查\n    wilddog_removeValue(wilddog, onDeleteCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"remove success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_addObserver()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_addObserver(Wilddog\\_T wilddog, Wilddog\\_EventType\\_T event, onEventFunc onDataChange, void \\*dataChangeArg)\n\n说明\n\n监听某节点的数据变化。一旦该数据发生改变, `onDataChange`函数将被调用。\n\n参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* event `Wilddog\\_EventType\\_T ` : 关注的事件类型，见`Wilddog_EventType_T`定义。\n* onDataChange `onEventFunc` : 数据变化所触发的回调函数，类型是`(*onEventFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)`,其中`p_snapshot`是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, `arg`为用户传递的值, `err`为状态码。 \n* dataChangeArg `void*` : 传给回调函数的`arg`。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n```c\nSTATIC void onObserverCallback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    if(err != WILDDOG_HTTP_OK){\n        wilddog_debug(\"observe failed!\");\n        return;\n    }\n    wilddog_debug(\"observe data!\");\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog = 0;\n    STATIC int count = 0;\n\n    //<url>即希望订阅数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_addObserver返回值的检查\n    wilddog_addObserver(wilddog, WD_ET_VALUECHANGE, onObserverCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            //每次接收到推送count + 1\n            wilddog_debug(\"get new data %d times!\", count++);\n\n            //重新设置接收状态为FALSE\n            isFinished = FALSE;\n\n            //count 超过10时，调用wilddog_removeObserver取消订阅，并退出\n            if(count > 10){\n                wilddog_debug(\"off the data!\");\n                wilddog_removeObserver(wilddog, WD_ET_VALUECHANGE);\n                break;\n            }\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_removeObserver()\n定义\n\nWilddog\\_Return\\_T wilddog\\_removeObserver(Wilddog\\_T \\*p\\_wilddog, Wilddog\\_EventType\\_T event)\n\n说明\n\n取消对某节点的监听(对应于on)。\n\n参数\n\n* p_wilddog `Wilddog_T*` : 当前节点引用的id。\n* event `Wilddog_EventType_T` : 取消的事件类型。\n\n返回值\n\n`Wilddog_Return_T`返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n\n见wilddog\\_addObserver的示例。\n\n----\n\n## wilddog\\_onDisconnectSetValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_onDisconnectSetValue(Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n当该客户端离线时，云端自动执行该操作，设置当前节点的数据，数据格式为`Wilddog_Node_T`。\n \n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T` : 指向离线时设置的节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`void (*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n 示例\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline set error!\");\n        return;\n    }\n    wilddog_debug(\"offline set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL;\n\n    /* create a node to \"wilddog\", value is \"123456\" */\n    p_node = wilddog_node_createUString(NULL,\"123456\");\n\n    //<url>即希望设置数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查\n    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (void*)&isFinish);\n    wilddog_node_delete(p_node);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            ...\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog\\_onDisconnectPush()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_onDisconnectPush( Wilddog\\_T wilddog, Wilddog\\_Node\\_T \\*p\\_node, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n当该客户端离线时，云端自动执行该操作，在当前节点下生成一个子节点。子节点的key利用服务端的当前时间生成。\n\n参数 \n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* p_node `Wilddog_Node_T*` : 指向离线时新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onPushCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline push failed\");\n        return;\n    }\n    wilddog_debug(\"offline push success\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL, *p_head = NULL;\n    p_head = wilddog_node_createObject(NULL);\n    p_node = wilddog_node_createNum(\"2\",1234);\n    wilddog_node_addChild(p_head, p_node);\n    \n    //<url>即希望推送数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_onDisconnectPush返回值的检查\n    wilddog_onDisconnectPush(wilddog, p_head, onPushCallback, (void *)&isFinish);\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(isFinish){\n            wilddog_debug(\"push success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_onDisconnectRemoveValue()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_onDisconnectRemoveValue(Wilddog\\_T wilddog, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n当该客户端离线时，云端自动执行该操作，删除当前节点及节点下所有数据。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onDeleteCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline delete failed!\");\n        return;\n    }\n    wilddog_debug(\"offline delete success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog = 0;\n\n    //<url>即希望删除数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_onDisconnectRemoveValue返回值的检查\n    wilddog_onDisconnectRemoveValue(wilddog, onDeleteCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"remove success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## wilddog\\_cancelDisconnectOperations()\n\n定义\n\nWilddog\\_Return\\_T wilddog\\_cancelDisconnectOperations(Wilddog\\_T wilddog, onDisConnectFunc callback, void\\* arg)\n\n说明\n\n取消之前设置的离线事件。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n* callback `onDisConnectFunc` : 服务端回应或者回应超时触发的回调函数 ,类型是`(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)`,其中`arg`为用户传递的值,`err`为状态码。\n* arg `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 返回 `0`:成功 `<0`:失败，返回码见`wilddog.h`。\n\n示例\n```c\nSTATIC void onCancelCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline operation cancel failed!\");\n        return;\n    }\n    wilddog_debug(\"offline operation cancel success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog = 0;\n\n    //<url>即希望删除数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(<url>);\n\n    //注意，这里省略了对wilddog_cancelDisconnectOperations返回值的检查\n    wilddog_cancelDisconnectOperations(wilddog, onCancelCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"operation cancel success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n## wilddog_goOffline()\n\n 定义\n\nvoid wilddog_goOffline(void)\n\n说明\n\n通过调用`wilddog_goOffline` 断开客户端和云端的连接，之前若注册了离线事件则云端会触发断线事件。\n\n 返回值\n\nvoid\n\n----\n## wilddog_goOnline()\n\n 定义\n\nvoid wilddog_goOnline(void)\n\n说明\n\n通过调用`wilddog_goOnline` 若客户端处于离线状态，则重新连接云端服务，之前若注册了监听事件，则 SDK 回重新发送监听请求，这时候需要注意监听回调的触发并非代表云端数据有修改，而重连时获取的数据。\n\n 返回值\n\nvoid\n\n----\n\n## wilddog\\_trySync()\n\n 定义\n\nvoid wilddog\\_trySync(void)\n\n说明\n\n通过调用`wilddog_trySync`来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，触发用户注册的回调函数。\n\n 返回值\n\nvoid\n\n----\n\n## wilddog\\_increaseTime()\n\n定义\n\nvoid wilddog\\_increaseTime(u32 ms)。\n\n 说明\n\n用于校准 Wilddog 的时钟(可以在定时器中调用)。一般情况下 Wilddog 会根据自己推算的时间执行业务操作，这个时间的推算会有偏差，我们可以通过传入一个时间增量来校准 Wilddog 时钟。\n\n 参数\n\n* ms `u32 ` : 增加的时间(单位为毫秒)。\n\n 返回值\n\nvoid\n\n 示例\n```c\nvoid timer_isr()\n{\n    //this isr is been called per ms。\n\n    wilddog_increaseTime(1);\n}\n```\n----\n# Wilddog(*Properties*)\n\n## wilddog\\_getParent()\n\n 定义\n\nWilddog\\_T wilddog\\_getParent(Wilddog\\_T wilddog)\n\n 说明\n\n获取父节点引用的id。如果当前节点是root节点，创建失败，返回0。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n\n 返回值\n\n返回父节点引用的id，如果创建失败，返回0。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//定位到user\nWilddog_T parent = wilddog_getParent(wilddog);\n```\n----\n## wilddog\\_getRoot()\n\n 定义\n\nWilddog\\_T wilddog\\_getRoot(Wilddog\\_T wilddog)\n\n 说明\n\n获取根节点引用的id。\n\n 参数\n\n* wilddog `Wilddog_T` : 当前节点引用的id。\n\n 返回值\n\nWilddog\\_T `root` : 根节点引用的id，如果失败，返回0。 \n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//定位到root(\"/\")\nWilddog_T root = wilddog_getRoot(wilddog);\n```\n----\n\n## wilddog\\_getChild()\n\n 定义\n\nWilddog\\_T wilddog\\_getChild(Wilddog\\_T wilddog, Wilddog\\_Str\\_T \\*childName)\n\n 说明\n\n获取当前引用下名字为childName的子节点引用的id。\n\n 参数\n\nwilddog `Wilddog_T` : 当前引用的id。\n\nchildName `Wilddog_Str_T*` : 子节点的相对路径，多级子节点需用'/'隔开，即使子节点不存在也能创建。\n\n 返回值\n\n`Wilddog_T` 子节点引用的id，如果创建失败，返回0。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//定位到user/jackxy/aaa\nWilddog_T child = wilddog_getChild(wilddog, \"aaa\");\n```\n----\n\n## wilddog\\_getKey()\n\n 定义\n\nWilddog\\_Str\\_T \\*wilddog\\_getKey(Wilddog\\_T wilddog)\n\n 说明\n\n获取当前引用的key。\n\n 参数\n\nwilddog `Wilddog_T` : 当前引用的id。\n\n 返回值\n\n`Wilddog_Str_T` 当前引用的key值，如果获取失败，返回NULL。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//获取Key值（即jackxy）\nWilddog_Str_T *key = wilddog_getKey(wilddog);\n```\n----\n\n## wilddog\\_getHost()\n\n 定义\n\nWilddog\\_Str\\_T \\*wilddog\\_getHost(Wilddog\\_T wilddog)\n\n 说明\n\n获取当前引用的host。\n\n 参数\n\nwilddog `Wilddog_T` : 当前引用的id。\n\n 返回值\n\n`Wilddog_Str_T` 当前引用的host，如果获取失败，返回NULL。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//获取host（即<appId>.wilddogio.com）\nWilddog_Str_T *host = wilddog_getHost(wilddog);\n```\n----\n\n## wilddog\\_getPath()\n\n 定义\n\nWilddog\\_Str\\_T \\*wilddog\\_getPath(Wilddog\\_T wilddog)\n\n 说明\n\n 获取当前节点的path。\n\n 参数\n\nwilddog `Wilddog_T` : 当前节点的引用id。\n\n 返回值\n\n`Wilddog_Str_T` 当前引用的path，如果获取失败，返回NULL。\n\n 示例\n```c\n//定位到user/jackxy\nWilddog_T wilddog=wilddog_initWithUrl(\"coaps://<appId>.wilddogio.com/user/jackxy\");\n\n//获取path（即/user/jackxy）\nWilddog_Str_T *path = wilddog_getPath(wilddog);\n```\n----\n\n# Node(*Methods*)\n\n##wilddog\\_node\\_createObject()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createObject(Wilddog_Str\\_T \\*key)\n\n 说明\n\n创建一个 Object 类型的节点，Object 类型的节点，通俗的来说就是非叶子节点，这种类型的节点的子节点就是它们的值。\n\n 参数\n\n* key `Wilddog_Str_T* ` : 节点的key值。\n\n 返回值\n\n创建成功则返回该节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\n```\n\n----\n\n## wilddog\\_node\\_createUString()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createUString(Wilddog\\_Str\\_T \\*key, Wilddog\\_Str\\_T \\*value)\n\n 说明\n\n创建一个字符串类型节点。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n* value `Wilddog_Str_T*` : 指向utf-8字符串的指针。\n\n 返回值\n\n`Wilddog_Node_T` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createUString((Wilddog_Str_T *)\"this is key\",(Wilddog_Str_T *)\"this is value\");\n```\n\n----\n\n##wilddog\\_node\\_createBString()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createBString(Wilddog\\_Str\\_T \\*key, u8 \\*value, int len)\n\n 说明\n\n创建一个二进制数组类型节点。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n* value `u8*` : 二进制数组的指针。\n* len `int` : 数据的长度(字节)。\n\n 返回值\n\n`Wilddog_Node_T*` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nu8 data[8] = {0};\n...\nWilddog_Node_T *p_node = wilddog_node_createBString((Wilddog_Str_T *)\"this is key\", data, 8);\n```\n\n----\n\n## wilddog\\_node\\_createFloat()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createFloat(Wilddog\\_Str\\_T \\*key, wFloat num)\n\n 说明\n\n创建一个浮点类型的节点。\n\n 参数\n\n* key `Wilddog_Str_T *` : 节点的key值。\n* num `wFloat` : 浮点数据(8位机器为32bits, 其他为64bits)。\n\n 返回值\n\n`Wilddog_Node_T *` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nwFloat data = 1.234;\nWilddog_Node_T *p_node = wilddog_node_createFloat((Wilddog_Str_T *)\"this is key\", data);\n```\n\n----\n\n## wilddog\\_node\\_createNum()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createNum(Wilddog\\_Str\\_T \\*key, s32 num)\n\n 说明\n\n创建一个整数类型节点，只支持32位整型。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n* num `s32` : 32位有符号整数。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\ns32 data = 1;\nWilddog_Node_T *p_node = wilddog_node_createNum((Wilddog_Str_T *)\"this is key\", data);\n```\n\n----\n\n## wilddog\\_node\\_createNull()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createNull(Wilddog\\_Str\\_T \\*key)。\n\n 说明\n\n创建一个Null类型节点，对应到JSON中即其值为 null 。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createNull((Wilddog_Str_T *)\"this is key\");\n```\n\n----\n\n## wilddog\\_node\\_createTrue()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createTrue(Wilddog\\_Str\\_T \\*key)。\n\n 说明\n\n创建一个TRUE类型节点，对应到JSON中即其值为 true。\n\n 参数\n\n* key ` Wilddog_Str_T*` : 节点的key值。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createTrue((Wilddog_Str_T *)\"this is key\");\n```\n\n----\n\n## wilddog\\_node\\_createFalse()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_createFalse(Wilddog\\_Str\\_T \\*key)。\n\n 说明\n\n创建一个FALSE类型节点，对应到JSON中即其值为 false。\n\n 参数\n\n* key `Wilddog_Str_T*` : 节点的key值。\n\n 返回值\n\n`Wilddog_Node_T ` 创建成功则返回节点的指针，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_node = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\n```\n\n----\n\n## wilddog\\_node\\_addChild()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_node\\_addChild(Wilddog\\_Node\\_T \\*parent, Wilddog\\_Node\\_T \\*child)。\n\n 说明\n\n向一个节点添加子节点，成功后，child 节点成为父节点 parent 的子节点，parent 节点可以通过`parent->p_wn_child`或者`parent->p_wn_child->p_wn_next`（可能有多次`p_wn_next`，由 parent 节点的组成决定）的链表顺序查找方式找到。\n\n 参数\n\n* parent `Wilddog_Node_T*` : 指向父节点的指针，如果父节点不是 Object 类型，会自动转换为 Object 类型，原有的值会丢失。\n* child `Wilddog_Node_T*` : 指向要添加的子节点的指针。\n\n 返回值\n\n`Wilddog_Return_T` 成功返回 `0`, 失败返回 `<0`的值。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n```\n\n----\n\n## wilddog\\_node\\_delete()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_node\\_delete( Wilddog\\_Node\\_T \\*head)\n\n 说明\n\n删除节点及其所有子节点。\n\n 参数\n\n* head `Wilddog_Node_T*` : 要删除节点的指针。\n\n 返回值\n\n`Wilddog_Return_T` 成功返回 `0`, 失败返回 `<0`的值。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n\nwilddog_node_delete(p_father); //会将 p_father 和子节点 p_child 全部删除\n```\n\n----\n\n## wilddog\\_node\\_clone()\n\n 定义\n\nWilddog\\_Node\\_T \\* wilddog\\_node\\_clone( Wilddog\\_Node\\_T \\*head)\n\n 说明\n\n拷贝当前节点及其下所有子节点。\n\n 参数\n\n* head `Wilddog_Node_T*` : 指向节点的指针。\n\n 返回值\n\n`Wilddog_Node_T` 成功返回当前节点副本的指针, 失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n\nWilddog_Node_T *p_clone = wilddog_node_clone(p_father); //会复制一个一模一样的副本，需要单独调用wilddog_node_delete 释放\n```\n\n----\n\n## wilddog\\_node\\_find()\n\n 定义\n\nWilddog\\_Node\\_T \\*wilddog\\_node\\_find( Wilddog\\_Node\\_T \\*root, char \\*path)\n\n 说明\n\nroot中查找相对路径下的节点。\n\n 参数\n\n* root `Wilddog_Node_T*` : 指向根节点的指针。\n* path `char*` : 指向相对路径的指针。\n\n 返回值\n\n`Wilddog_Node_T` 成功返回节点指针, 失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)\"123\");\nWilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)\"this is key\");\nwilddog_node_addChild(p_father, p_child);\n\nWilddog_Node_T *p_find = wilddog_node_find(p_father, \"this is key\"); //p_find和p_child是同一个节点\n```\n\n----\n\n## wilddog\\_node\\_getValue()\n\n 定义\n\nWilddog\\_Str\\_T* wilddog\\_node\\_getValue(Wilddog\\_Node\\_T \\*node, int \\*len)\n\n 说明\n\n获取当前节点的value值，其中，值为true，false，null的节点无法通过这种方式获取，而应该直接根据节点的`d_wn_type`得出其类型，类型在`wildog.h`中定义。\n\n 参数\n\n* node `Wilddog_Node_T*` : 指向节点的指针。\n* len `int*` : 输出参数，将存储value值的长度(字节)。\n\n 返回值\n\n`Wilddog_Node_T` 成功返回指向节点value的指针(可根据type和传出的len来转化)，失败返回NULL。\n\n 示例\n```c\nWilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)\"this is key\",234);\nint len = 0;\ns32 value;\nWilddog_Str_T *p_data = wilddog_node_getValue(p_father, &len); //len 应和sizeof(s32)相同\nvalue = (s32)(*p_data);\n```\n\n----\n\n## wilddog\\_node\\_setValue()\n\n 定义\n\nWilddog\\_Return\\_T (Wilddog\\_Node\\_T \\*node, u8 \\*value, int len)\n\n 说明\n\n设置当前节点的value值,其中，值为true，false，null的节点无法通过这种方式设置，整数类型和浮点类型的节点，len 应该为`sizeof(s32)`和`sizeof(wFloat)`。\n\n 参数\n\n* node `Wilddog_Node_T*` : 指向节点的指针。\n* value `u8*` : 指向新value值的指针。\n* len `int` : 新value的长度。\n\n 返回值\n\n`Wilddog_Return_T` 成功返回 `0`, 失败返回 `<0` 的数。\n\n 示例\n```c\nWilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)\"this is key\",234);\nint len = sizeof(s32);\ns32 value = 456;\nwilddog_node_setValue(p_father, &value, len);\n```\n\n----\n# AuthData (*Methods*)\n\n## wilddog\\_auth()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_auth(Wilddog\\_Str\\_T \\*p\\_host, u8 \\*p\\_auth, int len, onAuthFunc onAuth, void \\*args)\n\n 说明\n\n发送auth数据到服务器进行认证，每个 host 只需要认证一次。\n\n 参数\n\np_host `Wilddog_Str_T` : 进行auth认证的host字符串，如 `\"<appId>.wilddogio.com\"`。\n\np_auth `u8*` : 指向auth数据的指针，auth 数据可以使用其他端 sdk 的 token，或者[通过 wilddog token 生成器生成](https://z.wilddog.com/rule/guide#5-zi-ding-yi-token0)。\n\nint `len` : auth数据的长度。\n\nonAuthFunc `onAuth` : 服务端回应认证或者认证超时触发的回调函数，类型是`void (*onAuthFunc)(void* arg, Wilddog_Return_T err)`，其中`arg`为用户传递的值，（即下面的`args`），`err`为状态码，具体见`Wilddog_Return_T`定义。\n\nargs `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，确认是否在云端认证成功需要在回调函数中判断。\n\n 示例\n```c\nvoid myOnAuthFunc(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_ERR_NOERR || err >= WILDDOG_HTTP_BAD_REQUEST){\n        printf(\"auth fail!\\n\");\n        return;\n    }\n    printf(\"auth success! %d\\n\", *(int*)arg);\n    return;\n}\n\n//aquired a new auth token\nchar* newToken=\"ABCD1234567890\";\n\nwilddog_auth(\"aaa.wilddogio.com\", newToken, strlen(newToken), myOnAuthFunc, NULL);\n...\n```\n----\n\n## wilddog\\_unauth()\n\n 定义\n\nWilddog\\_Return\\_T wilddog\\_unauth(Wilddog\\_Str\\_T \\*p\\_host, onAuthFunc onAuth, void \\*args)\n\n 说明\n\n取消和服务器的auth认证，，每个 host 只需要取消认证一次。\n\n 参数\n\np_host `Wilddog_Str_T` : 进行auth认证的host字符串，如 `\"<appId>.wilddogio.com\"`。\n\nonAuthFunc `onAuth` : 服务端回应认证或者认证超时触发的回调函数，类型是`void (*onAuthFunc)(void* arg, Wilddog_Return_T err)`，其中`arg`为用户传递的值，（即下面的`args`），`err`为状态码，具体见`Wilddog_Return_T`定义。\n\nargs `void*` : 用户给回调函数传入的参数。\n\n 返回值\n\n`Wilddog_Return_T` 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，是否成功取消认证需要在回调函数中判断。\n\n 示例\n```c\nvoid myOnAuthFunc(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_ERR_NOERR || err >= WILDDOG_HTTP_BAD_REQUEST){\n        printf(\"auth fail!\\n\");\n        return;\n    }\n    printf(\"hello world! %d\\n\", (int)arg);\n    return;\n}\n\nwilddog_unauth(\"aaa.wilddogio.com\", myOnAuthFunc, NULL);\n...\n```\n","date":"2016-09-06T03:38:22.515Z","updated":"2016-09-06T03:38:22.515Z","path":"api/sync/c.html","comments":1,"layout":"page","_id":"cisswi9j3000bz4fwr32512he","content":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"wilddog-initWithUrl\"><a href=\"#wilddog-initWithUrl\" class=\"headerlink\" title=\"wilddog_initWithUrl()\"></a>wilddog_initWithUrl()</h2><p>定义</p>\n<p>Wilddog_T wilddog_initWithUrl(Wilddog_Str_T *url)</p>\n<p>说明</p>\n<p>初始化应用 URL 对应的 Wilddog 引用。</p>\n<p>参数</p>\n<ul>\n<li>Wilddog_Str_T *<code>url</code> : 应用URL。Wilddog 中任何数据都能够通过一个URL来进行访问，如<code>coap[s]://&lt;appId&gt;.wilddogio.com/&lt;path&gt;</code><br>其中<appid\\>为开发者在 Wilddog 平台申请的应用id。<br><path\\>为客户端关注的路径。</path\\></appid\\></li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_T</code> 类型Wilddog引用的id，如果创建失败，返回0。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化引用</span></div><div class=\"line\">    Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy/device/light/10abcde\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//销毁引用</span></div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-destroy\"><a href=\"#wilddog-destroy\" class=\"headerlink\" title=\"wilddog_destroy()\"></a>wilddog_destroy()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_destroy(Wilddog_T *p_wilddog)</p>\n<p>说明</p>\n<p>销毁一个引用并回收内存。</p>\n<p>参数</p>\n<ul>\n<li>p_wilddog <code>Wilddog_T*</code> : 当前节点引用id的地址。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//销毁引用</span></div><div class=\"line\">wilddog_destroy(&amp;wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getValue\"><a href=\"#wilddog-getValue\" class=\"headerlink\" title=\"wilddog_getValue()\"></a>wilddog_getValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_getValue(Wilddog_T wilddog, onQueryFunc callback, void* arg)</p>\n<p>说明</p>\n<p>获取当前节点的数据,数据格式为<code>Wilddog_Node_T</code>(类似JSON)。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onQueryFunc</code> : 服务端回应数据或者回应超时触发的回调函数,类型是<code>void (*onQueryFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)</code>,其中<code>p_snapshot</code>是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, <code>arg</code>为用户传递的值, <code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onQueryCallback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err != WILDDOG_HTTP_OK)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"query error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"query success!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(p_snapshot)&#123;</div><div class=\"line\">        *(Wilddog_Node_T**)arg = wilddog_node_clone(p_snapshot);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：将云端发回的数据clone到本地</span></div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望获取数据的url，如https://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_getValue返回值的检查</span></div><div class=\"line\">    wilddog_getValue(wilddog, onQueryCallback, (<span class=\"keyword\">void</span>*)(&amp;p_node));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(p_node)&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//打印得到的节点数据</span></div><div class=\"line\">            <span class=\"number\">_</span>wilddog_debug_printnode(p_node);</div><div class=\"line\">            ...</div><div class=\"line\">            wilddog_node_delete(p_node);</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-setValue\"><a href=\"#wilddog-setValue\" class=\"headerlink\" title=\"wilddog_setValue()\"></a>wilddog_setValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_setValue(Wilddog_T wilddog, Wilddog_Node_T *p_node, onSetFunc callback, void *arg)</p>\n<p> 说明</p>\n<p>设置当前节点的数据,数据格式为<code>Wilddog_Node_T</code>。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T</code> : 指向节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onSetFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>void (*onSetFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node to \"wilddog\", value is \"123456\" */</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"literal\">NULL</span>,<span class=\"string\">\"123456\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望设置数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_setValue返回值的检查</span></div><div class=\"line\">    wilddog_setValue(wilddog, p_node, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据已经设置到云端，删除刚才建立的节点</span></div><div class=\"line\">    wilddog_node_delete(p_node);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-push\"><a href=\"#wilddog-push\" class=\"headerlink\" title=\"wilddog_push()\"></a>wilddog_push()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_push( Wilddog_T wilddog, Wilddog_Node_T *p_node, onPushFunc callback, void *arg)<br>说明</p>\n<p>在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成。</p>\n<p>参数 </p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T*</code> : 指向新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onPushFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onPushFunc)(Wilddog_Str_T * p_newPath, void* arg, Wilddog_Return_T err)</code>,其中 <code>p_newPath</code> 是新增节点的完整路径,<code>arg</code> 为用户传递的值,<code>err</code> 为状态码。 </li>\n<li><p>arg <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(u8 *p_path,<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"new path is %s\"</span>, p_path);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>, *p_head = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个object节点，即类似json中的&#123;&#125;</span></div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个key为2，value为数字1234的节点</span></div><div class=\"line\">    p_node = wilddog_node_createNum(<span class=\"string\">\"2\"</span>,<span class=\"number\">1234</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将节点p_node添加到object中</span></div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望推送数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//把新的object推送到云端</span></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_push返回值的检查</span></div><div class=\"line\">    wilddog_push(wilddog, p_head, onPushCallback, (<span class=\"keyword\">void</span> *)&amp;isFinish);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据已经推送，删除刚才建立的节点</span></div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"push success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-removeValue\"><a href=\"#wilddog-removeValue\" class=\"headerlink\" title=\"wilddog_removeValue()\"></a>wilddog_removeValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_removeValue(Wilddog_T wilddog, onRemoveFunc callback, void *arg)</p>\n<p>说明</p>\n<p>删除当前节点及节点下所有数据。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onRemoveFunc</code> : 服务器回应或者回应超时触发的回调函数，类型是<code>void (*onRemoveFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code> 为用户传递的值,<code>err</code> 为状态码。</li>\n<li>arg <code>void*</code> : 用户传给回调函数的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"delete failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"delete success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望删除数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_removeValue返回值的检查</span></div><div class=\"line\">    wilddog_removeValue(wilddog, onDeleteCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"remove success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-addObserver\"><a href=\"#wilddog-addObserver\" class=\"headerlink\" title=\"wilddog_addObserver()\"></a>wilddog_addObserver()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_addObserver(Wilddog_T wilddog, Wilddog_EventType_T event, onEventFunc onDataChange, void *dataChangeArg)</p>\n<p>说明</p>\n<p>监听某节点的数据变化。一旦该数据发生改变, <code>onDataChange</code>函数将被调用。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>event <code>Wilddog\\_EventType\\_T</code> : 关注的事件类型，见<code>Wilddog_EventType_T</code>定义。</li>\n<li>onDataChange <code>onEventFunc</code> : 数据变化所触发的回调函数，类型是<code>(*onEventFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)</code>,其中<code>p_snapshot</code>是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, <code>arg</code>为用户传递的值, <code>err</code>为状态码。 </li>\n<li>dataChangeArg <code>void*</code> : 传给回调函数的<code>arg</code>。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onObserverCallback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err != WILDDOG_HTTP_OK)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"observe failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"observe data!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    STATIC <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望订阅数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_addObserver返回值的检查</span></div><div class=\"line\">    wilddog_addObserver(wilddog, WD_ET_VALUECHANGE, onObserverCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            <span class=\"comment\">//每次接收到推送count + 1</span></div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"get new data %d times!\"</span>, count++);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//重新设置接收状态为FALSE</span></div><div class=\"line\">            isFinished = FALSE;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//count 超过10时，调用wilddog_removeObserver取消订阅，并退出</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(count &gt; <span class=\"number\">10</span>)&#123;</div><div class=\"line\">                wilddog_debug(<span class=\"string\">\"off the data!\"</span>);</div><div class=\"line\">                wilddog_removeObserver(wilddog, WD_ET_VALUECHANGE);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-removeObserver\"><a href=\"#wilddog-removeObserver\" class=\"headerlink\" title=\"wilddog_removeObserver()\"></a>wilddog_removeObserver()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_removeObserver(Wilddog_T *p_wilddog, Wilddog_EventType_T event)</p>\n<p>说明</p>\n<p>取消对某节点的监听(对应于on)。</p>\n<p>参数</p>\n<ul>\n<li>p_wilddog <code>Wilddog_T*</code> : 当前节点引用的id。</li>\n<li>event <code>Wilddog_EventType_T</code> : 取消的事件类型。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code>返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例</p>\n<p>见wilddog_addObserver的示例。</p>\n<hr>\n<h2 id=\"wilddog-onDisconnectSetValue\"><a href=\"#wilddog-onDisconnectSetValue\" class=\"headerlink\" title=\"wilddog_onDisconnectSetValue()\"></a>wilddog_onDisconnectSetValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_onDisconnectSetValue(Wilddog_T wilddog, Wilddog_Node_T *p_node, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>当该客户端离线时，云端自动执行该操作，设置当前节点的数据，数据格式为<code>Wilddog_Node_T</code>。</p>\n<p> 参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T</code> : 指向离线时设置的节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>void (*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node to \"wilddog\", value is \"123456\" */</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"literal\">NULL</span>,<span class=\"string\">\"123456\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望设置数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_node);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-onDisconnectPush\"><a href=\"#wilddog-onDisconnectPush\" class=\"headerlink\" title=\"wilddog_onDisconnectPush()\"></a>wilddog_onDisconnectPush()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_onDisconnectPush( Wilddog_T wilddog, Wilddog_Node_T *p_node, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>当该客户端离线时，云端自动执行该操作，在当前节点下生成一个子节点。子节点的key利用服务端的当前时间生成。</p>\n<p>参数 </p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T*</code> : 指向离线时新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline push success\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>, *p_head = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\">    p_node = wilddog_node_createNum(<span class=\"string\">\"2\"</span>,<span class=\"number\">1234</span>);</div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望推送数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectPush返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectPush(wilddog, p_head, onPushCallback, (<span class=\"keyword\">void</span> *)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"push success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-onDisconnectRemoveValue\"><a href=\"#wilddog-onDisconnectRemoveValue\" class=\"headerlink\" title=\"wilddog_onDisconnectRemoveValue()\"></a>wilddog_onDisconnectRemoveValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_onDisconnectRemoveValue(Wilddog_T wilddog, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>当该客户端离线时，云端自动执行该操作，删除当前节点及节点下所有数据。</p>\n<p> 参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline delete failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline delete success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望删除数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectRemoveValue返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectRemoveValue(wilddog, onDeleteCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"remove success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-cancelDisconnectOperations\"><a href=\"#wilddog-cancelDisconnectOperations\" class=\"headerlink\" title=\"wilddog_cancelDisconnectOperations()\"></a>wilddog_cancelDisconnectOperations()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_cancelDisconnectOperations(Wilddog_T wilddog, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>取消之前设置的离线事件。</p>\n<p> 参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li><p>arg <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onCancelCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline operation cancel failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline operation cancel success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望删除数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_cancelDisconnectOperations返回值的检查</span></div><div class=\"line\">    wilddog_cancelDisconnectOperations(wilddog, onCancelCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"operation cancel success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-goOffline\"><a href=\"#wilddog-goOffline\" class=\"headerlink\" title=\"wilddog_goOffline()\"></a>wilddog_goOffline()</h2><p> 定义</p>\n<p>void wilddog_goOffline(void)</p>\n<p>说明</p>\n<p>通过调用<code>wilddog_goOffline</code> 断开客户端和云端的连接，之前若注册了离线事件则云端会触发断线事件。</p>\n<p> 返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"wilddog-goOnline\"><a href=\"#wilddog-goOnline\" class=\"headerlink\" title=\"wilddog_goOnline()\"></a>wilddog_goOnline()</h2><p> 定义</p>\n<p>void wilddog_goOnline(void)</p>\n<p>说明</p>\n<p>通过调用<code>wilddog_goOnline</code> 若客户端处于离线状态，则重新连接云端服务，之前若注册了监听事件，则 SDK 回重新发送监听请求，这时候需要注意监听回调的触发并非代表云端数据有修改，而重连时获取的数据。</p>\n<p> 返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"wilddog-trySync\"><a href=\"#wilddog-trySync\" class=\"headerlink\" title=\"wilddog_trySync()\"></a>wilddog_trySync()</h2><p> 定义</p>\n<p>void wilddog_trySync(void)</p>\n<p>说明</p>\n<p>通过调用<code>wilddog_trySync</code>来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，触发用户注册的回调函数。</p>\n<p> 返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"wilddog-increaseTime\"><a href=\"#wilddog-increaseTime\" class=\"headerlink\" title=\"wilddog_increaseTime()\"></a>wilddog_increaseTime()</h2><p>定义</p>\n<p>void wilddog_increaseTime(u32 ms)。</p>\n<p> 说明</p>\n<p>用于校准 Wilddog 的时钟(可以在定时器中调用)。一般情况下 Wilddog 会根据自己推算的时间执行业务操作，这个时间的推算会有偏差，我们可以通过传入一个时间增量来校准 Wilddog 时钟。</p>\n<p> 参数</p>\n<ul>\n<li><p>ms <code>u32</code> : 增加的时间(单位为毫秒)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>void</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timer_isr</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//this isr is been called per ms。</span></div><div class=\"line\"></div><div class=\"line\">    wilddog_increaseTime(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"Wilddog-Properties\"><a href=\"#Wilddog-Properties\" class=\"headerlink\" title=\"Wilddog(Properties)\"></a>Wilddog(<em>Properties</em>)</h1><h2 id=\"wilddog-getParent\"><a href=\"#wilddog-getParent\" class=\"headerlink\" title=\"wilddog_getParent()\"></a>wilddog_getParent()</h2><p> 定义</p>\n<p>Wilddog_T wilddog_getParent(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取父节点引用的id。如果当前节点是root节点，创建失败，返回0。</p>\n<p> 参数</p>\n<ul>\n<li><p>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>返回父节点引用的id，如果创建失败，返回0。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定位到user</span></div><div class=\"line\">Wilddog_T parent = wilddog_getParent(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getRoot\"><a href=\"#wilddog-getRoot\" class=\"headerlink\" title=\"wilddog_getRoot()\"></a>wilddog_getRoot()</h2><p> 定义</p>\n<p>Wilddog_T wilddog_getRoot(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取根节点引用的id。</p>\n<p> 参数</p>\n<ul>\n<li><p>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>Wilddog_T <code>root</code> : 根节点引用的id，如果失败，返回0。 </p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定位到root(\"/\")</span></div><div class=\"line\">Wilddog_T root = wilddog_getRoot(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getChild\"><a href=\"#wilddog-getChild\" class=\"headerlink\" title=\"wilddog_getChild()\"></a>wilddog_getChild()</h2><p> 定义</p>\n<p>Wilddog_T wilddog_getChild(Wilddog_T wilddog, Wilddog_Str_T *childName)</p>\n<p> 说明</p>\n<p>获取当前引用下名字为childName的子节点引用的id。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前引用的id。</p>\n<p>childName <code>Wilddog_Str_T*</code> : 子节点的相对路径，多级子节点需用’/‘隔开，即使子节点不存在也能创建。</p>\n<p> 返回值</p>\n<p><code>Wilddog_T</code> 子节点引用的id，如果创建失败，返回0。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定位到user/jackxy/aaa</span></div><div class=\"line\">Wilddog_T child = wilddog_getChild(wilddog, <span class=\"string\">\"aaa\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getKey\"><a href=\"#wilddog-getKey\" class=\"headerlink\" title=\"wilddog_getKey()\"></a>wilddog_getKey()</h2><p> 定义</p>\n<p>Wilddog_Str_T *wilddog_getKey(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取当前引用的key。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前引用的id。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Str_T</code> 当前引用的key值，如果获取失败，返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取Key值（即jackxy）</span></div><div class=\"line\">Wilddog_Str_T *key = wilddog_getKey(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getHost\"><a href=\"#wilddog-getHost\" class=\"headerlink\" title=\"wilddog_getHost()\"></a>wilddog_getHost()</h2><p> 定义</p>\n<p>Wilddog_Str_T *wilddog_getHost(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取当前引用的host。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前引用的id。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Str_T</code> 当前引用的host，如果获取失败，返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取host（即&lt;appId&gt;.wilddogio.com）</span></div><div class=\"line\">Wilddog_Str_T *host = wilddog_getHost(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getPath\"><a href=\"#wilddog-getPath\" class=\"headerlink\" title=\"wilddog_getPath()\"></a>wilddog_getPath()</h2><p> 定义</p>\n<p>Wilddog_Str_T *wilddog_getPath(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p> 获取当前节点的path。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前节点的引用id。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Str_T</code> 当前引用的path，如果获取失败，返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取path（即/user/jackxy）</span></div><div class=\"line\">Wilddog_Str_T *path = wilddog_getPath(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"Node-Methods\"><a href=\"#Node-Methods\" class=\"headerlink\" title=\"Node(Methods)\"></a>Node(<em>Methods</em>)</h1><p>##wilddog_node_createObject()</p>\n<p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createObject(Wilddog_Str_T *key)</p>\n<p> 说明</p>\n<p>创建一个 Object 类型的节点，Object 类型的节点，通俗的来说就是非叶子节点，这种类型的节点的子节点就是它们的值。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>创建成功则返回该节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createUString\"><a href=\"#wilddog-node-createUString\" class=\"headerlink\" title=\"wilddog_node_createUString()\"></a>wilddog_node_createUString()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createUString(Wilddog_Str_T *key, Wilddog_Str_T *value)</p>\n<p> 说明</p>\n<p>创建一个字符串类型节点。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T*</code> : 节点的key值。</li>\n<li><p>value <code>Wilddog_Str_T*</code> : 指向utf-8字符串的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createUString((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>,(Wilddog_Str_T *)<span class=\"string\">\"this is value\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<p>##wilddog_node_createBString()</p>\n<p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createBString(Wilddog_Str_T *key, u8 *value, int len)</p>\n<p> 说明</p>\n<p>创建一个二进制数组类型节点。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T*</code> : 节点的key值。</li>\n<li>value <code>u8*</code> : 二进制数组的指针。</li>\n<li><p>len <code>int</code> : 数据的长度(字节)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T*</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">u8 data[<span class=\"number\">8</span>] = &#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">...</div><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createBString((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>, data, <span class=\"number\">8</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createFloat\"><a href=\"#wilddog-node-createFloat\" class=\"headerlink\" title=\"wilddog_node_createFloat()\"></a>wilddog_node_createFloat()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createFloat(Wilddog_Str_T *key, wFloat num)</p>\n<p> 说明</p>\n<p>创建一个浮点类型的节点。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T *</code> : 节点的key值。</li>\n<li><p>num <code>wFloat</code> : 浮点数据(8位机器为32bits, 其他为64bits)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T *</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wFloat data = <span class=\"number\">1.234</span>;</div><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createFloat((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>, data);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createNum\"><a href=\"#wilddog-node-createNum\" class=\"headerlink\" title=\"wilddog_node_createNum()\"></a>wilddog_node_createNum()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createNum(Wilddog_Str_T *key, s32 num)</p>\n<p> 说明</p>\n<p>创建一个整数类型节点，只支持32位整型。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T*</code> : 节点的key值。</li>\n<li><p>num <code>s32</code> : 32位有符号整数。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">s32 data = <span class=\"number\">1</span>;</div><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createNum((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>, data);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createNull\"><a href=\"#wilddog-node-createNull\" class=\"headerlink\" title=\"wilddog_node_createNull()\"></a>wilddog_node_createNull()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createNull(Wilddog_Str_T *key)。</p>\n<p> 说明</p>\n<p>创建一个Null类型节点，对应到JSON中即其值为 null 。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createNull((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createTrue\"><a href=\"#wilddog-node-createTrue\" class=\"headerlink\" title=\"wilddog_node_createTrue()\"></a>wilddog_node_createTrue()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createTrue(Wilddog_Str_T *key)。</p>\n<p> 说明</p>\n<p>创建一个TRUE类型节点，对应到JSON中即其值为 true。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createTrue((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createFalse\"><a href=\"#wilddog-node-createFalse\" class=\"headerlink\" title=\"wilddog_node_createFalse()\"></a>wilddog_node_createFalse()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createFalse(Wilddog_Str_T *key)。</p>\n<p> 说明</p>\n<p>创建一个FALSE类型节点，对应到JSON中即其值为 false。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-addChild\"><a href=\"#wilddog-node-addChild\" class=\"headerlink\" title=\"wilddog_node_addChild()\"></a>wilddog_node_addChild()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_node_addChild(Wilddog_Node_T *parent, Wilddog_Node_T *child)。</p>\n<p> 说明</p>\n<p>向一个节点添加子节点，成功后，child 节点成为父节点 parent 的子节点，parent 节点可以通过<code>parent-&gt;p_wn_child</code>或者<code>parent-&gt;p_wn_child-&gt;p_wn_next</code>（可能有多次<code>p_wn_next</code>，由 parent 节点的组成决定）的链表顺序查找方式找到。</p>\n<p> 参数</p>\n<ul>\n<li>parent <code>Wilddog_Node_T*</code> : 指向父节点的指针，如果父节点不是 Object 类型，会自动转换为 Object 类型，原有的值会丢失。</li>\n<li><p>child <code>Wilddog_Node_T*</code> : 指向要添加的子节点的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 成功返回 <code>0</code>, 失败返回 <code>&lt;0</code>的值。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-delete\"><a href=\"#wilddog-node-delete\" class=\"headerlink\" title=\"wilddog_node_delete()\"></a>wilddog_node_delete()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_node_delete( Wilddog_Node_T *head)</p>\n<p> 说明</p>\n<p>删除节点及其所有子节点。</p>\n<p> 参数</p>\n<ul>\n<li><p>head <code>Wilddog_Node_T*</code> : 要删除节点的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 成功返回 <code>0</code>, 失败返回 <code>&lt;0</code>的值。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div><div class=\"line\"></div><div class=\"line\">wilddog_node_delete(p_father); <span class=\"comment\">//会将 p_father 和子节点 p_child 全部删除</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-clone\"><a href=\"#wilddog-node-clone\" class=\"headerlink\" title=\"wilddog_node_clone()\"></a>wilddog_node_clone()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_clone( Wilddog_Node_T *head)</p>\n<p> 说明</p>\n<p>拷贝当前节点及其下所有子节点。</p>\n<p> 参数</p>\n<ul>\n<li><p>head <code>Wilddog_Node_T*</code> : 指向节点的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 成功返回当前节点副本的指针, 失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div><div class=\"line\"></div><div class=\"line\">Wilddog_Node_T *p_clone = wilddog_node_clone(p_father); <span class=\"comment\">//会复制一个一模一样的副本，需要单独调用wilddog_node_delete 释放</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-find\"><a href=\"#wilddog-node-find\" class=\"headerlink\" title=\"wilddog_node_find()\"></a>wilddog_node_find()</h2><p> 定义</p>\n<p>Wilddog_Node_T *wilddog_node_find( Wilddog_Node_T *root, char *path)</p>\n<p> 说明</p>\n<p>root中查找相对路径下的节点。</p>\n<p> 参数</p>\n<ul>\n<li>root <code>Wilddog_Node_T*</code> : 指向根节点的指针。</li>\n<li><p>path <code>char*</code> : 指向相对路径的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 成功返回节点指针, 失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div><div class=\"line\"></div><div class=\"line\">Wilddog_Node_T *p_find = wilddog_node_find(p_father, <span class=\"string\">\"this is key\"</span>); <span class=\"comment\">//p_find和p_child是同一个节点</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-getValue\"><a href=\"#wilddog-node-getValue\" class=\"headerlink\" title=\"wilddog_node_getValue()\"></a>wilddog_node_getValue()</h2><p> 定义</p>\n<p>Wilddog_Str_T<em> wilddog_node_getValue(Wilddog_Node_T \\</em>node, int *len)</p>\n<p> 说明</p>\n<p>获取当前节点的value值，其中，值为true，false，null的节点无法通过这种方式获取，而应该直接根据节点的<code>d_wn_type</code>得出其类型，类型在<code>wildog.h</code>中定义。</p>\n<p> 参数</p>\n<ul>\n<li>node <code>Wilddog_Node_T*</code> : 指向节点的指针。</li>\n<li><p>len <code>int*</code> : 输出参数，将存储value值的长度(字节)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 成功返回指向节点value的指针(可根据type和传出的len来转化)，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>,<span class=\"number\">234</span>);</div><div class=\"line\"><span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</div><div class=\"line\">s32 value;</div><div class=\"line\">Wilddog_Str_T *p_data = wilddog_node_getValue(p_father, &amp;len); <span class=\"comment\">//len 应和sizeof(s32)相同</span></div><div class=\"line\">value = (s32)(*p_data);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-setValue\"><a href=\"#wilddog-node-setValue\" class=\"headerlink\" title=\"wilddog_node_setValue()\"></a>wilddog_node_setValue()</h2><p> 定义</p>\n<p>Wilddog_Return_T (Wilddog_Node_T *node, u8 *value, int len)</p>\n<p> 说明</p>\n<p>设置当前节点的value值,其中，值为true，false，null的节点无法通过这种方式设置，整数类型和浮点类型的节点，len 应该为<code>sizeof(s32)</code>和<code>sizeof(wFloat)</code>。</p>\n<p> 参数</p>\n<ul>\n<li>node <code>Wilddog_Node_T*</code> : 指向节点的指针。</li>\n<li>value <code>u8*</code> : 指向新value值的指针。</li>\n<li><p>len <code>int</code> : 新value的长度。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 成功返回 <code>0</code>, 失败返回 <code>&lt;0</code> 的数。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>,<span class=\"number\">234</span>);</div><div class=\"line\"><span class=\"keyword\">int</span> len = <span class=\"keyword\">sizeof</span>(s32);</div><div class=\"line\">s32 value = <span class=\"number\">456</span>;</div><div class=\"line\">wilddog_node_setValue(p_father, &amp;value, len);</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"AuthData-Methods\"><a href=\"#AuthData-Methods\" class=\"headerlink\" title=\"AuthData (Methods)\"></a>AuthData (<em>Methods</em>)</h1><h2 id=\"wilddog-auth\"><a href=\"#wilddog-auth\" class=\"headerlink\" title=\"wilddog_auth()\"></a>wilddog_auth()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_auth(Wilddog_Str_T *p_host, u8 *p_auth, int len, onAuthFunc onAuth, void *args)</p>\n<p> 说明</p>\n<p>发送auth数据到服务器进行认证，每个 host 只需要认证一次。</p>\n<p> 参数</p>\n<p>p_host <code>Wilddog_Str_T</code> : 进行auth认证的host字符串，如 <code>&quot;&lt;appId&gt;.wilddogio.com&quot;</code>。</p>\n<p>p_auth <code>u8*</code> : 指向auth数据的指针，auth 数据可以使用其他端 sdk 的 token，或者<a href=\"https://z.wilddog.com/rule/guide#5-zi-ding-yi-token0\" target=\"_blank\" rel=\"external\">通过 wilddog token 生成器生成</a>。</p>\n<p>int <code>len</code> : auth数据的长度。</p>\n<p>onAuthFunc <code>onAuth</code> : 服务端回应认证或者认证超时触发的回调函数，类型是<code>void (*onAuthFunc)(void* arg, Wilddog_Return_T err)</code>，其中<code>arg</code>为用户传递的值，（即下面的<code>args</code>），<code>err</code>为状态码，具体见<code>Wilddog_Return_T</code>定义。</p>\n<p>args <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Return_T</code> 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，确认是否在云端认证成功需要在回调函数中判断。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myOnAuthFunc</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_ERR_NOERR || err &gt;= WILDDOG_HTTP_BAD_REQUEST)&#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"auth fail!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"auth success! %d\\n\"</span>, *(<span class=\"keyword\">int</span>*)arg);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//aquired a new auth token</span></div><div class=\"line\"><span class=\"keyword\">char</span>* newToken=<span class=\"string\">\"ABCD1234567890\"</span>;</div><div class=\"line\"></div><div class=\"line\">wilddog_auth(<span class=\"string\">\"aaa.wilddogio.com\"</span>, newToken, <span class=\"built_in\">strlen</span>(newToken), myOnAuthFunc, <span class=\"literal\">NULL</span>);</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-unauth\"><a href=\"#wilddog-unauth\" class=\"headerlink\" title=\"wilddog_unauth()\"></a>wilddog_unauth()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_unauth(Wilddog_Str_T *p_host, onAuthFunc onAuth, void *args)</p>\n<p> 说明</p>\n<p>取消和服务器的auth认证，，每个 host 只需要取消认证一次。</p>\n<p> 参数</p>\n<p>p_host <code>Wilddog_Str_T</code> : 进行auth认证的host字符串，如 <code>&quot;&lt;appId&gt;.wilddogio.com&quot;</code>。</p>\n<p>onAuthFunc <code>onAuth</code> : 服务端回应认证或者认证超时触发的回调函数，类型是<code>void (*onAuthFunc)(void* arg, Wilddog_Return_T err)</code>，其中<code>arg</code>为用户传递的值，（即下面的<code>args</code>），<code>err</code>为状态码，具体见<code>Wilddog_Return_T</code>定义。</p>\n<p>args <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Return_T</code> 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，是否成功取消认证需要在回调函数中判断。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myOnAuthFunc</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_ERR_NOERR || err &gt;= WILDDOG_HTTP_BAD_REQUEST)&#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"auth fail!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world! %d\\n\"</span>, (<span class=\"keyword\">int</span>)arg);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">wilddog_unauth(<span class=\"string\">\"aaa.wilddogio.com\"</span>, myOnAuthFunc, <span class=\"literal\">NULL</span>);</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"wilddog-initWithUrl\"><a href=\"#wilddog-initWithUrl\" class=\"headerlink\" title=\"wilddog_initWithUrl()\"></a>wilddog_initWithUrl()</h2><p>定义</p>\n<p>Wilddog_T wilddog_initWithUrl(Wilddog_Str_T *url)</p>\n<p>说明</p>\n<p>初始化应用 URL 对应的 Wilddog 引用。</p>\n<p>参数</p>\n<ul>\n<li>Wilddog_Str_T *<code>url</code> : 应用URL。Wilddog 中任何数据都能够通过一个URL来进行访问，如<code>coap[s]://&lt;appId&gt;.wilddogio.com/&lt;path&gt;</code><br>其中<appId\\>为开发者在 Wilddog 平台申请的应用id。<br><path\\>为客户端关注的路径。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_T</code> 类型Wilddog引用的id，如果创建失败，返回0。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化引用</span></div><div class=\"line\">    Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy/device/light/10abcde\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//do something</span></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//销毁引用</span></div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-destroy\"><a href=\"#wilddog-destroy\" class=\"headerlink\" title=\"wilddog_destroy()\"></a>wilddog_destroy()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_destroy(Wilddog_T *p_wilddog)</p>\n<p>说明</p>\n<p>销毁一个引用并回收内存。</p>\n<p>参数</p>\n<ul>\n<li>p_wilddog <code>Wilddog_T*</code> : 当前节点引用id的地址。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//销毁引用</span></div><div class=\"line\">wilddog_destroy(&amp;wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getValue\"><a href=\"#wilddog-getValue\" class=\"headerlink\" title=\"wilddog_getValue()\"></a>wilddog_getValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_getValue(Wilddog_T wilddog, onQueryFunc callback, void* arg)</p>\n<p>说明</p>\n<p>获取当前节点的数据,数据格式为<code>Wilddog_Node_T</code>(类似JSON)。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onQueryFunc</code> : 服务端回应数据或者回应超时触发的回调函数,类型是<code>void (*onQueryFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)</code>,其中<code>p_snapshot</code>是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, <code>arg</code>为用户传递的值, <code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onQueryCallback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err != WILDDOG_HTTP_OK)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"query error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"query success!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(p_snapshot)&#123;</div><div class=\"line\">        *(Wilddog_Node_T**)arg = wilddog_node_clone(p_snapshot);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：将云端发回的数据clone到本地</span></div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望获取数据的url，如https://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_getValue返回值的检查</span></div><div class=\"line\">    wilddog_getValue(wilddog, onQueryCallback, (<span class=\"keyword\">void</span>*)(&amp;p_node));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(p_node)&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//打印得到的节点数据</span></div><div class=\"line\">            <span class=\"number\">_</span>wilddog_debug_printnode(p_node);</div><div class=\"line\">            ...</div><div class=\"line\">            wilddog_node_delete(p_node);</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-setValue\"><a href=\"#wilddog-setValue\" class=\"headerlink\" title=\"wilddog_setValue()\"></a>wilddog_setValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_setValue(Wilddog_T wilddog, Wilddog_Node_T *p_node, onSetFunc callback, void *arg)</p>\n<p> 说明</p>\n<p>设置当前节点的数据,数据格式为<code>Wilddog_Node_T</code>。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T</code> : 指向节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onSetFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>void (*onSetFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node to \"wilddog\", value is \"123456\" */</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"literal\">NULL</span>,<span class=\"string\">\"123456\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望设置数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_setValue返回值的检查</span></div><div class=\"line\">    wilddog_setValue(wilddog, p_node, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据已经设置到云端，删除刚才建立的节点</span></div><div class=\"line\">    wilddog_node_delete(p_node);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-push\"><a href=\"#wilddog-push\" class=\"headerlink\" title=\"wilddog_push()\"></a>wilddog_push()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_push( Wilddog_T wilddog, Wilddog_Node_T *p_node, onPushFunc callback, void *arg)<br>说明</p>\n<p>在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成。</p>\n<p>参数 </p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T*</code> : 指向新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onPushFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onPushFunc)(Wilddog_Str_T * p_newPath, void* arg, Wilddog_Return_T err)</code>,其中 <code>p_newPath</code> 是新增节点的完整路径,<code>arg</code> 为用户传递的值,<code>err</code> 为状态码。 </li>\n<li><p>arg <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(u8 *p_path,<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"new path is %s\"</span>, p_path);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>, *p_head = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个object节点，即类似json中的&#123;&#125;</span></div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个key为2，value为数字1234的节点</span></div><div class=\"line\">    p_node = wilddog_node_createNum(<span class=\"string\">\"2\"</span>,<span class=\"number\">1234</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将节点p_node添加到object中</span></div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望推送数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//把新的object推送到云端</span></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_push返回值的检查</span></div><div class=\"line\">    wilddog_push(wilddog, p_head, onPushCallback, (<span class=\"keyword\">void</span> *)&amp;isFinish);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据已经推送，删除刚才建立的节点</span></div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"push success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-removeValue\"><a href=\"#wilddog-removeValue\" class=\"headerlink\" title=\"wilddog_removeValue()\"></a>wilddog_removeValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_removeValue(Wilddog_T wilddog, onRemoveFunc callback, void *arg)</p>\n<p>说明</p>\n<p>删除当前节点及节点下所有数据。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onRemoveFunc</code> : 服务器回应或者回应超时触发的回调函数，类型是<code>void (*onRemoveFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code> 为用户传递的值,<code>err</code> 为状态码。</li>\n<li>arg <code>void*</code> : 用户传给回调函数的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"delete failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"delete success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望删除数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_removeValue返回值的检查</span></div><div class=\"line\">    wilddog_removeValue(wilddog, onDeleteCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"remove success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-addObserver\"><a href=\"#wilddog-addObserver\" class=\"headerlink\" title=\"wilddog_addObserver()\"></a>wilddog_addObserver()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_addObserver(Wilddog_T wilddog, Wilddog_EventType_T event, onEventFunc onDataChange, void *dataChangeArg)</p>\n<p>说明</p>\n<p>监听某节点的数据变化。一旦该数据发生改变, <code>onDataChange</code>函数将被调用。</p>\n<p>参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>event <code>Wilddog\\_EventType\\_T</code> : 关注的事件类型，见<code>Wilddog_EventType_T</code>定义。</li>\n<li>onDataChange <code>onEventFunc</code> : 数据变化所触发的回调函数，类型是<code>(*onEventFunc)(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err)</code>,其中<code>p_snapshot</code>是取回的数据镜像（err为200时）或者NULL，退出函数后即被销毁, <code>arg</code>为用户传递的值, <code>err</code>为状态码。 </li>\n<li>dataChangeArg <code>void*</code> : 传给回调函数的<code>arg</code>。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onObserverCallback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err != WILDDOG_HTTP_OK)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"observe failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"observe data!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    STATIC <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望订阅数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_addObserver返回值的检查</span></div><div class=\"line\">    wilddog_addObserver(wilddog, WD_ET_VALUECHANGE, onObserverCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            <span class=\"comment\">//每次接收到推送count + 1</span></div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"get new data %d times!\"</span>, count++);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//重新设置接收状态为FALSE</span></div><div class=\"line\">            isFinished = FALSE;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//count 超过10时，调用wilddog_removeObserver取消订阅，并退出</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(count &gt; <span class=\"number\">10</span>)&#123;</div><div class=\"line\">                wilddog_debug(<span class=\"string\">\"off the data!\"</span>);</div><div class=\"line\">                wilddog_removeObserver(wilddog, WD_ET_VALUECHANGE);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-removeObserver\"><a href=\"#wilddog-removeObserver\" class=\"headerlink\" title=\"wilddog_removeObserver()\"></a>wilddog_removeObserver()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_removeObserver(Wilddog_T *p_wilddog, Wilddog_EventType_T event)</p>\n<p>说明</p>\n<p>取消对某节点的监听(对应于on)。</p>\n<p>参数</p>\n<ul>\n<li>p_wilddog <code>Wilddog_T*</code> : 当前节点引用的id。</li>\n<li>event <code>Wilddog_EventType_T</code> : 取消的事件类型。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code>返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例</p>\n<p>见wilddog_addObserver的示例。</p>\n<hr>\n<h2 id=\"wilddog-onDisconnectSetValue\"><a href=\"#wilddog-onDisconnectSetValue\" class=\"headerlink\" title=\"wilddog_onDisconnectSetValue()\"></a>wilddog_onDisconnectSetValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_onDisconnectSetValue(Wilddog_T wilddog, Wilddog_Node_T *p_node, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>当该客户端离线时，云端自动执行该操作，设置当前节点的数据，数据格式为<code>Wilddog_Node_T</code>。</p>\n<p> 参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T</code> : 指向离线时设置的节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>void (*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node to \"wilddog\", value is \"123456\" */</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"literal\">NULL</span>,<span class=\"string\">\"123456\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望设置数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_node);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-onDisconnectPush\"><a href=\"#wilddog-onDisconnectPush\" class=\"headerlink\" title=\"wilddog_onDisconnectPush()\"></a>wilddog_onDisconnectPush()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_onDisconnectPush( Wilddog_T wilddog, Wilddog_Node_T *p_node, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>当该客户端离线时，云端自动执行该操作，在当前节点下生成一个子节点。子节点的key利用服务端的当前时间生成。</p>\n<p>参数 </p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>p_node <code>Wilddog_Node_T*</code> : 指向离线时新增节点数据的指针，注意，头节点即为当前的 wilddog 节点。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline push success\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>, *p_head = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\">    p_node = wilddog_node_createNum(<span class=\"string\">\"2\"</span>,<span class=\"number\">1234</span>);</div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望推送数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectPush返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectPush(wilddog, p_head, onPushCallback, (<span class=\"keyword\">void</span> *)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"push success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-onDisconnectRemoveValue\"><a href=\"#wilddog-onDisconnectRemoveValue\" class=\"headerlink\" title=\"wilddog_onDisconnectRemoveValue()\"></a>wilddog_onDisconnectRemoveValue()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_onDisconnectRemoveValue(Wilddog_T wilddog, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>当该客户端离线时，云端自动执行该操作，删除当前节点及节点下所有数据。</p>\n<p> 参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li>arg <code>void*</code> : 用户给回调函数传入的参数。</li>\n</ul>\n<p>返回值</p>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline delete failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline delete success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望删除数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectRemoveValue返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectRemoveValue(wilddog, onDeleteCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"remove success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-cancelDisconnectOperations\"><a href=\"#wilddog-cancelDisconnectOperations\" class=\"headerlink\" title=\"wilddog_cancelDisconnectOperations()\"></a>wilddog_cancelDisconnectOperations()</h2><p>定义</p>\n<p>Wilddog_Return_T wilddog_cancelDisconnectOperations(Wilddog_T wilddog, onDisConnectFunc callback, void* arg)</p>\n<p>说明</p>\n<p>取消之前设置的离线事件。</p>\n<p> 参数</p>\n<ul>\n<li>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</li>\n<li>callback <code>onDisConnectFunc</code> : 服务端回应或者回应超时触发的回调函数 ,类型是<code>(*onDisConnectFunc)(void* arg, Wilddog_Return_T err)</code>,其中<code>arg</code>为用户传递的值,<code>err</code>为状态码。</li>\n<li><p>arg <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 返回 <code>0</code>:成功 <code>&lt;0</code>:失败，返回码见<code>wilddog.h</code>。</p>\n<p>示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onCancelCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline operation cancel failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline operation cancel success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望删除数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(&lt;url&gt;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_cancelDisconnectOperations返回值的检查</span></div><div class=\"line\">    wilddog_cancelDisconnectOperations(wilddog, onCancelCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"operation cancel success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-goOffline\"><a href=\"#wilddog-goOffline\" class=\"headerlink\" title=\"wilddog_goOffline()\"></a>wilddog_goOffline()</h2><p> 定义</p>\n<p>void wilddog_goOffline(void)</p>\n<p>说明</p>\n<p>通过调用<code>wilddog_goOffline</code> 断开客户端和云端的连接，之前若注册了离线事件则云端会触发断线事件。</p>\n<p> 返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"wilddog-goOnline\"><a href=\"#wilddog-goOnline\" class=\"headerlink\" title=\"wilddog_goOnline()\"></a>wilddog_goOnline()</h2><p> 定义</p>\n<p>void wilddog_goOnline(void)</p>\n<p>说明</p>\n<p>通过调用<code>wilddog_goOnline</code> 若客户端处于离线状态，则重新连接云端服务，之前若注册了监听事件，则 SDK 回重新发送监听请求，这时候需要注意监听回调的触发并非代表云端数据有修改，而重连时获取的数据。</p>\n<p> 返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"wilddog-trySync\"><a href=\"#wilddog-trySync\" class=\"headerlink\" title=\"wilddog_trySync()\"></a>wilddog_trySync()</h2><p> 定义</p>\n<p>void wilddog_trySync(void)</p>\n<p>说明</p>\n<p>通过调用<code>wilddog_trySync</code>来向Wilddog云端同步数据。每次调用都会处理来自云端的推送和请求超时的重发、长连接的维持 ，触发用户注册的回调函数。</p>\n<p> 返回值</p>\n<p>void</p>\n<hr>\n<h2 id=\"wilddog-increaseTime\"><a href=\"#wilddog-increaseTime\" class=\"headerlink\" title=\"wilddog_increaseTime()\"></a>wilddog_increaseTime()</h2><p>定义</p>\n<p>void wilddog_increaseTime(u32 ms)。</p>\n<p> 说明</p>\n<p>用于校准 Wilddog 的时钟(可以在定时器中调用)。一般情况下 Wilddog 会根据自己推算的时间执行业务操作，这个时间的推算会有偏差，我们可以通过传入一个时间增量来校准 Wilddog 时钟。</p>\n<p> 参数</p>\n<ul>\n<li><p>ms <code>u32</code> : 增加的时间(单位为毫秒)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>void</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timer_isr</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//this isr is been called per ms。</span></div><div class=\"line\"></div><div class=\"line\">    wilddog_increaseTime(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"Wilddog-Properties\"><a href=\"#Wilddog-Properties\" class=\"headerlink\" title=\"Wilddog(Properties)\"></a>Wilddog(<em>Properties</em>)</h1><h2 id=\"wilddog-getParent\"><a href=\"#wilddog-getParent\" class=\"headerlink\" title=\"wilddog_getParent()\"></a>wilddog_getParent()</h2><p> 定义</p>\n<p>Wilddog_T wilddog_getParent(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取父节点引用的id。如果当前节点是root节点，创建失败，返回0。</p>\n<p> 参数</p>\n<ul>\n<li><p>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>返回父节点引用的id，如果创建失败，返回0。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定位到user</span></div><div class=\"line\">Wilddog_T parent = wilddog_getParent(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getRoot\"><a href=\"#wilddog-getRoot\" class=\"headerlink\" title=\"wilddog_getRoot()\"></a>wilddog_getRoot()</h2><p> 定义</p>\n<p>Wilddog_T wilddog_getRoot(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取根节点引用的id。</p>\n<p> 参数</p>\n<ul>\n<li><p>wilddog <code>Wilddog_T</code> : 当前节点引用的id。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>Wilddog_T <code>root</code> : 根节点引用的id，如果失败，返回0。 </p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定位到root(\"/\")</span></div><div class=\"line\">Wilddog_T root = wilddog_getRoot(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getChild\"><a href=\"#wilddog-getChild\" class=\"headerlink\" title=\"wilddog_getChild()\"></a>wilddog_getChild()</h2><p> 定义</p>\n<p>Wilddog_T wilddog_getChild(Wilddog_T wilddog, Wilddog_Str_T *childName)</p>\n<p> 说明</p>\n<p>获取当前引用下名字为childName的子节点引用的id。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前引用的id。</p>\n<p>childName <code>Wilddog_Str_T*</code> : 子节点的相对路径，多级子节点需用’/‘隔开，即使子节点不存在也能创建。</p>\n<p> 返回值</p>\n<p><code>Wilddog_T</code> 子节点引用的id，如果创建失败，返回0。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//定位到user/jackxy/aaa</span></div><div class=\"line\">Wilddog_T child = wilddog_getChild(wilddog, <span class=\"string\">\"aaa\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getKey\"><a href=\"#wilddog-getKey\" class=\"headerlink\" title=\"wilddog_getKey()\"></a>wilddog_getKey()</h2><p> 定义</p>\n<p>Wilddog_Str_T *wilddog_getKey(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取当前引用的key。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前引用的id。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Str_T</code> 当前引用的key值，如果获取失败，返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取Key值（即jackxy）</span></div><div class=\"line\">Wilddog_Str_T *key = wilddog_getKey(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getHost\"><a href=\"#wilddog-getHost\" class=\"headerlink\" title=\"wilddog_getHost()\"></a>wilddog_getHost()</h2><p> 定义</p>\n<p>Wilddog_Str_T *wilddog_getHost(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p>获取当前引用的host。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前引用的id。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Str_T</code> 当前引用的host，如果获取失败，返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取host（即&lt;appId&gt;.wilddogio.com）</span></div><div class=\"line\">Wilddog_Str_T *host = wilddog_getHost(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-getPath\"><a href=\"#wilddog-getPath\" class=\"headerlink\" title=\"wilddog_getPath()\"></a>wilddog_getPath()</h2><p> 定义</p>\n<p>Wilddog_Str_T *wilddog_getPath(Wilddog_T wilddog)</p>\n<p> 说明</p>\n<p> 获取当前节点的path。</p>\n<p> 参数</p>\n<p>wilddog <code>Wilddog_T</code> : 当前节点的引用id。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Str_T</code> 当前引用的path，如果获取失败，返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定位到user/jackxy</span></div><div class=\"line\">Wilddog_T wilddog=wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appId&gt;.wilddogio.com/user/jackxy\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取path（即/user/jackxy）</span></div><div class=\"line\">Wilddog_Str_T *path = wilddog_getPath(wilddog);</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"Node-Methods\"><a href=\"#Node-Methods\" class=\"headerlink\" title=\"Node(Methods)\"></a>Node(<em>Methods</em>)</h1><p>##wilddog_node_createObject()</p>\n<p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createObject(Wilddog_Str_T *key)</p>\n<p> 说明</p>\n<p>创建一个 Object 类型的节点，Object 类型的节点，通俗的来说就是非叶子节点，这种类型的节点的子节点就是它们的值。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p>创建成功则返回该节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createUString\"><a href=\"#wilddog-node-createUString\" class=\"headerlink\" title=\"wilddog_node_createUString()\"></a>wilddog_node_createUString()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createUString(Wilddog_Str_T *key, Wilddog_Str_T *value)</p>\n<p> 说明</p>\n<p>创建一个字符串类型节点。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T*</code> : 节点的key值。</li>\n<li><p>value <code>Wilddog_Str_T*</code> : 指向utf-8字符串的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createUString((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>,(Wilddog_Str_T *)<span class=\"string\">\"this is value\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<p>##wilddog_node_createBString()</p>\n<p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createBString(Wilddog_Str_T *key, u8 *value, int len)</p>\n<p> 说明</p>\n<p>创建一个二进制数组类型节点。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T*</code> : 节点的key值。</li>\n<li>value <code>u8*</code> : 二进制数组的指针。</li>\n<li><p>len <code>int</code> : 数据的长度(字节)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T*</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">u8 data[<span class=\"number\">8</span>] = &#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">...</div><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createBString((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>, data, <span class=\"number\">8</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createFloat\"><a href=\"#wilddog-node-createFloat\" class=\"headerlink\" title=\"wilddog_node_createFloat()\"></a>wilddog_node_createFloat()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createFloat(Wilddog_Str_T *key, wFloat num)</p>\n<p> 说明</p>\n<p>创建一个浮点类型的节点。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T *</code> : 节点的key值。</li>\n<li><p>num <code>wFloat</code> : 浮点数据(8位机器为32bits, 其他为64bits)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T *</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wFloat data = <span class=\"number\">1.234</span>;</div><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createFloat((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>, data);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createNum\"><a href=\"#wilddog-node-createNum\" class=\"headerlink\" title=\"wilddog_node_createNum()\"></a>wilddog_node_createNum()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createNum(Wilddog_Str_T *key, s32 num)</p>\n<p> 说明</p>\n<p>创建一个整数类型节点，只支持32位整型。</p>\n<p> 参数</p>\n<ul>\n<li>key <code>Wilddog_Str_T*</code> : 节点的key值。</li>\n<li><p>num <code>s32</code> : 32位有符号整数。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">s32 data = <span class=\"number\">1</span>;</div><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createNum((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>, data);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createNull\"><a href=\"#wilddog-node-createNull\" class=\"headerlink\" title=\"wilddog_node_createNull()\"></a>wilddog_node_createNull()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createNull(Wilddog_Str_T *key)。</p>\n<p> 说明</p>\n<p>创建一个Null类型节点，对应到JSON中即其值为 null 。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createNull((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createTrue\"><a href=\"#wilddog-node-createTrue\" class=\"headerlink\" title=\"wilddog_node_createTrue()\"></a>wilddog_node_createTrue()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createTrue(Wilddog_Str_T *key)。</p>\n<p> 说明</p>\n<p>创建一个TRUE类型节点，对应到JSON中即其值为 true。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createTrue((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-createFalse\"><a href=\"#wilddog-node-createFalse\" class=\"headerlink\" title=\"wilddog_node_createFalse()\"></a>wilddog_node_createFalse()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_createFalse(Wilddog_Str_T *key)。</p>\n<p> 说明</p>\n<p>创建一个FALSE类型节点，对应到JSON中即其值为 false。</p>\n<p> 参数</p>\n<ul>\n<li><p>key <code>Wilddog_Str_T*</code> : 节点的key值。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 创建成功则返回节点的指针，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_node = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-addChild\"><a href=\"#wilddog-node-addChild\" class=\"headerlink\" title=\"wilddog_node_addChild()\"></a>wilddog_node_addChild()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_node_addChild(Wilddog_Node_T *parent, Wilddog_Node_T *child)。</p>\n<p> 说明</p>\n<p>向一个节点添加子节点，成功后，child 节点成为父节点 parent 的子节点，parent 节点可以通过<code>parent-&gt;p_wn_child</code>或者<code>parent-&gt;p_wn_child-&gt;p_wn_next</code>（可能有多次<code>p_wn_next</code>，由 parent 节点的组成决定）的链表顺序查找方式找到。</p>\n<p> 参数</p>\n<ul>\n<li>parent <code>Wilddog_Node_T*</code> : 指向父节点的指针，如果父节点不是 Object 类型，会自动转换为 Object 类型，原有的值会丢失。</li>\n<li><p>child <code>Wilddog_Node_T*</code> : 指向要添加的子节点的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 成功返回 <code>0</code>, 失败返回 <code>&lt;0</code>的值。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-delete\"><a href=\"#wilddog-node-delete\" class=\"headerlink\" title=\"wilddog_node_delete()\"></a>wilddog_node_delete()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_node_delete( Wilddog_Node_T *head)</p>\n<p> 说明</p>\n<p>删除节点及其所有子节点。</p>\n<p> 参数</p>\n<ul>\n<li><p>head <code>Wilddog_Node_T*</code> : 要删除节点的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 成功返回 <code>0</code>, 失败返回 <code>&lt;0</code>的值。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div><div class=\"line\"></div><div class=\"line\">wilddog_node_delete(p_father); <span class=\"comment\">//会将 p_father 和子节点 p_child 全部删除</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-clone\"><a href=\"#wilddog-node-clone\" class=\"headerlink\" title=\"wilddog_node_clone()\"></a>wilddog_node_clone()</h2><p> 定义</p>\n<p>Wilddog_Node_T * wilddog_node_clone( Wilddog_Node_T *head)</p>\n<p> 说明</p>\n<p>拷贝当前节点及其下所有子节点。</p>\n<p> 参数</p>\n<ul>\n<li><p>head <code>Wilddog_Node_T*</code> : 指向节点的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 成功返回当前节点副本的指针, 失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div><div class=\"line\"></div><div class=\"line\">Wilddog_Node_T *p_clone = wilddog_node_clone(p_father); <span class=\"comment\">//会复制一个一模一样的副本，需要单独调用wilddog_node_delete 释放</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-find\"><a href=\"#wilddog-node-find\" class=\"headerlink\" title=\"wilddog_node_find()\"></a>wilddog_node_find()</h2><p> 定义</p>\n<p>Wilddog_Node_T *wilddog_node_find( Wilddog_Node_T *root, char *path)</p>\n<p> 说明</p>\n<p>root中查找相对路径下的节点。</p>\n<p> 参数</p>\n<ul>\n<li>root <code>Wilddog_Node_T*</code> : 指向根节点的指针。</li>\n<li><p>path <code>char*</code> : 指向相对路径的指针。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 成功返回节点指针, 失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_father = wilddog_node_createObject((Wilddog_Str_T *)<span class=\"string\">\"123\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createFalse((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>);</div><div class=\"line\">wilddog_node_addChild(p_father, p_child);</div><div class=\"line\"></div><div class=\"line\">Wilddog_Node_T *p_find = wilddog_node_find(p_father, <span class=\"string\">\"this is key\"</span>); <span class=\"comment\">//p_find和p_child是同一个节点</span></div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-getValue\"><a href=\"#wilddog-node-getValue\" class=\"headerlink\" title=\"wilddog_node_getValue()\"></a>wilddog_node_getValue()</h2><p> 定义</p>\n<p>Wilddog_Str_T<em> wilddog_node_getValue(Wilddog_Node_T \\</em>node, int *len)</p>\n<p> 说明</p>\n<p>获取当前节点的value值，其中，值为true，false，null的节点无法通过这种方式获取，而应该直接根据节点的<code>d_wn_type</code>得出其类型，类型在<code>wildog.h</code>中定义。</p>\n<p> 参数</p>\n<ul>\n<li>node <code>Wilddog_Node_T*</code> : 指向节点的指针。</li>\n<li><p>len <code>int*</code> : 输出参数，将存储value值的长度(字节)。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Node_T</code> 成功返回指向节点value的指针(可根据type和传出的len来转化)，失败返回NULL。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>,<span class=\"number\">234</span>);</div><div class=\"line\"><span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</div><div class=\"line\">s32 value;</div><div class=\"line\">Wilddog_Str_T *p_data = wilddog_node_getValue(p_father, &amp;len); <span class=\"comment\">//len 应和sizeof(s32)相同</span></div><div class=\"line\">value = (s32)(*p_data);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-node-setValue\"><a href=\"#wilddog-node-setValue\" class=\"headerlink\" title=\"wilddog_node_setValue()\"></a>wilddog_node_setValue()</h2><p> 定义</p>\n<p>Wilddog_Return_T (Wilddog_Node_T *node, u8 *value, int len)</p>\n<p> 说明</p>\n<p>设置当前节点的value值,其中，值为true，false，null的节点无法通过这种方式设置，整数类型和浮点类型的节点，len 应该为<code>sizeof(s32)</code>和<code>sizeof(wFloat)</code>。</p>\n<p> 参数</p>\n<ul>\n<li>node <code>Wilddog_Node_T*</code> : 指向节点的指针。</li>\n<li>value <code>u8*</code> : 指向新value值的指针。</li>\n<li><p>len <code>int</code> : 新value的长度。</p>\n<p>返回值</p>\n</li>\n</ul>\n<p><code>Wilddog_Return_T</code> 成功返回 <code>0</code>, 失败返回 <code>&lt;0</code> 的数。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_child = wilddog_node_createNum((Wilddog_Str_T *)<span class=\"string\">\"this is key\"</span>,<span class=\"number\">234</span>);</div><div class=\"line\"><span class=\"keyword\">int</span> len = <span class=\"keyword\">sizeof</span>(s32);</div><div class=\"line\">s32 value = <span class=\"number\">456</span>;</div><div class=\"line\">wilddog_node_setValue(p_father, &amp;value, len);</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"AuthData-Methods\"><a href=\"#AuthData-Methods\" class=\"headerlink\" title=\"AuthData (Methods)\"></a>AuthData (<em>Methods</em>)</h1><h2 id=\"wilddog-auth\"><a href=\"#wilddog-auth\" class=\"headerlink\" title=\"wilddog_auth()\"></a>wilddog_auth()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_auth(Wilddog_Str_T *p_host, u8 *p_auth, int len, onAuthFunc onAuth, void *args)</p>\n<p> 说明</p>\n<p>发送auth数据到服务器进行认证，每个 host 只需要认证一次。</p>\n<p> 参数</p>\n<p>p_host <code>Wilddog_Str_T</code> : 进行auth认证的host字符串，如 <code>&quot;&lt;appId&gt;.wilddogio.com&quot;</code>。</p>\n<p>p_auth <code>u8*</code> : 指向auth数据的指针，auth 数据可以使用其他端 sdk 的 token，或者<a href=\"https://z.wilddog.com/rule/guide#5-zi-ding-yi-token0\">通过 wilddog token 生成器生成</a>。</p>\n<p>int <code>len</code> : auth数据的长度。</p>\n<p>onAuthFunc <code>onAuth</code> : 服务端回应认证或者认证超时触发的回调函数，类型是<code>void (*onAuthFunc)(void* arg, Wilddog_Return_T err)</code>，其中<code>arg</code>为用户传递的值，（即下面的<code>args</code>），<code>err</code>为状态码，具体见<code>Wilddog_Return_T</code>定义。</p>\n<p>args <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Return_T</code> 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，确认是否在云端认证成功需要在回调函数中判断。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myOnAuthFunc</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_ERR_NOERR || err &gt;= WILDDOG_HTTP_BAD_REQUEST)&#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"auth fail!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"auth success! %d\\n\"</span>, *(<span class=\"keyword\">int</span>*)arg);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//aquired a new auth token</span></div><div class=\"line\"><span class=\"keyword\">char</span>* newToken=<span class=\"string\">\"ABCD1234567890\"</span>;</div><div class=\"line\"></div><div class=\"line\">wilddog_auth(<span class=\"string\">\"aaa.wilddogio.com\"</span>, newToken, <span class=\"built_in\">strlen</span>(newToken), myOnAuthFunc, <span class=\"literal\">NULL</span>);</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"wilddog-unauth\"><a href=\"#wilddog-unauth\" class=\"headerlink\" title=\"wilddog_unauth()\"></a>wilddog_unauth()</h2><p> 定义</p>\n<p>Wilddog_Return_T wilddog_unauth(Wilddog_Str_T *p_host, onAuthFunc onAuth, void *args)</p>\n<p> 说明</p>\n<p>取消和服务器的auth认证，，每个 host 只需要取消认证一次。</p>\n<p> 参数</p>\n<p>p_host <code>Wilddog_Str_T</code> : 进行auth认证的host字符串，如 <code>&quot;&lt;appId&gt;.wilddogio.com&quot;</code>。</p>\n<p>onAuthFunc <code>onAuth</code> : 服务端回应认证或者认证超时触发的回调函数，类型是<code>void (*onAuthFunc)(void* arg, Wilddog_Return_T err)</code>，其中<code>arg</code>为用户传递的值，（即下面的<code>args</code>），<code>err</code>为状态码，具体见<code>Wilddog_Return_T</code>定义。</p>\n<p>args <code>void*</code> : 用户给回调函数传入的参数。</p>\n<p> 返回值</p>\n<p><code>Wilddog_Return_T</code> 发送成功返回0，发送失败则返回负数。注意该返回值仅表明发送是否成功，是否成功取消认证需要在回调函数中判断。</p>\n<p> 示例<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myOnAuthFunc</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_ERR_NOERR || err &gt;= WILDDOG_HTTP_BAD_REQUEST)&#123;</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"auth fail!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world! %d\\n\"</span>, (<span class=\"keyword\">int</span>)arg);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">wilddog_unauth(<span class=\"string\">\"aaa.wilddogio.com\"</span>, myOnAuthFunc, <span class=\"literal\">NULL</span>);</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n"},{"title":"完整 API 文档","_content":"\n# Wilddog (*Methods*)\n\n## – initWithUrl:\n\n 定义\n\n`- (id)initWithUrl:(NSString *)url`\n\n 说明\n\n用一个完整的 URL 初始化 Wilddog 对象。\n\n 参数\n\nurl  WilddogURL(例如: `https://<appId>.wilddogio.com`)\n\n----\n## – childByAppendingPath:\n \n 定义\n\n`- (Wilddog *)childByAppendingPath:(NSString *)pathString`\n\n 说明\n\n获得一个在指定路径节点处的 Wilddog 对象。\n相对路径可以是一个简单的节点名字（例如，‘fred’），或者是一个更深的路径（例如，'fred/name/first'）\n\n 参数\n\npathString 从这个节点到要设定的子节点的相对路径\n\n 返回值\n\n指定节点位置的 Wilddog 对象\n\n----\n## – childByAutoId\n\n 定义\n\n`- (Wilddog *) childByAutoId`\n\n 说明\n\n生成一个唯一名字的子节点，并且返回一个 Wilddog 对象。\n\n 返回值\n\n指定节点位置的 Wilddog 对象\n\n----\n## – setValue:\n\n 定义\n\n`- (void)setValue:(id)value`\n\n 说明\n\n设置一个节点的值。\n   \n往 Wilddog 当前路径写入一个值，这将会覆盖当前路径和子路径的所有数据。\n \n 支持的数据类型:\n \n - NSString -- @\"Hello World\"\n - NSNumber (包括 BOOL 类型) -- @YES, @43, @4.333\n - NSDictionary -- @{@\"key\": @\"value\", @\"nested\": @{@\"another\": @\"value\"} }\n - NSArray\n \n 传送一个 nil 或者 null 对象相当于调用 `removeValue`;\n 这个路径的所有数据和子路径的数据都将被删除.\n \n `setValue:` 将会删除先前保存的 priority，所以如果要保留先前 priority，必须调用 setValue:andPriority:\n \n `Server Timestamps:` Wilddog 服务器提供一种机制来获取服务器时间。比如我们可以结合 *onDisconnect* 来记录一个客户端的下线时间。\n \n`#define kWilddogServerValueTimestamp @{ @\".sv\": @\"timestamp\" }`\n\n``` \nWilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/users/joe/lastOnline\"];\n[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];\n\n```\n \n 参数\n\nvalue 将被写入的值\n\n----\n## – setValue:withCompletionBlock:\n\n 定义\n\n`- (void) setValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。\n\n 参数\nvalue 将被写入的值  \nblock 写操作提交到 Wilddog 服务器后回调的 block\n\n----\n## – setValue:andPriority:\n\n 定义\n\n`- (void) setValue:(id)value andPriority:(id)priority`\n\n 说明\n\n和 setValue: 方法类似，只是为要写入的数值添加了一个优先级。\n\n 参数\nvalue 要写入的数值  \npriority 这个数值的优先级\n\n----\n## – setValue:andPriority:withCompletionBlock:\n\n 定义\n\n`- (void) setValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。\n\n 参数\nvalue 要写入的数值  \npriority 这个数值的优先级  \nblock 当写操作被提交到服务器，将被触发的 block\n\n----\n## – removeValue\n\n 定义\n\n`- (void) removeValue`\n\n 说明\n\n删除当前节点，效果等同于 setValue:nil；  \n如果当前节点有子节点，子节点会被全部删除。\n当删除被提交到 Wilddog 数据库后，删除的效果会立即显现。\n\n----\n## – removeValueWithCompletionBlock:\n\n 定义\n\n`- (void) removeValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 remove 方法类似：增加了一个 block，当删除操作完成之后，会回调这个 block。\n\n 参数\n\nblock 删除操作提交到 Wilddog 服务器后，这个 block 会被回调\n\n----\n## – setPriority:\n\n 定义\n\n`- (void) setPriority:(id)priority`\n\n 说明\n\n设置 Wilddog 当前节点的优先级。  \n优先级被用来排序（如果没有指定优先级，子节点按照key排序）。  \n\n你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用 setValue:andPriority: ，当为已存在的数据指定优先级的时候，使用 setPriority:。\n节点按照如下规则排序：  \n没有 priority 的排最先。  \n有数字 priority 的次之，按照数值排序(从小到大)。  \n有字符串 priority 的排最后，按照字母表的顺序排列。  \n当两个子节点有相同的 priority（包括没有 priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。  \n注意：数值优先级被作为 IEEE 754双精度浮点型数字进行解析和排序，Key 以 String 类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。  \n\n 参数\n\npriority  指定节点的优先级。\n\n----\n## – setPriority:withCompletionBlock:\n\n 定义\n\n`- (void) setPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n和 setPriority: 方法类似，增加了一个 block，当 priority 操作被提交到 Wilddog 服务器之后，会回调这个 block。\n\n 参数\n\npriority 指定节点的优先级  \nblock 当 priority 操作被提交到 Wilddog 服务器之后，回调的 block\n\n----\n## – updateChildValues:\n\n 定义\n\n`- (void) updateChildValues:(NSDictionary *)values`\n\n 说明\n\n将输入对象的子节点合并到当前数据中。\n\n不存在的子节点将会被新增，存在子节点将会被替换。\n与 set 操作不同，update 不会直接覆盖原来的节点，而是将 value 中的所有子节点插入到已有的节点中，如果已有的节点中已经有同名子节点，则覆盖原有的子节点。  \n例如： update 之前 {\"l1\":\"on\",\"l3\":\"off\"} ,value={\"l1\":\"off\",\"l2\":\"on\"} update 后的数据是 {\"l1\":\"off\",\"l2\":\"on\",\"l3\":\"off\"}。\n\n 参数\n\nvalues 包含要合并子节点的对象\n\n----\n## – updateChildValues:withCompletionBlock:\n\n 定义\n\n`- (void) updateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 updateChildValues 方法类似：增加了一个 block，当更新操作完成之后，会回调这个 block。\n\n 参数\n\nvalues 包含要合并子节点的对象  \nblock updateChildValues操作提交到 Wilddog 服务器后，返回的 block\n\n----\n## – observeEventType:withBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。\n\n可以用 removeObserverWithHandle: 方法停止监听数据的变化。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到某事件时，回调 block\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。    \n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:withBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 \n\n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  \n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。 block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key   \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeSingleEventOfType:withBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\n同 observeEventType:withBlock: 类似，不同之处在于  observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到某事件时，回调 block\n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的key值。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n----\n## – observeSingleEventOfType:withBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n同 observeSingleEventOfType:withBlock: 类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock\n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n 参数\n\neventType   监听的事件类型    \nblock       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock\n\n----\n## – removeObserverWithHandle:\n\n 定义\n\n`- (void) removeObserverWithHandle:(WilddogHandle)handle`\n\n 说明\n\n取消监听事件。取消之前用 observeEventType:withBlock: 方法注册的监听事件。\n\n 参数\n\nhandle 由 observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – removeAllObservers\n\n 定义\n\n`- (void) removeAllObservers`\n\n 说明\n\n取消之前由 observeEventType:withBlock:方法注册的监听事件。\n\n----\n## – onDisconnectSetValue:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  \n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。  \nonDisconnectSetValue: 方法对实现在线系统是很有用的，这个在线系统可理解为：当用户失去连接时，一个数值被改变或者被清除，在别人的角度看，他的状态会显示“离线”。\n\n 参数\n\nvalue 断开连接后要设置的值\n\n----\n## – onDisconnectSetValue:withCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。\n\n 参数\n\nvalue 断开连接后要设置的值    \nblock 当设置值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发\n\n----\n## – onDisconnectSetValue:andPriority:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value andPriority:(id)priority`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  \n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。\n\n 参数\n\nvalue 断开连接后要设置的值  \npriority 断开连接后要设置的优先级\n\n----\n## – onDisconnectSetValue:andPriority:withCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。\n\n 参数\n\nvalue 连接断开后要设置的值  \npriority 连接断开后要设置的优先级  \nblock 当设置值的操作成功排队到Wilddog服务器上，这个 block 就会被触发\n\n----\n## – onDisconnectRemoveValue\n\n 定义\n\n`- (void) onDisconnectRemoveValue`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    \n\n当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValue 对实施在线系统很有用\n\n----\n## – onDisconnectRemoveValueWithCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectRemoveValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValueWithCompletionBlock: 对实施在线系统很有用\n\n 参数\n\nblock 当删除值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发\n\n----\n## – onDisconnectUpdateChildValues:\n\n 定义\n\n`- (void) onDisconnectUpdateChildValues:(NSDictionary *)values`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    \n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。\n\n 参数\n\nvalues 在连接断开之后，一个包含子节点键和值的字典\n\n----\n## – onDisconnectUpdateChildValues:withCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectUpdateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。\n\n 参数\n\nvalues 在连接断开之后，一个包含子节点键和值的字典  \nblock 当更新值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发\n\n----\n## – cancelDisconnectOperations\n\n 定义\n\n`- (void) cancelDisconnectOperations`\n\n 说明\n\n取消运行在离线状态设置的所有操作。  \n如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。\n\n----\n## – cancelDisconnectOperationsWithCompletionBlock:\n\n 定义\n\n`- (void) cancelDisconnectOperationsWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n取消运行在离线状态设置的所有操作。  \n如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。\n\n 参数\n\nblock 当 Wilddog 服务器接受到 cancel 请求，触发的 block\n\n----\n## + goOffline\n\n 定义\n\n`+ (void) goOffline`\n\n 说明\n\n手动建立连接，开启自动重连。\n\n----\n## + goOnline\n\n 定义\n\n`+ (void) goOnline`\n\n 说明\n\n手动断开连接，关闭自动重连。\n\n----\n## – runTransactionBlock:\n\n 定义\n\n`- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block`\n\n 说明\n\n更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。\n \n如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。\n \n 调用 [WTransactionResult abort] 可以取消这次操作。事例:\n \n```\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://<your-appid>.wilddogio.com\"];\n[[ref childByAppendingPath:@\"followNumber\"] runTransactionBlock:^WTransactionResult *(WMutableData *currentData)  {\nNSNumber *value = currentData.value;\nif (currentData.value == nil) {\n    value = @1;\n}else{\n    [currentData setValue:[NSNumber numberWithInt:(1 + [value intValue])]];\n}\nreturn [WTransactionResult successWithValue:currentData];\n}]; \n\n```\n\n 参数\n\nblock 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象\n\n----\n## – runTransactionBlock:andCompletionBlock:\n\n 定义\n\n`- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock`\n\n 说明\n\n更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。\n  \n如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。\n \n 调用 [WTransactionResult abort] 可以取消这次操作。 \n\n 参数\n\nblock 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象    \ncompletionBlock 当事务完成时这个块将被触发，无论成功与否\n\n----\n## – runTransactionBlock:andCompletionBlock:withLocalEvents:\n\n 定义\n\n`- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock withLocalEvents:(BOOL)localEvents`\n\n 说明\n\n更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。 \n \n如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。\n \n 调用 [WTransactionResult abort] 可以取消这次操作。\n\n 参数\n\nblock 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象    \ncompletionBlock 当事务完成时这个块将被触发，无论成功与否  \nlocalEvents  将其设置为 NO 来阻止触发中间状态的事件，只触发最终状态事件\n\n----\n## – description\n\n 定义\n\n`- (NSString *) description`\n\n 说明\n\n获取当前 Wilddog 数据库节点的绝对 URL。\n\n 返回值\n\n当前 Wilddog 数据库节点的绝对 URL\n\n----\n## + setLoggingEnabled:\n\n 定义\n\n`+ (void) setLoggingEnabled:(BOOL)enabled`\n\n 说明\n\n打印程序相关信息。\n\n 参数\n\nenabled 设为 YES 为打印。默认为 NO，不打印\n\n----\n## + sdkVersion\n\n 定义\n\n`+ (NSString *) sdkVersion`\n\n 说明\n\n返回 Wilddog SDK 版本号。\n\n 返回值\n\nWilddog SDK 版本号\n\n----\n## + defaultConfig\n\n 定义\n\n`+ (WConfig *)defaultConfig`\n\n 说明\n\n返回默认的配置对象，用于配置客户端。\n\n 返回值\n\n默认的配置对象\n\n----\n## + setDispatchQueue:\n\n 定义\n\n`+ (void)setDispatchQueue:(dispatch_queue_t)queue`\n\n 说明\n\n为事件 blocks 设置默认队列。\n\n 参数\n\nqueue 给所有的 Wilddog 事件类型设置的默认队列\n\n----\n## parent\n\n 定义\n\n`@property (strong, readonly, nonatomic) Wilddog *parent`\n\n 说明\n\n获取父节点的引用。如果当前节点就是 root 节点，方法执行后返回的依然是 root 节点的引用。\n\n----\n## root\n\n 定义\n\n`@property (strong, readonly, nonatomic) Wilddog *root`\n\n 说明\n\n获得 Wilddog 根结点的引用。\n\n----\n## key\n\n 定义\n\n`@property (strong, readonly, nonatomic) NSString *key`\n\n 说明\n\n获得当前路径下节点的名称。\n\n----\n## app\n\n 定义\n\n`@property (strong, readonly, nonatomic) WilddogApp *app`\n\n 说明\n\n根据引用获得 WilddogApp 实例。\n\n----\n# WDataSnapshot (*Methods*)\n\n## – childSnapshotForPath:\n 定义\n\n`- (WDataSnapshot *) childSnapshotForPath:(NSString *)childPathString`\n\n 说明\n\n根据指定的相对路径，来获取当前节点下的 WDataSnapshot。\n\nchildPathString 为相对路径  \n相对路径可以是一个简单的节点名字（例如，‘fred’）  \n也可以是一个更深的路径，（例如，'fred/name/first'）多层级间需要使用\"/\"分隔  \n如果节点的位置没有数据，则返回一个空的 WDataSnapshot\n\n 参数\n\nchildPathString 节点数据的相对路径\n\n 返回值\n\n指定节点位置的 WDataSnapshot\n\n----\n## – hasChild:\n\n 定义\n\n`- (BOOL) hasChild:(NSString *)childPathString`\n\n 说明\n\n如果指定路径下存在子节点，返回 YES。\n\n 参数\n\nchildPathString 相对路径\n\n 返回值\n\n如果指定路径下存在子节点，返回 YES，否则返回 NO\n\n----\n## – hasChildren\n\n 定义\n\n`- (BOOL) hasChildren`\n\n 说明\n\n如果这个 Datasnapshot 有任何子节点返回 YES，否则 NO。\n\n 返回值\n\n如果这个 Datasnapshot 有任何子节点返回 YES\n\n----\n## – exists\n\n 定义\n\n`- (BOOL)exists`\n\n 说明\n\n如果 DataSnapshot中包含非空数据，返回 YES。\n\n 返回值\n\n如果 DataSnapshot 包含一个非空数据，就返回 YES \n\n----\n## – valueInExportFormat\n\n 定义\n\n`- (id) valueInExportFormat`\n\n 说明\n\n返回该节点的原始数据\n\n----\n## value\n\n 定义\n\n`@property (strong, readonly, nonatomic) id value`\n\n 说明\n\n从 snapshot 中获得当前节点的数据。\n\n返回的数据类型有:NSDictionary、NSArray、NSNumber (包含 Bool 类型)、NSString\n\n----\n## childrenCount\n\n 定义\n\n`@property (readonly, nonatomic) NSUInteger childrenCount`\n\n 说明\n\n获得 DataSnapshot 的子节点的总数。\n\n----\n## ref\n\n 定义\n\n`@property (nonatomic, readonly, strong) Wilddog* ref`\n\n 说明\n\n从 DataSnapshot 中，获得当前节点的引用。\n\n----\n## key\n\n 定义\n\n`@property (strong, readonly, nonatomic) NSString* key`\n\n 说明\n\n从 DataSnapshot 中，获取当前节点的名称。\n\n----\n## children\n\n 定义\n\n`@property (strong, readonly, nonatomic) NSEnumerator* children`\n\n 说明\n\n获取当前 DataSnapshot 中，所有子节点的迭代器。\n\n```\nfor (WDataSnapshot* child in snapshot.children) {  \n     ...  \n}\n\n```\n\n----\n## priority\n\n 定义\n\n`@property (strong, readonly, nonatomic) id priority`\n\n 说明\n\n获取该 WDataSnapshot 对象的优先级。\n\n 返回值\n\n优先级是一个字符串，若没有设置优先级，则返回 nil\n\n----\n# WConfig (*Methods*)\n\n## persistenceEnabled\n\n 定义\n\n`@property (nonatomic) BOOL persistenceEnabled`\n\n 说明\n\n默认情况下，在你的应用程序正在运行时，Wilddog 客户端会将数据保存在内存中，当应用被重新启动时数据就没有了。把这个值设置为 YES 时，数据将被保存到设备，并且当应用程序重新启动时（即使在重新启动程序时没有网络连接），这些存储的数据也是可以用的。请注意，此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。  \n  \n如果你的应用使用了 Wilddog 认证，客户端将自动保存用户的身份认证 token ，即使没有启用数据持久化。但是，如果身份认证令牌在离线的时候过期，并且你打开了数据持久化，客户端将暂停写入操作，直到你成功地重新进行身份认证。这样做是因为防止写入的数据被发送给未经认证的用户和因安全规则的改变造成写入数据失败。\n\n----\n## persistenceCacheSizeBytes\n\n 定义\n\n`@property (nonatomic) NSUInteger persistenceCacheSizeBytes`\n\n 说明\n\n默认情况下，Wilddog 将占用最大10MB的磁盘空间去缓存数据。如果缓存大小超出此空间，Wilddog 将开始移除最近未使用的数据。如果你发现你的应用程序缓存太少或有过多的数据，调用此方法来更改缓存空间的大小。此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。 \n   \n请注意，指定缓存大小只是一个近似值，并在磁盘上的大小有时候可能会暂时超过它。\n\n----\n## callbackQueue\n\n 定义\n\n`@property (nonatomic, strong) dispatch_queue_t callbackQueue`\n\n 说明\n\n设置所有被触发事件的队列。默认队列为主队列。\n\n----\n# WQuery (*Methods*)\n\n## – observeEventType:withBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。\n\n可以用 removeObserverWithHandle: 方法停止监听数据的变化。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到某事件时，回调 block\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。  \n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:withBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n  \n由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 \n  \n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  \n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key     \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeSingleEventOfType:withBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\n同 observeEventType:withBlock: 类似，不同之处在于 observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到某事件时，回调 block  \n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n----\n## – observeSingleEventOfType:withBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n同 observeSingleEventOfType:withBlock:类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  \n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n 参数\n\neventType   监听的事件类型    \nblock       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  \n\n----\n## – removeObserverWithHandle:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\n取消监听事件。取消之前用 observeEventType:withBlock:注册的回调函数。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到某事件时，回调 block\n\n 返回值\n\nhandle 由 observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – removeAllObservers\n\n 定义\n\n`- (void) removeAllObservers`\n\n 说明\n\n取消之前由 observeEventType:withBlock:注册的所有的监听事件。\n\n----\n## – keepSynced:\n\n 定义\n\n`- (void) keepSynced:(BOOL)keepSynced`\n\n 说明\n\n在某一节点处通过调用`keepSynced:YES`方法，即使该节点处没有设置监听者，此节点处的数据也将自动下载存储并保持同步。\n\n 参数\n\nkeepSynced 参数设置为 YES，则在此节点处同步数据，设置为 NO，停止同步\n\n----\n## – queryLimitedToFirst:\n\n 定义\n\n`- (WQuery *) queryLimitedToFirst:(NSUInteger)limit`\n\n 说明\n\nqueryLimitedToFirst: 用于创建一个新 WQuery 引用，获取从第一条开始的指定数量的数据。    \n返回的 WQuery 查询器类将响应从第一个开始，到最多指定(limit)节点个数的数据。\n\n 参数\n\nlimit 这次查询能够获取的子节点的最大数量\n\n 返回值\n\n返回一个 WQuery 查询器类，最多指定(limit)个数的数据\n\n----\n## – queryLimitedToLast:\n\n 定义\n\n`- (WQuery *) queryLimitedToLast:(NSUInteger)limit`\n\n 说明\n\nqueryLimitedToLast: 用于创建一个新 WQuery 引用，获取从最后一条开始向前指定数量的数据。  \n将返回从最后一个开始，最多指定(limit)个数的数据。\n\n 参数\n\nlimit 这次查询能够获取的子节点的最大数量\n\n 返回值\n\n返回一个 WQuery 查询器类，最多指定(limit)个数的数据\n\n----\n## – queryOrderedByChild:\n\n 定义\n\n`- (WQuery *) queryOrderedByChild:(NSString *)key`\n\n 说明\n\nqueryOrderedByChild: 用于产生一个新 WQuery 引用，是按照特定子节点的值进行排序的。   \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 参数\n\nkey 指定用来排序的子节点的 key\n\n 返回值\n\n返回一个按指定的子节点 key 排序生成的 WQuery 查询器类\n\n----\n## – queryOrderedByKey\n\n 定义\n\n`- (WQuery *) queryOrderedByKey`\n\n 说明\n\nqueryOrderedByKey 用于产生一个新 WQuery 引用，是按照特定子节点的 key 进行排序的。  \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 返回值\n\n返回一个按指定的子节点 key 排序生成的 WQuery 查询器类\n\n----\n## – queryOrderedByValue\n\n 定义\n\n`- (WQuery *) queryOrderedByValue`\n\n 说明\n\nqueryOrderedByValue 用于产生一个新 WQuery 引用，是按照当前节点的值进行排序的。  \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 返回值\n\nhandle 由 observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – queryOrderedByPriority\n\n 定义\n\n`- (WQuery *) queryOrderedByPriority`\n\n 说明\n\nqueryOrderedByPriority 用于产生一个新 WQuery 引用，是按照当前节点的优先级排序的。     \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 返回值\n\nhandle 由observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – queryStartingAtValue:\n\n 定义\n\n`- (WQuery *) queryStartingAtValue:(id)startValue`\n\n 说明\n\nqueryStartingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均大于或等于 startValue。\n\n 参数\n\nstartValue query 查询到的值均大于等于 startValue\n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在数据值大于或等于 startValue 的节点事件\n\n----\n## – queryStartingAtValue:childKey:\n\n 定义\n\n`- (WQuery *) queryStartingAtValue:(id)startValue childKey:(NSString *)childKey`\n\n 说明\n\nqueryStartingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值大于 startValue，或者等于 startValue 并且 key 大于等于 childKey。\n\n 参数\n\nstartValue query查询到的值均大于等于 startValue\nchildKey query查询到的 key 均大于等于 childKey\n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在数据值大于 startValue，或等于 startValue 的值并且 key 大于或等于 childKey 的节点事件\n\n----\n## – queryEndingAtValue:\n\n 定义\n\n`- (WQuery *) queryEndingAtValue:(id)endValue`\n\n 说明\n\nqueryEndingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均小于或者等于 endValue。\n\n 参数\n\nendValue query查询到的值均小于等于 endValue  \n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在数据值均小于或等于 endValue 的节点事件\n\n----\n## – queryEndingAtValue:childKey:\n\n 定义\n\n`- (WQuery *) queryEndingAtValue:(id)endValue childKey:(NSString *)childKey`\n\n 说明\n\nqueryEndingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值小于 endValue，或者等于 endValue 并且 key 小于等于 childKey。\n\n 参数\n\nendValue query查询到的值均小于等于 endValue  \nchildKey query查询到的 key 均小于等于 childKey\n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在查询到的数据值小于 endValue，或者数据值等于 endValue 并且 key 小于等于 childKey 的节点事件\n\n----\n## – queryEqualToValue:\n\n 定义\n\n`- (WQuery *) queryEqualToValue:(id)value`\n\n 说明\n\nqueryEqualToValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值都等于 value。\n\n 参数\n\nvalue query查询到的值都等于 value  \n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应与 value 相等数值的节点事件\n\n----\n## – queryEqualToValue:childKey:\n\n 定义\n\n`- (WQuery *) queryEqualToValue:(id)value childKey:(NSString *)childKey`\n\n 说明\n\nqueryEqualToValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值等于 value 并且 key 等于 childKey。返回的值肯定是唯一的，因为 key 是唯一的。\n\n 参数\n\nvalue query查询到的值都等于 value  \nchildKey  query查询到的 key 都等于 childKey \n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应这个与之相等数值和 key 节点事件\n\n----\n## ref\n\n 定义\n\n`@property (nonatomic, readonly, strong) Wilddog* ref`\n\n 说明\n\n获取这个查询的 Wilddog 引用。\n\n----\n# WMutableData (*Methods*)\n\n## – hasChildren\n\n 定义\n\n`- (BOOL) hasChildren`\n\n 说明\n\n判断在当前 WMutableData 中，是否存在子节点。\n\n 返回值\n\nYES 为存在子节点，NO 为不存在\n\n----\n## – hasChildAtPath:\n\n 定义\n\n`- (BOOL) hasChildAtPath:(NSString *)path`\n\n 说明\n\n检查指定路径下是否存在子节点。\n\n 参数\n\npath 可以是类似'child'的单层级路径，也可以是类似'a/deeper/child'多层级路径\n\n 返回值\n\n如果在指定的相对路径下，该 WMutableData 包含子节点，则返回YES\n\n----\n## – childDataByAppendingPath:\n\n 定义\n\n`- (WMutableData *) childDataByAppendingPath:(NSString *)path`\n\n 说明\n\n用于获得一个在给定的相对路径下的 WMutableData 数据实例。\n\n 参数\n\npath 可以是类似'child'的单层级路径，也可以是类似'a/deeper/child'多层级路径\n\n 返回值\n\n指定路径下的 WMutableData 实例\n\n----\n## value\n\n 定义\n\n`@property (strong, nonatomic) id value`\n\n 说明\n\n修改 WMutableData 实例中的数据，value 可将其设置为 Wilddog 支持的任一原生数据类型：  \n NSNumber (includes BOOL)  \n NSDictionary  \n NSArray  \n NSString  \n nil / NSNull (设置 nil / NSNull 删除该数据)  \n注意修改这个 value，会覆盖这个节点的优先级  \n\n 返回值\n\n获得当前节点的数据\n\n----\n## priority\n\n 定义\n\n`@property (strong, nonatomic) id priority`\n\n 说明\n\n设置这个属性可以更新该节点下面的数据优先级，可以设置的值类型有：  \n* NSNumber  \n* NSString  \n* nil / NSNull (设置 nil / NSNull 删除该数据)   \n\n 返回值\n\n获得当前节点的优先级\n\n----\n## childrenCount\n\n 定义\n\n`@property (readonly, nonatomic) NSUInteger childrenCount`\n\n 返回值\n\n获得子节点的总数\n\n----\n## children\n\n 定义\n\n`@property (readonly, nonatomic, strong) NSEnumerator* children`\n\n 说明\n\n用于迭代该节点的子节点，可以用下面的这个方法：\n\n```  \nfor (WMutableData* child in data.children) {  \n    ...  \n}  \n\n```\n\n 返回值\n\n获取当前节点下所有子节点的 WMutabledata 实例的迭代器\n\n----\n## key\n\n 定义\n\n`@property (readonly, nonatomic, strong) NSString* key`\n\n 返回值\n\n获取当前节点的 key，最上层的节点的 key 是 nil\n\n----\n# WTransactionResult (*Methods*)\n\n\n## + successWithValue:\n\n 定义\n\n`+ (WTransactionResult *) successWithValue:(WMutableData *)value`\n\n 说明\n\n用于 runTransactionBlock: 方法中。 表明传入参数 value 应保存在这个节点处。\n\n 返回值\n\n返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值\n\n----\n## + abort\n\n 定义\n\n`+ (WTransactionResult *) abort`\n\n 说明\n\n用于 runTransactionBlock: 方法中。 使用该方法可以主动终止当前事务。\n\n 返回值\n\n返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值\n\n----\n# WilddogApp (*Methods*)\n\n\n## – goOffline\n\n 定义\n\n`- (void)goOffline`\n\n 说明\n\n断开与 Wilddog 服务器的连接\n\n----\n## – goOnline\n\n 定义\n\n`- (void)goOnline`\n\n 说明\n\n恢复与 Wilddog 服务器的连接\n\n\n\n\n","source":"api/sync/ios.md","raw":"title:  完整 API 文档\n---\n\n# Wilddog (*Methods*)\n\n## – initWithUrl:\n\n 定义\n\n`- (id)initWithUrl:(NSString *)url`\n\n 说明\n\n用一个完整的 URL 初始化 Wilddog 对象。\n\n 参数\n\nurl  WilddogURL(例如: `https://<appId>.wilddogio.com`)\n\n----\n## – childByAppendingPath:\n \n 定义\n\n`- (Wilddog *)childByAppendingPath:(NSString *)pathString`\n\n 说明\n\n获得一个在指定路径节点处的 Wilddog 对象。\n相对路径可以是一个简单的节点名字（例如，‘fred’），或者是一个更深的路径（例如，'fred/name/first'）\n\n 参数\n\npathString 从这个节点到要设定的子节点的相对路径\n\n 返回值\n\n指定节点位置的 Wilddog 对象\n\n----\n## – childByAutoId\n\n 定义\n\n`- (Wilddog *) childByAutoId`\n\n 说明\n\n生成一个唯一名字的子节点，并且返回一个 Wilddog 对象。\n\n 返回值\n\n指定节点位置的 Wilddog 对象\n\n----\n## – setValue:\n\n 定义\n\n`- (void)setValue:(id)value`\n\n 说明\n\n设置一个节点的值。\n   \n往 Wilddog 当前路径写入一个值，这将会覆盖当前路径和子路径的所有数据。\n \n 支持的数据类型:\n \n - NSString -- @\"Hello World\"\n - NSNumber (包括 BOOL 类型) -- @YES, @43, @4.333\n - NSDictionary -- @{@\"key\": @\"value\", @\"nested\": @{@\"another\": @\"value\"} }\n - NSArray\n \n 传送一个 nil 或者 null 对象相当于调用 `removeValue`;\n 这个路径的所有数据和子路径的数据都将被删除.\n \n `setValue:` 将会删除先前保存的 priority，所以如果要保留先前 priority，必须调用 setValue:andPriority:\n \n `Server Timestamps:` Wilddog 服务器提供一种机制来获取服务器时间。比如我们可以结合 *onDisconnect* 来记录一个客户端的下线时间。\n \n`#define kWilddogServerValueTimestamp @{ @\".sv\": @\"timestamp\" }`\n\n``` \nWilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/users/joe/lastOnline\"];\n[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];\n\n```\n \n 参数\n\nvalue 将被写入的值\n\n----\n## – setValue:withCompletionBlock:\n\n 定义\n\n`- (void) setValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。\n\n 参数\nvalue 将被写入的值  \nblock 写操作提交到 Wilddog 服务器后回调的 block\n\n----\n## – setValue:andPriority:\n\n 定义\n\n`- (void) setValue:(id)value andPriority:(id)priority`\n\n 说明\n\n和 setValue: 方法类似，只是为要写入的数值添加了一个优先级。\n\n 参数\nvalue 要写入的数值  \npriority 这个数值的优先级\n\n----\n## – setValue:andPriority:withCompletionBlock:\n\n 定义\n\n`- (void) setValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。\n\n 参数\nvalue 要写入的数值  \npriority 这个数值的优先级  \nblock 当写操作被提交到服务器，将被触发的 block\n\n----\n## – removeValue\n\n 定义\n\n`- (void) removeValue`\n\n 说明\n\n删除当前节点，效果等同于 setValue:nil；  \n如果当前节点有子节点，子节点会被全部删除。\n当删除被提交到 Wilddog 数据库后，删除的效果会立即显现。\n\n----\n## – removeValueWithCompletionBlock:\n\n 定义\n\n`- (void) removeValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 remove 方法类似：增加了一个 block，当删除操作完成之后，会回调这个 block。\n\n 参数\n\nblock 删除操作提交到 Wilddog 服务器后，这个 block 会被回调\n\n----\n## – setPriority:\n\n 定义\n\n`- (void) setPriority:(id)priority`\n\n 说明\n\n设置 Wilddog 当前节点的优先级。  \n优先级被用来排序（如果没有指定优先级，子节点按照key排序）。  \n\n你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用 setValue:andPriority: ，当为已存在的数据指定优先级的时候，使用 setPriority:。\n节点按照如下规则排序：  \n没有 priority 的排最先。  \n有数字 priority 的次之，按照数值排序(从小到大)。  \n有字符串 priority 的排最后，按照字母表的顺序排列。  \n当两个子节点有相同的 priority（包括没有 priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。  \n注意：数值优先级被作为 IEEE 754双精度浮点型数字进行解析和排序，Key 以 String 类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。  \n\n 参数\n\npriority  指定节点的优先级。\n\n----\n## – setPriority:withCompletionBlock:\n\n 定义\n\n`- (void) setPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n和 setPriority: 方法类似，增加了一个 block，当 priority 操作被提交到 Wilddog 服务器之后，会回调这个 block。\n\n 参数\n\npriority 指定节点的优先级  \nblock 当 priority 操作被提交到 Wilddog 服务器之后，回调的 block\n\n----\n## – updateChildValues:\n\n 定义\n\n`- (void) updateChildValues:(NSDictionary *)values`\n\n 说明\n\n将输入对象的子节点合并到当前数据中。\n\n不存在的子节点将会被新增，存在子节点将会被替换。\n与 set 操作不同，update 不会直接覆盖原来的节点，而是将 value 中的所有子节点插入到已有的节点中，如果已有的节点中已经有同名子节点，则覆盖原有的子节点。  \n例如： update 之前 {\"l1\":\"on\",\"l3\":\"off\"} ,value={\"l1\":\"off\",\"l2\":\"on\"} update 后的数据是 {\"l1\":\"off\",\"l2\":\"on\",\"l3\":\"off\"}。\n\n 参数\n\nvalues 包含要合并子节点的对象\n\n----\n## – updateChildValues:withCompletionBlock:\n\n 定义\n\n`- (void) updateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n同 updateChildValues 方法类似：增加了一个 block，当更新操作完成之后，会回调这个 block。\n\n 参数\n\nvalues 包含要合并子节点的对象  \nblock updateChildValues操作提交到 Wilddog 服务器后，返回的 block\n\n----\n## – observeEventType:withBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。\n\n可以用 removeObserverWithHandle: 方法停止监听数据的变化。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到某事件时，回调 block\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。    \n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:withBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 \n\n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  \n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。 block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key   \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeSingleEventOfType:withBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\n同 observeEventType:withBlock: 类似，不同之处在于  observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到某事件时，回调 block\n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的key值。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n----\n## – observeSingleEventOfType:withBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n同 observeSingleEventOfType:withBlock: 类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock\n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n 参数\n\neventType   监听的事件类型    \nblock       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock\n\n----\n## – removeObserverWithHandle:\n\n 定义\n\n`- (void) removeObserverWithHandle:(WilddogHandle)handle`\n\n 说明\n\n取消监听事件。取消之前用 observeEventType:withBlock: 方法注册的监听事件。\n\n 参数\n\nhandle 由 observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – removeAllObservers\n\n 定义\n\n`- (void) removeAllObservers`\n\n 说明\n\n取消之前由 observeEventType:withBlock:方法注册的监听事件。\n\n----\n## – onDisconnectSetValue:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  \n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。  \nonDisconnectSetValue: 方法对实现在线系统是很有用的，这个在线系统可理解为：当用户失去连接时，一个数值被改变或者被清除，在别人的角度看，他的状态会显示“离线”。\n\n 参数\n\nvalue 断开连接后要设置的值\n\n----\n## – onDisconnectSetValue:withCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。\n\n 参数\n\nvalue 断开连接后要设置的值    \nblock 当设置值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发\n\n----\n## – onDisconnectSetValue:andPriority:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value andPriority:(id)priority`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  \n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。\n\n 参数\n\nvalue 断开连接后要设置的值  \npriority 断开连接后要设置的优先级\n\n----\n## – onDisconnectSetValue:andPriority:withCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectSetValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。\n\n 参数\n\nvalue 连接断开后要设置的值  \npriority 连接断开后要设置的优先级  \nblock 当设置值的操作成功排队到Wilddog服务器上，这个 block 就会被触发\n\n----\n## – onDisconnectRemoveValue\n\n 定义\n\n`- (void) onDisconnectRemoveValue`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    \n\n当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValue 对实施在线系统很有用\n\n----\n## – onDisconnectRemoveValueWithCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectRemoveValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValueWithCompletionBlock: 对实施在线系统很有用\n\n 参数\n\nblock 当删除值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发\n\n----\n## – onDisconnectUpdateChildValues:\n\n 定义\n\n`- (void) onDisconnectUpdateChildValues:(NSDictionary *)values`\n\n 说明\n\n离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    \n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。\n\n 参数\n\nvalues 在连接断开之后，一个包含子节点键和值的字典\n\n----\n## – onDisconnectUpdateChildValues:withCompletionBlock:\n\n 定义\n\n`- (void) onDisconnectUpdateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。\n\n 参数\n\nvalues 在连接断开之后，一个包含子节点键和值的字典  \nblock 当更新值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发\n\n----\n## – cancelDisconnectOperations\n\n 定义\n\n`- (void) cancelDisconnectOperations`\n\n 说明\n\n取消运行在离线状态设置的所有操作。  \n如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。\n\n----\n## – cancelDisconnectOperationsWithCompletionBlock:\n\n 定义\n\n`- (void) cancelDisconnectOperationsWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block`\n\n 说明\n\n取消运行在离线状态设置的所有操作。  \n如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。\n\n 参数\n\nblock 当 Wilddog 服务器接受到 cancel 请求，触发的 block\n\n----\n## + goOffline\n\n 定义\n\n`+ (void) goOffline`\n\n 说明\n\n手动建立连接，开启自动重连。\n\n----\n## + goOnline\n\n 定义\n\n`+ (void) goOnline`\n\n 说明\n\n手动断开连接，关闭自动重连。\n\n----\n## – runTransactionBlock:\n\n 定义\n\n`- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block`\n\n 说明\n\n更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。\n \n如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。\n \n 调用 [WTransactionResult abort] 可以取消这次操作。事例:\n \n```\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://<your-appid>.wilddogio.com\"];\n[[ref childByAppendingPath:@\"followNumber\"] runTransactionBlock:^WTransactionResult *(WMutableData *currentData)  {\nNSNumber *value = currentData.value;\nif (currentData.value == nil) {\n    value = @1;\n}else{\n    [currentData setValue:[NSNumber numberWithInt:(1 + [value intValue])]];\n}\nreturn [WTransactionResult successWithValue:currentData];\n}]; \n\n```\n\n 参数\n\nblock 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象\n\n----\n## – runTransactionBlock:andCompletionBlock:\n\n 定义\n\n`- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock`\n\n 说明\n\n更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。\n  \n如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。\n \n 调用 [WTransactionResult abort] 可以取消这次操作。 \n\n 参数\n\nblock 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象    \ncompletionBlock 当事务完成时这个块将被触发，无论成功与否\n\n----\n## – runTransactionBlock:andCompletionBlock:withLocalEvents:\n\n 定义\n\n`- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock withLocalEvents:(BOOL)localEvents`\n\n 说明\n\n更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。 \n \n如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。\n \n 调用 [WTransactionResult abort] 可以取消这次操作。\n\n 参数\n\nblock 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象    \ncompletionBlock 当事务完成时这个块将被触发，无论成功与否  \nlocalEvents  将其设置为 NO 来阻止触发中间状态的事件，只触发最终状态事件\n\n----\n## – description\n\n 定义\n\n`- (NSString *) description`\n\n 说明\n\n获取当前 Wilddog 数据库节点的绝对 URL。\n\n 返回值\n\n当前 Wilddog 数据库节点的绝对 URL\n\n----\n## + setLoggingEnabled:\n\n 定义\n\n`+ (void) setLoggingEnabled:(BOOL)enabled`\n\n 说明\n\n打印程序相关信息。\n\n 参数\n\nenabled 设为 YES 为打印。默认为 NO，不打印\n\n----\n## + sdkVersion\n\n 定义\n\n`+ (NSString *) sdkVersion`\n\n 说明\n\n返回 Wilddog SDK 版本号。\n\n 返回值\n\nWilddog SDK 版本号\n\n----\n## + defaultConfig\n\n 定义\n\n`+ (WConfig *)defaultConfig`\n\n 说明\n\n返回默认的配置对象，用于配置客户端。\n\n 返回值\n\n默认的配置对象\n\n----\n## + setDispatchQueue:\n\n 定义\n\n`+ (void)setDispatchQueue:(dispatch_queue_t)queue`\n\n 说明\n\n为事件 blocks 设置默认队列。\n\n 参数\n\nqueue 给所有的 Wilddog 事件类型设置的默认队列\n\n----\n## parent\n\n 定义\n\n`@property (strong, readonly, nonatomic) Wilddog *parent`\n\n 说明\n\n获取父节点的引用。如果当前节点就是 root 节点，方法执行后返回的依然是 root 节点的引用。\n\n----\n## root\n\n 定义\n\n`@property (strong, readonly, nonatomic) Wilddog *root`\n\n 说明\n\n获得 Wilddog 根结点的引用。\n\n----\n## key\n\n 定义\n\n`@property (strong, readonly, nonatomic) NSString *key`\n\n 说明\n\n获得当前路径下节点的名称。\n\n----\n## app\n\n 定义\n\n`@property (strong, readonly, nonatomic) WilddogApp *app`\n\n 说明\n\n根据引用获得 WilddogApp 实例。\n\n----\n# WDataSnapshot (*Methods*)\n\n## – childSnapshotForPath:\n 定义\n\n`- (WDataSnapshot *) childSnapshotForPath:(NSString *)childPathString`\n\n 说明\n\n根据指定的相对路径，来获取当前节点下的 WDataSnapshot。\n\nchildPathString 为相对路径  \n相对路径可以是一个简单的节点名字（例如，‘fred’）  \n也可以是一个更深的路径，（例如，'fred/name/first'）多层级间需要使用\"/\"分隔  \n如果节点的位置没有数据，则返回一个空的 WDataSnapshot\n\n 参数\n\nchildPathString 节点数据的相对路径\n\n 返回值\n\n指定节点位置的 WDataSnapshot\n\n----\n## – hasChild:\n\n 定义\n\n`- (BOOL) hasChild:(NSString *)childPathString`\n\n 说明\n\n如果指定路径下存在子节点，返回 YES。\n\n 参数\n\nchildPathString 相对路径\n\n 返回值\n\n如果指定路径下存在子节点，返回 YES，否则返回 NO\n\n----\n## – hasChildren\n\n 定义\n\n`- (BOOL) hasChildren`\n\n 说明\n\n如果这个 Datasnapshot 有任何子节点返回 YES，否则 NO。\n\n 返回值\n\n如果这个 Datasnapshot 有任何子节点返回 YES\n\n----\n## – exists\n\n 定义\n\n`- (BOOL)exists`\n\n 说明\n\n如果 DataSnapshot中包含非空数据，返回 YES。\n\n 返回值\n\n如果 DataSnapshot 包含一个非空数据，就返回 YES \n\n----\n## – valueInExportFormat\n\n 定义\n\n`- (id) valueInExportFormat`\n\n 说明\n\n返回该节点的原始数据\n\n----\n## value\n\n 定义\n\n`@property (strong, readonly, nonatomic) id value`\n\n 说明\n\n从 snapshot 中获得当前节点的数据。\n\n返回的数据类型有:NSDictionary、NSArray、NSNumber (包含 Bool 类型)、NSString\n\n----\n## childrenCount\n\n 定义\n\n`@property (readonly, nonatomic) NSUInteger childrenCount`\n\n 说明\n\n获得 DataSnapshot 的子节点的总数。\n\n----\n## ref\n\n 定义\n\n`@property (nonatomic, readonly, strong) Wilddog* ref`\n\n 说明\n\n从 DataSnapshot 中，获得当前节点的引用。\n\n----\n## key\n\n 定义\n\n`@property (strong, readonly, nonatomic) NSString* key`\n\n 说明\n\n从 DataSnapshot 中，获取当前节点的名称。\n\n----\n## children\n\n 定义\n\n`@property (strong, readonly, nonatomic) NSEnumerator* children`\n\n 说明\n\n获取当前 DataSnapshot 中，所有子节点的迭代器。\n\n```\nfor (WDataSnapshot* child in snapshot.children) {  \n     ...  \n}\n\n```\n\n----\n## priority\n\n 定义\n\n`@property (strong, readonly, nonatomic) id priority`\n\n 说明\n\n获取该 WDataSnapshot 对象的优先级。\n\n 返回值\n\n优先级是一个字符串，若没有设置优先级，则返回 nil\n\n----\n# WConfig (*Methods*)\n\n## persistenceEnabled\n\n 定义\n\n`@property (nonatomic) BOOL persistenceEnabled`\n\n 说明\n\n默认情况下，在你的应用程序正在运行时，Wilddog 客户端会将数据保存在内存中，当应用被重新启动时数据就没有了。把这个值设置为 YES 时，数据将被保存到设备，并且当应用程序重新启动时（即使在重新启动程序时没有网络连接），这些存储的数据也是可以用的。请注意，此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。  \n  \n如果你的应用使用了 Wilddog 认证，客户端将自动保存用户的身份认证 token ，即使没有启用数据持久化。但是，如果身份认证令牌在离线的时候过期，并且你打开了数据持久化，客户端将暂停写入操作，直到你成功地重新进行身份认证。这样做是因为防止写入的数据被发送给未经认证的用户和因安全规则的改变造成写入数据失败。\n\n----\n## persistenceCacheSizeBytes\n\n 定义\n\n`@property (nonatomic) NSUInteger persistenceCacheSizeBytes`\n\n 说明\n\n默认情况下，Wilddog 将占用最大10MB的磁盘空间去缓存数据。如果缓存大小超出此空间，Wilddog 将开始移除最近未使用的数据。如果你发现你的应用程序缓存太少或有过多的数据，调用此方法来更改缓存空间的大小。此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。 \n   \n请注意，指定缓存大小只是一个近似值，并在磁盘上的大小有时候可能会暂时超过它。\n\n----\n## callbackQueue\n\n 定义\n\n`@property (nonatomic, strong) dispatch_queue_t callbackQueue`\n\n 说明\n\n设置所有被触发事件的队列。默认队列为主队列。\n\n----\n# WQuery (*Methods*)\n\n## – observeEventType:withBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。\n\n可以用 removeObserverWithHandle: 方法停止监听数据的变化。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到某事件时，回调 block\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。  \n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:withBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:withBlock: 用于监听一个指定节点的数据变化\n这是从 Wilddog 服务器读取数据的主要方式  \n如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\nobserveEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。  \n这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n  \n由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 \n  \n用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  \n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key     \ncancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用\n\n 返回值\n\n一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block\n\n----\n## – observeSingleEventOfType:withBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\n同 observeEventType:withBlock: 类似，不同之处在于 observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到某事件时，回调 block  \n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n 参数\n\neventType 监听的事件类型    \nblock     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key\n\n----\n## – observeSingleEventOfType:withBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n同 observeSingleEventOfType:withBlock:类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。\n\n 参数\n\neventType   监听的事件类型    \nblock       当监听到某事件时，回调 block    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  \n\n----\n## – observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\n\n 定义\n\n`- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock`\n\n 说明\n\n这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。\n\n 参数\n\neventType   监听的事件类型    \nblock       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key    \ncancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  \n\n----\n## – removeObserverWithHandle:\n\n 定义\n\n`- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block`\n\n 说明\n\n取消监听事件。取消之前用 observeEventType:withBlock:注册的回调函数。\n\n 参数\n\neventType 监听的事件类型  \nblock     当监听到某事件时，回调 block\n\n 返回值\n\nhandle 由 observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – removeAllObservers\n\n 定义\n\n`- (void) removeAllObservers`\n\n 说明\n\n取消之前由 observeEventType:withBlock:注册的所有的监听事件。\n\n----\n## – keepSynced:\n\n 定义\n\n`- (void) keepSynced:(BOOL)keepSynced`\n\n 说明\n\n在某一节点处通过调用`keepSynced:YES`方法，即使该节点处没有设置监听者，此节点处的数据也将自动下载存储并保持同步。\n\n 参数\n\nkeepSynced 参数设置为 YES，则在此节点处同步数据，设置为 NO，停止同步\n\n----\n## – queryLimitedToFirst:\n\n 定义\n\n`- (WQuery *) queryLimitedToFirst:(NSUInteger)limit`\n\n 说明\n\nqueryLimitedToFirst: 用于创建一个新 WQuery 引用，获取从第一条开始的指定数量的数据。    \n返回的 WQuery 查询器类将响应从第一个开始，到最多指定(limit)节点个数的数据。\n\n 参数\n\nlimit 这次查询能够获取的子节点的最大数量\n\n 返回值\n\n返回一个 WQuery 查询器类，最多指定(limit)个数的数据\n\n----\n## – queryLimitedToLast:\n\n 定义\n\n`- (WQuery *) queryLimitedToLast:(NSUInteger)limit`\n\n 说明\n\nqueryLimitedToLast: 用于创建一个新 WQuery 引用，获取从最后一条开始向前指定数量的数据。  \n将返回从最后一个开始，最多指定(limit)个数的数据。\n\n 参数\n\nlimit 这次查询能够获取的子节点的最大数量\n\n 返回值\n\n返回一个 WQuery 查询器类，最多指定(limit)个数的数据\n\n----\n## – queryOrderedByChild:\n\n 定义\n\n`- (WQuery *) queryOrderedByChild:(NSString *)key`\n\n 说明\n\nqueryOrderedByChild: 用于产生一个新 WQuery 引用，是按照特定子节点的值进行排序的。   \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 参数\n\nkey 指定用来排序的子节点的 key\n\n 返回值\n\n返回一个按指定的子节点 key 排序生成的 WQuery 查询器类\n\n----\n## – queryOrderedByKey\n\n 定义\n\n`- (WQuery *) queryOrderedByKey`\n\n 说明\n\nqueryOrderedByKey 用于产生一个新 WQuery 引用，是按照特定子节点的 key 进行排序的。  \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 返回值\n\n返回一个按指定的子节点 key 排序生成的 WQuery 查询器类\n\n----\n## – queryOrderedByValue\n\n 定义\n\n`- (WQuery *) queryOrderedByValue`\n\n 说明\n\nqueryOrderedByValue 用于产生一个新 WQuery 引用，是按照当前节点的值进行排序的。  \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 返回值\n\nhandle 由 observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – queryOrderedByPriority\n\n 定义\n\n`- (WQuery *) queryOrderedByPriority`\n\n 说明\n\nqueryOrderedByPriority 用于产生一个新 WQuery 引用，是按照当前节点的优先级排序的。     \n此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。\n\n 返回值\n\nhandle 由observeEventType:withBlock:返回的 WilddogHandle\n\n----\n## – queryStartingAtValue:\n\n 定义\n\n`- (WQuery *) queryStartingAtValue:(id)startValue`\n\n 说明\n\nqueryStartingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均大于或等于 startValue。\n\n 参数\n\nstartValue query 查询到的值均大于等于 startValue\n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在数据值大于或等于 startValue 的节点事件\n\n----\n## – queryStartingAtValue:childKey:\n\n 定义\n\n`- (WQuery *) queryStartingAtValue:(id)startValue childKey:(NSString *)childKey`\n\n 说明\n\nqueryStartingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值大于 startValue，或者等于 startValue 并且 key 大于等于 childKey。\n\n 参数\n\nstartValue query查询到的值均大于等于 startValue\nchildKey query查询到的 key 均大于等于 childKey\n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在数据值大于 startValue，或等于 startValue 的值并且 key 大于或等于 childKey 的节点事件\n\n----\n## – queryEndingAtValue:\n\n 定义\n\n`- (WQuery *) queryEndingAtValue:(id)endValue`\n\n 说明\n\nqueryEndingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均小于或者等于 endValue。\n\n 参数\n\nendValue query查询到的值均小于等于 endValue  \n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在数据值均小于或等于 endValue 的节点事件\n\n----\n## – queryEndingAtValue:childKey:\n\n 定义\n\n`- (WQuery *) queryEndingAtValue:(id)endValue childKey:(NSString *)childKey`\n\n 说明\n\nqueryEndingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值小于 endValue，或者等于 endValue 并且 key 小于等于 childKey。\n\n 参数\n\nendValue query查询到的值均小于等于 endValue  \nchildKey query查询到的 key 均小于等于 childKey\n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应在查询到的数据值小于 endValue，或者数据值等于 endValue 并且 key 小于等于 childKey 的节点事件\n\n----\n## – queryEqualToValue:\n\n 定义\n\n`- (WQuery *) queryEqualToValue:(id)value`\n\n 说明\n\nqueryEqualToValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值都等于 value。\n\n 参数\n\nvalue query查询到的值都等于 value  \n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应与 value 相等数值的节点事件\n\n----\n## – queryEqualToValue:childKey:\n\n 定义\n\n`- (WQuery *) queryEqualToValue:(id)value childKey:(NSString *)childKey`\n\n 说明\n\nqueryEqualToValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值等于 value 并且 key 等于 childKey。返回的值肯定是唯一的，因为 key 是唯一的。\n\n 参数\n\nvalue query查询到的值都等于 value  \nchildKey  query查询到的 key 都等于 childKey \n\n 返回值\n\n返回一个 WQuery 查询器类，用于响应这个与之相等数值和 key 节点事件\n\n----\n## ref\n\n 定义\n\n`@property (nonatomic, readonly, strong) Wilddog* ref`\n\n 说明\n\n获取这个查询的 Wilddog 引用。\n\n----\n# WMutableData (*Methods*)\n\n## – hasChildren\n\n 定义\n\n`- (BOOL) hasChildren`\n\n 说明\n\n判断在当前 WMutableData 中，是否存在子节点。\n\n 返回值\n\nYES 为存在子节点，NO 为不存在\n\n----\n## – hasChildAtPath:\n\n 定义\n\n`- (BOOL) hasChildAtPath:(NSString *)path`\n\n 说明\n\n检查指定路径下是否存在子节点。\n\n 参数\n\npath 可以是类似'child'的单层级路径，也可以是类似'a/deeper/child'多层级路径\n\n 返回值\n\n如果在指定的相对路径下，该 WMutableData 包含子节点，则返回YES\n\n----\n## – childDataByAppendingPath:\n\n 定义\n\n`- (WMutableData *) childDataByAppendingPath:(NSString *)path`\n\n 说明\n\n用于获得一个在给定的相对路径下的 WMutableData 数据实例。\n\n 参数\n\npath 可以是类似'child'的单层级路径，也可以是类似'a/deeper/child'多层级路径\n\n 返回值\n\n指定路径下的 WMutableData 实例\n\n----\n## value\n\n 定义\n\n`@property (strong, nonatomic) id value`\n\n 说明\n\n修改 WMutableData 实例中的数据，value 可将其设置为 Wilddog 支持的任一原生数据类型：  \n NSNumber (includes BOOL)  \n NSDictionary  \n NSArray  \n NSString  \n nil / NSNull (设置 nil / NSNull 删除该数据)  \n注意修改这个 value，会覆盖这个节点的优先级  \n\n 返回值\n\n获得当前节点的数据\n\n----\n## priority\n\n 定义\n\n`@property (strong, nonatomic) id priority`\n\n 说明\n\n设置这个属性可以更新该节点下面的数据优先级，可以设置的值类型有：  \n* NSNumber  \n* NSString  \n* nil / NSNull (设置 nil / NSNull 删除该数据)   \n\n 返回值\n\n获得当前节点的优先级\n\n----\n## childrenCount\n\n 定义\n\n`@property (readonly, nonatomic) NSUInteger childrenCount`\n\n 返回值\n\n获得子节点的总数\n\n----\n## children\n\n 定义\n\n`@property (readonly, nonatomic, strong) NSEnumerator* children`\n\n 说明\n\n用于迭代该节点的子节点，可以用下面的这个方法：\n\n```  \nfor (WMutableData* child in data.children) {  \n    ...  \n}  \n\n```\n\n 返回值\n\n获取当前节点下所有子节点的 WMutabledata 实例的迭代器\n\n----\n## key\n\n 定义\n\n`@property (readonly, nonatomic, strong) NSString* key`\n\n 返回值\n\n获取当前节点的 key，最上层的节点的 key 是 nil\n\n----\n# WTransactionResult (*Methods*)\n\n\n## + successWithValue:\n\n 定义\n\n`+ (WTransactionResult *) successWithValue:(WMutableData *)value`\n\n 说明\n\n用于 runTransactionBlock: 方法中。 表明传入参数 value 应保存在这个节点处。\n\n 返回值\n\n返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值\n\n----\n## + abort\n\n 定义\n\n`+ (WTransactionResult *) abort`\n\n 说明\n\n用于 runTransactionBlock: 方法中。 使用该方法可以主动终止当前事务。\n\n 返回值\n\n返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值\n\n----\n# WilddogApp (*Methods*)\n\n\n## – goOffline\n\n 定义\n\n`- (void)goOffline`\n\n 说明\n\n断开与 Wilddog 服务器的连接\n\n----\n## – goOnline\n\n 定义\n\n`- (void)goOnline`\n\n 说明\n\n恢复与 Wilddog 服务器的连接\n\n\n\n\n","date":"2016-09-06T03:38:22.516Z","updated":"2016-09-06T03:38:22.516Z","path":"api/sync/ios.html","comments":1,"layout":"page","_id":"cisswi9j3000cz4fwkz4tb7ip","content":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"–-initWithUrl\"><a href=\"#–-initWithUrl\" class=\"headerlink\" title=\"– initWithUrl:\"></a>– initWithUrl:</h2><p> 定义</p>\n<p><code>- (id)initWithUrl:(NSString *)url</code></p>\n<p> 说明</p>\n<p>用一个完整的 URL 初始化 Wilddog 对象。</p>\n<p> 参数</p>\n<p>url  WilddogURL(例如: <code>https://&lt;appId&gt;.wilddogio.com</code>)</p>\n<hr>\n<h2 id=\"–-childByAppendingPath\"><a href=\"#–-childByAppendingPath\" class=\"headerlink\" title=\"– childByAppendingPath:\"></a>– childByAppendingPath:</h2><p> 定义</p>\n<p><code>- (Wilddog *)childByAppendingPath:(NSString *)pathString</code></p>\n<p> 说明</p>\n<p>获得一个在指定路径节点处的 Wilddog 对象。<br>相对路径可以是一个简单的节点名字（例如，‘fred’），或者是一个更深的路径（例如，’fred/name/first’）</p>\n<p> 参数</p>\n<p>pathString 从这个节点到要设定的子节点的相对路径</p>\n<p> 返回值</p>\n<p>指定节点位置的 Wilddog 对象</p>\n<hr>\n<h2 id=\"–-childByAutoId\"><a href=\"#–-childByAutoId\" class=\"headerlink\" title=\"– childByAutoId\"></a>– childByAutoId</h2><p> 定义</p>\n<p><code>- (Wilddog *) childByAutoId</code></p>\n<p> 说明</p>\n<p>生成一个唯一名字的子节点，并且返回一个 Wilddog 对象。</p>\n<p> 返回值</p>\n<p>指定节点位置的 Wilddog 对象</p>\n<hr>\n<h2 id=\"–-setValue\"><a href=\"#–-setValue\" class=\"headerlink\" title=\"– setValue:\"></a>– setValue:</h2><p> 定义</p>\n<p><code>- (void)setValue:(id)value</code></p>\n<p> 说明</p>\n<p>设置一个节点的值。</p>\n<p>往 Wilddog 当前路径写入一个值，这将会覆盖当前路径和子路径的所有数据。</p>\n<p> 支持的数据类型:</p>\n<ul>\n<li>NSString – @”Hello World”</li>\n<li>NSNumber (包括 BOOL 类型) – @YES, @43, @4.333</li>\n<li>NSDictionary – @{@”key”: @”value”, @”nested”: @{@”another”: @”value”} }</li>\n<li><p>NSArray</p>\n<p>传送一个 nil 或者 null 对象相当于调用 <code>removeValue</code>;<br>这个路径的所有数据和子路径的数据都将被删除.</p>\n<p><code>setValue:</code> 将会删除先前保存的 priority，所以如果要保留先前 priority，必须调用 setValue:andPriority:</p>\n<p><code>Server Timestamps:</code> Wilddog 服务器提供一种机制来获取服务器时间。比如我们可以结合 <em>onDisconnect</em> 来记录一个客户端的下线时间。</p>\n</li>\n</ul>\n<p><code>#define kWilddogServerValueTimestamp @{ @&quot;.sv&quot;: @&quot;timestamp&quot; }</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:@&quot;https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/users/joe/lastOnline&quot;];</div><div class=\"line\">[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];</div></pre></td></tr></table></figure>\n<p> 参数</p>\n<p>value 将被写入的值</p>\n<hr>\n<h2 id=\"–-setValue-withCompletionBlock\"><a href=\"#–-setValue-withCompletionBlock\" class=\"headerlink\" title=\"– setValue:withCompletionBlock:\"></a>– setValue:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) setValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。</p>\n<p> 参数<br>value 将被写入的值<br>block 写操作提交到 Wilddog 服务器后回调的 block</p>\n<hr>\n<h2 id=\"–-setValue-andPriority\"><a href=\"#–-setValue-andPriority\" class=\"headerlink\" title=\"– setValue:andPriority:\"></a>– setValue:andPriority:</h2><p> 定义</p>\n<p><code>- (void) setValue:(id)value andPriority:(id)priority</code></p>\n<p> 说明</p>\n<p>和 setValue: 方法类似，只是为要写入的数值添加了一个优先级。</p>\n<p> 参数<br>value 要写入的数值<br>priority 这个数值的优先级</p>\n<hr>\n<h2 id=\"–-setValue-andPriority-withCompletionBlock\"><a href=\"#–-setValue-andPriority-withCompletionBlock\" class=\"headerlink\" title=\"– setValue:andPriority:withCompletionBlock:\"></a>– setValue:andPriority:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) setValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。</p>\n<p> 参数<br>value 要写入的数值<br>priority 这个数值的优先级<br>block 当写操作被提交到服务器，将被触发的 block</p>\n<hr>\n<h2 id=\"–-removeValue\"><a href=\"#–-removeValue\" class=\"headerlink\" title=\"– removeValue\"></a>– removeValue</h2><p> 定义</p>\n<p><code>- (void) removeValue</code></p>\n<p> 说明</p>\n<p>删除当前节点，效果等同于 setValue:nil；<br>如果当前节点有子节点，子节点会被全部删除。<br>当删除被提交到 Wilddog 数据库后，删除的效果会立即显现。</p>\n<hr>\n<h2 id=\"–-removeValueWithCompletionBlock\"><a href=\"#–-removeValueWithCompletionBlock\" class=\"headerlink\" title=\"– removeValueWithCompletionBlock:\"></a>– removeValueWithCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) removeValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 remove 方法类似：增加了一个 block，当删除操作完成之后，会回调这个 block。</p>\n<p> 参数</p>\n<p>block 删除操作提交到 Wilddog 服务器后，这个 block 会被回调</p>\n<hr>\n<h2 id=\"–-setPriority\"><a href=\"#–-setPriority\" class=\"headerlink\" title=\"– setPriority:\"></a>– setPriority:</h2><p> 定义</p>\n<p><code>- (void) setPriority:(id)priority</code></p>\n<p> 说明</p>\n<p>设置 Wilddog 当前节点的优先级。<br>优先级被用来排序（如果没有指定优先级，子节点按照key排序）。  </p>\n<p>你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用 setValue:andPriority: ，当为已存在的数据指定优先级的时候，使用 setPriority:。<br>节点按照如下规则排序：<br>没有 priority 的排最先。<br>有数字 priority 的次之，按照数值排序(从小到大)。<br>有字符串 priority 的排最后，按照字母表的顺序排列。<br>当两个子节点有相同的 priority（包括没有 priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。<br>注意：数值优先级被作为 IEEE 754双精度浮点型数字进行解析和排序，Key 以 String 类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。  </p>\n<p> 参数</p>\n<p>priority  指定节点的优先级。</p>\n<hr>\n<h2 id=\"–-setPriority-withCompletionBlock\"><a href=\"#–-setPriority-withCompletionBlock\" class=\"headerlink\" title=\"– setPriority:withCompletionBlock:\"></a>– setPriority:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) setPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>和 setPriority: 方法类似，增加了一个 block，当 priority 操作被提交到 Wilddog 服务器之后，会回调这个 block。</p>\n<p> 参数</p>\n<p>priority 指定节点的优先级<br>block 当 priority 操作被提交到 Wilddog 服务器之后，回调的 block</p>\n<hr>\n<h2 id=\"–-updateChildValues\"><a href=\"#–-updateChildValues\" class=\"headerlink\" title=\"– updateChildValues:\"></a>– updateChildValues:</h2><p> 定义</p>\n<p><code>- (void) updateChildValues:(NSDictionary *)values</code></p>\n<p> 说明</p>\n<p>将输入对象的子节点合并到当前数据中。</p>\n<p>不存在的子节点将会被新增，存在子节点将会被替换。<br>与 set 操作不同，update 不会直接覆盖原来的节点，而是将 value 中的所有子节点插入到已有的节点中，如果已有的节点中已经有同名子节点，则覆盖原有的子节点。<br>例如： update 之前 {“l1”:”on”,”l3”:”off”} ,value={“l1”:”off”,”l2”:”on”} update 后的数据是 {“l1”:”off”,”l2”:”on”,”l3”:”off”}。</p>\n<p> 参数</p>\n<p>values 包含要合并子节点的对象</p>\n<hr>\n<h2 id=\"–-updateChildValues-withCompletionBlock\"><a href=\"#–-updateChildValues-withCompletionBlock\" class=\"headerlink\" title=\"– updateChildValues:withCompletionBlock:\"></a>– updateChildValues:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) updateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 updateChildValues 方法类似：增加了一个 block，当更新操作完成之后，会回调这个 block。</p>\n<p> 参数</p>\n<p>values 包含要合并子节点的对象<br>block updateChildValues操作提交到 Wilddog 服务器后，返回的 block</p>\n<hr>\n<h2 id=\"–-observeEventType-withBlock\"><a href=\"#–-observeEventType-withBlock\" class=\"headerlink\" title=\"– observeEventType:withBlock:\"></a>– observeEventType:withBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。</p>\n<p>可以用 removeObserverWithHandle: 方法停止监听数据的变化。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。<br>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-withBlock-withCancelBlock\"><a href=\"#–-observeEventType-withBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeEventType:withBlock:withCancelBlock:\"></a>– observeEventType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p>由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 </p>\n<p>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  </p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。 block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock\"><a href=\"#–-observeSingleEventOfType-withBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:\"></a>– observeSingleEventOfType:withBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>同 observeEventType:withBlock: 类似，不同之处在于  observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的key值。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock-withCancelBlock\"><a href=\"#–-observeSingleEventOfType-withBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:withCancelBlock:\"></a>– observeSingleEventOfType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>同 observeSingleEventOfType:withBlock: 类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock</p>\n<hr>\n<h2 id=\"–-removeObserverWithHandle\"><a href=\"#–-removeObserverWithHandle\" class=\"headerlink\" title=\"– removeObserverWithHandle:\"></a>– removeObserverWithHandle:</h2><p> 定义</p>\n<p><code>- (void) removeObserverWithHandle:(WilddogHandle)handle</code></p>\n<p> 说明</p>\n<p>取消监听事件。取消之前用 observeEventType:withBlock: 方法注册的监听事件。</p>\n<p> 参数</p>\n<p>handle 由 observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-removeAllObservers\"><a href=\"#–-removeAllObservers\" class=\"headerlink\" title=\"– removeAllObservers\"></a>– removeAllObservers</h2><p> 定义</p>\n<p><code>- (void) removeAllObservers</code></p>\n<p> 说明</p>\n<p>取消之前由 observeEventType:withBlock:方法注册的监听事件。</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue\"><a href=\"#–-onDisconnectSetValue\" class=\"headerlink\" title=\"– onDisconnectSetValue:\"></a>– onDisconnectSetValue:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  </p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。<br>onDisconnectSetValue: 方法对实现在线系统是很有用的，这个在线系统可理解为：当用户失去连接时，一个数值被改变或者被清除，在别人的角度看，他的状态会显示“离线”。</p>\n<p> 参数</p>\n<p>value 断开连接后要设置的值</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue-withCompletionBlock\"><a href=\"#–-onDisconnectSetValue-withCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectSetValue:withCompletionBlock:\"></a>– onDisconnectSetValue:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。</p>\n<p> 参数</p>\n<p>value 断开连接后要设置的值<br>block 当设置值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue-andPriority\"><a href=\"#–-onDisconnectSetValue-andPriority\" class=\"headerlink\" title=\"– onDisconnectSetValue:andPriority:\"></a>– onDisconnectSetValue:andPriority:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value andPriority:(id)priority</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  </p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。</p>\n<p> 参数</p>\n<p>value 断开连接后要设置的值<br>priority 断开连接后要设置的优先级</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue-andPriority-withCompletionBlock\"><a href=\"#–-onDisconnectSetValue-andPriority-withCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectSetValue:andPriority:withCompletionBlock:\"></a>– onDisconnectSetValue:andPriority:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。</p>\n<p> 参数</p>\n<p>value 连接断开后要设置的值<br>priority 连接断开后要设置的优先级<br>block 当设置值的操作成功排队到Wilddog服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-onDisconnectRemoveValue\"><a href=\"#–-onDisconnectRemoveValue\" class=\"headerlink\" title=\"– onDisconnectRemoveValue\"></a>– onDisconnectRemoveValue</h2><p> 定义</p>\n<p><code>- (void) onDisconnectRemoveValue</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    </p>\n<p>当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValue 对实施在线系统很有用</p>\n<hr>\n<h2 id=\"–-onDisconnectRemoveValueWithCompletionBlock\"><a href=\"#–-onDisconnectRemoveValueWithCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectRemoveValueWithCompletionBlock:\"></a>– onDisconnectRemoveValueWithCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectRemoveValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValueWithCompletionBlock: 对实施在线系统很有用</p>\n<p> 参数</p>\n<p>block 当删除值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-onDisconnectUpdateChildValues\"><a href=\"#–-onDisconnectUpdateChildValues\" class=\"headerlink\" title=\"– onDisconnectUpdateChildValues:\"></a>– onDisconnectUpdateChildValues:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectUpdateChildValues:(NSDictionary *)values</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    </p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。</p>\n<p> 参数</p>\n<p>values 在连接断开之后，一个包含子节点键和值的字典</p>\n<hr>\n<h2 id=\"–-onDisconnectUpdateChildValues-withCompletionBlock\"><a href=\"#–-onDisconnectUpdateChildValues-withCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectUpdateChildValues:withCompletionBlock:\"></a>– onDisconnectUpdateChildValues:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectUpdateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。</p>\n<p> 参数</p>\n<p>values 在连接断开之后，一个包含子节点键和值的字典<br>block 当更新值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-cancelDisconnectOperations\"><a href=\"#–-cancelDisconnectOperations\" class=\"headerlink\" title=\"– cancelDisconnectOperations\"></a>– cancelDisconnectOperations</h2><p> 定义</p>\n<p><code>- (void) cancelDisconnectOperations</code></p>\n<p> 说明</p>\n<p>取消运行在离线状态设置的所有操作。<br>如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。</p>\n<hr>\n<h2 id=\"–-cancelDisconnectOperationsWithCompletionBlock\"><a href=\"#–-cancelDisconnectOperationsWithCompletionBlock\" class=\"headerlink\" title=\"– cancelDisconnectOperationsWithCompletionBlock:\"></a>– cancelDisconnectOperationsWithCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) cancelDisconnectOperationsWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>取消运行在离线状态设置的所有操作。<br>如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。</p>\n<p> 参数</p>\n<p>block 当 Wilddog 服务器接受到 cancel 请求，触发的 block</p>\n<hr>\n<h2 id=\"goOffline\"><a href=\"#goOffline\" class=\"headerlink\" title=\"+ goOffline\"></a>+ goOffline</h2><p> 定义</p>\n<p><code>+ (void) goOffline</code></p>\n<p> 说明</p>\n<p>手动建立连接，开启自动重连。</p>\n<hr>\n<h2 id=\"goOnline\"><a href=\"#goOnline\" class=\"headerlink\" title=\"+ goOnline\"></a>+ goOnline</h2><p> 定义</p>\n<p><code>+ (void) goOnline</code></p>\n<p> 说明</p>\n<p>手动断开连接，关闭自动重连。</p>\n<hr>\n<h2 id=\"–-runTransactionBlock\"><a href=\"#–-runTransactionBlock\" class=\"headerlink\" title=\"– runTransactionBlock:\"></a>– runTransactionBlock:</h2><p> 定义</p>\n<p><code>- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block</code></p>\n<p> 说明</p>\n<p>更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。</p>\n<p>如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。</p>\n<p> 调用 [WTransactionResult abort] 可以取消这次操作。事例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:@&quot;https://&lt;your-appid&gt;.wilddogio.com&quot;];</div><div class=\"line\">[[ref childByAppendingPath:@&quot;followNumber&quot;] runTransactionBlock:^WTransactionResult *(WMutableData *currentData)  &#123;</div><div class=\"line\">NSNumber *value = currentData.value;</div><div class=\"line\">if (currentData.value == nil) &#123;</div><div class=\"line\">    value = @1;</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">    [currentData setValue:[NSNumber numberWithInt:(1 + [value intValue])]];</div><div class=\"line\">&#125;</div><div class=\"line\">return [WTransactionResult successWithValue:currentData];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p> 参数</p>\n<p>block 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象</p>\n<hr>\n<h2 id=\"–-runTransactionBlock-andCompletionBlock\"><a href=\"#–-runTransactionBlock-andCompletionBlock\" class=\"headerlink\" title=\"– runTransactionBlock:andCompletionBlock:\"></a>– runTransactionBlock:andCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock</code></p>\n<p> 说明</p>\n<p>更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。</p>\n<p>如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。</p>\n<p> 调用 [WTransactionResult abort] 可以取消这次操作。 </p>\n<p> 参数</p>\n<p>block 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象<br>completionBlock 当事务完成时这个块将被触发，无论成功与否</p>\n<hr>\n<h2 id=\"–-runTransactionBlock-andCompletionBlock-withLocalEvents\"><a href=\"#–-runTransactionBlock-andCompletionBlock-withLocalEvents\" class=\"headerlink\" title=\"– runTransactionBlock:andCompletionBlock:withLocalEvents:\"></a>– runTransactionBlock:andCompletionBlock:withLocalEvents:</h2><p> 定义</p>\n<p><code>- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock withLocalEvents:(BOOL)localEvents</code></p>\n<p> 说明</p>\n<p>更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。 </p>\n<p>如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。</p>\n<p> 调用 [WTransactionResult abort] 可以取消这次操作。</p>\n<p> 参数</p>\n<p>block 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象<br>completionBlock 当事务完成时这个块将被触发，无论成功与否<br>localEvents  将其设置为 NO 来阻止触发中间状态的事件，只触发最终状态事件</p>\n<hr>\n<h2 id=\"–-description\"><a href=\"#–-description\" class=\"headerlink\" title=\"– description\"></a>– description</h2><p> 定义</p>\n<p><code>- (NSString *) description</code></p>\n<p> 说明</p>\n<p>获取当前 Wilddog 数据库节点的绝对 URL。</p>\n<p> 返回值</p>\n<p>当前 Wilddog 数据库节点的绝对 URL</p>\n<hr>\n<h2 id=\"setLoggingEnabled\"><a href=\"#setLoggingEnabled\" class=\"headerlink\" title=\"+ setLoggingEnabled:\"></a>+ setLoggingEnabled:</h2><p> 定义</p>\n<p><code>+ (void) setLoggingEnabled:(BOOL)enabled</code></p>\n<p> 说明</p>\n<p>打印程序相关信息。</p>\n<p> 参数</p>\n<p>enabled 设为 YES 为打印。默认为 NO，不打印</p>\n<hr>\n<h2 id=\"sdkVersion\"><a href=\"#sdkVersion\" class=\"headerlink\" title=\"+ sdkVersion\"></a>+ sdkVersion</h2><p> 定义</p>\n<p><code>+ (NSString *) sdkVersion</code></p>\n<p> 说明</p>\n<p>返回 Wilddog SDK 版本号。</p>\n<p> 返回值</p>\n<p>Wilddog SDK 版本号</p>\n<hr>\n<h2 id=\"defaultConfig\"><a href=\"#defaultConfig\" class=\"headerlink\" title=\"+ defaultConfig\"></a>+ defaultConfig</h2><p> 定义</p>\n<p><code>+ (WConfig *)defaultConfig</code></p>\n<p> 说明</p>\n<p>返回默认的配置对象，用于配置客户端。</p>\n<p> 返回值</p>\n<p>默认的配置对象</p>\n<hr>\n<h2 id=\"setDispatchQueue\"><a href=\"#setDispatchQueue\" class=\"headerlink\" title=\"+ setDispatchQueue:\"></a>+ setDispatchQueue:</h2><p> 定义</p>\n<p><code>+ (void)setDispatchQueue:(dispatch_queue_t)queue</code></p>\n<p> 说明</p>\n<p>为事件 blocks 设置默认队列。</p>\n<p> 参数</p>\n<p>queue 给所有的 Wilddog 事件类型设置的默认队列</p>\n<hr>\n<h2 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) Wilddog *parent</code></p>\n<p> 说明</p>\n<p>获取父节点的引用。如果当前节点就是 root 节点，方法执行后返回的依然是 root 节点的引用。</p>\n<hr>\n<h2 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"root\"></a>root</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) Wilddog *root</code></p>\n<p> 说明</p>\n<p>获得 Wilddog 根结点的引用。</p>\n<hr>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) NSString *key</code></p>\n<p> 说明</p>\n<p>获得当前路径下节点的名称。</p>\n<hr>\n<h2 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) WilddogApp *app</code></p>\n<p> 说明</p>\n<p>根据引用获得 WilddogApp 实例。</p>\n<hr>\n<h1 id=\"WDataSnapshot-Methods\"><a href=\"#WDataSnapshot-Methods\" class=\"headerlink\" title=\"WDataSnapshot (Methods)\"></a>WDataSnapshot (<em>Methods</em>)</h1><h2 id=\"–-childSnapshotForPath\"><a href=\"#–-childSnapshotForPath\" class=\"headerlink\" title=\"– childSnapshotForPath:\"></a>– childSnapshotForPath:</h2><p> 定义</p>\n<p><code>- (WDataSnapshot *) childSnapshotForPath:(NSString *)childPathString</code></p>\n<p> 说明</p>\n<p>根据指定的相对路径，来获取当前节点下的 WDataSnapshot。</p>\n<p>childPathString 为相对路径<br>相对路径可以是一个简单的节点名字（例如，‘fred’）<br>也可以是一个更深的路径，（例如，’fred/name/first’）多层级间需要使用”/“分隔<br>如果节点的位置没有数据，则返回一个空的 WDataSnapshot</p>\n<p> 参数</p>\n<p>childPathString 节点数据的相对路径</p>\n<p> 返回值</p>\n<p>指定节点位置的 WDataSnapshot</p>\n<hr>\n<h2 id=\"–-hasChild\"><a href=\"#–-hasChild\" class=\"headerlink\" title=\"– hasChild:\"></a>– hasChild:</h2><p> 定义</p>\n<p><code>- (BOOL) hasChild:(NSString *)childPathString</code></p>\n<p> 说明</p>\n<p>如果指定路径下存在子节点，返回 YES。</p>\n<p> 参数</p>\n<p>childPathString 相对路径</p>\n<p> 返回值</p>\n<p>如果指定路径下存在子节点，返回 YES，否则返回 NO</p>\n<hr>\n<h2 id=\"–-hasChildren\"><a href=\"#–-hasChildren\" class=\"headerlink\" title=\"– hasChildren\"></a>– hasChildren</h2><p> 定义</p>\n<p><code>- (BOOL) hasChildren</code></p>\n<p> 说明</p>\n<p>如果这个 Datasnapshot 有任何子节点返回 YES，否则 NO。</p>\n<p> 返回值</p>\n<p>如果这个 Datasnapshot 有任何子节点返回 YES</p>\n<hr>\n<h2 id=\"–-exists\"><a href=\"#–-exists\" class=\"headerlink\" title=\"– exists\"></a>– exists</h2><p> 定义</p>\n<p><code>- (BOOL)exists</code></p>\n<p> 说明</p>\n<p>如果 DataSnapshot中包含非空数据，返回 YES。</p>\n<p> 返回值</p>\n<p>如果 DataSnapshot 包含一个非空数据，就返回 YES </p>\n<hr>\n<h2 id=\"–-valueInExportFormat\"><a href=\"#–-valueInExportFormat\" class=\"headerlink\" title=\"– valueInExportFormat\"></a>– valueInExportFormat</h2><p> 定义</p>\n<p><code>- (id) valueInExportFormat</code></p>\n<p> 说明</p>\n<p>返回该节点的原始数据</p>\n<hr>\n<h2 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"value\"></a>value</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) id value</code></p>\n<p> 说明</p>\n<p>从 snapshot 中获得当前节点的数据。</p>\n<p>返回的数据类型有:NSDictionary、NSArray、NSNumber (包含 Bool 类型)、NSString</p>\n<hr>\n<h2 id=\"childrenCount\"><a href=\"#childrenCount\" class=\"headerlink\" title=\"childrenCount\"></a>childrenCount</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic) NSUInteger childrenCount</code></p>\n<p> 说明</p>\n<p>获得 DataSnapshot 的子节点的总数。</p>\n<hr>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p> 定义</p>\n<p><code>@property (nonatomic, readonly, strong) Wilddog* ref</code></p>\n<p> 说明</p>\n<p>从 DataSnapshot 中，获得当前节点的引用。</p>\n<hr>\n<h2 id=\"key-1\"><a href=\"#key-1\" class=\"headerlink\" title=\"key\"></a>key</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) NSString* key</code></p>\n<p> 说明</p>\n<p>从 DataSnapshot 中，获取当前节点的名称。</p>\n<hr>\n<h2 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"children\"></a>children</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) NSEnumerator* children</code></p>\n<p> 说明</p>\n<p>获取当前 DataSnapshot 中，所有子节点的迭代器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for (WDataSnapshot* child in snapshot.children) &#123;  </div><div class=\"line\">     ...  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"priority\"><a href=\"#priority\" class=\"headerlink\" title=\"priority\"></a>priority</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) id priority</code></p>\n<p> 说明</p>\n<p>获取该 WDataSnapshot 对象的优先级。</p>\n<p> 返回值</p>\n<p>优先级是一个字符串，若没有设置优先级，则返回 nil</p>\n<hr>\n<h1 id=\"WConfig-Methods\"><a href=\"#WConfig-Methods\" class=\"headerlink\" title=\"WConfig (Methods)\"></a>WConfig (<em>Methods</em>)</h1><h2 id=\"persistenceEnabled\"><a href=\"#persistenceEnabled\" class=\"headerlink\" title=\"persistenceEnabled\"></a>persistenceEnabled</h2><p> 定义</p>\n<p><code>@property (nonatomic) BOOL persistenceEnabled</code></p>\n<p> 说明</p>\n<p>默认情况下，在你的应用程序正在运行时，Wilddog 客户端会将数据保存在内存中，当应用被重新启动时数据就没有了。把这个值设置为 YES 时，数据将被保存到设备，并且当应用程序重新启动时（即使在重新启动程序时没有网络连接），这些存储的数据也是可以用的。请注意，此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。  </p>\n<p>如果你的应用使用了 Wilddog 认证，客户端将自动保存用户的身份认证 token ，即使没有启用数据持久化。但是，如果身份认证令牌在离线的时候过期，并且你打开了数据持久化，客户端将暂停写入操作，直到你成功地重新进行身份认证。这样做是因为防止写入的数据被发送给未经认证的用户和因安全规则的改变造成写入数据失败。</p>\n<hr>\n<h2 id=\"persistenceCacheSizeBytes\"><a href=\"#persistenceCacheSizeBytes\" class=\"headerlink\" title=\"persistenceCacheSizeBytes\"></a>persistenceCacheSizeBytes</h2><p> 定义</p>\n<p><code>@property (nonatomic) NSUInteger persistenceCacheSizeBytes</code></p>\n<p> 说明</p>\n<p>默认情况下，Wilddog 将占用最大10MB的磁盘空间去缓存数据。如果缓存大小超出此空间，Wilddog 将开始移除最近未使用的数据。如果你发现你的应用程序缓存太少或有过多的数据，调用此方法来更改缓存空间的大小。此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。 </p>\n<p>请注意，指定缓存大小只是一个近似值，并在磁盘上的大小有时候可能会暂时超过它。</p>\n<hr>\n<h2 id=\"callbackQueue\"><a href=\"#callbackQueue\" class=\"headerlink\" title=\"callbackQueue\"></a>callbackQueue</h2><p> 定义</p>\n<p><code>@property (nonatomic, strong) dispatch_queue_t callbackQueue</code></p>\n<p> 说明</p>\n<p>设置所有被触发事件的队列。默认队列为主队列。</p>\n<hr>\n<h1 id=\"WQuery-Methods\"><a href=\"#WQuery-Methods\" class=\"headerlink\" title=\"WQuery (Methods)\"></a>WQuery (<em>Methods</em>)</h1><h2 id=\"–-observeEventType-withBlock-1\"><a href=\"#–-observeEventType-withBlock-1\" class=\"headerlink\" title=\"– observeEventType:withBlock:\"></a>– observeEventType:withBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。</p>\n<p>可以用 removeObserverWithHandle: 方法停止监听数据的变化。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock-1\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock-1\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。<br>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-withBlock-withCancelBlock-1\"><a href=\"#–-observeEventType-withBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeEventType:withBlock:withCancelBlock:\"></a>– observeEventType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p>由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 </p>\n<p>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  </p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock-1\"><a href=\"#–-observeSingleEventOfType-withBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:\"></a>– observeSingleEventOfType:withBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>同 observeEventType:withBlock: 类似，不同之处在于 observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block  </p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-1\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock-withCancelBlock-1\"><a href=\"#–-observeSingleEventOfType-withBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:withCancelBlock:\"></a>– observeSingleEventOfType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>同 observeSingleEventOfType:withBlock:类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  </p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  </p>\n<hr>\n<h2 id=\"–-removeObserverWithHandle-1\"><a href=\"#–-removeObserverWithHandle-1\" class=\"headerlink\" title=\"– removeObserverWithHandle:\"></a>– removeObserverWithHandle:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>取消监听事件。取消之前用 observeEventType:withBlock:注册的回调函数。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<p> 返回值</p>\n<p>handle 由 observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-removeAllObservers-1\"><a href=\"#–-removeAllObservers-1\" class=\"headerlink\" title=\"– removeAllObservers\"></a>– removeAllObservers</h2><p> 定义</p>\n<p><code>- (void) removeAllObservers</code></p>\n<p> 说明</p>\n<p>取消之前由 observeEventType:withBlock:注册的所有的监听事件。</p>\n<hr>\n<h2 id=\"–-keepSynced\"><a href=\"#–-keepSynced\" class=\"headerlink\" title=\"– keepSynced:\"></a>– keepSynced:</h2><p> 定义</p>\n<p><code>- (void) keepSynced:(BOOL)keepSynced</code></p>\n<p> 说明</p>\n<p>在某一节点处通过调用<code>keepSynced:YES</code>方法，即使该节点处没有设置监听者，此节点处的数据也将自动下载存储并保持同步。</p>\n<p> 参数</p>\n<p>keepSynced 参数设置为 YES，则在此节点处同步数据，设置为 NO，停止同步</p>\n<hr>\n<h2 id=\"–-queryLimitedToFirst\"><a href=\"#–-queryLimitedToFirst\" class=\"headerlink\" title=\"– queryLimitedToFirst:\"></a>– queryLimitedToFirst:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryLimitedToFirst:(NSUInteger)limit</code></p>\n<p> 说明</p>\n<p>queryLimitedToFirst: 用于创建一个新 WQuery 引用，获取从第一条开始的指定数量的数据。<br>返回的 WQuery 查询器类将响应从第一个开始，到最多指定(limit)节点个数的数据。</p>\n<p> 参数</p>\n<p>limit 这次查询能够获取的子节点的最大数量</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，最多指定(limit)个数的数据</p>\n<hr>\n<h2 id=\"–-queryLimitedToLast\"><a href=\"#–-queryLimitedToLast\" class=\"headerlink\" title=\"– queryLimitedToLast:\"></a>– queryLimitedToLast:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryLimitedToLast:(NSUInteger)limit</code></p>\n<p> 说明</p>\n<p>queryLimitedToLast: 用于创建一个新 WQuery 引用，获取从最后一条开始向前指定数量的数据。<br>将返回从最后一个开始，最多指定(limit)个数的数据。</p>\n<p> 参数</p>\n<p>limit 这次查询能够获取的子节点的最大数量</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，最多指定(limit)个数的数据</p>\n<hr>\n<h2 id=\"–-queryOrderedByChild\"><a href=\"#–-queryOrderedByChild\" class=\"headerlink\" title=\"– queryOrderedByChild:\"></a>– queryOrderedByChild:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByChild:(NSString *)key</code></p>\n<p> 说明</p>\n<p>queryOrderedByChild: 用于产生一个新 WQuery 引用，是按照特定子节点的值进行排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 参数</p>\n<p>key 指定用来排序的子节点的 key</p>\n<p> 返回值</p>\n<p>返回一个按指定的子节点 key 排序生成的 WQuery 查询器类</p>\n<hr>\n<h2 id=\"–-queryOrderedByKey\"><a href=\"#–-queryOrderedByKey\" class=\"headerlink\" title=\"– queryOrderedByKey\"></a>– queryOrderedByKey</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByKey</code></p>\n<p> 说明</p>\n<p>queryOrderedByKey 用于产生一个新 WQuery 引用，是按照特定子节点的 key 进行排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 返回值</p>\n<p>返回一个按指定的子节点 key 排序生成的 WQuery 查询器类</p>\n<hr>\n<h2 id=\"–-queryOrderedByValue\"><a href=\"#–-queryOrderedByValue\" class=\"headerlink\" title=\"– queryOrderedByValue\"></a>– queryOrderedByValue</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByValue</code></p>\n<p> 说明</p>\n<p>queryOrderedByValue 用于产生一个新 WQuery 引用，是按照当前节点的值进行排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 返回值</p>\n<p>handle 由 observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-queryOrderedByPriority\"><a href=\"#–-queryOrderedByPriority\" class=\"headerlink\" title=\"– queryOrderedByPriority\"></a>– queryOrderedByPriority</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByPriority</code></p>\n<p> 说明</p>\n<p>queryOrderedByPriority 用于产生一个新 WQuery 引用，是按照当前节点的优先级排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 返回值</p>\n<p>handle 由observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-queryStartingAtValue\"><a href=\"#–-queryStartingAtValue\" class=\"headerlink\" title=\"– queryStartingAtValue:\"></a>– queryStartingAtValue:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryStartingAtValue:(id)startValue</code></p>\n<p> 说明</p>\n<p>queryStartingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均大于或等于 startValue。</p>\n<p> 参数</p>\n<p>startValue query 查询到的值均大于等于 startValue</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在数据值大于或等于 startValue 的节点事件</p>\n<hr>\n<h2 id=\"–-queryStartingAtValue-childKey\"><a href=\"#–-queryStartingAtValue-childKey\" class=\"headerlink\" title=\"– queryStartingAtValue:childKey:\"></a>– queryStartingAtValue:childKey:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryStartingAtValue:(id)startValue childKey:(NSString *)childKey</code></p>\n<p> 说明</p>\n<p>queryStartingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值大于 startValue，或者等于 startValue 并且 key 大于等于 childKey。</p>\n<p> 参数</p>\n<p>startValue query查询到的值均大于等于 startValue<br>childKey query查询到的 key 均大于等于 childKey</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在数据值大于 startValue，或等于 startValue 的值并且 key 大于或等于 childKey 的节点事件</p>\n<hr>\n<h2 id=\"–-queryEndingAtValue\"><a href=\"#–-queryEndingAtValue\" class=\"headerlink\" title=\"– queryEndingAtValue:\"></a>– queryEndingAtValue:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEndingAtValue:(id)endValue</code></p>\n<p> 说明</p>\n<p>queryEndingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均小于或者等于 endValue。</p>\n<p> 参数</p>\n<p>endValue query查询到的值均小于等于 endValue  </p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在数据值均小于或等于 endValue 的节点事件</p>\n<hr>\n<h2 id=\"–-queryEndingAtValue-childKey\"><a href=\"#–-queryEndingAtValue-childKey\" class=\"headerlink\" title=\"– queryEndingAtValue:childKey:\"></a>– queryEndingAtValue:childKey:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEndingAtValue:(id)endValue childKey:(NSString *)childKey</code></p>\n<p> 说明</p>\n<p>queryEndingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值小于 endValue，或者等于 endValue 并且 key 小于等于 childKey。</p>\n<p> 参数</p>\n<p>endValue query查询到的值均小于等于 endValue<br>childKey query查询到的 key 均小于等于 childKey</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在查询到的数据值小于 endValue，或者数据值等于 endValue 并且 key 小于等于 childKey 的节点事件</p>\n<hr>\n<h2 id=\"–-queryEqualToValue\"><a href=\"#–-queryEqualToValue\" class=\"headerlink\" title=\"– queryEqualToValue:\"></a>– queryEqualToValue:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEqualToValue:(id)value</code></p>\n<p> 说明</p>\n<p>queryEqualToValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值都等于 value。</p>\n<p> 参数</p>\n<p>value query查询到的值都等于 value  </p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应与 value 相等数值的节点事件</p>\n<hr>\n<h2 id=\"–-queryEqualToValue-childKey\"><a href=\"#–-queryEqualToValue-childKey\" class=\"headerlink\" title=\"– queryEqualToValue:childKey:\"></a>– queryEqualToValue:childKey:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEqualToValue:(id)value childKey:(NSString *)childKey</code></p>\n<p> 说明</p>\n<p>queryEqualToValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值等于 value 并且 key 等于 childKey。返回的值肯定是唯一的，因为 key 是唯一的。</p>\n<p> 参数</p>\n<p>value query查询到的值都等于 value<br>childKey  query查询到的 key 都等于 childKey </p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应这个与之相等数值和 key 节点事件</p>\n<hr>\n<h2 id=\"ref-1\"><a href=\"#ref-1\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p> 定义</p>\n<p><code>@property (nonatomic, readonly, strong) Wilddog* ref</code></p>\n<p> 说明</p>\n<p>获取这个查询的 Wilddog 引用。</p>\n<hr>\n<h1 id=\"WMutableData-Methods\"><a href=\"#WMutableData-Methods\" class=\"headerlink\" title=\"WMutableData (Methods)\"></a>WMutableData (<em>Methods</em>)</h1><h2 id=\"–-hasChildren-1\"><a href=\"#–-hasChildren-1\" class=\"headerlink\" title=\"– hasChildren\"></a>– hasChildren</h2><p> 定义</p>\n<p><code>- (BOOL) hasChildren</code></p>\n<p> 说明</p>\n<p>判断在当前 WMutableData 中，是否存在子节点。</p>\n<p> 返回值</p>\n<p>YES 为存在子节点，NO 为不存在</p>\n<hr>\n<h2 id=\"–-hasChildAtPath\"><a href=\"#–-hasChildAtPath\" class=\"headerlink\" title=\"– hasChildAtPath:\"></a>– hasChildAtPath:</h2><p> 定义</p>\n<p><code>- (BOOL) hasChildAtPath:(NSString *)path</code></p>\n<p> 说明</p>\n<p>检查指定路径下是否存在子节点。</p>\n<p> 参数</p>\n<p>path 可以是类似’child’的单层级路径，也可以是类似’a/deeper/child’多层级路径</p>\n<p> 返回值</p>\n<p>如果在指定的相对路径下，该 WMutableData 包含子节点，则返回YES</p>\n<hr>\n<h2 id=\"–-childDataByAppendingPath\"><a href=\"#–-childDataByAppendingPath\" class=\"headerlink\" title=\"– childDataByAppendingPath:\"></a>– childDataByAppendingPath:</h2><p> 定义</p>\n<p><code>- (WMutableData *) childDataByAppendingPath:(NSString *)path</code></p>\n<p> 说明</p>\n<p>用于获得一个在给定的相对路径下的 WMutableData 数据实例。</p>\n<p> 参数</p>\n<p>path 可以是类似’child’的单层级路径，也可以是类似’a/deeper/child’多层级路径</p>\n<p> 返回值</p>\n<p>指定路径下的 WMutableData 实例</p>\n<hr>\n<h2 id=\"value-1\"><a href=\"#value-1\" class=\"headerlink\" title=\"value\"></a>value</h2><p> 定义</p>\n<p><code>@property (strong, nonatomic) id value</code></p>\n<p> 说明</p>\n<p>修改 WMutableData 实例中的数据，value 可将其设置为 Wilddog 支持的任一原生数据类型：<br> NSNumber (includes BOOL)<br> NSDictionary<br> NSArray<br> NSString<br> nil / NSNull (设置 nil / NSNull 删除该数据)<br>注意修改这个 value，会覆盖这个节点的优先级  </p>\n<p> 返回值</p>\n<p>获得当前节点的数据</p>\n<hr>\n<h2 id=\"priority-1\"><a href=\"#priority-1\" class=\"headerlink\" title=\"priority\"></a>priority</h2><p> 定义</p>\n<p><code>@property (strong, nonatomic) id priority</code></p>\n<p> 说明</p>\n<p>设置这个属性可以更新该节点下面的数据优先级，可以设置的值类型有：  </p>\n<ul>\n<li>NSNumber  </li>\n<li>NSString  </li>\n<li><p>nil / NSNull (设置 nil / NSNull 删除该数据)   </p>\n<p>返回值</p>\n</li>\n</ul>\n<p>获得当前节点的优先级</p>\n<hr>\n<h2 id=\"childrenCount-1\"><a href=\"#childrenCount-1\" class=\"headerlink\" title=\"childrenCount\"></a>childrenCount</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic) NSUInteger childrenCount</code></p>\n<p> 返回值</p>\n<p>获得子节点的总数</p>\n<hr>\n<h2 id=\"children-1\"><a href=\"#children-1\" class=\"headerlink\" title=\"children\"></a>children</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic, strong) NSEnumerator* children</code></p>\n<p> 说明</p>\n<p>用于迭代该节点的子节点，可以用下面的这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for (WMutableData* child in data.children) &#123;  </div><div class=\"line\">    ...  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 返回值</p>\n<p>获取当前节点下所有子节点的 WMutabledata 实例的迭代器</p>\n<hr>\n<h2 id=\"key-2\"><a href=\"#key-2\" class=\"headerlink\" title=\"key\"></a>key</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic, strong) NSString* key</code></p>\n<p> 返回值</p>\n<p>获取当前节点的 key，最上层的节点的 key 是 nil</p>\n<hr>\n<h1 id=\"WTransactionResult-Methods\"><a href=\"#WTransactionResult-Methods\" class=\"headerlink\" title=\"WTransactionResult (Methods)\"></a>WTransactionResult (<em>Methods</em>)</h1><h2 id=\"successWithValue\"><a href=\"#successWithValue\" class=\"headerlink\" title=\"+ successWithValue:\"></a>+ successWithValue:</h2><p> 定义</p>\n<p><code>+ (WTransactionResult *) successWithValue:(WMutableData *)value</code></p>\n<p> 说明</p>\n<p>用于 runTransactionBlock: 方法中。 表明传入参数 value 应保存在这个节点处。</p>\n<p> 返回值</p>\n<p>返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值</p>\n<hr>\n<h2 id=\"abort\"><a href=\"#abort\" class=\"headerlink\" title=\"+ abort\"></a>+ abort</h2><p> 定义</p>\n<p><code>+ (WTransactionResult *) abort</code></p>\n<p> 说明</p>\n<p>用于 runTransactionBlock: 方法中。 使用该方法可以主动终止当前事务。</p>\n<p> 返回值</p>\n<p>返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值</p>\n<hr>\n<h1 id=\"WilddogApp-Methods\"><a href=\"#WilddogApp-Methods\" class=\"headerlink\" title=\"WilddogApp (Methods)\"></a>WilddogApp (<em>Methods</em>)</h1><h2 id=\"–-goOffline\"><a href=\"#–-goOffline\" class=\"headerlink\" title=\"– goOffline\"></a>– goOffline</h2><p> 定义</p>\n<p><code>- (void)goOffline</code></p>\n<p> 说明</p>\n<p>断开与 Wilddog 服务器的连接</p>\n<hr>\n<h2 id=\"–-goOnline\"><a href=\"#–-goOnline\" class=\"headerlink\" title=\"– goOnline\"></a>– goOnline</h2><p> 定义</p>\n<p><code>- (void)goOnline</code></p>\n<p> 说明</p>\n<p>恢复与 Wilddog 服务器的连接</p>\n","excerpt":"","more":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"–-initWithUrl\"><a href=\"#–-initWithUrl\" class=\"headerlink\" title=\"– initWithUrl:\"></a>– initWithUrl:</h2><p> 定义</p>\n<p><code>- (id)initWithUrl:(NSString *)url</code></p>\n<p> 说明</p>\n<p>用一个完整的 URL 初始化 Wilddog 对象。</p>\n<p> 参数</p>\n<p>url  WilddogURL(例如: <code>https://&lt;appId&gt;.wilddogio.com</code>)</p>\n<hr>\n<h2 id=\"–-childByAppendingPath\"><a href=\"#–-childByAppendingPath\" class=\"headerlink\" title=\"– childByAppendingPath:\"></a>– childByAppendingPath:</h2><p> 定义</p>\n<p><code>- (Wilddog *)childByAppendingPath:(NSString *)pathString</code></p>\n<p> 说明</p>\n<p>获得一个在指定路径节点处的 Wilddog 对象。<br>相对路径可以是一个简单的节点名字（例如，‘fred’），或者是一个更深的路径（例如，’fred/name/first’）</p>\n<p> 参数</p>\n<p>pathString 从这个节点到要设定的子节点的相对路径</p>\n<p> 返回值</p>\n<p>指定节点位置的 Wilddog 对象</p>\n<hr>\n<h2 id=\"–-childByAutoId\"><a href=\"#–-childByAutoId\" class=\"headerlink\" title=\"– childByAutoId\"></a>– childByAutoId</h2><p> 定义</p>\n<p><code>- (Wilddog *) childByAutoId</code></p>\n<p> 说明</p>\n<p>生成一个唯一名字的子节点，并且返回一个 Wilddog 对象。</p>\n<p> 返回值</p>\n<p>指定节点位置的 Wilddog 对象</p>\n<hr>\n<h2 id=\"–-setValue\"><a href=\"#–-setValue\" class=\"headerlink\" title=\"– setValue:\"></a>– setValue:</h2><p> 定义</p>\n<p><code>- (void)setValue:(id)value</code></p>\n<p> 说明</p>\n<p>设置一个节点的值。</p>\n<p>往 Wilddog 当前路径写入一个值，这将会覆盖当前路径和子路径的所有数据。</p>\n<p> 支持的数据类型:</p>\n<ul>\n<li>NSString – @”Hello World”</li>\n<li>NSNumber (包括 BOOL 类型) – @YES, @43, @4.333</li>\n<li>NSDictionary – @{@”key”: @”value”, @”nested”: @{@”another”: @”value”} }</li>\n<li><p>NSArray</p>\n<p>传送一个 nil 或者 null 对象相当于调用 <code>removeValue</code>;<br>这个路径的所有数据和子路径的数据都将被删除.</p>\n<p><code>setValue:</code> 将会删除先前保存的 priority，所以如果要保留先前 priority，必须调用 setValue:andPriority:</p>\n<p><code>Server Timestamps:</code> Wilddog 服务器提供一种机制来获取服务器时间。比如我们可以结合 <em>onDisconnect</em> 来记录一个客户端的下线时间。</p>\n</li>\n</ul>\n<p><code>#define kWilddogServerValueTimestamp @{ @&quot;.sv&quot;: @&quot;timestamp&quot; }</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:@&quot;https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/users/joe/lastOnline&quot;];</div><div class=\"line\">[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];</div></pre></td></tr></table></figure>\n<p> 参数</p>\n<p>value 将被写入的值</p>\n<hr>\n<h2 id=\"–-setValue-withCompletionBlock\"><a href=\"#–-setValue-withCompletionBlock\" class=\"headerlink\" title=\"– setValue:withCompletionBlock:\"></a>– setValue:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) setValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。</p>\n<p> 参数<br>value 将被写入的值<br>block 写操作提交到 Wilddog 服务器后回调的 block</p>\n<hr>\n<h2 id=\"–-setValue-andPriority\"><a href=\"#–-setValue-andPriority\" class=\"headerlink\" title=\"– setValue:andPriority:\"></a>– setValue:andPriority:</h2><p> 定义</p>\n<p><code>- (void) setValue:(id)value andPriority:(id)priority</code></p>\n<p> 说明</p>\n<p>和 setValue: 方法类似，只是为要写入的数值添加了一个优先级。</p>\n<p> 参数<br>value 要写入的数值<br>priority 这个数值的优先级</p>\n<hr>\n<h2 id=\"–-setValue-andPriority-withCompletionBlock\"><a href=\"#–-setValue-andPriority-withCompletionBlock\" class=\"headerlink\" title=\"– setValue:andPriority:withCompletionBlock:\"></a>– setValue:andPriority:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) setValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 setValue 方法类似：增加了一个 block，当写操作完成之后，会回调这个 block。</p>\n<p> 参数<br>value 要写入的数值<br>priority 这个数值的优先级<br>block 当写操作被提交到服务器，将被触发的 block</p>\n<hr>\n<h2 id=\"–-removeValue\"><a href=\"#–-removeValue\" class=\"headerlink\" title=\"– removeValue\"></a>– removeValue</h2><p> 定义</p>\n<p><code>- (void) removeValue</code></p>\n<p> 说明</p>\n<p>删除当前节点，效果等同于 setValue:nil；<br>如果当前节点有子节点，子节点会被全部删除。<br>当删除被提交到 Wilddog 数据库后，删除的效果会立即显现。</p>\n<hr>\n<h2 id=\"–-removeValueWithCompletionBlock\"><a href=\"#–-removeValueWithCompletionBlock\" class=\"headerlink\" title=\"– removeValueWithCompletionBlock:\"></a>– removeValueWithCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) removeValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 remove 方法类似：增加了一个 block，当删除操作完成之后，会回调这个 block。</p>\n<p> 参数</p>\n<p>block 删除操作提交到 Wilddog 服务器后，这个 block 会被回调</p>\n<hr>\n<h2 id=\"–-setPriority\"><a href=\"#–-setPriority\" class=\"headerlink\" title=\"– setPriority:\"></a>– setPriority:</h2><p> 定义</p>\n<p><code>- (void) setPriority:(id)priority</code></p>\n<p> 说明</p>\n<p>设置 Wilddog 当前节点的优先级。<br>优先级被用来排序（如果没有指定优先级，子节点按照key排序）。  </p>\n<p>你不能对一个不存在的节点设置优先级。因此，当为新数据设置指定的优先级的时候，使用 setValue:andPriority: ，当为已存在的数据指定优先级的时候，使用 setPriority:。<br>节点按照如下规则排序：<br>没有 priority 的排最先。<br>有数字 priority 的次之，按照数值排序(从小到大)。<br>有字符串 priority 的排最后，按照字母表的顺序排列。<br>当两个子节点有相同的 priority（包括没有 priority），它们按照名字进行排列，数字排在最先（按数值大小排序），其他的跟在后面(以字典序排序)。<br>注意：数值优先级被作为 IEEE 754双精度浮点型数字进行解析和排序，Key 以 String 类型进行存储，只有当它能被解析成32位整型数字时被当作数字来处理。  </p>\n<p> 参数</p>\n<p>priority  指定节点的优先级。</p>\n<hr>\n<h2 id=\"–-setPriority-withCompletionBlock\"><a href=\"#–-setPriority-withCompletionBlock\" class=\"headerlink\" title=\"– setPriority:withCompletionBlock:\"></a>– setPriority:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) setPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>和 setPriority: 方法类似，增加了一个 block，当 priority 操作被提交到 Wilddog 服务器之后，会回调这个 block。</p>\n<p> 参数</p>\n<p>priority 指定节点的优先级<br>block 当 priority 操作被提交到 Wilddog 服务器之后，回调的 block</p>\n<hr>\n<h2 id=\"–-updateChildValues\"><a href=\"#–-updateChildValues\" class=\"headerlink\" title=\"– updateChildValues:\"></a>– updateChildValues:</h2><p> 定义</p>\n<p><code>- (void) updateChildValues:(NSDictionary *)values</code></p>\n<p> 说明</p>\n<p>将输入对象的子节点合并到当前数据中。</p>\n<p>不存在的子节点将会被新增，存在子节点将会被替换。<br>与 set 操作不同，update 不会直接覆盖原来的节点，而是将 value 中的所有子节点插入到已有的节点中，如果已有的节点中已经有同名子节点，则覆盖原有的子节点。<br>例如： update 之前 {“l1”:”on”,”l3”:”off”} ,value={“l1”:”off”,”l2”:”on”} update 后的数据是 {“l1”:”off”,”l2”:”on”,”l3”:”off”}。</p>\n<p> 参数</p>\n<p>values 包含要合并子节点的对象</p>\n<hr>\n<h2 id=\"–-updateChildValues-withCompletionBlock\"><a href=\"#–-updateChildValues-withCompletionBlock\" class=\"headerlink\" title=\"– updateChildValues:withCompletionBlock:\"></a>– updateChildValues:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) updateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>同 updateChildValues 方法类似：增加了一个 block，当更新操作完成之后，会回调这个 block。</p>\n<p> 参数</p>\n<p>values 包含要合并子节点的对象<br>block updateChildValues操作提交到 Wilddog 服务器后，返回的 block</p>\n<hr>\n<h2 id=\"–-observeEventType-withBlock\"><a href=\"#–-observeEventType-withBlock\" class=\"headerlink\" title=\"– observeEventType:withBlock:\"></a>– observeEventType:withBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。</p>\n<p>可以用 removeObserverWithHandle: 方法停止监听数据的变化。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。<br>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-withBlock-withCancelBlock\"><a href=\"#–-observeEventType-withBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeEventType:withBlock:withCancelBlock:\"></a>– observeEventType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p>由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 </p>\n<p>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  </p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。 block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock\"><a href=\"#–-observeSingleEventOfType-withBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:\"></a>– observeSingleEventOfType:withBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>同 observeEventType:withBlock: 类似，不同之处在于  observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的key值。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock-withCancelBlock\"><a href=\"#–-observeSingleEventOfType-withBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:withCancelBlock:\"></a>– observeSingleEventOfType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>同 observeSingleEventOfType:withBlock: 类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock</p>\n<hr>\n<h2 id=\"–-removeObserverWithHandle\"><a href=\"#–-removeObserverWithHandle\" class=\"headerlink\" title=\"– removeObserverWithHandle:\"></a>– removeObserverWithHandle:</h2><p> 定义</p>\n<p><code>- (void) removeObserverWithHandle:(WilddogHandle)handle</code></p>\n<p> 说明</p>\n<p>取消监听事件。取消之前用 observeEventType:withBlock: 方法注册的监听事件。</p>\n<p> 参数</p>\n<p>handle 由 observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-removeAllObservers\"><a href=\"#–-removeAllObservers\" class=\"headerlink\" title=\"– removeAllObservers\"></a>– removeAllObservers</h2><p> 定义</p>\n<p><code>- (void) removeAllObservers</code></p>\n<p> 说明</p>\n<p>取消之前由 observeEventType:withBlock:方法注册的监听事件。</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue\"><a href=\"#–-onDisconnectSetValue\" class=\"headerlink\" title=\"– onDisconnectSetValue:\"></a>– onDisconnectSetValue:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  </p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。<br>onDisconnectSetValue: 方法对实现在线系统是很有用的，这个在线系统可理解为：当用户失去连接时，一个数值被改变或者被清除，在别人的角度看，他的状态会显示“离线”。</p>\n<p> 参数</p>\n<p>value 断开连接后要设置的值</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue-withCompletionBlock\"><a href=\"#–-onDisconnectSetValue-withCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectSetValue:withCompletionBlock:\"></a>– onDisconnectSetValue:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值。</p>\n<p> 参数</p>\n<p>value 断开连接后要设置的值<br>block 当设置值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue-andPriority\"><a href=\"#–-onDisconnectSetValue-andPriority\" class=\"headerlink\" title=\"– onDisconnectSetValue:andPriority:\"></a>– onDisconnectSetValue:andPriority:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value andPriority:(id)priority</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。  </p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。</p>\n<p> 参数</p>\n<p>value 断开连接后要设置的值<br>priority 断开连接后要设置的优先级</p>\n<hr>\n<h2 id=\"–-onDisconnectSetValue-andPriority-withCompletionBlock\"><a href=\"#–-onDisconnectSetValue-andPriority-withCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectSetValue:andPriority:withCompletionBlock:\"></a>– onDisconnectSetValue:andPriority:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectSetValue:(id)value andPriority:(id)priority withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被设置成我们未离线前设定的值和优先级。</p>\n<p> 参数</p>\n<p>value 连接断开后要设置的值<br>priority 连接断开后要设置的优先级<br>block 当设置值的操作成功排队到Wilddog服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-onDisconnectRemoveValue\"><a href=\"#–-onDisconnectRemoveValue\" class=\"headerlink\" title=\"– onDisconnectRemoveValue\"></a>– onDisconnectRemoveValue</h2><p> 定义</p>\n<p><code>- (void) onDisconnectRemoveValue</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    </p>\n<p>当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValue 对实施在线系统很有用</p>\n<hr>\n<h2 id=\"–-onDisconnectRemoveValueWithCompletionBlock\"><a href=\"#–-onDisconnectRemoveValueWithCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectRemoveValueWithCompletionBlock:\"></a>– onDisconnectRemoveValueWithCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectRemoveValueWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭 app，导航一个新的页面，或者网络出现问题）时，确保在该节点的数据被删除。onDisconnectRemoveValueWithCompletionBlock: 对实施在线系统很有用</p>\n<p> 参数</p>\n<p>block 当删除值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-onDisconnectUpdateChildValues\"><a href=\"#–-onDisconnectUpdateChildValues\" class=\"headerlink\" title=\"– onDisconnectUpdateChildValues:\"></a>– onDisconnectUpdateChildValues:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectUpdateChildValues:(NSDictionary *)values</code></p>\n<p> 说明</p>\n<p>离线操作的含义是客户端的推送的数据并非立刻生效,而是当客户端离线的时候才生效。    </p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。</p>\n<p> 参数</p>\n<p>values 在连接断开之后，一个包含子节点键和值的字典</p>\n<hr>\n<h2 id=\"–-onDisconnectUpdateChildValues-withCompletionBlock\"><a href=\"#–-onDisconnectUpdateChildValues-withCompletionBlock\" class=\"headerlink\" title=\"– onDisconnectUpdateChildValues:withCompletionBlock:\"></a>– onDisconnectUpdateChildValues:withCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) onDisconnectUpdateChildValues:(NSDictionary *)values withCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>当客户端失去连接（因为关闭浏览器，导航一个新的页面，或者网络出现问题）时，确保拥有子节点的数据被更新。</p>\n<p> 参数</p>\n<p>values 在连接断开之后，一个包含子节点键和值的字典<br>block 当更新值的操作成功排队到 Wilddog 服务器上，这个 block 就会被触发</p>\n<hr>\n<h2 id=\"–-cancelDisconnectOperations\"><a href=\"#–-cancelDisconnectOperations\" class=\"headerlink\" title=\"– cancelDisconnectOperations\"></a>– cancelDisconnectOperations</h2><p> 定义</p>\n<p><code>- (void) cancelDisconnectOperations</code></p>\n<p> 说明</p>\n<p>取消运行在离线状态设置的所有操作。<br>如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。</p>\n<hr>\n<h2 id=\"–-cancelDisconnectOperationsWithCompletionBlock\"><a href=\"#–-cancelDisconnectOperationsWithCompletionBlock\" class=\"headerlink\" title=\"– cancelDisconnectOperationsWithCompletionBlock:\"></a>– cancelDisconnectOperationsWithCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) cancelDisconnectOperationsWithCompletionBlock:(void (^)(NSError* error, Wilddog* ref))block</code></p>\n<p> 说明</p>\n<p>取消运行在离线状态设置的所有操作。<br>如果你之前调用了 onDisconnectSetValue:,onDisconnectRemoveValue:, 或者 onDisconnectUpdateChildValues: 方法, 并且当连接断开时，不想再更新数值，这时候就调用 cancelDisconnectOperations:方法。</p>\n<p> 参数</p>\n<p>block 当 Wilddog 服务器接受到 cancel 请求，触发的 block</p>\n<hr>\n<h2 id=\"goOffline\"><a href=\"#goOffline\" class=\"headerlink\" title=\"+ goOffline\"></a>+ goOffline</h2><p> 定义</p>\n<p><code>+ (void) goOffline</code></p>\n<p> 说明</p>\n<p>手动建立连接，开启自动重连。</p>\n<hr>\n<h2 id=\"goOnline\"><a href=\"#goOnline\" class=\"headerlink\" title=\"+ goOnline\"></a>+ goOnline</h2><p> 定义</p>\n<p><code>+ (void) goOnline</code></p>\n<p> 说明</p>\n<p>手动断开连接，关闭自动重连。</p>\n<hr>\n<h2 id=\"–-runTransactionBlock\"><a href=\"#–-runTransactionBlock\" class=\"headerlink\" title=\"– runTransactionBlock:\"></a>– runTransactionBlock:</h2><p> 定义</p>\n<p><code>- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block</code></p>\n<p> 说明</p>\n<p>更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。</p>\n<p>如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。</p>\n<p> 调用 [WTransactionResult abort] 可以取消这次操作。事例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:@&quot;https://&lt;your-appid&gt;.wilddogio.com&quot;];</div><div class=\"line\">[[ref childByAppendingPath:@&quot;followNumber&quot;] runTransactionBlock:^WTransactionResult *(WMutableData *currentData)  &#123;</div><div class=\"line\">NSNumber *value = currentData.value;</div><div class=\"line\">if (currentData.value == nil) &#123;</div><div class=\"line\">    value = @1;</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">    [currentData setValue:[NSNumber numberWithInt:(1 + [value intValue])]];</div><div class=\"line\">&#125;</div><div class=\"line\">return [WTransactionResult successWithValue:currentData];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p> 参数</p>\n<p>block 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象</p>\n<hr>\n<h2 id=\"–-runTransactionBlock-andCompletionBlock\"><a href=\"#–-runTransactionBlock-andCompletionBlock\" class=\"headerlink\" title=\"– runTransactionBlock:andCompletionBlock:\"></a>– runTransactionBlock:andCompletionBlock:</h2><p> 定义</p>\n<p><code>- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock</code></p>\n<p> 说明</p>\n<p>更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。</p>\n<p>如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。</p>\n<p> 调用 [WTransactionResult abort] 可以取消这次操作。 </p>\n<p> 参数</p>\n<p>block 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象<br>completionBlock 当事务完成时这个块将被触发，无论成功与否</p>\n<hr>\n<h2 id=\"–-runTransactionBlock-andCompletionBlock-withLocalEvents\"><a href=\"#–-runTransactionBlock-andCompletionBlock-withLocalEvents\" class=\"headerlink\" title=\"– runTransactionBlock:andCompletionBlock:withLocalEvents:\"></a>– runTransactionBlock:andCompletionBlock:withLocalEvents:</h2><p> 定义</p>\n<p><code>- (void) runTransactionBlock:(WTransactionResult* (^) (WMutableData* currentData))block andCompletionBlock:(void (^) (NSError* error, BOOL committed, WDataSnapshot* snapshot))completionBlock withLocalEvents:(BOOL)localEvents</code></p>\n<p> 说明</p>\n<p>更新当前路径下的数据。服务器数据将会在 block 中返回，我们所要做的就是在 block 中把数据改成你要想要的，然后返回到 WTransactionResult 中。 </p>\n<p>如果这个节点数据发送到服务器上时已经被其他人修改过，那么这个 block 将会获取服务器最新数据再次执行。</p>\n<p> 调用 [WTransactionResult abort] 可以取消这次操作。</p>\n<p> 参数</p>\n<p>block 块(block)接收的当前数据(currentData)，然后返回一个WTransactionResult对象<br>completionBlock 当事务完成时这个块将被触发，无论成功与否<br>localEvents  将其设置为 NO 来阻止触发中间状态的事件，只触发最终状态事件</p>\n<hr>\n<h2 id=\"–-description\"><a href=\"#–-description\" class=\"headerlink\" title=\"– description\"></a>– description</h2><p> 定义</p>\n<p><code>- (NSString *) description</code></p>\n<p> 说明</p>\n<p>获取当前 Wilddog 数据库节点的绝对 URL。</p>\n<p> 返回值</p>\n<p>当前 Wilddog 数据库节点的绝对 URL</p>\n<hr>\n<h2 id=\"setLoggingEnabled\"><a href=\"#setLoggingEnabled\" class=\"headerlink\" title=\"+ setLoggingEnabled:\"></a>+ setLoggingEnabled:</h2><p> 定义</p>\n<p><code>+ (void) setLoggingEnabled:(BOOL)enabled</code></p>\n<p> 说明</p>\n<p>打印程序相关信息。</p>\n<p> 参数</p>\n<p>enabled 设为 YES 为打印。默认为 NO，不打印</p>\n<hr>\n<h2 id=\"sdkVersion\"><a href=\"#sdkVersion\" class=\"headerlink\" title=\"+ sdkVersion\"></a>+ sdkVersion</h2><p> 定义</p>\n<p><code>+ (NSString *) sdkVersion</code></p>\n<p> 说明</p>\n<p>返回 Wilddog SDK 版本号。</p>\n<p> 返回值</p>\n<p>Wilddog SDK 版本号</p>\n<hr>\n<h2 id=\"defaultConfig\"><a href=\"#defaultConfig\" class=\"headerlink\" title=\"+ defaultConfig\"></a>+ defaultConfig</h2><p> 定义</p>\n<p><code>+ (WConfig *)defaultConfig</code></p>\n<p> 说明</p>\n<p>返回默认的配置对象，用于配置客户端。</p>\n<p> 返回值</p>\n<p>默认的配置对象</p>\n<hr>\n<h2 id=\"setDispatchQueue\"><a href=\"#setDispatchQueue\" class=\"headerlink\" title=\"+ setDispatchQueue:\"></a>+ setDispatchQueue:</h2><p> 定义</p>\n<p><code>+ (void)setDispatchQueue:(dispatch_queue_t)queue</code></p>\n<p> 说明</p>\n<p>为事件 blocks 设置默认队列。</p>\n<p> 参数</p>\n<p>queue 给所有的 Wilddog 事件类型设置的默认队列</p>\n<hr>\n<h2 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) Wilddog *parent</code></p>\n<p> 说明</p>\n<p>获取父节点的引用。如果当前节点就是 root 节点，方法执行后返回的依然是 root 节点的引用。</p>\n<hr>\n<h2 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"root\"></a>root</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) Wilddog *root</code></p>\n<p> 说明</p>\n<p>获得 Wilddog 根结点的引用。</p>\n<hr>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) NSString *key</code></p>\n<p> 说明</p>\n<p>获得当前路径下节点的名称。</p>\n<hr>\n<h2 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) WilddogApp *app</code></p>\n<p> 说明</p>\n<p>根据引用获得 WilddogApp 实例。</p>\n<hr>\n<h1 id=\"WDataSnapshot-Methods\"><a href=\"#WDataSnapshot-Methods\" class=\"headerlink\" title=\"WDataSnapshot (Methods)\"></a>WDataSnapshot (<em>Methods</em>)</h1><h2 id=\"–-childSnapshotForPath\"><a href=\"#–-childSnapshotForPath\" class=\"headerlink\" title=\"– childSnapshotForPath:\"></a>– childSnapshotForPath:</h2><p> 定义</p>\n<p><code>- (WDataSnapshot *) childSnapshotForPath:(NSString *)childPathString</code></p>\n<p> 说明</p>\n<p>根据指定的相对路径，来获取当前节点下的 WDataSnapshot。</p>\n<p>childPathString 为相对路径<br>相对路径可以是一个简单的节点名字（例如，‘fred’）<br>也可以是一个更深的路径，（例如，’fred/name/first’）多层级间需要使用”/“分隔<br>如果节点的位置没有数据，则返回一个空的 WDataSnapshot</p>\n<p> 参数</p>\n<p>childPathString 节点数据的相对路径</p>\n<p> 返回值</p>\n<p>指定节点位置的 WDataSnapshot</p>\n<hr>\n<h2 id=\"–-hasChild\"><a href=\"#–-hasChild\" class=\"headerlink\" title=\"– hasChild:\"></a>– hasChild:</h2><p> 定义</p>\n<p><code>- (BOOL) hasChild:(NSString *)childPathString</code></p>\n<p> 说明</p>\n<p>如果指定路径下存在子节点，返回 YES。</p>\n<p> 参数</p>\n<p>childPathString 相对路径</p>\n<p> 返回值</p>\n<p>如果指定路径下存在子节点，返回 YES，否则返回 NO</p>\n<hr>\n<h2 id=\"–-hasChildren\"><a href=\"#–-hasChildren\" class=\"headerlink\" title=\"– hasChildren\"></a>– hasChildren</h2><p> 定义</p>\n<p><code>- (BOOL) hasChildren</code></p>\n<p> 说明</p>\n<p>如果这个 Datasnapshot 有任何子节点返回 YES，否则 NO。</p>\n<p> 返回值</p>\n<p>如果这个 Datasnapshot 有任何子节点返回 YES</p>\n<hr>\n<h2 id=\"–-exists\"><a href=\"#–-exists\" class=\"headerlink\" title=\"– exists\"></a>– exists</h2><p> 定义</p>\n<p><code>- (BOOL)exists</code></p>\n<p> 说明</p>\n<p>如果 DataSnapshot中包含非空数据，返回 YES。</p>\n<p> 返回值</p>\n<p>如果 DataSnapshot 包含一个非空数据，就返回 YES </p>\n<hr>\n<h2 id=\"–-valueInExportFormat\"><a href=\"#–-valueInExportFormat\" class=\"headerlink\" title=\"– valueInExportFormat\"></a>– valueInExportFormat</h2><p> 定义</p>\n<p><code>- (id) valueInExportFormat</code></p>\n<p> 说明</p>\n<p>返回该节点的原始数据</p>\n<hr>\n<h2 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"value\"></a>value</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) id value</code></p>\n<p> 说明</p>\n<p>从 snapshot 中获得当前节点的数据。</p>\n<p>返回的数据类型有:NSDictionary、NSArray、NSNumber (包含 Bool 类型)、NSString</p>\n<hr>\n<h2 id=\"childrenCount\"><a href=\"#childrenCount\" class=\"headerlink\" title=\"childrenCount\"></a>childrenCount</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic) NSUInteger childrenCount</code></p>\n<p> 说明</p>\n<p>获得 DataSnapshot 的子节点的总数。</p>\n<hr>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p> 定义</p>\n<p><code>@property (nonatomic, readonly, strong) Wilddog* ref</code></p>\n<p> 说明</p>\n<p>从 DataSnapshot 中，获得当前节点的引用。</p>\n<hr>\n<h2 id=\"key-1\"><a href=\"#key-1\" class=\"headerlink\" title=\"key\"></a>key</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) NSString* key</code></p>\n<p> 说明</p>\n<p>从 DataSnapshot 中，获取当前节点的名称。</p>\n<hr>\n<h2 id=\"children\"><a href=\"#children\" class=\"headerlink\" title=\"children\"></a>children</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) NSEnumerator* children</code></p>\n<p> 说明</p>\n<p>获取当前 DataSnapshot 中，所有子节点的迭代器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for (WDataSnapshot* child in snapshot.children) &#123;  </div><div class=\"line\">     ...  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"priority\"><a href=\"#priority\" class=\"headerlink\" title=\"priority\"></a>priority</h2><p> 定义</p>\n<p><code>@property (strong, readonly, nonatomic) id priority</code></p>\n<p> 说明</p>\n<p>获取该 WDataSnapshot 对象的优先级。</p>\n<p> 返回值</p>\n<p>优先级是一个字符串，若没有设置优先级，则返回 nil</p>\n<hr>\n<h1 id=\"WConfig-Methods\"><a href=\"#WConfig-Methods\" class=\"headerlink\" title=\"WConfig (Methods)\"></a>WConfig (<em>Methods</em>)</h1><h2 id=\"persistenceEnabled\"><a href=\"#persistenceEnabled\" class=\"headerlink\" title=\"persistenceEnabled\"></a>persistenceEnabled</h2><p> 定义</p>\n<p><code>@property (nonatomic) BOOL persistenceEnabled</code></p>\n<p> 说明</p>\n<p>默认情况下，在你的应用程序正在运行时，Wilddog 客户端会将数据保存在内存中，当应用被重新启动时数据就没有了。把这个值设置为 YES 时，数据将被保存到设备，并且当应用程序重新启动时（即使在重新启动程序时没有网络连接），这些存储的数据也是可以用的。请注意，此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。  </p>\n<p>如果你的应用使用了 Wilddog 认证，客户端将自动保存用户的身份认证 token ，即使没有启用数据持久化。但是，如果身份认证令牌在离线的时候过期，并且你打开了数据持久化，客户端将暂停写入操作，直到你成功地重新进行身份认证。这样做是因为防止写入的数据被发送给未经认证的用户和因安全规则的改变造成写入数据失败。</p>\n<hr>\n<h2 id=\"persistenceCacheSizeBytes\"><a href=\"#persistenceCacheSizeBytes\" class=\"headerlink\" title=\"persistenceCacheSizeBytes\"></a>persistenceCacheSizeBytes</h2><p> 定义</p>\n<p><code>@property (nonatomic) NSUInteger persistenceCacheSizeBytes</code></p>\n<p> 说明</p>\n<p>默认情况下，Wilddog 将占用最大10MB的磁盘空间去缓存数据。如果缓存大小超出此空间，Wilddog 将开始移除最近未使用的数据。如果你发现你的应用程序缓存太少或有过多的数据，调用此方法来更改缓存空间的大小。此属性必须在创建第一个Wilddog 引用之前设置，并且每次启用应用程序只需要调用一次即可。 </p>\n<p>请注意，指定缓存大小只是一个近似值，并在磁盘上的大小有时候可能会暂时超过它。</p>\n<hr>\n<h2 id=\"callbackQueue\"><a href=\"#callbackQueue\" class=\"headerlink\" title=\"callbackQueue\"></a>callbackQueue</h2><p> 定义</p>\n<p><code>@property (nonatomic, strong) dispatch_queue_t callbackQueue</code></p>\n<p> 说明</p>\n<p>设置所有被触发事件的队列。默认队列为主队列。</p>\n<hr>\n<h1 id=\"WQuery-Methods\"><a href=\"#WQuery-Methods\" class=\"headerlink\" title=\"WQuery (Methods)\"></a>WQuery (<em>Methods</em>)</h1><h2 id=\"–-observeEventType-withBlock-1\"><a href=\"#–-observeEventType-withBlock-1\" class=\"headerlink\" title=\"– observeEventType:withBlock:\"></a>– observeEventType:withBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>在任何时刻，只要被监听的数据发生变化，这个 block 就会被触发。</p>\n<p>可以用 removeObserverWithHandle: 方法停止监听数据的变化。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock-1\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock-1\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。<br>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-withBlock-withCancelBlock-1\"><a href=\"#–-observeEventType-withBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeEventType:withBlock:withCancelBlock:\"></a>– observeEventType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:withBlock: 用于监听一个指定节点的数据变化<br>这是从 Wilddog 服务器读取数据的主要方式<br>如果你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\"><a href=\"#–-observeEventType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeEventType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>observeEventType:andPreviousSiblingKeyWithBlock: 用于监听在特定节点处的数据的变化。<br>这是从 Wilddog 数据库读取数据的主要方法。block 当监听到初始数据和初始数据有改变时触发。 此外， 对于 WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p>由于你没有读取权限，就接受不到新的事件，这时 cancelBlock 就会被调用。 </p>\n<p>用 removeObserverWithHandle: 方法去停止接受数据更新的监听。  </p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果客户端没有权限去接受这些事件，这个 block 将会被调用</p>\n<p> 返回值</p>\n<p>一个 WilddogHandle，用于调用函数 removeObserverWithHandle: 去注销这个 block</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock-1\"><a href=\"#–-observeSingleEventOfType-withBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:\"></a>– observeSingleEventOfType:withBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>同 observeEventType:withBlock: 类似，不同之处在于 observeSingleEventOfType:withBlock: 中的回调函数只被执行一次。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block  </p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-1\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到初始数据和初始数据发生变化时，这个 block 将被回调。block 将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key</p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-withBlock-withCancelBlock-1\"><a href=\"#–-observeSingleEventOfType-withBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:withBlock:withCancelBlock:\"></a>– observeSingleEventOfType:withBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>同 observeSingleEventOfType:withBlock:类似，如果你没有在这个节点读取数据的权限，cancelBlock 将会被回调。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       当监听到某事件时，回调 block<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  </p>\n<hr>\n<h2 id=\"–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\"><a href=\"#–-observeSingleEventOfType-andPreviousSiblingKeyWithBlock-withCancelBlock-1\" class=\"headerlink\" title=\"– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:\"></a>– observeSingleEventOfType:andPreviousSiblingKeyWithBlock:withCancelBlock:</h2><p> 定义</p>\n<p><code>- (void) observeSingleEventOfType:(WEventType)eventType andPreviousSiblingKeyWithBlock:(void (^)(WDataSnapshot* snapshot, NSString* prevKey))block withCancelBlock:(void (^)(NSError* error))cancelBlock</code></p>\n<p> 说明</p>\n<p>这个方法和 observeEventType:withBlock: 方法类似。不同之处是：在初始数据返回后，这个 block 回调一次就被取消监听。 此外， 对于  WEventTypeChildAdded, WEventTypeChildMoved, 和 WEventTypeChildChanged 事件, block 通过 priority 排序将传输前一节点的 key 值。</p>\n<p> 参数</p>\n<p>eventType   监听的事件类型<br>block       将传输一个 WDataSnapshot 类型的数据和前一个子节点的 key<br>cancelBlock 如果您没有权限访问此数据，将调用该 cancelBlock  </p>\n<hr>\n<h2 id=\"–-removeObserverWithHandle-1\"><a href=\"#–-removeObserverWithHandle-1\" class=\"headerlink\" title=\"– removeObserverWithHandle:\"></a>– removeObserverWithHandle:</h2><p> 定义</p>\n<p><code>- (WilddogHandle) observeEventType:(WEventType)eventType withBlock:(void (^)(WDataSnapshot* snapshot))block</code></p>\n<p> 说明</p>\n<p>取消监听事件。取消之前用 observeEventType:withBlock:注册的回调函数。</p>\n<p> 参数</p>\n<p>eventType 监听的事件类型<br>block     当监听到某事件时，回调 block</p>\n<p> 返回值</p>\n<p>handle 由 observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-removeAllObservers-1\"><a href=\"#–-removeAllObservers-1\" class=\"headerlink\" title=\"– removeAllObservers\"></a>– removeAllObservers</h2><p> 定义</p>\n<p><code>- (void) removeAllObservers</code></p>\n<p> 说明</p>\n<p>取消之前由 observeEventType:withBlock:注册的所有的监听事件。</p>\n<hr>\n<h2 id=\"–-keepSynced\"><a href=\"#–-keepSynced\" class=\"headerlink\" title=\"– keepSynced:\"></a>– keepSynced:</h2><p> 定义</p>\n<p><code>- (void) keepSynced:(BOOL)keepSynced</code></p>\n<p> 说明</p>\n<p>在某一节点处通过调用<code>keepSynced:YES</code>方法，即使该节点处没有设置监听者，此节点处的数据也将自动下载存储并保持同步。</p>\n<p> 参数</p>\n<p>keepSynced 参数设置为 YES，则在此节点处同步数据，设置为 NO，停止同步</p>\n<hr>\n<h2 id=\"–-queryLimitedToFirst\"><a href=\"#–-queryLimitedToFirst\" class=\"headerlink\" title=\"– queryLimitedToFirst:\"></a>– queryLimitedToFirst:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryLimitedToFirst:(NSUInteger)limit</code></p>\n<p> 说明</p>\n<p>queryLimitedToFirst: 用于创建一个新 WQuery 引用，获取从第一条开始的指定数量的数据。<br>返回的 WQuery 查询器类将响应从第一个开始，到最多指定(limit)节点个数的数据。</p>\n<p> 参数</p>\n<p>limit 这次查询能够获取的子节点的最大数量</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，最多指定(limit)个数的数据</p>\n<hr>\n<h2 id=\"–-queryLimitedToLast\"><a href=\"#–-queryLimitedToLast\" class=\"headerlink\" title=\"– queryLimitedToLast:\"></a>– queryLimitedToLast:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryLimitedToLast:(NSUInteger)limit</code></p>\n<p> 说明</p>\n<p>queryLimitedToLast: 用于创建一个新 WQuery 引用，获取从最后一条开始向前指定数量的数据。<br>将返回从最后一个开始，最多指定(limit)个数的数据。</p>\n<p> 参数</p>\n<p>limit 这次查询能够获取的子节点的最大数量</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，最多指定(limit)个数的数据</p>\n<hr>\n<h2 id=\"–-queryOrderedByChild\"><a href=\"#–-queryOrderedByChild\" class=\"headerlink\" title=\"– queryOrderedByChild:\"></a>– queryOrderedByChild:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByChild:(NSString *)key</code></p>\n<p> 说明</p>\n<p>queryOrderedByChild: 用于产生一个新 WQuery 引用，是按照特定子节点的值进行排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 参数</p>\n<p>key 指定用来排序的子节点的 key</p>\n<p> 返回值</p>\n<p>返回一个按指定的子节点 key 排序生成的 WQuery 查询器类</p>\n<hr>\n<h2 id=\"–-queryOrderedByKey\"><a href=\"#–-queryOrderedByKey\" class=\"headerlink\" title=\"– queryOrderedByKey\"></a>– queryOrderedByKey</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByKey</code></p>\n<p> 说明</p>\n<p>queryOrderedByKey 用于产生一个新 WQuery 引用，是按照特定子节点的 key 进行排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 返回值</p>\n<p>返回一个按指定的子节点 key 排序生成的 WQuery 查询器类</p>\n<hr>\n<h2 id=\"–-queryOrderedByValue\"><a href=\"#–-queryOrderedByValue\" class=\"headerlink\" title=\"– queryOrderedByValue\"></a>– queryOrderedByValue</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByValue</code></p>\n<p> 说明</p>\n<p>queryOrderedByValue 用于产生一个新 WQuery 引用，是按照当前节点的值进行排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 返回值</p>\n<p>handle 由 observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-queryOrderedByPriority\"><a href=\"#–-queryOrderedByPriority\" class=\"headerlink\" title=\"– queryOrderedByPriority\"></a>– queryOrderedByPriority</h2><p> 定义</p>\n<p><code>- (WQuery *) queryOrderedByPriority</code></p>\n<p> 说明</p>\n<p>queryOrderedByPriority 用于产生一个新 WQuery 引用，是按照当前节点的优先级排序的。<br>此方法要与 queryStartingAtValue:, queryEndingAtValue: 或 queryEqualToValue: 方法联合使用。</p>\n<p> 返回值</p>\n<p>handle 由observeEventType:withBlock:返回的 WilddogHandle</p>\n<hr>\n<h2 id=\"–-queryStartingAtValue\"><a href=\"#–-queryStartingAtValue\" class=\"headerlink\" title=\"– queryStartingAtValue:\"></a>– queryStartingAtValue:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryStartingAtValue:(id)startValue</code></p>\n<p> 说明</p>\n<p>queryStartingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均大于或等于 startValue。</p>\n<p> 参数</p>\n<p>startValue query 查询到的值均大于等于 startValue</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在数据值大于或等于 startValue 的节点事件</p>\n<hr>\n<h2 id=\"–-queryStartingAtValue-childKey\"><a href=\"#–-queryStartingAtValue-childKey\" class=\"headerlink\" title=\"– queryStartingAtValue:childKey:\"></a>– queryStartingAtValue:childKey:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryStartingAtValue:(id)startValue childKey:(NSString *)childKey</code></p>\n<p> 说明</p>\n<p>queryStartingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值大于 startValue，或者等于 startValue 并且 key 大于等于 childKey。</p>\n<p> 参数</p>\n<p>startValue query查询到的值均大于等于 startValue<br>childKey query查询到的 key 均大于等于 childKey</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在数据值大于 startValue，或等于 startValue 的值并且 key 大于或等于 childKey 的节点事件</p>\n<hr>\n<h2 id=\"–-queryEndingAtValue\"><a href=\"#–-queryEndingAtValue\" class=\"headerlink\" title=\"– queryEndingAtValue:\"></a>– queryEndingAtValue:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEndingAtValue:(id)endValue</code></p>\n<p> 说明</p>\n<p>queryEndingAtValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值均小于或者等于 endValue。</p>\n<p> 参数</p>\n<p>endValue query查询到的值均小于等于 endValue  </p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在数据值均小于或等于 endValue 的节点事件</p>\n<hr>\n<h2 id=\"–-queryEndingAtValue-childKey\"><a href=\"#–-queryEndingAtValue-childKey\" class=\"headerlink\" title=\"– queryEndingAtValue:childKey:\"></a>– queryEndingAtValue:childKey:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEndingAtValue:(id)endValue childKey:(NSString *)childKey</code></p>\n<p> 说明</p>\n<p>queryEndingAtValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值小于 endValue，或者等于 endValue 并且 key 小于等于 childKey。</p>\n<p> 参数</p>\n<p>endValue query查询到的值均小于等于 endValue<br>childKey query查询到的 key 均小于等于 childKey</p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应在查询到的数据值小于 endValue，或者数据值等于 endValue 并且 key 小于等于 childKey 的节点事件</p>\n<hr>\n<h2 id=\"–-queryEqualToValue\"><a href=\"#–-queryEqualToValue\" class=\"headerlink\" title=\"– queryEqualToValue:\"></a>– queryEqualToValue:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEqualToValue:(id)value</code></p>\n<p> 说明</p>\n<p>queryEqualToValue: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值都等于 value。</p>\n<p> 参数</p>\n<p>value query查询到的值都等于 value  </p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应与 value 相等数值的节点事件</p>\n<hr>\n<h2 id=\"–-queryEqualToValue-childKey\"><a href=\"#–-queryEqualToValue-childKey\" class=\"headerlink\" title=\"– queryEqualToValue:childKey:\"></a>– queryEqualToValue:childKey:</h2><p> 定义</p>\n<p><code>- (WQuery *) queryEqualToValue:(id)value childKey:(NSString *)childKey</code></p>\n<p> 说明</p>\n<p>queryEqualToValue:childKey: 用于返回一个 WQuery 引用，这个引用用来监测数据的变化，这些被监测的数据的值等于 value 并且 key 等于 childKey。返回的值肯定是唯一的，因为 key 是唯一的。</p>\n<p> 参数</p>\n<p>value query查询到的值都等于 value<br>childKey  query查询到的 key 都等于 childKey </p>\n<p> 返回值</p>\n<p>返回一个 WQuery 查询器类，用于响应这个与之相等数值和 key 节点事件</p>\n<hr>\n<h2 id=\"ref-1\"><a href=\"#ref-1\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p> 定义</p>\n<p><code>@property (nonatomic, readonly, strong) Wilddog* ref</code></p>\n<p> 说明</p>\n<p>获取这个查询的 Wilddog 引用。</p>\n<hr>\n<h1 id=\"WMutableData-Methods\"><a href=\"#WMutableData-Methods\" class=\"headerlink\" title=\"WMutableData (Methods)\"></a>WMutableData (<em>Methods</em>)</h1><h2 id=\"–-hasChildren-1\"><a href=\"#–-hasChildren-1\" class=\"headerlink\" title=\"– hasChildren\"></a>– hasChildren</h2><p> 定义</p>\n<p><code>- (BOOL) hasChildren</code></p>\n<p> 说明</p>\n<p>判断在当前 WMutableData 中，是否存在子节点。</p>\n<p> 返回值</p>\n<p>YES 为存在子节点，NO 为不存在</p>\n<hr>\n<h2 id=\"–-hasChildAtPath\"><a href=\"#–-hasChildAtPath\" class=\"headerlink\" title=\"– hasChildAtPath:\"></a>– hasChildAtPath:</h2><p> 定义</p>\n<p><code>- (BOOL) hasChildAtPath:(NSString *)path</code></p>\n<p> 说明</p>\n<p>检查指定路径下是否存在子节点。</p>\n<p> 参数</p>\n<p>path 可以是类似’child’的单层级路径，也可以是类似’a/deeper/child’多层级路径</p>\n<p> 返回值</p>\n<p>如果在指定的相对路径下，该 WMutableData 包含子节点，则返回YES</p>\n<hr>\n<h2 id=\"–-childDataByAppendingPath\"><a href=\"#–-childDataByAppendingPath\" class=\"headerlink\" title=\"– childDataByAppendingPath:\"></a>– childDataByAppendingPath:</h2><p> 定义</p>\n<p><code>- (WMutableData *) childDataByAppendingPath:(NSString *)path</code></p>\n<p> 说明</p>\n<p>用于获得一个在给定的相对路径下的 WMutableData 数据实例。</p>\n<p> 参数</p>\n<p>path 可以是类似’child’的单层级路径，也可以是类似’a/deeper/child’多层级路径</p>\n<p> 返回值</p>\n<p>指定路径下的 WMutableData 实例</p>\n<hr>\n<h2 id=\"value-1\"><a href=\"#value-1\" class=\"headerlink\" title=\"value\"></a>value</h2><p> 定义</p>\n<p><code>@property (strong, nonatomic) id value</code></p>\n<p> 说明</p>\n<p>修改 WMutableData 实例中的数据，value 可将其设置为 Wilddog 支持的任一原生数据类型：<br> NSNumber (includes BOOL)<br> NSDictionary<br> NSArray<br> NSString<br> nil / NSNull (设置 nil / NSNull 删除该数据)<br>注意修改这个 value，会覆盖这个节点的优先级  </p>\n<p> 返回值</p>\n<p>获得当前节点的数据</p>\n<hr>\n<h2 id=\"priority-1\"><a href=\"#priority-1\" class=\"headerlink\" title=\"priority\"></a>priority</h2><p> 定义</p>\n<p><code>@property (strong, nonatomic) id priority</code></p>\n<p> 说明</p>\n<p>设置这个属性可以更新该节点下面的数据优先级，可以设置的值类型有：  </p>\n<ul>\n<li>NSNumber  </li>\n<li>NSString  </li>\n<li><p>nil / NSNull (设置 nil / NSNull 删除该数据)   </p>\n<p>返回值</p>\n</li>\n</ul>\n<p>获得当前节点的优先级</p>\n<hr>\n<h2 id=\"childrenCount-1\"><a href=\"#childrenCount-1\" class=\"headerlink\" title=\"childrenCount\"></a>childrenCount</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic) NSUInteger childrenCount</code></p>\n<p> 返回值</p>\n<p>获得子节点的总数</p>\n<hr>\n<h2 id=\"children-1\"><a href=\"#children-1\" class=\"headerlink\" title=\"children\"></a>children</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic, strong) NSEnumerator* children</code></p>\n<p> 说明</p>\n<p>用于迭代该节点的子节点，可以用下面的这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for (WMutableData* child in data.children) &#123;  </div><div class=\"line\">    ...  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 返回值</p>\n<p>获取当前节点下所有子节点的 WMutabledata 实例的迭代器</p>\n<hr>\n<h2 id=\"key-2\"><a href=\"#key-2\" class=\"headerlink\" title=\"key\"></a>key</h2><p> 定义</p>\n<p><code>@property (readonly, nonatomic, strong) NSString* key</code></p>\n<p> 返回值</p>\n<p>获取当前节点的 key，最上层的节点的 key 是 nil</p>\n<hr>\n<h1 id=\"WTransactionResult-Methods\"><a href=\"#WTransactionResult-Methods\" class=\"headerlink\" title=\"WTransactionResult (Methods)\"></a>WTransactionResult (<em>Methods</em>)</h1><h2 id=\"successWithValue\"><a href=\"#successWithValue\" class=\"headerlink\" title=\"+ successWithValue:\"></a>+ successWithValue:</h2><p> 定义</p>\n<p><code>+ (WTransactionResult *) successWithValue:(WMutableData *)value</code></p>\n<p> 说明</p>\n<p>用于 runTransactionBlock: 方法中。 表明传入参数 value 应保存在这个节点处。</p>\n<p> 返回值</p>\n<p>返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值</p>\n<hr>\n<h2 id=\"abort\"><a href=\"#abort\" class=\"headerlink\" title=\"+ abort\"></a>+ abort</h2><p> 定义</p>\n<p><code>+ (WTransactionResult *) abort</code></p>\n<p> 说明</p>\n<p>用于 runTransactionBlock: 方法中。 使用该方法可以主动终止当前事务。</p>\n<p> 返回值</p>\n<p>返回一个 WTransactionResult 实例，它可以作为给 runTransactionBlock: 方法中 block 的一个返回值</p>\n<hr>\n<h1 id=\"WilddogApp-Methods\"><a href=\"#WilddogApp-Methods\" class=\"headerlink\" title=\"WilddogApp (Methods)\"></a>WilddogApp (<em>Methods</em>)</h1><h2 id=\"–-goOffline\"><a href=\"#–-goOffline\" class=\"headerlink\" title=\"– goOffline\"></a>– goOffline</h2><p> 定义</p>\n<p><code>- (void)goOffline</code></p>\n<p> 说明</p>\n<p>断开与 Wilddog 服务器的连接</p>\n<hr>\n<h2 id=\"–-goOnline\"><a href=\"#–-goOnline\" class=\"headerlink\" title=\"– goOnline\"></a>– goOnline</h2><p> 定义</p>\n<p><code>- (void)goOnline</code></p>\n<p> 说明</p>\n<p>恢复与 Wilddog 服务器的连接</p>\n"},{"title":"REST API","_content":"\n我们可以使用任意的Wilddog应用的URL作为REST的结束点，我们只需要在URL的结尾处加上`.json`然后发送HTTPS请求即可。 HTTPS是必须的，Wilddog只会响应加密数据，所以你的数据是保证安全的。\n\n## GET\n\n说明\n\n通过HTTP发送GET请求就可以读取数据库中的数据 请求成功将会返回200 OK状态码。响应中会包含要查询的数据。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/users/jack/name.json'\n\n```\n\n返回值\n\n```\n{ \"first\": \"Jack\", \"last\": \"Sparrow\" }\n\n```\n\n---\n\n## PUT\n\n说明\n\n我们可以使用 `PUT` 请求写入数据\n\n示例\n\n```\ncurl -X PUT -d '{ \"first\": \"Jack\", \"last\": \"Sparrow\" }' \\\n  'https://samplechat.wilddogio.com/users/jack/name.json'\n\n```\n\n返回值\n\n```\n{ \"first\": \"Jack\", \"last\": \"Sparrow\" }\n\n```\n\n---\n\n## POST\n\n说明\n\n要实现js中`push()`方法类似的功能，我们可以使用`POST`请求\n\n示例\n\n```\ncurl -X POST -d '{\"user_id\" : \"jack\", \"text\" : \"Ahoy!\"}' \\\n  'https://samplechat.wilddogio.com/message_list.json'\n\n```\n\n返回值\n\n```\n{ \"name\": \"-INOQPH-aV_psbk3ZXEX\" }\n\n```\n\n---\n\n## PATCH\n\n说明\n\n我们可以使用`PATCH`请求来更新指定位置的数据而不覆盖其他已有的数据。`PATCH`请求中指定的节点数据会被覆盖，没有提到的节点不会被删除。该功能与js中的`update()`方法类似。\n\n示例\n\n```\ncurl -X PATCH -d '{\"last\":\"Jones\"}' \\\n 'https://samplechat.wilddogio.com/users/jack/name/.json'\n\n```\n\n返回值\n\n```\n{ \"last\": \"Jones\" }\n\n```\n\n---\n\n## DELETE\n\n说明\n\n我们可以使用`DELETE`请求来删除数据。\n\n示例\n\n```\ncurl -X DELETE \\\n  'https://samplechat.wilddogio.com/users/jack/name/last.json'\n\n```\n\n返回值\n\n请求成功将会返回200 OK状态码。响应中会包含空的JSON\n\n---\n\n## 方法覆盖\n\n说明\n\n如果我们发出REST调用的浏览器不支持上面的方法，我们可以覆盖请求方法，发送`POST`请求通过请求头中的`X-HTTP-Method-Override`设置要覆盖的方法。\n\n示例\n\n```\ncurl -X POST -H \"X-HTTP-Method-Override: DELETE\" \\\n  'https://samplechat.wilddogio.com/users/jack/name/last.json'\n\n```\n\n我们也可以使用`x-http-method-override`查询参数：\n\n```\ncurl -X POST \\\n  'https://samplechat.wilddogio.com/users/jack/name/last.json?x-http-method-override=DELETE'\n\n```\n\n返回值\n\n请求成功将会返回200 OK状态码。响应中会包含空的JSON\n\n---\n\n# Query\n\nWilddog的REST API接收以下的查询参数和值\n\n## shallow\n\n说明\n\n这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 shallow=true 将限制数据返回的深度。如果返回的数据是JSON primitive \\(string, number or boolean\\)， 它的value将被返回。 如果数据的snapshot是 JSON object，每一个key的value将被截断成布尔类型`true`。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/.json?shallow=true'\n\n```\n\n使用shallow参数后， 将不能使用其他查询参数。\n\n---\n\n## count\n\n说明\n\n查询当前节点下直接子节点的个数。设置 count=true 返回数量。可以与条件查询连用。与条件查询连用时，返回的是满足条件的节点的数量。\n\n示例\n\n```\n//查询 rest 节点下的子节点个数\ncurl 'https://docs-examples.wilddogio.com/rest.json?count=true'\n\n//查询高度为0.6的恐龙的个数\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&equalTo=0.6&count=true'\n\n```\n\n---\n\n## print\n\n说明\n\n格式化响应返回的数据。\n\n| 参数REST方法描述 |                               |                                          |\n| :--------- | :---------------------------- | :--------------------------------------- |\n| pretty     | GET, PUT, POST, PATCH, DELETE | 以易读的方式查看数据                               |\n| silent     | GET, PUT, POST, PATCH         | 写入数据的时候控制输出，响应返回的是空值，http状态码为204 No Content |\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/users/jack/name.json?print=pretty'\ncurl -X PUT -d '{ \"first\": \"Jack\", \"last\": \"Sparrow\" }' \\\n  'https://samplechat.wilddogio.com/users/jack/name.json?print=silent'\n\n```\n\n---\n\n## callback\n\n说明\n\n仅支持 `get` 方式。为了让web客户端的rest请求实现跨域，你可以用JSONNP在JavaScript回调方法中封装一个响应。使用 `callback=` 让rest API在你指定的回调方法中封装返回的数据。\n\n示例\n\n```\n<script>\n  function gotData(data) {\n    console.log(data);\n  }\n</script>\n<script src=\"https://samplechat.wilddogio.com/.json?callback=gotData\"></script>\n\n```\n\n---\n\n## format\n\n说明\n\n在 get 数据时，若带有如下参数，响应数据中会包含priority信息\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/.json?format=export'\n\n```\n\n---\n\n## download\n\n说明\n\n仅支持 `get` 方式。如果你想从web客户端把你的数据下载到一个文件中，请使用 `download=` 参数。参数后加上一个合适的文件名以让客户端将数据保存到这个文件中。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/.json?download=myfilename.txt'\n\n```\n\n---\n\n## orderBy\n\n在 [完整文档 - 查询数据](/guide/sync/rest/guide.html#查询数据) 文档中获取更多信息。\n\n## limitToFirst, limitToLast\n\n在 [完整文档 - 查询数据](/guide/sync/rest/guide.html#查询数据) 文档中获取更多信息。\n\n## startAt, endAt, equalTo\n\n在 [完整文档 - 查询](/guide/sync/rest/guide.html#查询数据) 文档中获取更多信息。\n\n---\n\n# Auth\n\n## auth\n\n说明\n\n所有的请求都支持。可以授权请求访问被规则表达式保护的数据。可以使用应用的密钥，也可以使用认证令牌。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/users/jack/name.json?auth=CREDENTIAL'\n```\n\n\n---\n\n## customTokenToIdToken\n\n说明\n\n将 SDK 生成的 CustomToken 转换为 Wilddog IdToken。仅支持 `POST` 方式。\n\n示例\n\n```\ncurl -X POST -d '{\"token\":\"<YOUR CUSTOM TOKEN HERE>\"}' \\\n'https://<appid>.wilddogio.com/.auth/customTokenToIdToken.json'\n```\n\n返回值\n\n```json\n{\n    \"idToken\":\"<IDTOEKN HERE>\",\n    \"expireIn\":<EXPIRE TIME IN SECONDS>\n}\n```\n\n如果转换过程中出现错误，系统会返回如下格式结果：\n\n```json\n{\n    \"error\":{\n        \"code\":\"<ERRER CODE>\",\n        \"errorMessage\":\"<ERROR MESSAGE>\"\n    }\n}\n```\n\n---\n\n# Streaming\n\nWilddog REST API支持 [EventSource \\/ Server-Sent Events ](http://www.w3.org/TR/eventsource/)协议。在Wilddog数据库使用 Server-Sent Events（简写 SSE）， 你需要准备以下：\n\n* １. 设置Accept = \"text\\/event-stream\"\n* ２. 支持HTTP转跳，HTTP code 307\n* ３. 如果read操作有规则表达式， 需要设置auth参数\n\n云端返回的数据的协议：\n\n```\nevent: event name\n\ndata: JSON encoded data payload\n\n```\n\n下面是云端返回的数据协议：\n\n## put\n\n说明\n\ndata是json对象， 包含两个key： `path`和`data`。`path`是`data`相关的路径。客户端应该替换`path`的所有数据。\n\n---\n\n## patch\n\n说明\n\ndata是json对象， 包含两个key： `path` 和 `data`。`path`是`data`相关的路径。对于data的每一个key，客户端应该替换这个key对应的数据。\n\n---\n\n## keep-alive\n\n说明\n\nevent的data为null，即无任何操作。\n\n---\n\n## auth\\_revoked\n\n说明\n\n此event的数据为一个字符串，该字符串表示该认证已过期。当提供的认证过期时，此event将被发送。\n\n---\n\n## 示例\n\n先开启一个端口用于查看云端发送的event，下面是云端发送的event示例:\n\n```\n//  设置你整个数据\nevent: put\ndata: {\"path\": \"/\", \"data\": {\"a\": 1, \"b\": 2}}\n\n//  推送key为c的新数据, 然后整个数据如下\n// {\"a\": 1, \"b\": 2, \"c\": {\"foo\": true, \"bar\": false}}\nevent: put\ndata: {\"path\": \"/c\", \"data\": {\"foo\": true, \"bar\": false}}\n\n// 在每个数据的key, 更新或添加数据，\n// 然后整个数据如下\n//  {\"a\": 1, \"b\": 2, \"c\": {\"foo\": 3, \"bar\": false, \"baz\": 4}}\nevent: patch\ndata: {\"path\": \"/c\", \"data\": {\"foo\": 3, \"baz\": 4}}\n\n```\n\n为了产生变化，可以再开启一个端口输入命令。\n\n如：使用curl命令开启SSE\n\n```\ncurl -X GET -H 'Accept:text/event-stream' 'https://<appId>.wilddogio.com/.json'\n\n```\n\n使用curl命令put数据\n\n```\ncurl -X PUT -d '{\"path\": \"/\", \"data\": {\"a\": 1, \"b\": 2}}' 'https://<appId>.wilddogio.com/.json'\n{\"path\":\"/\",\"data\":{\"a\":1,\"b\":2}}\n\n```\n\n---\n\n# Priorities\n\n某个节点的优先级信息会被一个名为 .priority 的虚拟节点储存。优先级可以通过REST请求读取或写入。例如，下面的请求用来检索 users\\/tom 节点的优先级信息：\n\n```\ncurl 'https://samplechat.wilddogio.com/users/tom/.priority.json'\n\n```\n\n当要同时写入优先级信息和数据信息时，你可以在要写入的JSON中增加 .priority 子节点：\n\n```\ncurl -X PUT -d '{\"name\": {\"first\": \"Tom\"}, \".priority\": 1.0}' \\\n  'https://samplechat.wilddogio.com/users/tom.json'\n\n```\n\n当要同时写入优先级信息和原始类型数据（如字符串）时，你可以增加一个 .priority 子节点，并将原始类型数据放在 .value 子节点中：\n\n```\ncurl -X PUT -d '{\".value\": \"Tom\", \".priority\": 1.0}' \\\n  'https://samplechat.wilddogio.com/users/tom/name/first.json'\n\n```\n\n这个示例写入的值是Tom，优先级是1.0。优先级可以放在JSON结构的任意深度。\n\n---\n\n# Server Values\n\n说明\n\n服务端数值使用占位符： `.sv`。`.sv`的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：\n\n示例\n\n```\ncurl -X PUT -d '{\".sv\": \"timestamp\"}' \\\n  'https://<appId>.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json'\n\n```\n\n说明\n\n当我们需要获取服务器的当前时间戳时，可以进行如下操作 :\n\n示例\n\n```\ncurl 'https://<appId>.wilddogio.com/.json?sv=timestamp'\n\n```\n\n该操作将会直接返回服务器的当前时间戳，而不包括查询的数据。\n\n服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考[百科](http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa)。\n\n---\n\n# 规则表达式\n\nREST API可以用来查询和更改规则表达式。该操作必须使用应用的超级密钥，你可以在应用的控制面板--超级密钥页面获取超级密钥。\n\n```\ncurl -X PUT -d '{\"rules\":{\".read\":true}}' 'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n```\ncurl  'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n---\n\n# 错误原因\n\n## 错误码\n\n说明\n\nWilddog的REST API将在以下情况返回错误码：\n\n| HTTP状态码描述              |                         |\n| :--------------------- | :---------------------- |\n| 404 Not Found          | 通过HTTP请求而不是HTTPS请求      |\n| 400 Bad Request        | 不能解析PUT或POST数据          |\n| 400 Bad Request        | 丢失PUT或POST数据            |\n| 400 Bad Request        | PUT或POST数据过长            |\n| 417 Expectation Failed | REST API调用没有指定Wilddog名字 |\n| 400 Bad Request        | REST API调用路径中包含非法的子节点名字 |\n| 403 Forbidden          | 请求违反规则表达式               |\n\n## 错误信息\n\n说明\n\nWilddog的REST API将在业务错误时返回值中返回error信息：\n\nFor example :\n\n```\n{\n  \"error\":\"单次请求数据量过大\"\n}\n\n```\n\n常见error信息列举如下：\n\n| error信息描述推荐解决方案  |                                   |                                          |\n| :--------------- | :-------------------------------- | :--------------------------------------- |\n| 单次请求数据量过大        | 用户对相应节点导出的数据超过了REST API允许导出的数据量范围 | 用户将问题通过提交工单的方式进行反馈,会有专员为用户提取数据           |\n| 写入数据中叶子节点数据量过大   | 用户写入的数据中存在节点超过了每个节点允许的最大数据量       | 用户若存在节点数据大于节点最大数据允许范围,则需要重新设计数据结构        |\n| orderBy参数不合法     | 用户orderBy参数不符合orederBy的参数的规范      | 用户确认orderBy中的参数信息是否有异常字符.eg:若orderBy参数中若有$符号,则参数必须为$key、$priority、$value这三种情况的一种 |\n| 路径不合法，超过最大深度32层  | 用户的数据节点深度超过最大深度32层                | 用户的数据节点深度不能超过32层,若超过32层,则需重新设计数据结构       |\n| 单次写入数据量超过4M字节的限制 | 单次写入数据量超过4M字节的限制                  | 用户将写操作的数据通过数据拆分的形式进行分批操作                 |\n\n","source":"api/sync/rest.md","raw":"\ntitle: REST API\n---\n\n我们可以使用任意的Wilddog应用的URL作为REST的结束点，我们只需要在URL的结尾处加上`.json`然后发送HTTPS请求即可。 HTTPS是必须的，Wilddog只会响应加密数据，所以你的数据是保证安全的。\n\n## GET\n\n说明\n\n通过HTTP发送GET请求就可以读取数据库中的数据 请求成功将会返回200 OK状态码。响应中会包含要查询的数据。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/users/jack/name.json'\n\n```\n\n返回值\n\n```\n{ \"first\": \"Jack\", \"last\": \"Sparrow\" }\n\n```\n\n---\n\n## PUT\n\n说明\n\n我们可以使用 `PUT` 请求写入数据\n\n示例\n\n```\ncurl -X PUT -d '{ \"first\": \"Jack\", \"last\": \"Sparrow\" }' \\\n  'https://samplechat.wilddogio.com/users/jack/name.json'\n\n```\n\n返回值\n\n```\n{ \"first\": \"Jack\", \"last\": \"Sparrow\" }\n\n```\n\n---\n\n## POST\n\n说明\n\n要实现js中`push()`方法类似的功能，我们可以使用`POST`请求\n\n示例\n\n```\ncurl -X POST -d '{\"user_id\" : \"jack\", \"text\" : \"Ahoy!\"}' \\\n  'https://samplechat.wilddogio.com/message_list.json'\n\n```\n\n返回值\n\n```\n{ \"name\": \"-INOQPH-aV_psbk3ZXEX\" }\n\n```\n\n---\n\n## PATCH\n\n说明\n\n我们可以使用`PATCH`请求来更新指定位置的数据而不覆盖其他已有的数据。`PATCH`请求中指定的节点数据会被覆盖，没有提到的节点不会被删除。该功能与js中的`update()`方法类似。\n\n示例\n\n```\ncurl -X PATCH -d '{\"last\":\"Jones\"}' \\\n 'https://samplechat.wilddogio.com/users/jack/name/.json'\n\n```\n\n返回值\n\n```\n{ \"last\": \"Jones\" }\n\n```\n\n---\n\n## DELETE\n\n说明\n\n我们可以使用`DELETE`请求来删除数据。\n\n示例\n\n```\ncurl -X DELETE \\\n  'https://samplechat.wilddogio.com/users/jack/name/last.json'\n\n```\n\n返回值\n\n请求成功将会返回200 OK状态码。响应中会包含空的JSON\n\n---\n\n## 方法覆盖\n\n说明\n\n如果我们发出REST调用的浏览器不支持上面的方法，我们可以覆盖请求方法，发送`POST`请求通过请求头中的`X-HTTP-Method-Override`设置要覆盖的方法。\n\n示例\n\n```\ncurl -X POST -H \"X-HTTP-Method-Override: DELETE\" \\\n  'https://samplechat.wilddogio.com/users/jack/name/last.json'\n\n```\n\n我们也可以使用`x-http-method-override`查询参数：\n\n```\ncurl -X POST \\\n  'https://samplechat.wilddogio.com/users/jack/name/last.json?x-http-method-override=DELETE'\n\n```\n\n返回值\n\n请求成功将会返回200 OK状态码。响应中会包含空的JSON\n\n---\n\n# Query\n\nWilddog的REST API接收以下的查询参数和值\n\n## shallow\n\n说明\n\n这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 shallow=true 将限制数据返回的深度。如果返回的数据是JSON primitive \\(string, number or boolean\\)， 它的value将被返回。 如果数据的snapshot是 JSON object，每一个key的value将被截断成布尔类型`true`。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/.json?shallow=true'\n\n```\n\n使用shallow参数后， 将不能使用其他查询参数。\n\n---\n\n## count\n\n说明\n\n查询当前节点下直接子节点的个数。设置 count=true 返回数量。可以与条件查询连用。与条件查询连用时，返回的是满足条件的节点的数量。\n\n示例\n\n```\n//查询 rest 节点下的子节点个数\ncurl 'https://docs-examples.wilddogio.com/rest.json?count=true'\n\n//查询高度为0.6的恐龙的个数\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&equalTo=0.6&count=true'\n\n```\n\n---\n\n## print\n\n说明\n\n格式化响应返回的数据。\n\n| 参数REST方法描述 |                               |                                          |\n| :--------- | :---------------------------- | :--------------------------------------- |\n| pretty     | GET, PUT, POST, PATCH, DELETE | 以易读的方式查看数据                               |\n| silent     | GET, PUT, POST, PATCH         | 写入数据的时候控制输出，响应返回的是空值，http状态码为204 No Content |\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/users/jack/name.json?print=pretty'\ncurl -X PUT -d '{ \"first\": \"Jack\", \"last\": \"Sparrow\" }' \\\n  'https://samplechat.wilddogio.com/users/jack/name.json?print=silent'\n\n```\n\n---\n\n## callback\n\n说明\n\n仅支持 `get` 方式。为了让web客户端的rest请求实现跨域，你可以用JSONNP在JavaScript回调方法中封装一个响应。使用 `callback=` 让rest API在你指定的回调方法中封装返回的数据。\n\n示例\n\n```\n<script>\n  function gotData(data) {\n    console.log(data);\n  }\n</script>\n<script src=\"https://samplechat.wilddogio.com/.json?callback=gotData\"></script>\n\n```\n\n---\n\n## format\n\n说明\n\n在 get 数据时，若带有如下参数，响应数据中会包含priority信息\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/.json?format=export'\n\n```\n\n---\n\n## download\n\n说明\n\n仅支持 `get` 方式。如果你想从web客户端把你的数据下载到一个文件中，请使用 `download=` 参数。参数后加上一个合适的文件名以让客户端将数据保存到这个文件中。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/.json?download=myfilename.txt'\n\n```\n\n---\n\n## orderBy\n\n在 [完整文档 - 查询数据](/guide/sync/rest/guide.html#查询数据) 文档中获取更多信息。\n\n## limitToFirst, limitToLast\n\n在 [完整文档 - 查询数据](/guide/sync/rest/guide.html#查询数据) 文档中获取更多信息。\n\n## startAt, endAt, equalTo\n\n在 [完整文档 - 查询](/guide/sync/rest/guide.html#查询数据) 文档中获取更多信息。\n\n---\n\n# Auth\n\n## auth\n\n说明\n\n所有的请求都支持。可以授权请求访问被规则表达式保护的数据。可以使用应用的密钥，也可以使用认证令牌。\n\n示例\n\n```\ncurl 'https://samplechat.wilddogio.com/users/jack/name.json?auth=CREDENTIAL'\n```\n\n\n---\n\n## customTokenToIdToken\n\n说明\n\n将 SDK 生成的 CustomToken 转换为 Wilddog IdToken。仅支持 `POST` 方式。\n\n示例\n\n```\ncurl -X POST -d '{\"token\":\"<YOUR CUSTOM TOKEN HERE>\"}' \\\n'https://<appid>.wilddogio.com/.auth/customTokenToIdToken.json'\n```\n\n返回值\n\n```json\n{\n    \"idToken\":\"<IDTOEKN HERE>\",\n    \"expireIn\":<EXPIRE TIME IN SECONDS>\n}\n```\n\n如果转换过程中出现错误，系统会返回如下格式结果：\n\n```json\n{\n    \"error\":{\n        \"code\":\"<ERRER CODE>\",\n        \"errorMessage\":\"<ERROR MESSAGE>\"\n    }\n}\n```\n\n---\n\n# Streaming\n\nWilddog REST API支持 [EventSource \\/ Server-Sent Events ](http://www.w3.org/TR/eventsource/)协议。在Wilddog数据库使用 Server-Sent Events（简写 SSE）， 你需要准备以下：\n\n* １. 设置Accept = \"text\\/event-stream\"\n* ２. 支持HTTP转跳，HTTP code 307\n* ３. 如果read操作有规则表达式， 需要设置auth参数\n\n云端返回的数据的协议：\n\n```\nevent: event name\n\ndata: JSON encoded data payload\n\n```\n\n下面是云端返回的数据协议：\n\n## put\n\n说明\n\ndata是json对象， 包含两个key： `path`和`data`。`path`是`data`相关的路径。客户端应该替换`path`的所有数据。\n\n---\n\n## patch\n\n说明\n\ndata是json对象， 包含两个key： `path` 和 `data`。`path`是`data`相关的路径。对于data的每一个key，客户端应该替换这个key对应的数据。\n\n---\n\n## keep-alive\n\n说明\n\nevent的data为null，即无任何操作。\n\n---\n\n## auth\\_revoked\n\n说明\n\n此event的数据为一个字符串，该字符串表示该认证已过期。当提供的认证过期时，此event将被发送。\n\n---\n\n## 示例\n\n先开启一个端口用于查看云端发送的event，下面是云端发送的event示例:\n\n```\n//  设置你整个数据\nevent: put\ndata: {\"path\": \"/\", \"data\": {\"a\": 1, \"b\": 2}}\n\n//  推送key为c的新数据, 然后整个数据如下\n// {\"a\": 1, \"b\": 2, \"c\": {\"foo\": true, \"bar\": false}}\nevent: put\ndata: {\"path\": \"/c\", \"data\": {\"foo\": true, \"bar\": false}}\n\n// 在每个数据的key, 更新或添加数据，\n// 然后整个数据如下\n//  {\"a\": 1, \"b\": 2, \"c\": {\"foo\": 3, \"bar\": false, \"baz\": 4}}\nevent: patch\ndata: {\"path\": \"/c\", \"data\": {\"foo\": 3, \"baz\": 4}}\n\n```\n\n为了产生变化，可以再开启一个端口输入命令。\n\n如：使用curl命令开启SSE\n\n```\ncurl -X GET -H 'Accept:text/event-stream' 'https://<appId>.wilddogio.com/.json'\n\n```\n\n使用curl命令put数据\n\n```\ncurl -X PUT -d '{\"path\": \"/\", \"data\": {\"a\": 1, \"b\": 2}}' 'https://<appId>.wilddogio.com/.json'\n{\"path\":\"/\",\"data\":{\"a\":1,\"b\":2}}\n\n```\n\n---\n\n# Priorities\n\n某个节点的优先级信息会被一个名为 .priority 的虚拟节点储存。优先级可以通过REST请求读取或写入。例如，下面的请求用来检索 users\\/tom 节点的优先级信息：\n\n```\ncurl 'https://samplechat.wilddogio.com/users/tom/.priority.json'\n\n```\n\n当要同时写入优先级信息和数据信息时，你可以在要写入的JSON中增加 .priority 子节点：\n\n```\ncurl -X PUT -d '{\"name\": {\"first\": \"Tom\"}, \".priority\": 1.0}' \\\n  'https://samplechat.wilddogio.com/users/tom.json'\n\n```\n\n当要同时写入优先级信息和原始类型数据（如字符串）时，你可以增加一个 .priority 子节点，并将原始类型数据放在 .value 子节点中：\n\n```\ncurl -X PUT -d '{\".value\": \"Tom\", \".priority\": 1.0}' \\\n  'https://samplechat.wilddogio.com/users/tom/name/first.json'\n\n```\n\n这个示例写入的值是Tom，优先级是1.0。优先级可以放在JSON结构的任意深度。\n\n---\n\n# Server Values\n\n说明\n\n服务端数值使用占位符： `.sv`。`.sv`的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：\n\n示例\n\n```\ncurl -X PUT -d '{\".sv\": \"timestamp\"}' \\\n  'https://<appId>.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json'\n\n```\n\n说明\n\n当我们需要获取服务器的当前时间戳时，可以进行如下操作 :\n\n示例\n\n```\ncurl 'https://<appId>.wilddogio.com/.json?sv=timestamp'\n\n```\n\n该操作将会直接返回服务器的当前时间戳，而不包括查询的数据。\n\n服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考[百科](http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa)。\n\n---\n\n# 规则表达式\n\nREST API可以用来查询和更改规则表达式。该操作必须使用应用的超级密钥，你可以在应用的控制面板--超级密钥页面获取超级密钥。\n\n```\ncurl -X PUT -d '{\"rules\":{\".read\":true}}' 'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n```\ncurl  'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n---\n\n# 错误原因\n\n## 错误码\n\n说明\n\nWilddog的REST API将在以下情况返回错误码：\n\n| HTTP状态码描述              |                         |\n| :--------------------- | :---------------------- |\n| 404 Not Found          | 通过HTTP请求而不是HTTPS请求      |\n| 400 Bad Request        | 不能解析PUT或POST数据          |\n| 400 Bad Request        | 丢失PUT或POST数据            |\n| 400 Bad Request        | PUT或POST数据过长            |\n| 417 Expectation Failed | REST API调用没有指定Wilddog名字 |\n| 400 Bad Request        | REST API调用路径中包含非法的子节点名字 |\n| 403 Forbidden          | 请求违反规则表达式               |\n\n## 错误信息\n\n说明\n\nWilddog的REST API将在业务错误时返回值中返回error信息：\n\nFor example :\n\n```\n{\n  \"error\":\"单次请求数据量过大\"\n}\n\n```\n\n常见error信息列举如下：\n\n| error信息描述推荐解决方案  |                                   |                                          |\n| :--------------- | :-------------------------------- | :--------------------------------------- |\n| 单次请求数据量过大        | 用户对相应节点导出的数据超过了REST API允许导出的数据量范围 | 用户将问题通过提交工单的方式进行反馈,会有专员为用户提取数据           |\n| 写入数据中叶子节点数据量过大   | 用户写入的数据中存在节点超过了每个节点允许的最大数据量       | 用户若存在节点数据大于节点最大数据允许范围,则需要重新设计数据结构        |\n| orderBy参数不合法     | 用户orderBy参数不符合orederBy的参数的规范      | 用户确认orderBy中的参数信息是否有异常字符.eg:若orderBy参数中若有$符号,则参数必须为$key、$priority、$value这三种情况的一种 |\n| 路径不合法，超过最大深度32层  | 用户的数据节点深度超过最大深度32层                | 用户的数据节点深度不能超过32层,若超过32层,则需重新设计数据结构       |\n| 单次写入数据量超过4M字节的限制 | 单次写入数据量超过4M字节的限制                  | 用户将写操作的数据通过数据拆分的形式进行分批操作                 |\n\n","date":"2016-09-06T03:38:22.516Z","updated":"2016-09-06T03:38:22.516Z","path":"api/sync/rest.html","comments":1,"layout":"page","_id":"cisswi9j3000dz4fwwgh0v265","content":"<p>我们可以使用任意的Wilddog应用的URL作为REST的结束点，我们只需要在URL的结尾处加上<code>.json</code>然后发送HTTPS请求即可。 HTTPS是必须的，Wilddog只会响应加密数据，所以你的数据是保证安全的。</p>\n<h2 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h2><p>说明</p>\n<p>通过HTTP发送GET请求就可以读取数据库中的数据 请求成功将会返回200 OK状态码。响应中会包含要查询的数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/jack/name.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"PUT\"><a href=\"#PUT\" class=\"headerlink\" title=\"PUT\"></a>PUT</h2><p>说明</p>\n<p>我们可以使用 <code>PUT</code> 请求写入数据</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h2><p>说明</p>\n<p>要实现js中<code>push()</code>方法类似的功能，我们可以使用<code>POST</code>请求</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;user_id&quot; : &quot;jack&quot;, &quot;text&quot; : &quot;Ahoy!&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/message_list.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;name&quot;: &quot;-INOQPH-aV_psbk3ZXEX&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"PATCH\"><a href=\"#PATCH\" class=\"headerlink\" title=\"PATCH\"></a>PATCH</h2><p>说明</p>\n<p>我们可以使用<code>PATCH</code>请求来更新指定位置的数据而不覆盖其他已有的数据。<code>PATCH</code>请求中指定的节点数据会被覆盖，没有提到的节点不会被删除。该功能与js中的<code>update()</code>方法类似。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PATCH -d &apos;&#123;&quot;last&quot;:&quot;Jones&quot;&#125;&apos; \\</div><div class=\"line\"> &apos;https://samplechat.wilddogio.com/users/jack/name/.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;last&quot;: &quot;Jones&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h2><p>说明</p>\n<p>我们可以使用<code>DELETE</code>请求来删除数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X DELETE \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name/last.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<p>请求成功将会返回200 OK状态码。响应中会包含空的JSON</p>\n<hr>\n<h2 id=\"方法覆盖\"><a href=\"#方法覆盖\" class=\"headerlink\" title=\"方法覆盖\"></a>方法覆盖</h2><p>说明</p>\n<p>如果我们发出REST调用的浏览器不支持上面的方法，我们可以覆盖请求方法，发送<code>POST</code>请求通过请求头中的<code>X-HTTP-Method-Override</code>设置要覆盖的方法。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &quot;X-HTTP-Method-Override: DELETE&quot; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name/last.json&apos;</div></pre></td></tr></table></figure>\n<p>我们也可以使用<code>x-http-method-override</code>查询参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name/last.json?x-http-method-override=DELETE&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<p>请求成功将会返回200 OK状态码。响应中会包含空的JSON</p>\n<hr>\n<h1 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h1><p>Wilddog的REST API接收以下的查询参数和值</p>\n<h2 id=\"shallow\"><a href=\"#shallow\" class=\"headerlink\" title=\"shallow\"></a>shallow</h2><p>说明</p>\n<p>这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 shallow=true 将限制数据返回的深度。如果返回的数据是JSON primitive (string, number or boolean)， 它的value将被返回。 如果数据的snapshot是 JSON object，每一个key的value将被截断成布尔类型<code>true</code>。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/.json?shallow=true&apos;</div></pre></td></tr></table></figure>\n<p>使用shallow参数后， 将不能使用其他查询参数。</p>\n<hr>\n<h2 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count\"></a>count</h2><p>说明</p>\n<p>查询当前节点下直接子节点的个数。设置 count=true 返回数量。可以与条件查询连用。与条件查询连用时，返回的是满足条件的节点的数量。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//查询 rest 节点下的子节点个数</div><div class=\"line\">curl &apos;https://docs-examples.wilddogio.com/rest.json?count=true&apos;</div><div class=\"line\"></div><div class=\"line\">//查询高度为0.6的恐龙的个数</div><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;equalTo=0.6&amp;count=true&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h2><p>说明</p>\n<p>格式化响应返回的数据。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数REST方法描述</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">pretty</td>\n<td style=\"text-align:left\">GET, PUT, POST, PATCH, DELETE</td>\n<td style=\"text-align:left\">以易读的方式查看数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">silent</td>\n<td style=\"text-align:left\">GET, PUT, POST, PATCH</td>\n<td style=\"text-align:left\">写入数据的时候控制输出，响应返回的是空值，http状态码为204 No Content</td>\n</tr>\n</tbody>\n</table>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/jack/name.json?print=pretty&apos;</div><div class=\"line\">curl -X PUT -d &apos;&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name.json?print=silent&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h2><p>说明</p>\n<p>仅支持 <code>get</code> 方式。为了让web客户端的rest请求实现跨域，你可以用JSONNP在JavaScript回调方法中封装一个响应。使用 <code>callback=</code> 让rest API在你指定的回调方法中封装返回的数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">  function gotData(data) &#123;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;https://samplechat.wilddogio.com/.json?callback=gotData&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"format\"><a href=\"#format\" class=\"headerlink\" title=\"format\"></a>format</h2><p>说明</p>\n<p>在 get 数据时，若带有如下参数，响应数据中会包含priority信息</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/.json?format=export&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"download\"><a href=\"#download\" class=\"headerlink\" title=\"download\"></a>download</h2><p>说明</p>\n<p>仅支持 <code>get</code> 方式。如果你想从web客户端把你的数据下载到一个文件中，请使用 <code>download=</code> 参数。参数后加上一个合适的文件名以让客户端将数据保存到这个文件中。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/.json?download=myfilename.txt&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderBy\"><a href=\"#orderBy\" class=\"headerlink\" title=\"orderBy\"></a>orderBy</h2><p>在 <a href=\"/guide/sync/rest/guide.html#查询数据\">完整文档 - 查询数据</a> 文档中获取更多信息。</p>\n<h2 id=\"limitToFirst-limitToLast\"><a href=\"#limitToFirst-limitToLast\" class=\"headerlink\" title=\"limitToFirst, limitToLast\"></a>limitToFirst, limitToLast</h2><p>在 <a href=\"/guide/sync/rest/guide.html#查询数据\">完整文档 - 查询数据</a> 文档中获取更多信息。</p>\n<h2 id=\"startAt-endAt-equalTo\"><a href=\"#startAt-endAt-equalTo\" class=\"headerlink\" title=\"startAt, endAt, equalTo\"></a>startAt, endAt, equalTo</h2><p>在 <a href=\"/guide/sync/rest/guide.html#查询数据\">完整文档 - 查询</a> 文档中获取更多信息。</p>\n<hr>\n<h1 id=\"Auth\"><a href=\"#Auth\" class=\"headerlink\" title=\"Auth\"></a>Auth</h1><h2 id=\"auth\"><a href=\"#auth\" class=\"headerlink\" title=\"auth\"></a>auth</h2><p>说明</p>\n<p>所有的请求都支持。可以授权请求访问被规则表达式保护的数据。可以使用应用的密钥，也可以使用认证令牌。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/jack/name.json?auth=CREDENTIAL&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"customTokenToIdToken\"><a href=\"#customTokenToIdToken\" class=\"headerlink\" title=\"customTokenToIdToken\"></a>customTokenToIdToken</h2><p>说明</p>\n<p>将 SDK 生成的 CustomToken 转换为 Wilddog IdToken。仅支持 <code>POST</code> 方式。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;token&quot;:&quot;&lt;YOUR CUSTOM TOKEN HERE&gt;&quot;&#125;&apos; \\</div><div class=\"line\">&apos;https://&lt;appid&gt;.wilddogio.com/.auth/customTokenToIdToken.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"idToken\"</span>:<span class=\"string\">\"&lt;IDTOEKN HERE&gt;\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"expireIn\"</span>:&lt;EXPIRE TIME IN SECONDS&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果转换过程中出现错误，系统会返回如下格式结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"error\"</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">\"code\"</span>:<span class=\"string\">\"&lt;ERRER CODE&gt;\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"errorMessage\"</span>:<span class=\"string\">\"&lt;ERROR MESSAGE&gt;\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Streaming\"><a href=\"#Streaming\" class=\"headerlink\" title=\"Streaming\"></a>Streaming</h1><p>Wilddog REST API支持 <a href=\"http://www.w3.org/TR/eventsource/\" target=\"_blank\" rel=\"external\">EventSource \\/ Server-Sent Events </a>协议。在Wilddog数据库使用 Server-Sent Events（简写 SSE）， 你需要准备以下：</p>\n<ul>\n<li>１. 设置Accept = “text\\/event-stream”</li>\n<li>２. 支持HTTP转跳，HTTP code 307</li>\n<li>３. 如果read操作有规则表达式， 需要设置auth参数</li>\n</ul>\n<p>云端返回的数据的协议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">event: event name</div><div class=\"line\"></div><div class=\"line\">data: JSON encoded data payload</div></pre></td></tr></table></figure>\n<p>下面是云端返回的数据协议：</p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h2><p>说明</p>\n<p>data是json对象， 包含两个key： <code>path</code>和<code>data</code>。<code>path</code>是<code>data</code>相关的路径。客户端应该替换<code>path</code>的所有数据。</p>\n<hr>\n<h2 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h2><p>说明</p>\n<p>data是json对象， 包含两个key： <code>path</code> 和 <code>data</code>。<code>path</code>是<code>data</code>相关的路径。对于data的每一个key，客户端应该替换这个key对应的数据。</p>\n<hr>\n<h2 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h2><p>说明</p>\n<p>event的data为null，即无任何操作。</p>\n<hr>\n<h2 id=\"auth-revoked\"><a href=\"#auth-revoked\" class=\"headerlink\" title=\"auth_revoked\"></a>auth_revoked</h2><p>说明</p>\n<p>此event的数据为一个字符串，该字符串表示该认证已过期。当提供的认证过期时，此event将被发送。</p>\n<hr>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>先开启一个端口用于查看云端发送的event，下面是云端发送的event示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//  设置你整个数据</div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/&quot;, &quot;data&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">//  推送key为c的新数据, 然后整个数据如下</div><div class=\"line\">// &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">// 在每个数据的key, 更新或添加数据，</div><div class=\"line\">// 然后整个数据如下</div><div class=\"line\">//  &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: 3, &quot;bar&quot;: false, &quot;baz&quot;: 4&#125;&#125;</div><div class=\"line\">event: patch</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: 3, &quot;baz&quot;: 4&#125;&#125;</div></pre></td></tr></table></figure>\n<p>为了产生变化，可以再开启一个端口输入命令。</p>\n<p>如：使用curl命令开启SSE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X GET -H &apos;Accept:text/event-stream&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.json&apos;</div></pre></td></tr></table></figure>\n<p>使用curl命令put数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;path&quot;: &quot;/&quot;, &quot;data&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#125;&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.json&apos;</div><div class=\"line\">&#123;&quot;path&quot;:&quot;/&quot;,&quot;data&quot;:&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Priorities\"><a href=\"#Priorities\" class=\"headerlink\" title=\"Priorities\"></a>Priorities</h1><p>某个节点的优先级信息会被一个名为 .priority 的虚拟节点储存。优先级可以通过REST请求读取或写入。例如，下面的请求用来检索 users\\/tom 节点的优先级信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/tom/.priority.json&apos;</div></pre></td></tr></table></figure>\n<p>当要同时写入优先级信息和数据信息时，你可以在要写入的JSON中增加 .priority 子节点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;name&quot;: &#123;&quot;first&quot;: &quot;Tom&quot;&#125;, &quot;.priority&quot;: 1.0&#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/tom.json&apos;</div></pre></td></tr></table></figure>\n<p>当要同时写入优先级信息和原始类型数据（如字符串）时，你可以增加一个 .priority 子节点，并将原始类型数据放在 .value 子节点中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;.value&quot;: &quot;Tom&quot;, &quot;.priority&quot;: 1.0&#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/tom/name/first.json&apos;</div></pre></td></tr></table></figure>\n<p>这个示例写入的值是Tom，优先级是1.0。优先级可以放在JSON结构的任意深度。</p>\n<hr>\n<h1 id=\"Server-Values\"><a href=\"#Server-Values\" class=\"headerlink\" title=\"Server Values\"></a>Server Values</h1><p>说明</p>\n<p>服务端数值使用占位符： <code>.sv</code>。<code>.sv</code>的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;.sv&quot;: &quot;timestamp&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://&lt;appId&gt;.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json&apos;</div></pre></td></tr></table></figure>\n<p>说明</p>\n<p>当我们需要获取服务器的当前时间戳时，可以进行如下操作 :</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/.json?sv=timestamp&apos;</div></pre></td></tr></table></figure>\n<p>该操作将会直接返回服务器的当前时间戳，而不包括查询的数据。</p>\n<p>服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考<a href=\"http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa\" target=\"_blank\" rel=\"external\">百科</a>。</p>\n<hr>\n<h1 id=\"规则表达式\"><a href=\"#规则表达式\" class=\"headerlink\" title=\"规则表达式\"></a>规则表达式</h1><p>REST API可以用来查询和更改规则表达式。该操作必须使用应用的超级密钥，你可以在应用的控制面板–超级密钥页面获取超级密钥。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;rules&quot;:&#123;&quot;.read&quot;:true&#125;&#125;&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl  &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h1><h2 id=\"错误码\"><a href=\"#错误码\" class=\"headerlink\" title=\"错误码\"></a>错误码</h2><p>说明</p>\n<p>Wilddog的REST API将在以下情况返回错误码：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">HTTP状态码描述</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">404 Not Found</td>\n<td style=\"text-align:left\">通过HTTP请求而不是HTTPS请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">不能解析PUT或POST数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">丢失PUT或POST数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">PUT或POST数据过长</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">417 Expectation Failed</td>\n<td style=\"text-align:left\">REST API调用没有指定Wilddog名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">REST API调用路径中包含非法的子节点名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">403 Forbidden</td>\n<td style=\"text-align:left\">请求违反规则表达式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"错误信息\"><a href=\"#错误信息\" class=\"headerlink\" title=\"错误信息\"></a>错误信息</h2><p>说明</p>\n<p>Wilddog的REST API将在业务错误时返回值中返回error信息：</p>\n<p>For example :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;error&quot;:&quot;单次请求数据量过大&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>常见error信息列举如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">error信息描述推荐解决方案</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">单次请求数据量过大</td>\n<td style=\"text-align:left\">用户对相应节点导出的数据超过了REST API允许导出的数据量范围</td>\n<td style=\"text-align:left\">用户将问题通过提交工单的方式进行反馈,会有专员为用户提取数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">写入数据中叶子节点数据量过大</td>\n<td style=\"text-align:left\">用户写入的数据中存在节点超过了每个节点允许的最大数据量</td>\n<td style=\"text-align:left\">用户若存在节点数据大于节点最大数据允许范围,则需要重新设计数据结构</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">orderBy参数不合法</td>\n<td style=\"text-align:left\">用户orderBy参数不符合orederBy的参数的规范</td>\n<td style=\"text-align:left\">用户确认orderBy中的参数信息是否有异常字符.eg:若orderBy参数中若有$符号,则参数必须为$key、$priority、$value这三种情况的一种</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">路径不合法，超过最大深度32层</td>\n<td style=\"text-align:left\">用户的数据节点深度超过最大深度32层</td>\n<td style=\"text-align:left\">用户的数据节点深度不能超过32层,若超过32层,则需重新设计数据结构</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">单次写入数据量超过4M字节的限制</td>\n<td style=\"text-align:left\">单次写入数据量超过4M字节的限制</td>\n<td style=\"text-align:left\">用户将写操作的数据通过数据拆分的形式进行分批操作</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<p>我们可以使用任意的Wilddog应用的URL作为REST的结束点，我们只需要在URL的结尾处加上<code>.json</code>然后发送HTTPS请求即可。 HTTPS是必须的，Wilddog只会响应加密数据，所以你的数据是保证安全的。</p>\n<h2 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h2><p>说明</p>\n<p>通过HTTP发送GET请求就可以读取数据库中的数据 请求成功将会返回200 OK状态码。响应中会包含要查询的数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/jack/name.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"PUT\"><a href=\"#PUT\" class=\"headerlink\" title=\"PUT\"></a>PUT</h2><p>说明</p>\n<p>我们可以使用 <code>PUT</code> 请求写入数据</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h2><p>说明</p>\n<p>要实现js中<code>push()</code>方法类似的功能，我们可以使用<code>POST</code>请求</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;user_id&quot; : &quot;jack&quot;, &quot;text&quot; : &quot;Ahoy!&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/message_list.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;name&quot;: &quot;-INOQPH-aV_psbk3ZXEX&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"PATCH\"><a href=\"#PATCH\" class=\"headerlink\" title=\"PATCH\"></a>PATCH</h2><p>说明</p>\n<p>我们可以使用<code>PATCH</code>请求来更新指定位置的数据而不覆盖其他已有的数据。<code>PATCH</code>请求中指定的节点数据会被覆盖，没有提到的节点不会被删除。该功能与js中的<code>update()</code>方法类似。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PATCH -d &apos;&#123;&quot;last&quot;:&quot;Jones&quot;&#125;&apos; \\</div><div class=\"line\"> &apos;https://samplechat.wilddogio.com/users/jack/name/.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; &quot;last&quot;: &quot;Jones&quot; &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h2><p>说明</p>\n<p>我们可以使用<code>DELETE</code>请求来删除数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X DELETE \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name/last.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<p>请求成功将会返回200 OK状态码。响应中会包含空的JSON</p>\n<hr>\n<h2 id=\"方法覆盖\"><a href=\"#方法覆盖\" class=\"headerlink\" title=\"方法覆盖\"></a>方法覆盖</h2><p>说明</p>\n<p>如果我们发出REST调用的浏览器不支持上面的方法，我们可以覆盖请求方法，发送<code>POST</code>请求通过请求头中的<code>X-HTTP-Method-Override</code>设置要覆盖的方法。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -H &quot;X-HTTP-Method-Override: DELETE&quot; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name/last.json&apos;</div></pre></td></tr></table></figure>\n<p>我们也可以使用<code>x-http-method-override</code>查询参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name/last.json?x-http-method-override=DELETE&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<p>请求成功将会返回200 OK状态码。响应中会包含空的JSON</p>\n<hr>\n<h1 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h1><p>Wilddog的REST API接收以下的查询参数和值</p>\n<h2 id=\"shallow\"><a href=\"#shallow\" class=\"headerlink\" title=\"shallow\"></a>shallow</h2><p>说明</p>\n<p>这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 shallow=true 将限制数据返回的深度。如果返回的数据是JSON primitive (string, number or boolean)， 它的value将被返回。 如果数据的snapshot是 JSON object，每一个key的value将被截断成布尔类型<code>true</code>。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/.json?shallow=true&apos;</div></pre></td></tr></table></figure>\n<p>使用shallow参数后， 将不能使用其他查询参数。</p>\n<hr>\n<h2 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count\"></a>count</h2><p>说明</p>\n<p>查询当前节点下直接子节点的个数。设置 count=true 返回数量。可以与条件查询连用。与条件查询连用时，返回的是满足条件的节点的数量。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//查询 rest 节点下的子节点个数</div><div class=\"line\">curl &apos;https://docs-examples.wilddogio.com/rest.json?count=true&apos;</div><div class=\"line\"></div><div class=\"line\">//查询高度为0.6的恐龙的个数</div><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;equalTo=0.6&amp;count=true&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h2><p>说明</p>\n<p>格式化响应返回的数据。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数REST方法描述</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">pretty</td>\n<td style=\"text-align:left\">GET, PUT, POST, PATCH, DELETE</td>\n<td style=\"text-align:left\">以易读的方式查看数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">silent</td>\n<td style=\"text-align:left\">GET, PUT, POST, PATCH</td>\n<td style=\"text-align:left\">写入数据的时候控制输出，响应返回的是空值，http状态码为204 No Content</td>\n</tr>\n</tbody>\n</table>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/jack/name.json?print=pretty&apos;</div><div class=\"line\">curl -X PUT -d &apos;&#123; &quot;first&quot;: &quot;Jack&quot;, &quot;last&quot;: &quot;Sparrow&quot; &#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/jack/name.json?print=silent&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h2><p>说明</p>\n<p>仅支持 <code>get</code> 方式。为了让web客户端的rest请求实现跨域，你可以用JSONNP在JavaScript回调方法中封装一个响应。使用 <code>callback=</code> 让rest API在你指定的回调方法中封装返回的数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">  function gotData(data) &#123;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;https://samplechat.wilddogio.com/.json?callback=gotData&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"format\"><a href=\"#format\" class=\"headerlink\" title=\"format\"></a>format</h2><p>说明</p>\n<p>在 get 数据时，若带有如下参数，响应数据中会包含priority信息</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/.json?format=export&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"download\"><a href=\"#download\" class=\"headerlink\" title=\"download\"></a>download</h2><p>说明</p>\n<p>仅支持 <code>get</code> 方式。如果你想从web客户端把你的数据下载到一个文件中，请使用 <code>download=</code> 参数。参数后加上一个合适的文件名以让客户端将数据保存到这个文件中。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/.json?download=myfilename.txt&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderBy\"><a href=\"#orderBy\" class=\"headerlink\" title=\"orderBy\"></a>orderBy</h2><p>在 <a href=\"/guide/sync/rest/guide.html#查询数据\">完整文档 - 查询数据</a> 文档中获取更多信息。</p>\n<h2 id=\"limitToFirst-limitToLast\"><a href=\"#limitToFirst-limitToLast\" class=\"headerlink\" title=\"limitToFirst, limitToLast\"></a>limitToFirst, limitToLast</h2><p>在 <a href=\"/guide/sync/rest/guide.html#查询数据\">完整文档 - 查询数据</a> 文档中获取更多信息。</p>\n<h2 id=\"startAt-endAt-equalTo\"><a href=\"#startAt-endAt-equalTo\" class=\"headerlink\" title=\"startAt, endAt, equalTo\"></a>startAt, endAt, equalTo</h2><p>在 <a href=\"/guide/sync/rest/guide.html#查询数据\">完整文档 - 查询</a> 文档中获取更多信息。</p>\n<hr>\n<h1 id=\"Auth\"><a href=\"#Auth\" class=\"headerlink\" title=\"Auth\"></a>Auth</h1><h2 id=\"auth\"><a href=\"#auth\" class=\"headerlink\" title=\"auth\"></a>auth</h2><p>说明</p>\n<p>所有的请求都支持。可以授权请求访问被规则表达式保护的数据。可以使用应用的密钥，也可以使用认证令牌。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/jack/name.json?auth=CREDENTIAL&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"customTokenToIdToken\"><a href=\"#customTokenToIdToken\" class=\"headerlink\" title=\"customTokenToIdToken\"></a>customTokenToIdToken</h2><p>说明</p>\n<p>将 SDK 生成的 CustomToken 转换为 Wilddog IdToken。仅支持 <code>POST</code> 方式。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;token&quot;:&quot;&lt;YOUR CUSTOM TOKEN HERE&gt;&quot;&#125;&apos; \\</div><div class=\"line\">&apos;https://&lt;appid&gt;.wilddogio.com/.auth/customTokenToIdToken.json&apos;</div></pre></td></tr></table></figure>\n<p>返回值</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"idToken\"</span>:<span class=\"string\">\"&lt;IDTOEKN HERE&gt;\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"expireIn\"</span>:&lt;EXPIRE TIME IN SECONDS&gt;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果转换过程中出现错误，系统会返回如下格式结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"error\"</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">\"code\"</span>:<span class=\"string\">\"&lt;ERRER CODE&gt;\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"errorMessage\"</span>:<span class=\"string\">\"&lt;ERROR MESSAGE&gt;\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Streaming\"><a href=\"#Streaming\" class=\"headerlink\" title=\"Streaming\"></a>Streaming</h1><p>Wilddog REST API支持 <a href=\"http://www.w3.org/TR/eventsource/\">EventSource \\/ Server-Sent Events </a>协议。在Wilddog数据库使用 Server-Sent Events（简写 SSE）， 你需要准备以下：</p>\n<ul>\n<li>１. 设置Accept = “text\\/event-stream”</li>\n<li>２. 支持HTTP转跳，HTTP code 307</li>\n<li>３. 如果read操作有规则表达式， 需要设置auth参数</li>\n</ul>\n<p>云端返回的数据的协议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">event: event name</div><div class=\"line\"></div><div class=\"line\">data: JSON encoded data payload</div></pre></td></tr></table></figure>\n<p>下面是云端返回的数据协议：</p>\n<h2 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put\"></a>put</h2><p>说明</p>\n<p>data是json对象， 包含两个key： <code>path</code>和<code>data</code>。<code>path</code>是<code>data</code>相关的路径。客户端应该替换<code>path</code>的所有数据。</p>\n<hr>\n<h2 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h2><p>说明</p>\n<p>data是json对象， 包含两个key： <code>path</code> 和 <code>data</code>。<code>path</code>是<code>data</code>相关的路径。对于data的每一个key，客户端应该替换这个key对应的数据。</p>\n<hr>\n<h2 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h2><p>说明</p>\n<p>event的data为null，即无任何操作。</p>\n<hr>\n<h2 id=\"auth-revoked\"><a href=\"#auth-revoked\" class=\"headerlink\" title=\"auth_revoked\"></a>auth_revoked</h2><p>说明</p>\n<p>此event的数据为一个字符串，该字符串表示该认证已过期。当提供的认证过期时，此event将被发送。</p>\n<hr>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>先开启一个端口用于查看云端发送的event，下面是云端发送的event示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//  设置你整个数据</div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/&quot;, &quot;data&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">//  推送key为c的新数据, 然后整个数据如下</div><div class=\"line\">// &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">// 在每个数据的key, 更新或添加数据，</div><div class=\"line\">// 然后整个数据如下</div><div class=\"line\">//  &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: 3, &quot;bar&quot;: false, &quot;baz&quot;: 4&#125;&#125;</div><div class=\"line\">event: patch</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: 3, &quot;baz&quot;: 4&#125;&#125;</div></pre></td></tr></table></figure>\n<p>为了产生变化，可以再开启一个端口输入命令。</p>\n<p>如：使用curl命令开启SSE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X GET -H &apos;Accept:text/event-stream&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.json&apos;</div></pre></td></tr></table></figure>\n<p>使用curl命令put数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;path&quot;: &quot;/&quot;, &quot;data&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#125;&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.json&apos;</div><div class=\"line\">&#123;&quot;path&quot;:&quot;/&quot;,&quot;data&quot;:&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Priorities\"><a href=\"#Priorities\" class=\"headerlink\" title=\"Priorities\"></a>Priorities</h1><p>某个节点的优先级信息会被一个名为 .priority 的虚拟节点储存。优先级可以通过REST请求读取或写入。例如，下面的请求用来检索 users\\/tom 节点的优先级信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://samplechat.wilddogio.com/users/tom/.priority.json&apos;</div></pre></td></tr></table></figure>\n<p>当要同时写入优先级信息和数据信息时，你可以在要写入的JSON中增加 .priority 子节点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;name&quot;: &#123;&quot;first&quot;: &quot;Tom&quot;&#125;, &quot;.priority&quot;: 1.0&#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/tom.json&apos;</div></pre></td></tr></table></figure>\n<p>当要同时写入优先级信息和原始类型数据（如字符串）时，你可以增加一个 .priority 子节点，并将原始类型数据放在 .value 子节点中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;.value&quot;: &quot;Tom&quot;, &quot;.priority&quot;: 1.0&#125;&apos; \\</div><div class=\"line\">  &apos;https://samplechat.wilddogio.com/users/tom/name/first.json&apos;</div></pre></td></tr></table></figure>\n<p>这个示例写入的值是Tom，优先级是1.0。优先级可以放在JSON结构的任意深度。</p>\n<hr>\n<h1 id=\"Server-Values\"><a href=\"#Server-Values\" class=\"headerlink\" title=\"Server Values\"></a>Server Values</h1><p>说明</p>\n<p>服务端数值使用占位符： <code>.sv</code>。<code>.sv</code>的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;.sv&quot;: &quot;timestamp&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://&lt;appId&gt;.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json&apos;</div></pre></td></tr></table></figure>\n<p>说明</p>\n<p>当我们需要获取服务器的当前时间戳时，可以进行如下操作 :</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/.json?sv=timestamp&apos;</div></pre></td></tr></table></figure>\n<p>该操作将会直接返回服务器的当前时间戳，而不包括查询的数据。</p>\n<p>服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考<a href=\"http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa\">百科</a>。</p>\n<hr>\n<h1 id=\"规则表达式\"><a href=\"#规则表达式\" class=\"headerlink\" title=\"规则表达式\"></a>规则表达式</h1><p>REST API可以用来查询和更改规则表达式。该操作必须使用应用的超级密钥，你可以在应用的控制面板–超级密钥页面获取超级密钥。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;rules&quot;:&#123;&quot;.read&quot;:true&#125;&#125;&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl  &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h1><h2 id=\"错误码\"><a href=\"#错误码\" class=\"headerlink\" title=\"错误码\"></a>错误码</h2><p>说明</p>\n<p>Wilddog的REST API将在以下情况返回错误码：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">HTTP状态码描述</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">404 Not Found</td>\n<td style=\"text-align:left\">通过HTTP请求而不是HTTPS请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">不能解析PUT或POST数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">丢失PUT或POST数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">PUT或POST数据过长</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">417 Expectation Failed</td>\n<td style=\"text-align:left\">REST API调用没有指定Wilddog名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">REST API调用路径中包含非法的子节点名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">403 Forbidden</td>\n<td style=\"text-align:left\">请求违反规则表达式</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"错误信息\"><a href=\"#错误信息\" class=\"headerlink\" title=\"错误信息\"></a>错误信息</h2><p>说明</p>\n<p>Wilddog的REST API将在业务错误时返回值中返回error信息：</p>\n<p>For example :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;error&quot;:&quot;单次请求数据量过大&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>常见error信息列举如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">error信息描述推荐解决方案</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">单次请求数据量过大</td>\n<td style=\"text-align:left\">用户对相应节点导出的数据超过了REST API允许导出的数据量范围</td>\n<td style=\"text-align:left\">用户将问题通过提交工单的方式进行反馈,会有专员为用户提取数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">写入数据中叶子节点数据量过大</td>\n<td style=\"text-align:left\">用户写入的数据中存在节点超过了每个节点允许的最大数据量</td>\n<td style=\"text-align:left\">用户若存在节点数据大于节点最大数据允许范围,则需要重新设计数据结构</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">orderBy参数不合法</td>\n<td style=\"text-align:left\">用户orderBy参数不符合orederBy的参数的规范</td>\n<td style=\"text-align:left\">用户确认orderBy中的参数信息是否有异常字符.eg:若orderBy参数中若有$符号,则参数必须为$key、$priority、$value这三种情况的一种</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">路径不合法，超过最大深度32层</td>\n<td style=\"text-align:left\">用户的数据节点深度超过最大深度32层</td>\n<td style=\"text-align:left\">用户的数据节点深度不能超过32层,若超过32层,则需重新设计数据结构</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">单次写入数据量超过4M字节的限制</td>\n<td style=\"text-align:left\">单次写入数据量超过4M字节的限制</td>\n<td style=\"text-align:left\">用户将写操作的数据通过数据拆分的形式进行分批操作</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"规则表达式API 文档","_content":"\n# Rule (*Type*)\n\n## .read\n\n定义\n\n对指定路径赋予读取数据的权限。\n\n说明\n\n读取规则是Wilddog数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的读取规则。例如：\n\n```\n\".read\": \"auth != null && auth.provider == 'weibo'\"\n```\n\n.read 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以读取， 而且它的所有子节点也是可以读取的。值为false 则不能读取数据。\n\n.read对除了newData外的所有Wilddog变量可用。\n\n------\n\n## .write\n\n定义\n\n对指定路径赋予写数据的权限。\n\n说明\n\n写规则是Wilddog 数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的写规则。例如：\n\n.write 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以写， 而且它的所有子节点也是可以写的。值为false 则不能写数据。\n\n.write规则对Wilddog所有的Rule变量可用。\n\n------\n\n## .validate\n\n定义\n\n.write规则获得权限后使用，以确保所写的数据符合特定的模式。\n\n说明\n\n.write 规则获得权限后使用，以确保所写的数据符合特定的模式。除此之外，.write 获得权限后，.validate 规则必须取得验证成功。例如：\n\n```\n\".validate\": \"newData.hasChildren(['name', 'age'])\"\n\n```\n\n.validate 规则的值类型是字符串，这个表达式使用的Javascript语法。\n\n.validate 规则对Wilddog所有的Rule变量可用。\n\n------\n\n## .indexOn\n\n定义\n\n为数据添加索引，提高查询效率。\n\n说明\n\n.indexOn 规则可以为指定的节点建立索引，以此来提高查询效率。例如：\n\n```\n{\n  \"rules\": {\n    \"dinosaurs\": {\n      \".indexOn\": [\"height\", \"length\"]\n    }\n  }\n}\n\n```\n\n.indexOn 规则的值类型是字符串，或者是字符串数组。 节点的名称key和优先级priority默认建立索引，不需要额外设置。 关于 .indexOn 规则更多介绍，请参考规则表达式文档 [数据索引](/guide/sync/rules/guide.html#数据索引) 部分。\n\n------\n\n# Rule (*Variables*)\n\n## auth\n\n定义\n\n这个变量与用户是否使用认证有关。使用认证就是调用auth相关的方法，比如authWithPassword()。 如果客户端已经登录认证，这个变量中包含token信息，否则为null。\n\n说明\n\nWilddog 认证\n\n野狗内置几种认证方式。你可以轻松使用它们来生成tokens。在使用一种认证方式和，auth变量包含以下内容：\n\n| 字段       | 描述                                       |\n| -------- | ---------------------------------------- |\n| provider | 认证提供商 (\"password\", \"anonymous\", \"qq\", \"weibo\", \"weixin\", or \"weixinmp\")。 |\n| uid      | 一个唯一的用户id，保证独一无二。                        |\n\n举一个例子, 有一个博客的评论， 只能修改和删除评论， 我们配置以下规则：\n\n```\n{\n  \"rules\": {\n    \".read\": true,\n    \"$comment\": {\n      \".write\": \"!data.exists() && newData.child('user_id').val() == auth.uid\"\n    }\n  }\n}\n\n```\n\n如果要求只有微博登修改，只需要轻松修改rule配置， 就能搞定。\n\n```\n{\n  \"rules\": {\n    \".read\": true,\n    \"$comment\": {\n      \".write\": \"!data.exists() && auth.provider == 'weibo'\"\n    }\n  }\n}\n\n```\n\n下面java版生成工具依赖\n\n```\n<dependency>\n    <groupId>com.wilddog</groupId>\n    <artifactId>wilddog-token-generator</artifactId>\n    <version>1.0.0</version>\n</dependency>\n\n```\n\n------\n\n## $location\n\n定义\n\n一个可以用来在规则表达式中使用的代表位置的变量。\n\n说明\n\n当你使用$location在你规则表达式，这个变量是以`$`开头，用于替换实际读写子节点的名称。假设我们希望给每个用户读写他们自己的`/users/`的位置，我们可以使用：\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user\": {\n        \".read\": \"auth.uid == $user\",\n        \".write\": \"auth.uid == $user\"\n      }\n    }\n  }\n}\n\n```\n\n当一个用户试图访问`/users/barney`，位置变量$user将匹配到`\"barney\"`。所以.read 规则将判断 `auth.uid == 'barney'`。\n\n------\n\n## now\n\n定义\n\n包含一个在Wilddog服务器的Unix时间秒数。\n\n说明\n\n包含一个在Wilddog服务器的Unix时间秒数。例如:\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user\": {\n        \"created\": {\n          \".validate\": \"newData.val() < now\"\n        }\n      }\n    }\n  }\n}\n\n```\n\n------\n\n## root\n\n定义\n\n你的Wilddog数据库中的根节点的数据快照`RuleDataSnapshot`\n\n说明\n\nroot变量标识的`RuleDataSnapshot`，对应着你的Wilddog数据库根节点。你能够在读任何数据的时候在表达式中使用它。例如：你想允许用户仅在 `/users//active`设置为true的时候读取 `/comments`。我们这样使用：\n\n```\n{\n  \"rules\": {\n    \"comments\": {\n      \".read\": \"root.child('users').child(auth.uid).child('active').val() == true\"\n    }\n  }\n}\n\n```\n\n------\n\n## newData\n\n定义\n\n一个数据快照`RuleDataSnapshot`对应的将要被写的数据。\n\n说明\n\n在.write和.validate规则中使用，newData变量允许代表一个将要被写的`RuleDataSnapshot`，也可能是一个从其他节点移过来的`RuleDataSnapshot`。下面的例子，要求每个用户必须包含name和age字段：\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user\": {\n        \".read\": true,\n        \".write\": true,\n        \".validate\": \"newData.hasChildren(['name', 'age'])\"\n      }\n    }\n  }\n}\n\n```\n\n由于newData合并包括存在的数据和新添加的数据。\n\n```\nvar fredRef = new Wilddog(\"https://samplechat.wilddogio.com/users/fred\");\n// 可行\nfredRef.set({ name: \"Fred\", age: 19 });\n// 可行\nfredRef.child(\"age\").set(27);\n// 因为.validate不再为真，所以不可行\nfredRef.child(\"name\").remove();\nnewData变量在.read规则中不可用，因为没有新数据被写入，只能用data变量。\n\n```\n\n------\n\n# RuleDataSnapshot (*Methods*)\n\n## val()\n\n定义\n\nString val()\n\n说明\n\n从 `RuleDataSnapshot`获取原生类型 (`string`, `number`, `boolean`, or `null`)。与DataSnapshot.val()不一样，`RuleDataSnapshot`调用 `val()`方法将不会返回一个`object`，就算包含子节点也这样。\n\n返回值\n\nString, Number, Boolean, Null RuleDataSnapshot 的原生类型数据。\n\n示例\n\n```\n\".read\": \"data.child('isReadable').val() == true\"\n\n```\n\n------\n\n## child()\n\n定义\n\nRuleDataSnapshot child()\n\n说明\n\n通过相对路径获取`RuleDataSnapshot`的子节点。\n\n参数\n\n- childPath `String` 子节点的相对路径。\n\n返回值\n\n子节点的 `RuleDataSnapshot`\n\n示例\n\n```\n\".read\": \"data.child('isReadable').val() == true\"\n\n```\n\n------\n\n## parent()\n\n定义\n\nRuleDataSnapshot parent()\n\n说明\n\n通过相对路径获取`RuleDataSnapshot`的父节点。\n\n返回值\n\n父节点的 `RuleDataSnapshot`.\n\n------\n\n## hasChild()\n\n定义\n\nBoolean hasChild(String childPath)\n\n说明\n\n判断`RuleDataSnapshot` 是否存在子节点。\n\n参数\n\nchildPath `String` 潜在子节点的相对路径。\n\n返回值\n\nBoolean 存在返回`true`，否则`false`\n\n示例\n\n```\n\".validate\": \"newData.hasChild('name')\"\n\n```\n\n------\n\n## hasChildren()\n\n定义\n\nBoolean hasChildren([children]);\n\n说明\n\n判断当前节点是否存在指定一组子节点。\n\n参数\n\nchildren `Array` *optional 所有存在子节点的数组。\n\n返回值\n\nBoolean\n\npathList List 路径数组 一组子节点路径，例如['a','b','c']\n\n示例\n\n```\n\".validate\": \"newData.hasChildren()\"\n\n```\n\n```\n\".validate\": \"newData.hasChildren(['name', 'age'])\"\n\n```\n\n------\n\n## exists()\n\n定义\n\nBoolean exists()\n\n说明\n\n判断这个`RuleDataSnapshot`是否存在，包含数据返回true。等价于`data.val() != null`\n\n返回值\n\nBoolean 包含返回`true`，否则返回`false`。\n\n示例\n\n```\n\".write\": \"!data.exists()\"\n\n```\n\n------\n\n## getPriority()\n\n定义\n\nString getPriority()\n\n说明\n\n获取`RuleDataSnapshot`的优先级。\n\n返回值\n\nString, Number, Null\n\n示例\n\n```\n\".validate\": \"newData.getPriority() != null\"\n\n```\n\n------\n\n## isNumber()\n\n定义\n\nBoolean isNumber()\n\n说明\n\n判断获取`RuleDataSnapshot`的是否是数字类型。\n\n返回值\n\nBoolean 是数字为`true` 否则返回 `false`.\n\n示例\n\n```\n\".validate\": \"newData.child('age').isNumber()\"\n\n```\n\n------\n\n## isString()\n\n定义\n\nBoolean isString()\n\n说明\n\n判断获取`RuleDataSnapshot`的是否是字符串类型。\n\n返回值\n\nBoolean 是字符串为`true` 否则返回 `false`.\n\n示例\n\n```\n\".validate\": \"newData.child('name').isString()\n\n```\n\n------\n\n## isBoolean()\n\n定义\n\nBoolean isBoolean()\n\n说明\n\n判断获取`RuleDataSnapshot`的是否是布尔类型。\n\n返回值\n\nBoolean 是布尔为`true` 否则返回 `false`.\n\n示例\n\n```\n\".validate\": \"newData.child('active').isBoolean()\"\n\n```\n\n------\n\n# String (*Methods*)\n\n## length()\n\n定义\n\n字符串的长度。\n\n说明\n\n返回字符串的长度。\n\n返回值\n\nNumber\n\n示例\n\n```\n\".validate\": \"newData.isString() && newData.val().length() >= 10\"\n\n```\n\n------\n\n## contains()\n\n定义\n\nBoolean contains(String substring)\n\n说明\n\n判断字符串是否包含指定的子串。\n\n参数\n\n- substring `String` 指定的子串。\n\n返回值\n\nBoolean\n\n示例\n\n```\n\".validate\": \"newData.isString() && newData.val().contains('@')\"\n\n```\n\n------\n\n## beginsWith()\n\n定义\n\nBoolean beginsWith(String substring)\n\n说明\n\n以一个子串开头。\n\n参数\n\n- substring `String`\n\n返回值\n\nBoolean\n\n示例\n\n------\n\n## endsWith()\n\n定义\n\nBoolean endsWith(String substring)\n\n说明\n\n以一个子串开头结尾。\n\n参数\n\n- substring `String`\n\n返回值\n\nBoolean\n\n示例\n\n------\n\n## replace()\n\n定义\n\nString replace(String substring, String replacement)\n\n说明\n\n我们的replace()方法与JavaScript中的replace()方法稍微有些不同。我们的replace是用replacement替换掉所有的substring，而JavaScript中只是替换掉第一个。因为key中不能包含句号“.”,我们应该对特殊字符进行escape编码后，才能存储它们。\n\n参数\n\n- substring `String` 查找的子字符串。\n- replacement `String` 替换的子字符串。\n\n返回值\n\nString 返回替换后的新字符串。\n\n示例\n\n假设我们在`/whitelist/` 节点有一个email白名单列表：\n\n```\n{\n \"user\": {\n   \"$uid\": {\n     \"email\": <email>\n   }\n },\n \"whitelist\": {\n   \"fred@gmail%2Ecom\": true,\n   \"barney@aol%2Ecom\": true\n }\n}\n\n```\n\n我们可以如下制定rule规则，只允许email在白名单中的用户。\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".read\": \"true\",\n        \".write\": \"root.child('whitelist').child(newData.child('email').val().replace('.', '%2E')).exists()\"\n      }\n    }\n  }\n}\n\n```\n\n------\n\n## toLowerCase()\n\n定义\n\nString toLowerCase()\n\n说明\n\n返回小写的字符串\n\n返回值\n\n小写字符串。\n\n示例\n\n------\n\n## toUpperCase()\n\n定义\n\nString toUpperCase()\n\n说明\n\n返回大写的字符串。\n\n返回值\n\n`string` 大写的字符串。\n\n示例\n\n------\n\n## matches()\n\n定义\n\nBoolean matches(String regex)\n\n说明\n\n可以利用正则表达式校验客户端提供的字符串。用string.matches(pattern)来验证指定字符串是否符合规则表达式。我们的正则表达式的语法与传统规则表达式不完全一致：\n\n`+` `*` `.` `( )` `[ ]` `{ }` `\\` 与传统语法一致\n\n`^` and `$`只被用来匹配首尾\n\n只支持 `i` (忽略大小写) 修饰符\n\n正则表达式以/pattern/的形式被引入规则表达式。被用来检验一个字符串是否符合正则表达式。下面的校验规则用来检验新的字符串是否以'foo'开头。\n\n```\n\".validate\": 'newData.val().matches(\"^foo\")'\n\n```\n\nWilddog只支持一部分正则表达式的功能，不过，工程师们应该对正则表达式语法很熟悉。 下面是所支持的正则符号：\n\n| 字符                | 描述                                       |\n| ----------------- | ---------------------------------------- |\n| \\s \\w \\d \\S \\W \\D | 匹配任何空白字符，包括空格、制表符、换页符；匹配任何字类字符；数字字符匹配；匹配任何非空白字符；与任何非单词字符匹配；非数字字符匹配。 |\n|                  | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符              |\n| ^                 | 匹配输入字符串开始的位置                             |\n| $                 | 匹配输入字符串结尾的位置                             |\n| *                 | 零次或多次匹配前面的字符或子表达式                        |\n| +                 | 一次或多次匹配前面的字符或子表达式                        |\n| ?                 | 零次或一次匹配前面的字符或子表达式                        |\n| .                 | 匹配除“\\n”之外的任何单个字符                         |\n| i                 | 一个以'i'结尾的正则表达式表示忽略大小写                    |\n| (pattern)         | 匹配 pattern 并捕获该匹配的子表达式                   |\n| a\\|b              | 匹配 a 或 b                                 |\n| [akz]             | 字符集，匹配包含的任一字符。/[ABCDEF]/匹配a-f中的大写字母      |\n| [a-z]             | 一个字符区间, 匹配包含在指定范围内的所有字母。/[0-9A-F]/匹配十六进制字符串 |\n| [^0-9]            | 以'^'开头，匹配不在指定字符集中的字符                     |\n\n在Wilddog安全规则中,正则表达式既不是贪婪的也不是非贪婪的，因为，它只允许你用来进行匹配而不是获取字符串。\n\n参数\n\n- regex `String` 正则表达式\n\n返回值\n\nBoolean 如果满足正则表达式返回true,否则返回false。\n\n示例\n\n新数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式。\n\n```\n\".validate\": \"newData.isString() && newData.val().matches('^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$')\"\n\n```\n\n校验新数据符合email格式。\n\n```\n\".validate\": \"newData.isString() && newData.val().matches('^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,4}$')\"\n\n```\n\n------\n\n# Operators (*Methods*)\n\n## +\n\n符号\n\n加法\n\n定义\n\n用作变量加法运算或字符串连接。\n\n说明\n\n因为Wilddog路径中keys总是string字符串，所以尝试比较 $variable和一个数字一定会失败。可以通过\"+\"把nubmber转化为string。\n\n```\n\".write\": \"newData.val() == data.val() + 1\"\n\n```\n\n```\n\".validate\": \"root.child('room_names/' + $room_id).exists()\"\n\n```\n\n------\n\n## -\n\n符号\n\n取反 或 减号\n\n定义\n\n取反或剪法运算。\n\n说明\n\nThis validation rule checks that the new value is the inverse of a child value at the Wilddog location: 下面的校验规则用来检查新值是否是某子节点数据的取反。\n\n```\n\".validate\": \"newData.val() == -(data.child('quantity').val())\"\n\n```\n\n下面的校验规则用来保证只有过去十分钟之内的信息才能被读取。\n\n```\n\".read\": \"newData.child('timestamp').val() > (now - 600000)\"\n\n```\n\n------\n\n## *\n\n符号\n\n乘法\n\n定义\n\n取乘积\n\n说明\n\n下面的校验规则用来验证新的值是否等于price和quantity的乘积。\n\n```\n\".validate\": \"newData.val() == data.child('price').val() * data.child('quantity').val()\"\n\n```\n\n------\n\n## /\n\n符号\n\n除法\n\n定义\n\n取商\n\n说明\n\n下面的校验规则保证被存储的值是所有数值的平均值。\n\n```\n\".validate\": \"newData.val() == data.parent().child('sum').val() / data.parent().child('numItems').val()\"\n\n```\n\n------\n\n## %\n\n符号\n\n取模\n\n定义\n\n取模\n\n说明\n\n下面的校验规则保证userId是偶数才具备写权限。\n\n```\n\"$user_id\": {\n    \".write\": \"$user_id % 2 == 0\"\n}\n\n```\n\n------\n\n## ==\n\n符号\n\n等于\n\n定义\n\n用来检验在规则表达式中两个变量是否具有相同值。\n\n说明\n\n下面校验规则保证用户账户的所有者才具备写权限。\n\n```\n\"users\": {\n  \".write\": \"$user_id == auth.uid\"\n}\n\n```\n\n------\n\n## !=\n\n符号\n\n不等于\n\n定义\n\n不等于\n\n说明\n\n```\n\".read\": \"auth != null\"\n\n```\n\n------\n\n## &&\n\n符号\n\n与\n\n定义\n\n与操作\n\n说明\n\n下面的校验规则用来检验新数据是小于100个字符的字符串。\n\n```\n\".validate\": \"newData.isString() && newData.val().length < 100\"\n\n```\n\n------\n\n## ||\n\n符号\n\n或\n\n定义\n\n或操作\n\n说明\n\n下面的校验规则保证我们可以删除或者创建数据，但是不能更新数据。\n\n```\n\".write\": \"!data.exists() || !newData.exists()\"\n\n```\n\n------\n\n## !\n\n符号\n\n非\n\n定义\n\n非操作\n\n说明\n\n在规则表达式中，!常被用来查看数据是否已经被写到节点中。 下面的校验规则规定，只有在指定的节点中没有数据的时候才能写入。\n\n```\n\".write\": \"!data.exists()\"\n\n```\n\n------\n\n## >\n\n符号\n\n大于\n\n定义\n\n大于\n\n说明\n\n下面的校验规则规定写入的数据不能为空。\n\n```\n\".validate\": \"newData.isString() && newData.val().length > 0\"\n\n```\n\n------\n\n## <\n\n符号\n\n小于\n\n定义\n\n小于\n\n说明\n\n下面的校验规则规定数据需要是字符串并且长度小于20。\n\n```\n\".validate\": \"newData.isString() && newData.val().length < 20\"\n\n```\n\n------\n\n## >=\n\n符号\n\n大于或等于\n\n定义\n\n大于或者等于\n\n说明\n\n下面的校验规则规定写入的数据不能为空。\n\n```\n\".validate\": \"newData.isString() && newData.val().length >= 1\"\n\n```\n\n------\n\n## <=\n\n符号\n\n小于或等于\n\n定义\n\n小于或等于\n\n说明\n\n下面的校验规则保证新数据未来不能被添加。\n\n```\n\".validate\": \"newData.val() <= now\"\n\n```\n\n------\n\n## ?\n\n符号\n\n三元表达式\n\n定义\n\n三元表达式\n\n说明\n\n问号前面是条件，条件成立第二个表达式被校验，条件不成立第三个表达式被校验。\n\n下面的校验规则规定，新数据必须是一个数字或者是布尔型值，如果是数字必须大于0。\n\n```\n\".validate\": \"newData.isNumber() ? newData.val() > 0 : newData.isBoolean()\"\n```","source":"api/sync/rule.md","raw":"\ntitle: 规则表达式API 文档\n---\n\n# Rule (*Type*)\n\n## .read\n\n定义\n\n对指定路径赋予读取数据的权限。\n\n说明\n\n读取规则是Wilddog数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的读取规则。例如：\n\n```\n\".read\": \"auth != null && auth.provider == 'weibo'\"\n```\n\n.read 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以读取， 而且它的所有子节点也是可以读取的。值为false 则不能读取数据。\n\n.read对除了newData外的所有Wilddog变量可用。\n\n------\n\n## .write\n\n定义\n\n对指定路径赋予写数据的权限。\n\n说明\n\n写规则是Wilddog 数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的写规则。例如：\n\n.write 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以写， 而且它的所有子节点也是可以写的。值为false 则不能写数据。\n\n.write规则对Wilddog所有的Rule变量可用。\n\n------\n\n## .validate\n\n定义\n\n.write规则获得权限后使用，以确保所写的数据符合特定的模式。\n\n说明\n\n.write 规则获得权限后使用，以确保所写的数据符合特定的模式。除此之外，.write 获得权限后，.validate 规则必须取得验证成功。例如：\n\n```\n\".validate\": \"newData.hasChildren(['name', 'age'])\"\n\n```\n\n.validate 规则的值类型是字符串，这个表达式使用的Javascript语法。\n\n.validate 规则对Wilddog所有的Rule变量可用。\n\n------\n\n## .indexOn\n\n定义\n\n为数据添加索引，提高查询效率。\n\n说明\n\n.indexOn 规则可以为指定的节点建立索引，以此来提高查询效率。例如：\n\n```\n{\n  \"rules\": {\n    \"dinosaurs\": {\n      \".indexOn\": [\"height\", \"length\"]\n    }\n  }\n}\n\n```\n\n.indexOn 规则的值类型是字符串，或者是字符串数组。 节点的名称key和优先级priority默认建立索引，不需要额外设置。 关于 .indexOn 规则更多介绍，请参考规则表达式文档 [数据索引](/guide/sync/rules/guide.html#数据索引) 部分。\n\n------\n\n# Rule (*Variables*)\n\n## auth\n\n定义\n\n这个变量与用户是否使用认证有关。使用认证就是调用auth相关的方法，比如authWithPassword()。 如果客户端已经登录认证，这个变量中包含token信息，否则为null。\n\n说明\n\nWilddog 认证\n\n野狗内置几种认证方式。你可以轻松使用它们来生成tokens。在使用一种认证方式和，auth变量包含以下内容：\n\n| 字段       | 描述                                       |\n| -------- | ---------------------------------------- |\n| provider | 认证提供商 (\"password\", \"anonymous\", \"qq\", \"weibo\", \"weixin\", or \"weixinmp\")。 |\n| uid      | 一个唯一的用户id，保证独一无二。                        |\n\n举一个例子, 有一个博客的评论， 只能修改和删除评论， 我们配置以下规则：\n\n```\n{\n  \"rules\": {\n    \".read\": true,\n    \"$comment\": {\n      \".write\": \"!data.exists() && newData.child('user_id').val() == auth.uid\"\n    }\n  }\n}\n\n```\n\n如果要求只有微博登修改，只需要轻松修改rule配置， 就能搞定。\n\n```\n{\n  \"rules\": {\n    \".read\": true,\n    \"$comment\": {\n      \".write\": \"!data.exists() && auth.provider == 'weibo'\"\n    }\n  }\n}\n\n```\n\n下面java版生成工具依赖\n\n```\n<dependency>\n    <groupId>com.wilddog</groupId>\n    <artifactId>wilddog-token-generator</artifactId>\n    <version>1.0.0</version>\n</dependency>\n\n```\n\n------\n\n## $location\n\n定义\n\n一个可以用来在规则表达式中使用的代表位置的变量。\n\n说明\n\n当你使用$location在你规则表达式，这个变量是以`$`开头，用于替换实际读写子节点的名称。假设我们希望给每个用户读写他们自己的`/users/`的位置，我们可以使用：\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user\": {\n        \".read\": \"auth.uid == $user\",\n        \".write\": \"auth.uid == $user\"\n      }\n    }\n  }\n}\n\n```\n\n当一个用户试图访问`/users/barney`，位置变量$user将匹配到`\"barney\"`。所以.read 规则将判断 `auth.uid == 'barney'`。\n\n------\n\n## now\n\n定义\n\n包含一个在Wilddog服务器的Unix时间秒数。\n\n说明\n\n包含一个在Wilddog服务器的Unix时间秒数。例如:\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user\": {\n        \"created\": {\n          \".validate\": \"newData.val() < now\"\n        }\n      }\n    }\n  }\n}\n\n```\n\n------\n\n## root\n\n定义\n\n你的Wilddog数据库中的根节点的数据快照`RuleDataSnapshot`\n\n说明\n\nroot变量标识的`RuleDataSnapshot`，对应着你的Wilddog数据库根节点。你能够在读任何数据的时候在表达式中使用它。例如：你想允许用户仅在 `/users//active`设置为true的时候读取 `/comments`。我们这样使用：\n\n```\n{\n  \"rules\": {\n    \"comments\": {\n      \".read\": \"root.child('users').child(auth.uid).child('active').val() == true\"\n    }\n  }\n}\n\n```\n\n------\n\n## newData\n\n定义\n\n一个数据快照`RuleDataSnapshot`对应的将要被写的数据。\n\n说明\n\n在.write和.validate规则中使用，newData变量允许代表一个将要被写的`RuleDataSnapshot`，也可能是一个从其他节点移过来的`RuleDataSnapshot`。下面的例子，要求每个用户必须包含name和age字段：\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user\": {\n        \".read\": true,\n        \".write\": true,\n        \".validate\": \"newData.hasChildren(['name', 'age'])\"\n      }\n    }\n  }\n}\n\n```\n\n由于newData合并包括存在的数据和新添加的数据。\n\n```\nvar fredRef = new Wilddog(\"https://samplechat.wilddogio.com/users/fred\");\n// 可行\nfredRef.set({ name: \"Fred\", age: 19 });\n// 可行\nfredRef.child(\"age\").set(27);\n// 因为.validate不再为真，所以不可行\nfredRef.child(\"name\").remove();\nnewData变量在.read规则中不可用，因为没有新数据被写入，只能用data变量。\n\n```\n\n------\n\n# RuleDataSnapshot (*Methods*)\n\n## val()\n\n定义\n\nString val()\n\n说明\n\n从 `RuleDataSnapshot`获取原生类型 (`string`, `number`, `boolean`, or `null`)。与DataSnapshot.val()不一样，`RuleDataSnapshot`调用 `val()`方法将不会返回一个`object`，就算包含子节点也这样。\n\n返回值\n\nString, Number, Boolean, Null RuleDataSnapshot 的原生类型数据。\n\n示例\n\n```\n\".read\": \"data.child('isReadable').val() == true\"\n\n```\n\n------\n\n## child()\n\n定义\n\nRuleDataSnapshot child()\n\n说明\n\n通过相对路径获取`RuleDataSnapshot`的子节点。\n\n参数\n\n- childPath `String` 子节点的相对路径。\n\n返回值\n\n子节点的 `RuleDataSnapshot`\n\n示例\n\n```\n\".read\": \"data.child('isReadable').val() == true\"\n\n```\n\n------\n\n## parent()\n\n定义\n\nRuleDataSnapshot parent()\n\n说明\n\n通过相对路径获取`RuleDataSnapshot`的父节点。\n\n返回值\n\n父节点的 `RuleDataSnapshot`.\n\n------\n\n## hasChild()\n\n定义\n\nBoolean hasChild(String childPath)\n\n说明\n\n判断`RuleDataSnapshot` 是否存在子节点。\n\n参数\n\nchildPath `String` 潜在子节点的相对路径。\n\n返回值\n\nBoolean 存在返回`true`，否则`false`\n\n示例\n\n```\n\".validate\": \"newData.hasChild('name')\"\n\n```\n\n------\n\n## hasChildren()\n\n定义\n\nBoolean hasChildren([children]);\n\n说明\n\n判断当前节点是否存在指定一组子节点。\n\n参数\n\nchildren `Array` *optional 所有存在子节点的数组。\n\n返回值\n\nBoolean\n\npathList List 路径数组 一组子节点路径，例如['a','b','c']\n\n示例\n\n```\n\".validate\": \"newData.hasChildren()\"\n\n```\n\n```\n\".validate\": \"newData.hasChildren(['name', 'age'])\"\n\n```\n\n------\n\n## exists()\n\n定义\n\nBoolean exists()\n\n说明\n\n判断这个`RuleDataSnapshot`是否存在，包含数据返回true。等价于`data.val() != null`\n\n返回值\n\nBoolean 包含返回`true`，否则返回`false`。\n\n示例\n\n```\n\".write\": \"!data.exists()\"\n\n```\n\n------\n\n## getPriority()\n\n定义\n\nString getPriority()\n\n说明\n\n获取`RuleDataSnapshot`的优先级。\n\n返回值\n\nString, Number, Null\n\n示例\n\n```\n\".validate\": \"newData.getPriority() != null\"\n\n```\n\n------\n\n## isNumber()\n\n定义\n\nBoolean isNumber()\n\n说明\n\n判断获取`RuleDataSnapshot`的是否是数字类型。\n\n返回值\n\nBoolean 是数字为`true` 否则返回 `false`.\n\n示例\n\n```\n\".validate\": \"newData.child('age').isNumber()\"\n\n```\n\n------\n\n## isString()\n\n定义\n\nBoolean isString()\n\n说明\n\n判断获取`RuleDataSnapshot`的是否是字符串类型。\n\n返回值\n\nBoolean 是字符串为`true` 否则返回 `false`.\n\n示例\n\n```\n\".validate\": \"newData.child('name').isString()\n\n```\n\n------\n\n## isBoolean()\n\n定义\n\nBoolean isBoolean()\n\n说明\n\n判断获取`RuleDataSnapshot`的是否是布尔类型。\n\n返回值\n\nBoolean 是布尔为`true` 否则返回 `false`.\n\n示例\n\n```\n\".validate\": \"newData.child('active').isBoolean()\"\n\n```\n\n------\n\n# String (*Methods*)\n\n## length()\n\n定义\n\n字符串的长度。\n\n说明\n\n返回字符串的长度。\n\n返回值\n\nNumber\n\n示例\n\n```\n\".validate\": \"newData.isString() && newData.val().length() >= 10\"\n\n```\n\n------\n\n## contains()\n\n定义\n\nBoolean contains(String substring)\n\n说明\n\n判断字符串是否包含指定的子串。\n\n参数\n\n- substring `String` 指定的子串。\n\n返回值\n\nBoolean\n\n示例\n\n```\n\".validate\": \"newData.isString() && newData.val().contains('@')\"\n\n```\n\n------\n\n## beginsWith()\n\n定义\n\nBoolean beginsWith(String substring)\n\n说明\n\n以一个子串开头。\n\n参数\n\n- substring `String`\n\n返回值\n\nBoolean\n\n示例\n\n------\n\n## endsWith()\n\n定义\n\nBoolean endsWith(String substring)\n\n说明\n\n以一个子串开头结尾。\n\n参数\n\n- substring `String`\n\n返回值\n\nBoolean\n\n示例\n\n------\n\n## replace()\n\n定义\n\nString replace(String substring, String replacement)\n\n说明\n\n我们的replace()方法与JavaScript中的replace()方法稍微有些不同。我们的replace是用replacement替换掉所有的substring，而JavaScript中只是替换掉第一个。因为key中不能包含句号“.”,我们应该对特殊字符进行escape编码后，才能存储它们。\n\n参数\n\n- substring `String` 查找的子字符串。\n- replacement `String` 替换的子字符串。\n\n返回值\n\nString 返回替换后的新字符串。\n\n示例\n\n假设我们在`/whitelist/` 节点有一个email白名单列表：\n\n```\n{\n \"user\": {\n   \"$uid\": {\n     \"email\": <email>\n   }\n },\n \"whitelist\": {\n   \"fred@gmail%2Ecom\": true,\n   \"barney@aol%2Ecom\": true\n }\n}\n\n```\n\n我们可以如下制定rule规则，只允许email在白名单中的用户。\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".read\": \"true\",\n        \".write\": \"root.child('whitelist').child(newData.child('email').val().replace('.', '%2E')).exists()\"\n      }\n    }\n  }\n}\n\n```\n\n------\n\n## toLowerCase()\n\n定义\n\nString toLowerCase()\n\n说明\n\n返回小写的字符串\n\n返回值\n\n小写字符串。\n\n示例\n\n------\n\n## toUpperCase()\n\n定义\n\nString toUpperCase()\n\n说明\n\n返回大写的字符串。\n\n返回值\n\n`string` 大写的字符串。\n\n示例\n\n------\n\n## matches()\n\n定义\n\nBoolean matches(String regex)\n\n说明\n\n可以利用正则表达式校验客户端提供的字符串。用string.matches(pattern)来验证指定字符串是否符合规则表达式。我们的正则表达式的语法与传统规则表达式不完全一致：\n\n`+` `*` `.` `( )` `[ ]` `{ }` `\\` 与传统语法一致\n\n`^` and `$`只被用来匹配首尾\n\n只支持 `i` (忽略大小写) 修饰符\n\n正则表达式以/pattern/的形式被引入规则表达式。被用来检验一个字符串是否符合正则表达式。下面的校验规则用来检验新的字符串是否以'foo'开头。\n\n```\n\".validate\": 'newData.val().matches(\"^foo\")'\n\n```\n\nWilddog只支持一部分正则表达式的功能，不过，工程师们应该对正则表达式语法很熟悉。 下面是所支持的正则符号：\n\n| 字符                | 描述                                       |\n| ----------------- | ---------------------------------------- |\n| \\s \\w \\d \\S \\W \\D | 匹配任何空白字符，包括空格、制表符、换页符；匹配任何字类字符；数字字符匹配；匹配任何非空白字符；与任何非单词字符匹配；非数字字符匹配。 |\n|                  | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符              |\n| ^                 | 匹配输入字符串开始的位置                             |\n| $                 | 匹配输入字符串结尾的位置                             |\n| *                 | 零次或多次匹配前面的字符或子表达式                        |\n| +                 | 一次或多次匹配前面的字符或子表达式                        |\n| ?                 | 零次或一次匹配前面的字符或子表达式                        |\n| .                 | 匹配除“\\n”之外的任何单个字符                         |\n| i                 | 一个以'i'结尾的正则表达式表示忽略大小写                    |\n| (pattern)         | 匹配 pattern 并捕获该匹配的子表达式                   |\n| a\\|b              | 匹配 a 或 b                                 |\n| [akz]             | 字符集，匹配包含的任一字符。/[ABCDEF]/匹配a-f中的大写字母      |\n| [a-z]             | 一个字符区间, 匹配包含在指定范围内的所有字母。/[0-9A-F]/匹配十六进制字符串 |\n| [^0-9]            | 以'^'开头，匹配不在指定字符集中的字符                     |\n\n在Wilddog安全规则中,正则表达式既不是贪婪的也不是非贪婪的，因为，它只允许你用来进行匹配而不是获取字符串。\n\n参数\n\n- regex `String` 正则表达式\n\n返回值\n\nBoolean 如果满足正则表达式返回true,否则返回false。\n\n示例\n\n新数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式。\n\n```\n\".validate\": \"newData.isString() && newData.val().matches('^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$')\"\n\n```\n\n校验新数据符合email格式。\n\n```\n\".validate\": \"newData.isString() && newData.val().matches('^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,4}$')\"\n\n```\n\n------\n\n# Operators (*Methods*)\n\n## +\n\n符号\n\n加法\n\n定义\n\n用作变量加法运算或字符串连接。\n\n说明\n\n因为Wilddog路径中keys总是string字符串，所以尝试比较 $variable和一个数字一定会失败。可以通过\"+\"把nubmber转化为string。\n\n```\n\".write\": \"newData.val() == data.val() + 1\"\n\n```\n\n```\n\".validate\": \"root.child('room_names/' + $room_id).exists()\"\n\n```\n\n------\n\n## -\n\n符号\n\n取反 或 减号\n\n定义\n\n取反或剪法运算。\n\n说明\n\nThis validation rule checks that the new value is the inverse of a child value at the Wilddog location: 下面的校验规则用来检查新值是否是某子节点数据的取反。\n\n```\n\".validate\": \"newData.val() == -(data.child('quantity').val())\"\n\n```\n\n下面的校验规则用来保证只有过去十分钟之内的信息才能被读取。\n\n```\n\".read\": \"newData.child('timestamp').val() > (now - 600000)\"\n\n```\n\n------\n\n## *\n\n符号\n\n乘法\n\n定义\n\n取乘积\n\n说明\n\n下面的校验规则用来验证新的值是否等于price和quantity的乘积。\n\n```\n\".validate\": \"newData.val() == data.child('price').val() * data.child('quantity').val()\"\n\n```\n\n------\n\n## /\n\n符号\n\n除法\n\n定义\n\n取商\n\n说明\n\n下面的校验规则保证被存储的值是所有数值的平均值。\n\n```\n\".validate\": \"newData.val() == data.parent().child('sum').val() / data.parent().child('numItems').val()\"\n\n```\n\n------\n\n## %\n\n符号\n\n取模\n\n定义\n\n取模\n\n说明\n\n下面的校验规则保证userId是偶数才具备写权限。\n\n```\n\"$user_id\": {\n    \".write\": \"$user_id % 2 == 0\"\n}\n\n```\n\n------\n\n## ==\n\n符号\n\n等于\n\n定义\n\n用来检验在规则表达式中两个变量是否具有相同值。\n\n说明\n\n下面校验规则保证用户账户的所有者才具备写权限。\n\n```\n\"users\": {\n  \".write\": \"$user_id == auth.uid\"\n}\n\n```\n\n------\n\n## !=\n\n符号\n\n不等于\n\n定义\n\n不等于\n\n说明\n\n```\n\".read\": \"auth != null\"\n\n```\n\n------\n\n## &&\n\n符号\n\n与\n\n定义\n\n与操作\n\n说明\n\n下面的校验规则用来检验新数据是小于100个字符的字符串。\n\n```\n\".validate\": \"newData.isString() && newData.val().length < 100\"\n\n```\n\n------\n\n## ||\n\n符号\n\n或\n\n定义\n\n或操作\n\n说明\n\n下面的校验规则保证我们可以删除或者创建数据，但是不能更新数据。\n\n```\n\".write\": \"!data.exists() || !newData.exists()\"\n\n```\n\n------\n\n## !\n\n符号\n\n非\n\n定义\n\n非操作\n\n说明\n\n在规则表达式中，!常被用来查看数据是否已经被写到节点中。 下面的校验规则规定，只有在指定的节点中没有数据的时候才能写入。\n\n```\n\".write\": \"!data.exists()\"\n\n```\n\n------\n\n## >\n\n符号\n\n大于\n\n定义\n\n大于\n\n说明\n\n下面的校验规则规定写入的数据不能为空。\n\n```\n\".validate\": \"newData.isString() && newData.val().length > 0\"\n\n```\n\n------\n\n## <\n\n符号\n\n小于\n\n定义\n\n小于\n\n说明\n\n下面的校验规则规定数据需要是字符串并且长度小于20。\n\n```\n\".validate\": \"newData.isString() && newData.val().length < 20\"\n\n```\n\n------\n\n## >=\n\n符号\n\n大于或等于\n\n定义\n\n大于或者等于\n\n说明\n\n下面的校验规则规定写入的数据不能为空。\n\n```\n\".validate\": \"newData.isString() && newData.val().length >= 1\"\n\n```\n\n------\n\n## <=\n\n符号\n\n小于或等于\n\n定义\n\n小于或等于\n\n说明\n\n下面的校验规则保证新数据未来不能被添加。\n\n```\n\".validate\": \"newData.val() <= now\"\n\n```\n\n------\n\n## ?\n\n符号\n\n三元表达式\n\n定义\n\n三元表达式\n\n说明\n\n问号前面是条件，条件成立第二个表达式被校验，条件不成立第三个表达式被校验。\n\n下面的校验规则规定，新数据必须是一个数字或者是布尔型值，如果是数字必须大于0。\n\n```\n\".validate\": \"newData.isNumber() ? newData.val() > 0 : newData.isBoolean()\"\n```","date":"2016-09-06T03:38:22.517Z","updated":"2016-09-06T03:38:22.517Z","path":"api/sync/rule.html","comments":1,"layout":"page","_id":"cisswi9j3000ez4fw4onzp93a","content":"<h1 id=\"Rule-Type\"><a href=\"#Rule-Type\" class=\"headerlink\" title=\"Rule (Type)\"></a>Rule (<em>Type</em>)</h1><h2 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\".read\"></a>.read</h2><p>定义</p>\n<p>对指定路径赋予读取数据的权限。</p>\n<p>说明</p>\n<p>读取规则是Wilddog数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的读取规则。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;auth != null &amp;&amp; auth.provider == &apos;weibo&apos;&quot;</div></pre></td></tr></table></figure>\n<p>.read 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以读取， 而且它的所有子节点也是可以读取的。值为false 则不能读取数据。</p>\n<p>.read对除了newData外的所有Wilddog变量可用。</p>\n<hr>\n<h2 id=\"write\"><a href=\"#write\" class=\"headerlink\" title=\".write\"></a>.write</h2><p>定义</p>\n<p>对指定路径赋予写数据的权限。</p>\n<p>说明</p>\n<p>写规则是Wilddog 数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的写规则。例如：</p>\n<p>.write 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以写， 而且它的所有子节点也是可以写的。值为false 则不能写数据。</p>\n<p>.write规则对Wilddog所有的Rule变量可用。</p>\n<hr>\n<h2 id=\"validate\"><a href=\"#validate\" class=\"headerlink\" title=\".validate\"></a>.validate</h2><p>定义</p>\n<p>.write规则获得权限后使用，以确保所写的数据符合特定的模式。</p>\n<p>说明</p>\n<p>.write 规则获得权限后使用，以确保所写的数据符合特定的模式。除此之外，.write 获得权限后，.validate 规则必须取得验证成功。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChildren([&apos;name&apos;, &apos;age&apos;])&quot;</div></pre></td></tr></table></figure>\n<p>.validate 规则的值类型是字符串，这个表达式使用的Javascript语法。</p>\n<p>.validate 规则对Wilddog所有的Rule变量可用。</p>\n<hr>\n<h2 id=\"indexOn\"><a href=\"#indexOn\" class=\"headerlink\" title=\".indexOn\"></a>.indexOn</h2><p>定义</p>\n<p>为数据添加索引，提高查询效率。</p>\n<p>说明</p>\n<p>.indexOn 规则可以为指定的节点建立索引，以此来提高查询效率。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;dinosaurs&quot;: &#123;</div><div class=\"line\">      &quot;.indexOn&quot;: [&quot;height&quot;, &quot;length&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.indexOn 规则的值类型是字符串，或者是字符串数组。 节点的名称key和优先级priority默认建立索引，不需要额外设置。 关于 .indexOn 规则更多介绍，请参考规则表达式文档 <a href=\"/guide/sync/rules/guide.html#数据索引\">数据索引</a> 部分。</p>\n<hr>\n<h1 id=\"Rule-Variables\"><a href=\"#Rule-Variables\" class=\"headerlink\" title=\"Rule (Variables)\"></a>Rule (<em>Variables</em>)</h1><h2 id=\"auth\"><a href=\"#auth\" class=\"headerlink\" title=\"auth\"></a>auth</h2><p>定义</p>\n<p>这个变量与用户是否使用认证有关。使用认证就是调用auth相关的方法，比如authWithPassword()。 如果客户端已经登录认证，这个变量中包含token信息，否则为null。</p>\n<p>说明</p>\n<p>Wilddog 认证</p>\n<p>野狗内置几种认证方式。你可以轻松使用它们来生成tokens。在使用一种认证方式和，auth变量包含以下内容：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>provider</td>\n<td>认证提供商 (“password”, “anonymous”, “qq”, “weibo”, “weixin”, or “weixinmp”)。</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>一个唯一的用户id，保证独一无二。</td>\n</tr>\n</tbody>\n</table>\n<p>举一个例子, 有一个博客的评论， 只能修改和删除评论， 我们配置以下规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;.read&quot;: true,</div><div class=\"line\">    &quot;$comment&quot;: &#123;</div><div class=\"line\">      &quot;.write&quot;: &quot;!data.exists() &amp;&amp; newData.child(&apos;user_id&apos;).val() == auth.uid&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果要求只有微博登修改，只需要轻松修改rule配置， 就能搞定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;.read&quot;: true,</div><div class=\"line\">    &quot;$comment&quot;: &#123;</div><div class=\"line\">      &quot;.write&quot;: &quot;!data.exists() &amp;&amp; auth.provider == &apos;weibo&apos;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面java版生成工具依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.wilddog&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;wilddog-token-generator&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.0.0&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"$location\"></a>$location</h2><p>定义</p>\n<p>一个可以用来在规则表达式中使用的代表位置的变量。</p>\n<p>说明</p>\n<p>当你使用$location在你规则表达式，这个变量是以<code>$</code>开头，用于替换实际读写子节点的名称。假设我们希望给每个用户读写他们自己的<code>/users/</code>的位置，我们可以使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user&quot;: &#123;</div><div class=\"line\">        &quot;.read&quot;: &quot;auth.uid == $user&quot;,</div><div class=\"line\">        &quot;.write&quot;: &quot;auth.uid == $user&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当一个用户试图访问<code>/users/barney</code>，位置变量$user将匹配到<code>&quot;barney&quot;</code>。所以.read 规则将判断 <code>auth.uid == &#39;barney&#39;</code>。</p>\n<hr>\n<h2 id=\"now\"><a href=\"#now\" class=\"headerlink\" title=\"now\"></a>now</h2><p>定义</p>\n<p>包含一个在Wilddog服务器的Unix时间秒数。</p>\n<p>说明</p>\n<p>包含一个在Wilddog服务器的Unix时间秒数。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user&quot;: &#123;</div><div class=\"line\">        &quot;created&quot;: &#123;</div><div class=\"line\">          &quot;.validate&quot;: &quot;newData.val() &lt; now&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"root\"></a>root</h2><p>定义</p>\n<p>你的Wilddog数据库中的根节点的数据快照<code>RuleDataSnapshot</code></p>\n<p>说明</p>\n<p>root变量标识的<code>RuleDataSnapshot</code>，对应着你的Wilddog数据库根节点。你能够在读任何数据的时候在表达式中使用它。例如：你想允许用户仅在 <code>/users//active</code>设置为true的时候读取 <code>/comments</code>。我们这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;comments&quot;: &#123;</div><div class=\"line\">      &quot;.read&quot;: &quot;root.child(&apos;users&apos;).child(auth.uid).child(&apos;active&apos;).val() == true&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"newData\"><a href=\"#newData\" class=\"headerlink\" title=\"newData\"></a>newData</h2><p>定义</p>\n<p>一个数据快照<code>RuleDataSnapshot</code>对应的将要被写的数据。</p>\n<p>说明</p>\n<p>在.write和.validate规则中使用，newData变量允许代表一个将要被写的<code>RuleDataSnapshot</code>，也可能是一个从其他节点移过来的<code>RuleDataSnapshot</code>。下面的例子，要求每个用户必须包含name和age字段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user&quot;: &#123;</div><div class=\"line\">        &quot;.read&quot;: true,</div><div class=\"line\">        &quot;.write&quot;: true,</div><div class=\"line\">        &quot;.validate&quot;: &quot;newData.hasChildren([&apos;name&apos;, &apos;age&apos;])&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于newData合并包括存在的数据和新添加的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var fredRef = new Wilddog(&quot;https://samplechat.wilddogio.com/users/fred&quot;);</div><div class=\"line\">// 可行</div><div class=\"line\">fredRef.set(&#123; name: &quot;Fred&quot;, age: 19 &#125;);</div><div class=\"line\">// 可行</div><div class=\"line\">fredRef.child(&quot;age&quot;).set(27);</div><div class=\"line\">// 因为.validate不再为真，所以不可行</div><div class=\"line\">fredRef.child(&quot;name&quot;).remove();</div><div class=\"line\">newData变量在.read规则中不可用，因为没有新数据被写入，只能用data变量。</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"RuleDataSnapshot-Methods\"><a href=\"#RuleDataSnapshot-Methods\" class=\"headerlink\" title=\"RuleDataSnapshot (Methods)\"></a>RuleDataSnapshot (<em>Methods</em>)</h1><h2 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val()\"></a>val()</h2><p>定义</p>\n<p>String val()</p>\n<p>说明</p>\n<p>从 <code>RuleDataSnapshot</code>获取原生类型 (<code>string</code>, <code>number</code>, <code>boolean</code>, or <code>null</code>)。与DataSnapshot.val()不一样，<code>RuleDataSnapshot</code>调用 <code>val()</code>方法将不会返回一个<code>object</code>，就算包含子节点也这样。</p>\n<p>返回值</p>\n<p>String, Number, Boolean, Null RuleDataSnapshot 的原生类型数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;data.child(&apos;isReadable&apos;).val() == true&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义</p>\n<p>RuleDataSnapshot child()</p>\n<p>说明</p>\n<p>通过相对路径获取<code>RuleDataSnapshot</code>的子节点。</p>\n<p>参数</p>\n<ul>\n<li>childPath <code>String</code> 子节点的相对路径。</li>\n</ul>\n<p>返回值</p>\n<p>子节点的 <code>RuleDataSnapshot</code></p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;data.child(&apos;isReadable&apos;).val() == true&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent()\"></a>parent()</h2><p>定义</p>\n<p>RuleDataSnapshot parent()</p>\n<p>说明</p>\n<p>通过相对路径获取<code>RuleDataSnapshot</code>的父节点。</p>\n<p>返回值</p>\n<p>父节点的 <code>RuleDataSnapshot</code>.</p>\n<hr>\n<h2 id=\"hasChild\"><a href=\"#hasChild\" class=\"headerlink\" title=\"hasChild()\"></a>hasChild()</h2><p>定义</p>\n<p>Boolean hasChild(String childPath)</p>\n<p>说明</p>\n<p>判断<code>RuleDataSnapshot</code> 是否存在子节点。</p>\n<p>参数</p>\n<p>childPath <code>String</code> 潜在子节点的相对路径。</p>\n<p>返回值</p>\n<p>Boolean 存在返回<code>true</code>，否则<code>false</code></p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChild(&apos;name&apos;)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"hasChildren\"><a href=\"#hasChildren\" class=\"headerlink\" title=\"hasChildren()\"></a>hasChildren()</h2><p>定义</p>\n<p>Boolean hasChildren([children]);</p>\n<p>说明</p>\n<p>判断当前节点是否存在指定一组子节点。</p>\n<p>参数</p>\n<p>children <code>Array</code> *optional 所有存在子节点的数组。</p>\n<p>返回值</p>\n<p>Boolean</p>\n<p>pathList List 路径数组 一组子节点路径，例如[‘a’,’b’,’c’]</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChildren()&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChildren([&apos;name&apos;, &apos;age&apos;])&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"exists\"><a href=\"#exists\" class=\"headerlink\" title=\"exists()\"></a>exists()</h2><p>定义</p>\n<p>Boolean exists()</p>\n<p>说明</p>\n<p>判断这个<code>RuleDataSnapshot</code>是否存在，包含数据返回true。等价于<code>data.val() != null</code></p>\n<p>返回值</p>\n<p>Boolean 包含返回<code>true</code>，否则返回<code>false</code>。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;!data.exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"getPriority\"><a href=\"#getPriority\" class=\"headerlink\" title=\"getPriority()\"></a>getPriority()</h2><p>定义</p>\n<p>String getPriority()</p>\n<p>说明</p>\n<p>获取<code>RuleDataSnapshot</code>的优先级。</p>\n<p>返回值</p>\n<p>String, Number, Null</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.getPriority() != null&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"isNumber\"><a href=\"#isNumber\" class=\"headerlink\" title=\"isNumber()\"></a>isNumber()</h2><p>定义</p>\n<p>Boolean isNumber()</p>\n<p>说明</p>\n<p>判断获取<code>RuleDataSnapshot</code>的是否是数字类型。</p>\n<p>返回值</p>\n<p>Boolean 是数字为<code>true</code> 否则返回 <code>false</code>.</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.child(&apos;age&apos;).isNumber()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"isString\"><a href=\"#isString\" class=\"headerlink\" title=\"isString()\"></a>isString()</h2><p>定义</p>\n<p>Boolean isString()</p>\n<p>说明</p>\n<p>判断获取<code>RuleDataSnapshot</code>的是否是字符串类型。</p>\n<p>返回值</p>\n<p>Boolean 是字符串为<code>true</code> 否则返回 <code>false</code>.</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.child(&apos;name&apos;).isString()</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"isBoolean\"><a href=\"#isBoolean\" class=\"headerlink\" title=\"isBoolean()\"></a>isBoolean()</h2><p>定义</p>\n<p>Boolean isBoolean()</p>\n<p>说明</p>\n<p>判断获取<code>RuleDataSnapshot</code>的是否是布尔类型。</p>\n<p>返回值</p>\n<p>Boolean 是布尔为<code>true</code> 否则返回 <code>false</code>.</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.child(&apos;active&apos;).isBoolean()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"String-Methods\"><a href=\"#String-Methods\" class=\"headerlink\" title=\"String (Methods)\"></a>String (<em>Methods</em>)</h1><h2 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length()\"></a>length()</h2><p>定义</p>\n<p>字符串的长度。</p>\n<p>说明</p>\n<p>返回字符串的长度。</p>\n<p>返回值</p>\n<p>Number</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length() &gt;= 10&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"contains\"><a href=\"#contains\" class=\"headerlink\" title=\"contains()\"></a>contains()</h2><p>定义</p>\n<p>Boolean contains(String substring)</p>\n<p>说明</p>\n<p>判断字符串是否包含指定的子串。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code> 指定的子串。</li>\n</ul>\n<p>返回值</p>\n<p>Boolean</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().contains(&apos;@&apos;)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"beginsWith\"><a href=\"#beginsWith\" class=\"headerlink\" title=\"beginsWith()\"></a>beginsWith()</h2><p>定义</p>\n<p>Boolean beginsWith(String substring)</p>\n<p>说明</p>\n<p>以一个子串开头。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code></li>\n</ul>\n<p>返回值</p>\n<p>Boolean</p>\n<p>示例</p>\n<hr>\n<h2 id=\"endsWith\"><a href=\"#endsWith\" class=\"headerlink\" title=\"endsWith()\"></a>endsWith()</h2><p>定义</p>\n<p>Boolean endsWith(String substring)</p>\n<p>说明</p>\n<p>以一个子串开头结尾。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code></li>\n</ul>\n<p>返回值</p>\n<p>Boolean</p>\n<p>示例</p>\n<hr>\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h2><p>定义</p>\n<p>String replace(String substring, String replacement)</p>\n<p>说明</p>\n<p>我们的replace()方法与JavaScript中的replace()方法稍微有些不同。我们的replace是用replacement替换掉所有的substring，而JavaScript中只是替换掉第一个。因为key中不能包含句号“.”,我们应该对特殊字符进行escape编码后，才能存储它们。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code> 查找的子字符串。</li>\n<li>replacement <code>String</code> 替换的子字符串。</li>\n</ul>\n<p>返回值</p>\n<p>String 返回替换后的新字符串。</p>\n<p>示例</p>\n<p>假设我们在<code>/whitelist/</code> 节点有一个email白名单列表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"> &quot;user&quot;: &#123;</div><div class=\"line\">   &quot;$uid&quot;: &#123;</div><div class=\"line\">     &quot;email&quot;: &lt;email&gt;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;,</div><div class=\"line\"> &quot;whitelist&quot;: &#123;</div><div class=\"line\">   &quot;fred@gmail%2Ecom&quot;: true,</div><div class=\"line\">   &quot;barney@aol%2Ecom&quot;: true</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以如下制定rule规则，只允许email在白名单中的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$uid&quot;: &#123;</div><div class=\"line\">        &quot;.read&quot;: &quot;true&quot;,</div><div class=\"line\">        &quot;.write&quot;: &quot;root.child(&apos;whitelist&apos;).child(newData.child(&apos;email&apos;).val().replace(&apos;.&apos;, &apos;%2E&apos;)).exists()&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"toLowerCase\"><a href=\"#toLowerCase\" class=\"headerlink\" title=\"toLowerCase()\"></a>toLowerCase()</h2><p>定义</p>\n<p>String toLowerCase()</p>\n<p>说明</p>\n<p>返回小写的字符串</p>\n<p>返回值</p>\n<p>小写字符串。</p>\n<p>示例</p>\n<hr>\n<h2 id=\"toUpperCase\"><a href=\"#toUpperCase\" class=\"headerlink\" title=\"toUpperCase()\"></a>toUpperCase()</h2><p>定义</p>\n<p>String toUpperCase()</p>\n<p>说明</p>\n<p>返回大写的字符串。</p>\n<p>返回值</p>\n<p><code>string</code> 大写的字符串。</p>\n<p>示例</p>\n<hr>\n<h2 id=\"matches\"><a href=\"#matches\" class=\"headerlink\" title=\"matches()\"></a>matches()</h2><p>定义</p>\n<p>Boolean matches(String regex)</p>\n<p>说明</p>\n<p>可以利用正则表达式校验客户端提供的字符串。用string.matches(pattern)来验证指定字符串是否符合规则表达式。我们的正则表达式的语法与传统规则表达式不完全一致：</p>\n<p><code>+</code> <code>*</code> <code>.</code> <code>( )</code> <code>[ ]</code> <code>{ }</code> <code>\\</code> 与传统语法一致</p>\n<p><code>^</code> and <code>$</code>只被用来匹配首尾</p>\n<p>只支持 <code>i</code> (忽略大小写) 修饰符</p>\n<p>正则表达式以/pattern/的形式被引入规则表达式。被用来检验一个字符串是否符合正则表达式。下面的校验规则用来检验新的字符串是否以’foo’开头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &apos;newData.val().matches(&quot;^foo&quot;)&apos;</div></pre></td></tr></table></figure>\n<p>Wilddog只支持一部分正则表达式的功能，不过，工程师们应该对正则表达式语法很熟悉。 下面是所支持的正则符号：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\s \\w \\d \\S \\W \\D</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符；匹配任何字类字符；数字字符匹配；匹配任何非空白字符；与任何非单词字符匹配；非数字字符匹配。</td>\n</tr>\n<tr>\n<td></td>\n<td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串开始的位置</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入字符串结尾的位置</td>\n</tr>\n<tr>\n<td>*</td>\n<td>零次或多次匹配前面的字符或子表达式</td>\n</tr>\n<tr>\n<td>+</td>\n<td>一次或多次匹配前面的字符或子表达式</td>\n</tr>\n<tr>\n<td>?</td>\n<td>零次或一次匹配前面的字符或子表达式</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除“\\n”之外的任何单个字符</td>\n</tr>\n<tr>\n<td>i</td>\n<td>一个以’i’结尾的正则表达式表示忽略大小写</td>\n</tr>\n<tr>\n<td>(pattern)</td>\n<td>匹配 pattern 并捕获该匹配的子表达式</td>\n</tr>\n<tr>\n<td>a\\</td>\n<td>b</td>\n<td>匹配 a 或 b</td>\n</tr>\n<tr>\n<td>[akz]</td>\n<td>字符集，匹配包含的任一字符。/[ABCDEF]/匹配a-f中的大写字母</td>\n</tr>\n<tr>\n<td>[a-z]</td>\n<td>一个字符区间, 匹配包含在指定范围内的所有字母。/[0-9A-F]/匹配十六进制字符串</td>\n</tr>\n<tr>\n<td>[^0-9]</td>\n<td>以’^’开头，匹配不在指定字符集中的字符</td>\n</tr>\n</tbody>\n</table>\n<p>在Wilddog安全规则中,正则表达式既不是贪婪的也不是非贪婪的，因为，它只允许你用来进行匹配而不是获取字符串。</p>\n<p>参数</p>\n<ul>\n<li>regex <code>String</code> 正则表达式</li>\n</ul>\n<p>返回值</p>\n<p>Boolean 如果满足正则表达式返回true,否则返回false。</p>\n<p>示例</p>\n<p>新数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().matches(&apos;^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$&apos;)&quot;</div></pre></td></tr></table></figure>\n<p>校验新数据符合email格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().matches(&apos;^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]&#123;2,4&#125;$&apos;)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Operators-Methods\"><a href=\"#Operators-Methods\" class=\"headerlink\" title=\"Operators (Methods)\"></a>Operators (<em>Methods</em>)</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"+\"></a>+</h2><p>符号</p>\n<p>加法</p>\n<p>定义</p>\n<p>用作变量加法运算或字符串连接。</p>\n<p>说明</p>\n<p>因为Wilddog路径中keys总是string字符串，所以尝试比较 $variable和一个数字一定会失败。可以通过”+”把nubmber转化为string。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;newData.val() == data.val() + 1&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;root.child(&apos;room_names/&apos; + $room_id).exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"-\"></a>-</h2><p>符号</p>\n<p>取反 或 减号</p>\n<p>定义</p>\n<p>取反或剪法运算。</p>\n<p>说明</p>\n<p>This validation rule checks that the new value is the inverse of a child value at the Wilddog location: 下面的校验规则用来检查新值是否是某子节点数据的取反。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() == -(data.child(&apos;quantity&apos;).val())&quot;</div></pre></td></tr></table></figure>\n<p>下面的校验规则用来保证只有过去十分钟之内的信息才能被读取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;newData.child(&apos;timestamp&apos;).val() &gt; (now - 600000)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"*\"></a>*</h2><p>符号</p>\n<p>乘法</p>\n<p>定义</p>\n<p>取乘积</p>\n<p>说明</p>\n<p>下面的校验规则用来验证新的值是否等于price和quantity的乘积。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() == data.child(&apos;price&apos;).val() * data.child(&apos;quantity&apos;).val()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"/\"></a>/</h2><p>符号</p>\n<p>除法</p>\n<p>定义</p>\n<p>取商</p>\n<p>说明</p>\n<p>下面的校验规则保证被存储的值是所有数值的平均值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() == data.parent().child(&apos;sum&apos;).val() / data.parent().child(&apos;numItems&apos;).val()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"%\"></a>%</h2><p>符号</p>\n<p>取模</p>\n<p>定义</p>\n<p>取模</p>\n<p>说明</p>\n<p>下面的校验规则保证userId是偶数才具备写权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;$user_id&quot;: &#123;</div><div class=\"line\">    &quot;.write&quot;: &quot;$user_id % 2 == 0&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"==\"></a>==</h2><p>符号</p>\n<p>等于</p>\n<p>定义</p>\n<p>用来检验在规则表达式中两个变量是否具有相同值。</p>\n<p>说明</p>\n<p>下面校验规则保证用户账户的所有者才具备写权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;users&quot;: &#123;</div><div class=\"line\">  &quot;.write&quot;: &quot;$user_id == auth.uid&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"!=\"></a>!=</h2><p>符号</p>\n<p>不等于</p>\n<p>定义</p>\n<p>不等于</p>\n<p>说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;auth != null&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"amp-amp\"><a href=\"#amp-amp\" class=\"headerlink\" title=\"&amp;&amp;\"></a>&amp;&amp;</h2><p>符号</p>\n<p>与</p>\n<p>定义</p>\n<p>与操作</p>\n<p>说明</p>\n<p>下面的校验规则用来检验新数据是小于100个字符的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &lt; 100&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"||\"></a>||</h2><p>符号</p>\n<p>或</p>\n<p>定义</p>\n<p>或操作</p>\n<p>说明</p>\n<p>下面的校验规则保证我们可以删除或者创建数据，但是不能更新数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;!data.exists() || !newData.exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-8\"><a href=\"#-8\" class=\"headerlink\" title=\"!\"></a>!</h2><p>符号</p>\n<p>非</p>\n<p>定义</p>\n<p>非操作</p>\n<p>说明</p>\n<p>在规则表达式中，!常被用来查看数据是否已经被写到节点中。 下面的校验规则规定，只有在指定的节点中没有数据的时候才能写入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;!data.exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"gt\"><a href=\"#gt\" class=\"headerlink\" title=\"&gt;\"></a>&gt;</h2><p>符号</p>\n<p>大于</p>\n<p>定义</p>\n<p>大于</p>\n<p>说明</p>\n<p>下面的校验规则规定写入的数据不能为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &gt; 0&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"lt\"><a href=\"#lt\" class=\"headerlink\" title=\"&lt;\"></a>&lt;</h2><p>符号</p>\n<p>小于</p>\n<p>定义</p>\n<p>小于</p>\n<p>说明</p>\n<p>下面的校验规则规定数据需要是字符串并且长度小于20。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &lt; 20&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"gt-1\"><a href=\"#gt-1\" class=\"headerlink\" title=\"&gt;=\"></a>&gt;=</h2><p>符号</p>\n<p>大于或等于</p>\n<p>定义</p>\n<p>大于或者等于</p>\n<p>说明</p>\n<p>下面的校验规则规定写入的数据不能为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &gt;= 1&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"lt-1\"><a href=\"#lt-1\" class=\"headerlink\" title=\"&lt;=\"></a>&lt;=</h2><p>符号</p>\n<p>小于或等于</p>\n<p>定义</p>\n<p>小于或等于</p>\n<p>说明</p>\n<p>下面的校验规则保证新数据未来不能被添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() &lt;= now&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-9\"><a href=\"#-9\" class=\"headerlink\" title=\"?\"></a>?</h2><p>符号</p>\n<p>三元表达式</p>\n<p>定义</p>\n<p>三元表达式</p>\n<p>说明</p>\n<p>问号前面是条件，条件成立第二个表达式被校验，条件不成立第三个表达式被校验。</p>\n<p>下面的校验规则规定，新数据必须是一个数字或者是布尔型值，如果是数字必须大于0。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isNumber() ? newData.val() &gt; 0 : newData.isBoolean()&quot;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"Rule-Type\"><a href=\"#Rule-Type\" class=\"headerlink\" title=\"Rule (Type)\"></a>Rule (<em>Type</em>)</h1><h2 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\".read\"></a>.read</h2><p>定义</p>\n<p>对指定路径赋予读取数据的权限。</p>\n<p>说明</p>\n<p>读取规则是Wilddog数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的读取规则。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;auth != null &amp;&amp; auth.provider == &apos;weibo&apos;&quot;</div></pre></td></tr></table></figure>\n<p>.read 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以读取， 而且它的所有子节点也是可以读取的。值为false 则不能读取数据。</p>\n<p>.read对除了newData外的所有Wilddog变量可用。</p>\n<hr>\n<h2 id=\"write\"><a href=\"#write\" class=\"headerlink\" title=\".write\"></a>.write</h2><p>定义</p>\n<p>对指定路径赋予写数据的权限。</p>\n<p>说明</p>\n<p>写规则是Wilddog 数据库中一种安全规则。该规则是面向路径设计的，意味着不同路径可以设置不同的写规则。例如：</p>\n<p>.write 规则的值类型是字符串，这个表达式使用Javascript 语法。如果表达式的值为true 代表这个路径是可以写， 而且它的所有子节点也是可以写的。值为false 则不能写数据。</p>\n<p>.write规则对Wilddog所有的Rule变量可用。</p>\n<hr>\n<h2 id=\"validate\"><a href=\"#validate\" class=\"headerlink\" title=\".validate\"></a>.validate</h2><p>定义</p>\n<p>.write规则获得权限后使用，以确保所写的数据符合特定的模式。</p>\n<p>说明</p>\n<p>.write 规则获得权限后使用，以确保所写的数据符合特定的模式。除此之外，.write 获得权限后，.validate 规则必须取得验证成功。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChildren([&apos;name&apos;, &apos;age&apos;])&quot;</div></pre></td></tr></table></figure>\n<p>.validate 规则的值类型是字符串，这个表达式使用的Javascript语法。</p>\n<p>.validate 规则对Wilddog所有的Rule变量可用。</p>\n<hr>\n<h2 id=\"indexOn\"><a href=\"#indexOn\" class=\"headerlink\" title=\".indexOn\"></a>.indexOn</h2><p>定义</p>\n<p>为数据添加索引，提高查询效率。</p>\n<p>说明</p>\n<p>.indexOn 规则可以为指定的节点建立索引，以此来提高查询效率。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;dinosaurs&quot;: &#123;</div><div class=\"line\">      &quot;.indexOn&quot;: [&quot;height&quot;, &quot;length&quot;]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>.indexOn 规则的值类型是字符串，或者是字符串数组。 节点的名称key和优先级priority默认建立索引，不需要额外设置。 关于 .indexOn 规则更多介绍，请参考规则表达式文档 <a href=\"/guide/sync/rules/guide.html#数据索引\">数据索引</a> 部分。</p>\n<hr>\n<h1 id=\"Rule-Variables\"><a href=\"#Rule-Variables\" class=\"headerlink\" title=\"Rule (Variables)\"></a>Rule (<em>Variables</em>)</h1><h2 id=\"auth\"><a href=\"#auth\" class=\"headerlink\" title=\"auth\"></a>auth</h2><p>定义</p>\n<p>这个变量与用户是否使用认证有关。使用认证就是调用auth相关的方法，比如authWithPassword()。 如果客户端已经登录认证，这个变量中包含token信息，否则为null。</p>\n<p>说明</p>\n<p>Wilddog 认证</p>\n<p>野狗内置几种认证方式。你可以轻松使用它们来生成tokens。在使用一种认证方式和，auth变量包含以下内容：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>provider</td>\n<td>认证提供商 (“password”, “anonymous”, “qq”, “weibo”, “weixin”, or “weixinmp”)。</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>一个唯一的用户id，保证独一无二。</td>\n</tr>\n</tbody>\n</table>\n<p>举一个例子, 有一个博客的评论， 只能修改和删除评论， 我们配置以下规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;.read&quot;: true,</div><div class=\"line\">    &quot;$comment&quot;: &#123;</div><div class=\"line\">      &quot;.write&quot;: &quot;!data.exists() &amp;&amp; newData.child(&apos;user_id&apos;).val() == auth.uid&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果要求只有微博登修改，只需要轻松修改rule配置， 就能搞定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;.read&quot;: true,</div><div class=\"line\">    &quot;$comment&quot;: &#123;</div><div class=\"line\">      &quot;.write&quot;: &quot;!data.exists() &amp;&amp; auth.provider == &apos;weibo&apos;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面java版生成工具依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.wilddog&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;wilddog-token-generator&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;1.0.0&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"$location\"></a>$location</h2><p>定义</p>\n<p>一个可以用来在规则表达式中使用的代表位置的变量。</p>\n<p>说明</p>\n<p>当你使用$location在你规则表达式，这个变量是以<code>$</code>开头，用于替换实际读写子节点的名称。假设我们希望给每个用户读写他们自己的<code>/users/</code>的位置，我们可以使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user&quot;: &#123;</div><div class=\"line\">        &quot;.read&quot;: &quot;auth.uid == $user&quot;,</div><div class=\"line\">        &quot;.write&quot;: &quot;auth.uid == $user&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当一个用户试图访问<code>/users/barney</code>，位置变量$user将匹配到<code>&quot;barney&quot;</code>。所以.read 规则将判断 <code>auth.uid == &#39;barney&#39;</code>。</p>\n<hr>\n<h2 id=\"now\"><a href=\"#now\" class=\"headerlink\" title=\"now\"></a>now</h2><p>定义</p>\n<p>包含一个在Wilddog服务器的Unix时间秒数。</p>\n<p>说明</p>\n<p>包含一个在Wilddog服务器的Unix时间秒数。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user&quot;: &#123;</div><div class=\"line\">        &quot;created&quot;: &#123;</div><div class=\"line\">          &quot;.validate&quot;: &quot;newData.val() &lt; now&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"root\"></a>root</h2><p>定义</p>\n<p>你的Wilddog数据库中的根节点的数据快照<code>RuleDataSnapshot</code></p>\n<p>说明</p>\n<p>root变量标识的<code>RuleDataSnapshot</code>，对应着你的Wilddog数据库根节点。你能够在读任何数据的时候在表达式中使用它。例如：你想允许用户仅在 <code>/users//active</code>设置为true的时候读取 <code>/comments</code>。我们这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;comments&quot;: &#123;</div><div class=\"line\">      &quot;.read&quot;: &quot;root.child(&apos;users&apos;).child(auth.uid).child(&apos;active&apos;).val() == true&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"newData\"><a href=\"#newData\" class=\"headerlink\" title=\"newData\"></a>newData</h2><p>定义</p>\n<p>一个数据快照<code>RuleDataSnapshot</code>对应的将要被写的数据。</p>\n<p>说明</p>\n<p>在.write和.validate规则中使用，newData变量允许代表一个将要被写的<code>RuleDataSnapshot</code>，也可能是一个从其他节点移过来的<code>RuleDataSnapshot</code>。下面的例子，要求每个用户必须包含name和age字段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user&quot;: &#123;</div><div class=\"line\">        &quot;.read&quot;: true,</div><div class=\"line\">        &quot;.write&quot;: true,</div><div class=\"line\">        &quot;.validate&quot;: &quot;newData.hasChildren([&apos;name&apos;, &apos;age&apos;])&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于newData合并包括存在的数据和新添加的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var fredRef = new Wilddog(&quot;https://samplechat.wilddogio.com/users/fred&quot;);</div><div class=\"line\">// 可行</div><div class=\"line\">fredRef.set(&#123; name: &quot;Fred&quot;, age: 19 &#125;);</div><div class=\"line\">// 可行</div><div class=\"line\">fredRef.child(&quot;age&quot;).set(27);</div><div class=\"line\">// 因为.validate不再为真，所以不可行</div><div class=\"line\">fredRef.child(&quot;name&quot;).remove();</div><div class=\"line\">newData变量在.read规则中不可用，因为没有新数据被写入，只能用data变量。</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"RuleDataSnapshot-Methods\"><a href=\"#RuleDataSnapshot-Methods\" class=\"headerlink\" title=\"RuleDataSnapshot (Methods)\"></a>RuleDataSnapshot (<em>Methods</em>)</h1><h2 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val()\"></a>val()</h2><p>定义</p>\n<p>String val()</p>\n<p>说明</p>\n<p>从 <code>RuleDataSnapshot</code>获取原生类型 (<code>string</code>, <code>number</code>, <code>boolean</code>, or <code>null</code>)。与DataSnapshot.val()不一样，<code>RuleDataSnapshot</code>调用 <code>val()</code>方法将不会返回一个<code>object</code>，就算包含子节点也这样。</p>\n<p>返回值</p>\n<p>String, Number, Boolean, Null RuleDataSnapshot 的原生类型数据。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;data.child(&apos;isReadable&apos;).val() == true&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义</p>\n<p>RuleDataSnapshot child()</p>\n<p>说明</p>\n<p>通过相对路径获取<code>RuleDataSnapshot</code>的子节点。</p>\n<p>参数</p>\n<ul>\n<li>childPath <code>String</code> 子节点的相对路径。</li>\n</ul>\n<p>返回值</p>\n<p>子节点的 <code>RuleDataSnapshot</code></p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;data.child(&apos;isReadable&apos;).val() == true&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent()\"></a>parent()</h2><p>定义</p>\n<p>RuleDataSnapshot parent()</p>\n<p>说明</p>\n<p>通过相对路径获取<code>RuleDataSnapshot</code>的父节点。</p>\n<p>返回值</p>\n<p>父节点的 <code>RuleDataSnapshot</code>.</p>\n<hr>\n<h2 id=\"hasChild\"><a href=\"#hasChild\" class=\"headerlink\" title=\"hasChild()\"></a>hasChild()</h2><p>定义</p>\n<p>Boolean hasChild(String childPath)</p>\n<p>说明</p>\n<p>判断<code>RuleDataSnapshot</code> 是否存在子节点。</p>\n<p>参数</p>\n<p>childPath <code>String</code> 潜在子节点的相对路径。</p>\n<p>返回值</p>\n<p>Boolean 存在返回<code>true</code>，否则<code>false</code></p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChild(&apos;name&apos;)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"hasChildren\"><a href=\"#hasChildren\" class=\"headerlink\" title=\"hasChildren()\"></a>hasChildren()</h2><p>定义</p>\n<p>Boolean hasChildren([children]);</p>\n<p>说明</p>\n<p>判断当前节点是否存在指定一组子节点。</p>\n<p>参数</p>\n<p>children <code>Array</code> *optional 所有存在子节点的数组。</p>\n<p>返回值</p>\n<p>Boolean</p>\n<p>pathList List 路径数组 一组子节点路径，例如[‘a’,’b’,’c’]</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChildren()&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.hasChildren([&apos;name&apos;, &apos;age&apos;])&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"exists\"><a href=\"#exists\" class=\"headerlink\" title=\"exists()\"></a>exists()</h2><p>定义</p>\n<p>Boolean exists()</p>\n<p>说明</p>\n<p>判断这个<code>RuleDataSnapshot</code>是否存在，包含数据返回true。等价于<code>data.val() != null</code></p>\n<p>返回值</p>\n<p>Boolean 包含返回<code>true</code>，否则返回<code>false</code>。</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;!data.exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"getPriority\"><a href=\"#getPriority\" class=\"headerlink\" title=\"getPriority()\"></a>getPriority()</h2><p>定义</p>\n<p>String getPriority()</p>\n<p>说明</p>\n<p>获取<code>RuleDataSnapshot</code>的优先级。</p>\n<p>返回值</p>\n<p>String, Number, Null</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.getPriority() != null&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"isNumber\"><a href=\"#isNumber\" class=\"headerlink\" title=\"isNumber()\"></a>isNumber()</h2><p>定义</p>\n<p>Boolean isNumber()</p>\n<p>说明</p>\n<p>判断获取<code>RuleDataSnapshot</code>的是否是数字类型。</p>\n<p>返回值</p>\n<p>Boolean 是数字为<code>true</code> 否则返回 <code>false</code>.</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.child(&apos;age&apos;).isNumber()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"isString\"><a href=\"#isString\" class=\"headerlink\" title=\"isString()\"></a>isString()</h2><p>定义</p>\n<p>Boolean isString()</p>\n<p>说明</p>\n<p>判断获取<code>RuleDataSnapshot</code>的是否是字符串类型。</p>\n<p>返回值</p>\n<p>Boolean 是字符串为<code>true</code> 否则返回 <code>false</code>.</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.child(&apos;name&apos;).isString()</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"isBoolean\"><a href=\"#isBoolean\" class=\"headerlink\" title=\"isBoolean()\"></a>isBoolean()</h2><p>定义</p>\n<p>Boolean isBoolean()</p>\n<p>说明</p>\n<p>判断获取<code>RuleDataSnapshot</code>的是否是布尔类型。</p>\n<p>返回值</p>\n<p>Boolean 是布尔为<code>true</code> 否则返回 <code>false</code>.</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.child(&apos;active&apos;).isBoolean()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"String-Methods\"><a href=\"#String-Methods\" class=\"headerlink\" title=\"String (Methods)\"></a>String (<em>Methods</em>)</h1><h2 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length()\"></a>length()</h2><p>定义</p>\n<p>字符串的长度。</p>\n<p>说明</p>\n<p>返回字符串的长度。</p>\n<p>返回值</p>\n<p>Number</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length() &gt;= 10&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"contains\"><a href=\"#contains\" class=\"headerlink\" title=\"contains()\"></a>contains()</h2><p>定义</p>\n<p>Boolean contains(String substring)</p>\n<p>说明</p>\n<p>判断字符串是否包含指定的子串。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code> 指定的子串。</li>\n</ul>\n<p>返回值</p>\n<p>Boolean</p>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().contains(&apos;@&apos;)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"beginsWith\"><a href=\"#beginsWith\" class=\"headerlink\" title=\"beginsWith()\"></a>beginsWith()</h2><p>定义</p>\n<p>Boolean beginsWith(String substring)</p>\n<p>说明</p>\n<p>以一个子串开头。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code></li>\n</ul>\n<p>返回值</p>\n<p>Boolean</p>\n<p>示例</p>\n<hr>\n<h2 id=\"endsWith\"><a href=\"#endsWith\" class=\"headerlink\" title=\"endsWith()\"></a>endsWith()</h2><p>定义</p>\n<p>Boolean endsWith(String substring)</p>\n<p>说明</p>\n<p>以一个子串开头结尾。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code></li>\n</ul>\n<p>返回值</p>\n<p>Boolean</p>\n<p>示例</p>\n<hr>\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h2><p>定义</p>\n<p>String replace(String substring, String replacement)</p>\n<p>说明</p>\n<p>我们的replace()方法与JavaScript中的replace()方法稍微有些不同。我们的replace是用replacement替换掉所有的substring，而JavaScript中只是替换掉第一个。因为key中不能包含句号“.”,我们应该对特殊字符进行escape编码后，才能存储它们。</p>\n<p>参数</p>\n<ul>\n<li>substring <code>String</code> 查找的子字符串。</li>\n<li>replacement <code>String</code> 替换的子字符串。</li>\n</ul>\n<p>返回值</p>\n<p>String 返回替换后的新字符串。</p>\n<p>示例</p>\n<p>假设我们在<code>/whitelist/</code> 节点有一个email白名单列表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"> &quot;user&quot;: &#123;</div><div class=\"line\">   &quot;$uid&quot;: &#123;</div><div class=\"line\">     &quot;email&quot;: &lt;email&gt;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;,</div><div class=\"line\"> &quot;whitelist&quot;: &#123;</div><div class=\"line\">   &quot;fred@gmail%2Ecom&quot;: true,</div><div class=\"line\">   &quot;barney@aol%2Ecom&quot;: true</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以如下制定rule规则，只允许email在白名单中的用户。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$uid&quot;: &#123;</div><div class=\"line\">        &quot;.read&quot;: &quot;true&quot;,</div><div class=\"line\">        &quot;.write&quot;: &quot;root.child(&apos;whitelist&apos;).child(newData.child(&apos;email&apos;).val().replace(&apos;.&apos;, &apos;%2E&apos;)).exists()&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"toLowerCase\"><a href=\"#toLowerCase\" class=\"headerlink\" title=\"toLowerCase()\"></a>toLowerCase()</h2><p>定义</p>\n<p>String toLowerCase()</p>\n<p>说明</p>\n<p>返回小写的字符串</p>\n<p>返回值</p>\n<p>小写字符串。</p>\n<p>示例</p>\n<hr>\n<h2 id=\"toUpperCase\"><a href=\"#toUpperCase\" class=\"headerlink\" title=\"toUpperCase()\"></a>toUpperCase()</h2><p>定义</p>\n<p>String toUpperCase()</p>\n<p>说明</p>\n<p>返回大写的字符串。</p>\n<p>返回值</p>\n<p><code>string</code> 大写的字符串。</p>\n<p>示例</p>\n<hr>\n<h2 id=\"matches\"><a href=\"#matches\" class=\"headerlink\" title=\"matches()\"></a>matches()</h2><p>定义</p>\n<p>Boolean matches(String regex)</p>\n<p>说明</p>\n<p>可以利用正则表达式校验客户端提供的字符串。用string.matches(pattern)来验证指定字符串是否符合规则表达式。我们的正则表达式的语法与传统规则表达式不完全一致：</p>\n<p><code>+</code> <code>*</code> <code>.</code> <code>( )</code> <code>[ ]</code> <code>{ }</code> <code>\\</code> 与传统语法一致</p>\n<p><code>^</code> and <code>$</code>只被用来匹配首尾</p>\n<p>只支持 <code>i</code> (忽略大小写) 修饰符</p>\n<p>正则表达式以/pattern/的形式被引入规则表达式。被用来检验一个字符串是否符合正则表达式。下面的校验规则用来检验新的字符串是否以’foo’开头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &apos;newData.val().matches(&quot;^foo&quot;)&apos;</div></pre></td></tr></table></figure>\n<p>Wilddog只支持一部分正则表达式的功能，不过，工程师们应该对正则表达式语法很熟悉。 下面是所支持的正则符号：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\s \\w \\d \\S \\W \\D</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符；匹配任何字类字符；数字字符匹配；匹配任何非空白字符；与任何非单词字符匹配；非数字字符匹配。</td>\n</tr>\n<tr>\n<td></td>\n<td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串开始的位置</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入字符串结尾的位置</td>\n</tr>\n<tr>\n<td>*</td>\n<td>零次或多次匹配前面的字符或子表达式</td>\n</tr>\n<tr>\n<td>+</td>\n<td>一次或多次匹配前面的字符或子表达式</td>\n</tr>\n<tr>\n<td>?</td>\n<td>零次或一次匹配前面的字符或子表达式</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除“\\n”之外的任何单个字符</td>\n</tr>\n<tr>\n<td>i</td>\n<td>一个以’i’结尾的正则表达式表示忽略大小写</td>\n</tr>\n<tr>\n<td>(pattern)</td>\n<td>匹配 pattern 并捕获该匹配的子表达式</td>\n</tr>\n<tr>\n<td>a\\</td>\n<td>b</td>\n<td>匹配 a 或 b</td>\n</tr>\n<tr>\n<td>[akz]</td>\n<td>字符集，匹配包含的任一字符。/[ABCDEF]/匹配a-f中的大写字母</td>\n</tr>\n<tr>\n<td>[a-z]</td>\n<td>一个字符区间, 匹配包含在指定范围内的所有字母。/[0-9A-F]/匹配十六进制字符串</td>\n</tr>\n<tr>\n<td>[^0-9]</td>\n<td>以’^’开头，匹配不在指定字符集中的字符</td>\n</tr>\n</tbody>\n</table>\n<p>在Wilddog安全规则中,正则表达式既不是贪婪的也不是非贪婪的，因为，它只允许你用来进行匹配而不是获取字符串。</p>\n<p>参数</p>\n<ul>\n<li>regex <code>String</code> 正则表达式</li>\n</ul>\n<p>返回值</p>\n<p>Boolean 如果满足正则表达式返回true,否则返回false。</p>\n<p>示例</p>\n<p>新数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().matches(&apos;^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$&apos;)&quot;</div></pre></td></tr></table></figure>\n<p>校验新数据符合email格式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().matches(&apos;^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]&#123;2,4&#125;$&apos;)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Operators-Methods\"><a href=\"#Operators-Methods\" class=\"headerlink\" title=\"Operators (Methods)\"></a>Operators (<em>Methods</em>)</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"+\"></a>+</h2><p>符号</p>\n<p>加法</p>\n<p>定义</p>\n<p>用作变量加法运算或字符串连接。</p>\n<p>说明</p>\n<p>因为Wilddog路径中keys总是string字符串，所以尝试比较 $variable和一个数字一定会失败。可以通过”+”把nubmber转化为string。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;newData.val() == data.val() + 1&quot;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;root.child(&apos;room_names/&apos; + $room_id).exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"-\"></a>-</h2><p>符号</p>\n<p>取反 或 减号</p>\n<p>定义</p>\n<p>取反或剪法运算。</p>\n<p>说明</p>\n<p>This validation rule checks that the new value is the inverse of a child value at the Wilddog location: 下面的校验规则用来检查新值是否是某子节点数据的取反。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() == -(data.child(&apos;quantity&apos;).val())&quot;</div></pre></td></tr></table></figure>\n<p>下面的校验规则用来保证只有过去十分钟之内的信息才能被读取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;newData.child(&apos;timestamp&apos;).val() &gt; (now - 600000)&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"*\"></a>*</h2><p>符号</p>\n<p>乘法</p>\n<p>定义</p>\n<p>取乘积</p>\n<p>说明</p>\n<p>下面的校验规则用来验证新的值是否等于price和quantity的乘积。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() == data.child(&apos;price&apos;).val() * data.child(&apos;quantity&apos;).val()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"/\"></a>/</h2><p>符号</p>\n<p>除法</p>\n<p>定义</p>\n<p>取商</p>\n<p>说明</p>\n<p>下面的校验规则保证被存储的值是所有数值的平均值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() == data.parent().child(&apos;sum&apos;).val() / data.parent().child(&apos;numItems&apos;).val()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"%\"></a>%</h2><p>符号</p>\n<p>取模</p>\n<p>定义</p>\n<p>取模</p>\n<p>说明</p>\n<p>下面的校验规则保证userId是偶数才具备写权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;$user_id&quot;: &#123;</div><div class=\"line\">    &quot;.write&quot;: &quot;$user_id % 2 == 0&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"==\"></a>==</h2><p>符号</p>\n<p>等于</p>\n<p>定义</p>\n<p>用来检验在规则表达式中两个变量是否具有相同值。</p>\n<p>说明</p>\n<p>下面校验规则保证用户账户的所有者才具备写权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;users&quot;: &#123;</div><div class=\"line\">  &quot;.write&quot;: &quot;$user_id == auth.uid&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"!=\"></a>!=</h2><p>符号</p>\n<p>不等于</p>\n<p>定义</p>\n<p>不等于</p>\n<p>说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.read&quot;: &quot;auth != null&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"amp-amp\"><a href=\"#amp-amp\" class=\"headerlink\" title=\"&amp;&amp;\"></a>&amp;&amp;</h2><p>符号</p>\n<p>与</p>\n<p>定义</p>\n<p>与操作</p>\n<p>说明</p>\n<p>下面的校验规则用来检验新数据是小于100个字符的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &lt; 100&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"||\"></a>||</h2><p>符号</p>\n<p>或</p>\n<p>定义</p>\n<p>或操作</p>\n<p>说明</p>\n<p>下面的校验规则保证我们可以删除或者创建数据，但是不能更新数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;!data.exists() || !newData.exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-8\"><a href=\"#-8\" class=\"headerlink\" title=\"!\"></a>!</h2><p>符号</p>\n<p>非</p>\n<p>定义</p>\n<p>非操作</p>\n<p>说明</p>\n<p>在规则表达式中，!常被用来查看数据是否已经被写到节点中。 下面的校验规则规定，只有在指定的节点中没有数据的时候才能写入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.write&quot;: &quot;!data.exists()&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"gt\"><a href=\"#gt\" class=\"headerlink\" title=\"&gt;\"></a>&gt;</h2><p>符号</p>\n<p>大于</p>\n<p>定义</p>\n<p>大于</p>\n<p>说明</p>\n<p>下面的校验规则规定写入的数据不能为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &gt; 0&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"lt\"><a href=\"#lt\" class=\"headerlink\" title=\"&lt;\"></a>&lt;</h2><p>符号</p>\n<p>小于</p>\n<p>定义</p>\n<p>小于</p>\n<p>说明</p>\n<p>下面的校验规则规定数据需要是字符串并且长度小于20。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &lt; 20&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"gt-1\"><a href=\"#gt-1\" class=\"headerlink\" title=\"&gt;=\"></a>&gt;=</h2><p>符号</p>\n<p>大于或等于</p>\n<p>定义</p>\n<p>大于或者等于</p>\n<p>说明</p>\n<p>下面的校验规则规定写入的数据不能为空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length &gt;= 1&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"lt-1\"><a href=\"#lt-1\" class=\"headerlink\" title=\"&lt;=\"></a>&lt;=</h2><p>符号</p>\n<p>小于或等于</p>\n<p>定义</p>\n<p>小于或等于</p>\n<p>说明</p>\n<p>下面的校验规则保证新数据未来不能被添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.val() &lt;= now&quot;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"-9\"><a href=\"#-9\" class=\"headerlink\" title=\"?\"></a>?</h2><p>符号</p>\n<p>三元表达式</p>\n<p>定义</p>\n<p>三元表达式</p>\n<p>说明</p>\n<p>问号前面是条件，条件成立第二个表达式被校验，条件不成立第三个表达式被校验。</p>\n<p>下面的校验规则规定，新数据必须是一个数字或者是布尔型值，如果是数字必须大于0。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;.validate&quot;: &quot;newData.isNumber() ? newData.val() &gt; 0 : newData.isBoolean()&quot;</div></pre></td></tr></table></figure>"},{"title":"快速入门","_content":"\n快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。\n\n## 创建应用\n\n快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读[控制面板-创建应用](/console/creat.html)\n\n现在我们创建了一个新的应用，地址为 **gzztztestapp.wilddogio.com**。这个地址是该应用的根节点。\n\n<img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\">\n\n## 引入 SDK\n\n**使用Maven获得 Android SDK：**\n\n```\n<dependency>\n    <groupId>com.wilddog.client</groupId>\n    <artifactId>wilddog-auth-android</artifactId>\n    <version>2.0.0</version>\n</dependency> \n```\n\n**使用Gradle获得 Android SDK：**\n要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：\n\n```\ndependencies {\n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n}\n```\n\n如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：\n\n```\nandroid {\n    ...\n    packagingOptions {\n        exclude 'META-INF/LICENSE'\n        exclude 'META-INF/NOTICE'\n    }\n}\n\n```\n\n\n## 创建 Wilddog 引用\n\n引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。\n\n```java\nWilddogAuth mAuth=Wilddog.getInstance(\"gzztztestapp\",context);\n```\n\n## 使用匿名方式登录\n\n1. 去野狗控制面板中打开匿名登录开关：\n![](/images/openanonymous.png)\n2. 调用 `signInAnonymously()` 方法：\n\n```java\nmAuth.signInAnonymously().addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n\t@Override\n\tpublic void onComplete(Task<AuthResult> var1) {\n\t\tif(var1.isSuccessful()){\n\t\t\tLog.d(\"success\",\"Login success!\");  // 登录成功\n            Log.d(\"Anonymous\",String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));\n\t\t} else {\n\t\t\tLog.d(\"failure\",\"reason:\"+var1.getException()); // 登录失败及错误信息\n\t\t}\n\t}\n});\n```\n\n以上就是匿名登录的方式，我们还提供了其他各种登录方式。具体请看下面对应的文档。","source":"quickstart/auth/android.md","raw":"title:  快速入门\n---\n\n快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。\n\n## 创建应用\n\n快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读[控制面板-创建应用](/console/creat.html)\n\n现在我们创建了一个新的应用，地址为 **gzztztestapp.wilddogio.com**。这个地址是该应用的根节点。\n\n<img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\">\n\n## 引入 SDK\n\n**使用Maven获得 Android SDK：**\n\n```\n<dependency>\n    <groupId>com.wilddog.client</groupId>\n    <artifactId>wilddog-auth-android</artifactId>\n    <version>2.0.0</version>\n</dependency> \n```\n\n**使用Gradle获得 Android SDK：**\n要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：\n\n```\ndependencies {\n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n}\n```\n\n如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：\n\n```\nandroid {\n    ...\n    packagingOptions {\n        exclude 'META-INF/LICENSE'\n        exclude 'META-INF/NOTICE'\n    }\n}\n\n```\n\n\n## 创建 Wilddog 引用\n\n引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。\n\n```java\nWilddogAuth mAuth=Wilddog.getInstance(\"gzztztestapp\",context);\n```\n\n## 使用匿名方式登录\n\n1. 去野狗控制面板中打开匿名登录开关：\n![](/images/openanonymous.png)\n2. 调用 `signInAnonymously()` 方法：\n\n```java\nmAuth.signInAnonymously().addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n\t@Override\n\tpublic void onComplete(Task<AuthResult> var1) {\n\t\tif(var1.isSuccessful()){\n\t\t\tLog.d(\"success\",\"Login success!\");  // 登录成功\n            Log.d(\"Anonymous\",String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));\n\t\t} else {\n\t\t\tLog.d(\"failure\",\"reason:\"+var1.getException()); // 登录失败及错误信息\n\t\t}\n\t}\n});\n```\n\n以上就是匿名登录的方式，我们还提供了其他各种登录方式。具体请看下面对应的文档。","date":"2016-09-06T03:38:22.549Z","updated":"2016-09-06T03:38:22.549Z","path":"quickstart/auth/android.html","comments":1,"layout":"page","_id":"cisswi9jp000fz4fw47d7xi1s","content":"<p>快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。</p>\n<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><p>快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制面板-创建应用</a></p>\n<p>现在我们创建了一个新的应用，地址为 <strong>gzztztestapp.wilddogio.com</strong>。这个地址是该应用的根节点。</p>\n<p><img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\"></p>\n<h2 id=\"引入-SDK\"><a href=\"#引入-SDK\" class=\"headerlink\" title=\"引入 SDK\"></a>引入 SDK</h2><p><strong>使用Maven获得 Android SDK：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.wilddog.client&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;wilddog-auth-android&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.0.0&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p><strong>使用Gradle获得 Android SDK：</strong><br>要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    packagingOptions &#123;</div><div class=\"line\">        exclude &apos;META-INF/LICENSE&apos;</div><div class=\"line\">        exclude &apos;META-INF/NOTICE&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"创建-Wilddog-引用\"><a href=\"#创建-Wilddog-引用\" class=\"headerlink\" title=\"创建 Wilddog 引用\"></a>创建 Wilddog 引用</h2><p>引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth mAuth=Wilddog.getInstance(<span class=\"string\">\"gzztztestapp\"</span>,context);</div></pre></td></tr></table></figure>\n<h2 id=\"使用匿名方式登录\"><a href=\"#使用匿名方式登录\" class=\"headerlink\" title=\"使用匿名方式登录\"></a>使用匿名方式登录</h2><ol>\n<li>去野狗控制面板中打开匿名登录开关：<br><img src=\"/images/openanonymous.png\" alt=\"\"></li>\n<li>调用 <code>signInAnonymously()</code> 方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAuth.signInAnonymously().addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(var1.isSuccessful())&#123;</div><div class=\"line\">\t\t\tLog.d(<span class=\"string\">\"success\"</span>,<span class=\"string\">\"Login success!\"</span>);  <span class=\"comment\">// 登录成功</span></div><div class=\"line\">            Log.d(<span class=\"string\">\"Anonymous\"</span>,String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\tLog.d(<span class=\"string\">\"failure\"</span>,<span class=\"string\">\"reason:\"</span>+var1.getException()); <span class=\"comment\">// 登录失败及错误信息</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>以上就是匿名登录的方式，我们还提供了其他各种登录方式。具体请看下面对应的文档。</p>\n","excerpt":"","more":"<p>快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。</p>\n<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><p>快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制面板-创建应用</a></p>\n<p>现在我们创建了一个新的应用，地址为 <strong>gzztztestapp.wilddogio.com</strong>。这个地址是该应用的根节点。</p>\n<p><img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\"></p>\n<h2 id=\"引入-SDK\"><a href=\"#引入-SDK\" class=\"headerlink\" title=\"引入 SDK\"></a>引入 SDK</h2><p><strong>使用Maven获得 Android SDK：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.wilddog.client&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;wilddog-auth-android&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;2.0.0&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p><strong>使用Gradle获得 Android SDK：</strong><br>要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    packagingOptions &#123;</div><div class=\"line\">        exclude &apos;META-INF/LICENSE&apos;</div><div class=\"line\">        exclude &apos;META-INF/NOTICE&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"创建-Wilddog-引用\"><a href=\"#创建-Wilddog-引用\" class=\"headerlink\" title=\"创建 Wilddog 引用\"></a>创建 Wilddog 引用</h2><p>引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth mAuth=Wilddog.getInstance(<span class=\"string\">\"gzztztestapp\"</span>,context);</div></pre></td></tr></table></figure>\n<h2 id=\"使用匿名方式登录\"><a href=\"#使用匿名方式登录\" class=\"headerlink\" title=\"使用匿名方式登录\"></a>使用匿名方式登录</h2><ol>\n<li>去野狗控制面板中打开匿名登录开关：<br><img src=\"/images/openanonymous.png\" alt=\"\"></li>\n<li>调用 <code>signInAnonymously()</code> 方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAuth.signInAnonymously().addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(var1.isSuccessful())&#123;</div><div class=\"line\">\t\t\tLog.d(<span class=\"string\">\"success\"</span>,<span class=\"string\">\"Login success!\"</span>);  <span class=\"comment\">// 登录成功</span></div><div class=\"line\">            Log.d(<span class=\"string\">\"Anonymous\"</span>,String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\tLog.d(<span class=\"string\">\"failure\"</span>,<span class=\"string\">\"reason:\"</span>+var1.getException()); <span class=\"comment\">// 登录失败及错误信息</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>以上就是匿名登录的方式，我们还提供了其他各种登录方式。具体请看下面对应的文档。</p>\n"},{"title":"完整 API 文档","_content":"\n# Wilddog (*Methods*)\n\n## wilddog init\n\n定义\n\nwilddog.initializeApp(config)\n\n说明\n\n初始化一个Wilddog客户端。\n\n参数\n\nwilddogUrl `string` 应用url 如：`https://<appId>.wilddogio.com`\nauthDomain `string` Auth域 目前只支持`<appId>.wilddog.com`\n\n 返回值\n\nWilddog 对象的引用\n\n 示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar rootRef = wilddog.sync().ref();\n//Good, 我们已经创建了一个野狗客户端。\n\n```\n----\n\n## child()\n\n定义\n\nchild ( path )\n\n说明\n\n根据相对路径，来获取当前节点下子节点的引用\n\n参数\n\npath `String` \n\npath为相对路径，多层级间需要使用\"/\"分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。\n\n返回值\n\n`Wilddog`子节点的引用。\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"city\");\n//ref refer to node <appId>.wilddogio.com/city\n\nchild_ref = ref.child(\"Beijing\");\n//now child_ref refer to \"<appId>.wilddogio.com/city/Beijing\"\n```\n\n----\n\n## parent()\n\n定义\n\nparent()\n\n说明\n\n获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。\n\n返回值\n\n`String` Wilddog 父节点的引用\n\n示例\n\n```js\nvar parent_ref = ref.parent();\n//返回值 the refer to the father node of current\n```\n\n----\n\n## root()\n\n定义\n\nroot()\n\n说明\n\n获得`wilddog`根结点的引用\n\n返回值\n\n`String` wilddog根节点的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"city\");\n//ref refer to node <appId>.wilddogio.com/city\n\nvar root_ref = ref.root();\nvar path = root_ref.toString();\n//path is now 'https://<appId>.wilddogio.com'\n\n```\n\n\n-----\n\n## key()\n\n定义\n\nkey()\n\n说明\n\n获得当前路径下节点的名称。\n\n返回值\n\n`String` 节点名称\n\n示例\n\n\n```js\nchild_ref = ref.child(\"Beijing\");\n\n//返回值 the key to current node\nvar key = child_ref.key();\n//key is 'Bejing'\n```\n----\n\n## toString()\n\n定义\n\ntoString()\n\n说明\n获取当前节点的应用URL。\n\n返回值\n\n`String` 当前节点的应用URL。\n\n示例\n\n```js\nchild_ref = ref.child(\"/city/Beijing\");\n//返回值 the key to current node\n\nvar url = child_ref.toString();\n//url should be https://<appId>.wilddogio.com/city/Beijing\n```\n----\n\n## set()\n\n定义\n\n set ( value , [oncomplete] )\n\n说明\n\n设置一个节点的值。\n如果`value != null` ,当前节点上的数据会被value覆盖，如果中间路径不存在,Wilddog 会自动将中间路径补全。如果`value == null`,效果等同于remove操作。\n\n参数\n\n* value `object|string|number|boolean|null` 将被写入的值。\n* onComplete `function(error)` 如果操作成功 `error`为`null`；否则,error为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\n//the initial value is {\"temp\":23,\"humidity\":30,\"wind\":2}\n\nref.set({\"temp\":10,\"pm25\":500});\n//the expected value of https://<appId>.wilddogio.com/city/Beijing should be {\"temp\":10,\"pm25\":500}\n// or \nref.set({\n    \"temp\":10,\n    \"pm25\":500\n}, function(error) {\n    if (error == null){\n        // set 数据到野狗云端成功\n    }\n});\n\n```\n\n----\n\n## update()\n\n定义\n\nupdate ( value , [onComplete] )\n\n说明\n\n将输入对象的子节点合并到当前数据中。不存在的子节点将会被新增，存在子节点将会被替换。\n与`set`操作不同,`update` 不会直接覆盖原来的节点,而是将`value` 中的所有子节点插入到已有的节点中,如果已有的节点中已经有同名子节点,则覆盖原有的子节点。\n<br>\ne.g. update之前 `{\"l1\":\"on\",\"l3\":\"off\"}` ,`value={\"l1\":\"off\",\"l2\":\"on\"}` update 后期望的数据是 `{\"l1\":\"off\",\"l2\":\"on\",\"l3\":\"off\"}`。\n\n\n参数\n\n* value `object`包含要合并子节点的对象\n* onComplete `function(error)` 如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n//the initial value is {\"temp\":23,\"humidity\":30,\"wind\":2}\n\nref.update({\"temp\":10,\"pm25\":500});\n//the expected value of https://<appId>.wilddogio.com/city/Beijing should be {\"temp\":10,\"pm25\":500,\"humidity\":30,\"wind\":2}\n```\n----\n\n## remove()\n\n定义\n\nremove ( [onComplete] )\n\n说明\n\n删除当前节点,效果等同于 `set(null,[onComplete])`,\n如果父级节点只有当前节点一个子节点, 会递归删除父级节点。\n\n参数\n\nonComplete `function(error)`  如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\n//the initial value of https://<appId>.wilddogio.com is \n//{\"city\":{\"Beijing\":{\"temp\":23,\"humidity\":30,\"wind\":2}}}\n\nref.remove()\n// value of https://<appId>.wilddogio.com is {}\n\n```\n----\n\n## push()\n\n定义\n\npush (value , [oncomplete] )\n\n说明\n\n在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。\n\n参数\n\n* value `object|string|number|boolean|null` 用户希望在当前节点下新增的数据.\n* onComplete `function(error)`  如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n返回值\n\n`String` 新插入子节点的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"users\");\n\nvar childref = ref.push({\"name\":\"Thor\",\"planet\":\"Asgard\"});\n\nvar newKey = childref.key();\n//newKey shoud look like a base64-like series eg -JmRhjbYk73IFRZ7\n//th url of newKey shoud be https://<appId>.wilddogio.com/users/-JmRhjbYk73IFRZ7\n\n```\n--------\n\n## setWithPriority()\n\n定义\n\nsetWithPriority ( value , priority , [oncomplete] )\n\n说明\n\n把数据写到当前位置，类似set,不同之处是需要指定一个优先级。默认排序按照优先级排序。(参考排序规则的 [orderByPriority](/guide/sync/web/retrieve-data.html#排序规则) )\n\n参数\n\n* value `Object|String|Number|Boolean|Null` 将被写入的值。\n* priority `String|Number` 优先级数据，节点的优先级是默认排序的依据。\n* onComplete `function(error)`  如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/users/jack\");\n\nvar user = {\n  name: {\n    first: 'jack',\n    last: 'Lee'\n  }\n};\n\nref.setWithPriority(user,100);\n```\n\n----\n\n## setPriority()\n\n定义\n\nsetPriority ( priority , [onComplete] )\n\n说明\n\n设置当前节点的优先级，优先级可以是`Number`,也可以是`String` 。用来改当前节点在兄弟节点中的排序位置。这个排序会影响Snapshot.forEach()的顺序，同样也会影响`child_added`和`child_moved`事件中`prevChildName`参数。\n\n**节点按照如下规则排序**\n\n* 没有priority的排最先\n* 有数字 priority的次之，按照数值排序\n* 有字符串 priority的排最后，按照字母表的顺序排列\n* 当两个子节点有相同的 priority，它们按照名字进行排列，数字排在最先，字符串排最后\n\n参数\n\n* priority `String|Number` 优先级\n* onComplete `function(error)` 如果操作成功 `error`为`null`；否则,error 为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/users/jack\");\n\nref.setPriority(1000);\n```\n\n----\n\n## transaction()\n\n定义\n\ntransaction(updateFunction, [onComplete], [applyLocally])\n\n说明\n\n在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，transaction() 能够确保不同客户端在相同时间没有修改冲突。\n\n为了到达目的， 你通过 transaction() 的更新函数将的作用是把 current value 转换成 new value。当另外一个客户端在你之前先成功，你的更新函数将重新调用并带有 new current value。这过程一直重复直到写入成功或者不返回 value 来中止事务。\n\n如果需要， 你的 onComplete callback 将在事务完成后异步被调用。\n\n注意：在相同的路径上 使用 set() 和 transaction() , 极端情况下将出现不可预料的结果。\n\n参数\n\n* updateFunction `function`\n  更新数据的函数\n\n\n* onComplete `function(error, committed, snapshot)` \n 如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n committed `boolean`  提交成功。\n snapshot `DataSnapShot` 事务完成后的数据快照。\n\n示例\n\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/users/fred/rank\");\n\nref.transaction(function(currentRank) {\n        // If /users/fred/rank 没有设置数据，currentRank 将会是 null 。\n\treturn currentRank+1;\n});\n```\n\n```js\n// 试图创建 wilma 的用户， 如果你的用户 'wilma' 已经存在，那退出事务\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar wilmaRef = wilddog.sync().ref(\"/samplechat/users/wilma\");\n\nwilmaRef.transaction(function(currentData) {\n  if (currentData === null) {\n    return { name: { first: 'Wilma', last: 'Flintstone' } };\n  } else {\n    console.log('用户 wilma 已经存在。');\n    return; // 退出事务\n  }\n}, function(error, committed, snapshot) {\n  if (error) {\n    console.log('Transaction 失败了!', error);\n  } else if (!committed) {\n    console.log('我们退出事务，因为用户wilma 已经存在。');\n  } else {\n    console.log('用户 wilma 已经添加!');\n  }\n  console.log(\"Wilma's data: \", snapshot.val());\n});\n```\n-----\n\n## goOnline()\n\n定义\n\nWilddog.goOnline()\n\n说明\n\n手动建立连接，开启自动重连。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\n\nwilddog.sync().goOffline(); // All local Wilddog instances are disconnected\nwilddog.sync().goOnline(); // All local Wildodg instances automatically reconnect\n```\n\n-----\n\n## goOffline()\n定义\n\nWilddog.goOffline()\n\n说明\n\n手动断开连接，关闭自动重连。\n\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\n\nwilddog.sync().goOffline(); // All local Wilddog instances are disconnected\n```\n---\n\n# Query (*Methods*)\n\n## on()\n\n定义\n\non ( type , callback , [cancelCallback] ， [context] )\n\n说明\n\n监听某个事件,注册回调函数。\n\n参数\n\n* type `String`\n\n>|事件|说明|\n|----|----|\n|value| 当有数据请求或有任何数据发生变化时触发|\n|child_added| 当有新增子节点时触发|\n|child_changed|当某个子节点发生变化时触发 |\n|child_removed|当有子节点被删除时触发 |\n|child_moved|当有子节排序发生变化时触发 |\n\n\n**callback** `function(snapshot[,prev])` \n`snapshot`  为`Snapshot` 类型,当监听到某事件时callback 会被执行. 在child_* 事件中会有prev参数。表示当前节点的上一个节点的key\n\n**cancelCallback** `function(error)`\n如果操作失败，这个函数会被调用。传入一个 `Error` 对象，包含为何失败的信息。\n\n**context** `Object`\n如果指定，你的回调函数中的this将代表这个对象\n\n示例\n\n```js\nref.on('child_added',function(snapshot,prev){\n  console.log(snapshot.val());\n  console.log(\"the previous key is\",prev)\n});\n```\n--------\n\n## off()\n\n定义\n\noff ( [type] , [callback] , [context] )\n\n说明\n\n取消监听事件。取消之前用`on()`注册的回调函数。\n\n参数\n\n* type `String` `value`,`child_added`,`child_changed`,`child_removed`,`child_moved`  之一\n* callback `function(snapshot)`  `on()` 中被传入的函数\n* context `Object`  `on()` 中被传入的context\n\n示例\n\n```js\nvar onValueChange = function(dataSnapshot) { /* handle... */ };\nwilddogRef.on('value', onValueChange);\n// Sometime later...\nwilddogRef.off('value', onValueChange);\n```\n```js\nvar onValueChange = wilddogRef.on('value', function(dataSnapshot) { /* handle... */ });\n// Sometime later...\nwilddogRef.off('value', onValueChange);\n```\n\n------\n\n## once()\n\n定义\n\nonce ( type , callback , [cancelCallbak] , [context] )\n\n说明\n\n同on 类似,不同之处在于 once中的回调函数只被执行一次。\n\n参数\n\n* type `String`\n\n>|事件|说明|\n|----|----|\n|value| 当有数据请求或有任何数据发生变化时触发|\n|child_added| 当有新增子节点时触发|\n|child_changed|当某个子节点发生变化时触发 |\n|child_removed|当有子节点被删除时触发 |\n|child_moved|当有子节排序发生变化时触发 |\n\n\n\n**callback** `function(snapshot[,prev])` \n`snapshot`  为`Snapshot` 类型,当监听到某事件时callback 会被执行. 在child_* 事件中会有prev参数。表示当前节点的上一个节点的key\n**cancelCallback** `function(error)`\n如果操作失败，这个函数会被调用。传入一个 `Error` 对象，包含为何失败的信息。\n**context** `Object`\n 如果指定，你的回调函数中的this将代表这个对象\n\n示例\n\n```js\nref.once('child_added',function(snapshot){\n  console.log(snapshot.val());\n});\n```\n\n----\n\n## orderByChild() \n\n定义\n\norderByChild ( key )\n\n说明\n\n产生一个新`Query`对象，按照特定子节点的值进行排序。排序的详情请参考[数据排序](/guide/sync/web/retrieve-data.html#数据排序)。\n\n参数\n\n* key `String`\n\n指定用来排序的子节点的key\n\n返回值\n\n* 新生成的`Query` 对象的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByChild(\"height\").on(\"child_added\",function(snapshot){\n  console.log(snapshot.key() + \"is\" + snapshot.val().height +\"meters tall\");\n});\n\n```\n----\n\n## orderByKey()\n\n定义\n\norderByKey()\n\n说明\n\n产生一个新`Query`对象，按照当前节点的key进行排序。\n\n返回值\n\n新生成的`Query` 对象的引用\n\n示例\n\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## orderByValue() \n\n定义\n\norderByValue()\n\n说明\n\n产生一个新`Query`对象，按照当前节点的值进行排序。排序的详情请参考[数据排序](/guide/sync/web/retrieve-data.html#数据排序)。\n\n返回值\n\n* 新生成的`Query` 对象的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"dinosaur-facts.wilddog.com\",\n  syncURL: \"https://dinosaur-facts.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar scoresRef = wilddog.sync().ref(\"scores\");\n\nscoresRef.orderByValue().limitToLast(3).on(\"value\", function(snapshot) {\n  snapshot.forEach(function(data) {\n    console.log(\"The \" + data.key() + \" score is \" + data.val());\n  });\n}\n\n```\n\n----\n\n## orderByPriority()\n\n定义\n\norderByPriority()\n\n说明\n\n产生一个新`Query`对象，按照当前节点的优先级排序。\n\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\nref.orderByPriority().on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key());\n});\n```\n----\n\n## startAt()\n\n定义\n\nstartAt ( value , [key] )\n\n说明\n\n创建一个大于等于的范围查询，可配合orderBy方式使用。\n\n参数\n\n* value `String |Number|Null|Boolean`  查询的起始值，类型取决于这个查询用到的 `orderBy*()`函数。如果与`orderByKey()` 组合的话，`value` 一定是一个`String`。\n* key `String`  起始子节点的key，只有在 `orderByPriority()`时有效。\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().startAt('jack').on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## endAt()\n\n定义\n\nendAt ( value , [key] )\n\n说明\n\n创建一个小于等于的范围查询，可配合orderBy方式使用。\n\n参数\n\n* value `String|Number|Null|Boolean` 查询的结束值，类型取决于这个查询用到的 `orderBy*()`函数。如果与`orderByKey()` 组合的话，`value` 一定时一个`String`。\n* key `String` 起始子节点的key，只有在 `orderByPriority()`时有效。\n\n\n返回值\n\n新生成的`Query` 对象\n\n示例\n\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().endAt('jack').on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## equalTo()\n\n定义\n\nequalTo ( value , [key] )\n\n说明\n\n创建一个等于的精确查询。\n\n参数\n\n* value `String|Number|Null|Boolean` 需要匹配的数值，类型取决于这个查询用到的 `orderBy*()`函数。如果与`orderByKey()` 组合的话，`value` 一定是一个`String`。\n* key `String` 起始子节点的key，只有在 `orderByPriority()`时有效。\n\n\n返回值\n\n新生成的`Query` 对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().equalTo('jack').on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## limitToFirst()\n\n定义\n\nlimitToFirst ( limit )\n\n说明\n\n创建一个新`Query`对象，获取从第一条（或startAt指定的位置）开始指定数量的子节点。\n\n参数\n\nlimit `Number` 这次查询能够获取的子节点的最大数量。\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n示例\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.limitToFirst(10).on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n\n----\n\n## limitToLast()\n\n定义\n\nlimitToLast ( limit )\n\n说明\n\n创建一个新`Query`对象，获取从最后一条（或endAt指定的位置）开始向前指定数量的子节点。\n\n参数\n\nlimit `Number` 这次查询能够获取的子节点的最大数量。\n\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.limitToLast(10).on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## ref()\n\n定义\n\nref()\n\n说明\n\n获取这个查询的 `Wilddog` 引用\n\n返回值\n\n `Wilddog` 引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nvar query=ref.limitToLast(10);\nvar locationRef=query.ref();//ref==locationRef\n```\n\n-----\n\n# Wilddog.onDisconnect (*Methods*)\n\n## set()\n\n定义\n\nset (value,[onComplete])\n\n说明\n\n当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。\n\n参数\n\n* value `Object,String,Number,Boolean,Null` 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）\n* onComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n返回值\n\n没有返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().set('I disconnected!');\n```\n----\n\n## update()\n\n定义\n\nupdate(value,[onComplete])\n\n说明\n\n当客户端断开连接后，指定的子节点将被写入到当前位置的子节点集合中。\n\n参数\n\n* value `Object` 包含要写入当前位置子节点的集合。\n* onComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().update({message:'I disconnected!'});\n```\n\n----\n\n## remove()\n\n定义\n\nremove([onComplete])\n\n说明\n\n当客户端断开连接后，删除当前位置上的数据。\n\n参数\n\nonComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().remove();\n```\n\n----\n\n## setWithPriority()\n\n定义\n\nsetWithPriority(value, priority, [onComplete])\n\n说明\n当客户端断开连接后，指定的数据和其优先级会被写入当前位置。\n\n\n参数\n\n* value `Object`, `String`, `Number`, `Boolean`, `Null` 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）\n* priority `String`,`Number` value的优先级\n* onComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().setWithPriority('I disconnected', 10);\n```\n\n----\n\n## cancel()\n\n定义\n\ncancel()\n\n说明\n\n取消之前所有注册的离线操作。\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar fredOnlineRef = wilddog.sync().ref(\"/users/fred/online\");\n\nfredOnlineRef.onDisconnect().set(false);\n// cancel the previously set onDisconnect().set() event\nfredOnlineRef.onDisconnect().cancel();\n```\n\n-----\n\n# Wilddog.ServerValue (*Constants*)\n\n## TIMESTAMP\n\n定义\n\nwilddog.sync().ServerValue.TIMESTAMP\n\n说明\n\n获取当前服务端的时间戳。\n\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar sessionsRef = wilddog.sync().ref(\"sessions\");\n\nvar mySessionRef = sessionsRef.push();\nmySessionRef.onDisconnect().update({ endedAt: wilddog.sync().ServerValue.TIMESTAMP });\nmySessionRef.update({ startedAt: wilddog.sync().ServerValue.TIMESTAMP });\n```\n----\n\n\n# DataSnapshot (*Methods*)\n\nDataSnapshot是当前时间,某个节点数据的副本,Snapshot不会随当前节点数据的变化而发生改变.\n用户不会主动创建一个DataSnapshot,而是和 on或once 配合使用.\n\n## exists()\n\n定义\n\nexists()\n\n说明\n\n如果Datasnapshot对象包含数据返回 true，否则返回false\n\n返回值\n\nDatasnapshot是否包含数据\n\n示例\n\n假如我们有以下数据：\n\n``` json\n{\n  \"name\" : {\n    \"first\" : \"Jim\",\n    \"last\" : \"Gordon\"\n  } \n}\n\n```\n\n我们可以用exists检测是否包含特定字节点\n\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/samplechat/users/jim\");\n\nref.once(\"value\", function(snapshot) {\n  var a = snapshot.exists();\n  // a === true\n\n  var b = snapshot.child(\"name\").exists();\n  // b === true\n\n  var c = snapshot.child(\"name/first\").exists();\n  // c === true\n\n  var d = snapshot.child(\"name/middle\").exists();\n  // d === false (because there is no \"name/middle\" child in the data snapshot)\n});\n\n\n```\n\n----\n\n## val()\n\n定义\n\nval()\n\n说明\n\n返回当前快照的数据\n\n返回值 \n\n`object|string|null|number|boolean` 当前快照的真实数据。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tconsole.log(snapshot.val());\n\t//should output {\"pm25\":432}\n})\n```\n\n``` js\nref.update({\"pm25\":432})\n```\n----------\n\n## child()\n\n定义\n\nchild ( path )\n\n说明\n\n根据相对路径，来获取当前节点下子节点的快照。\n\n参数\n\npath `string` path为相对路径，多层级间需要使用\"/\"分隔，例如“a/b”。\n\n返回值 \n\n子节点的快照\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse{\n\t\tvar pm25=snapshot.child('pm25');\n\t\tconsole.log(\"The pm25 of Bejing is\",pm25.val())\n\t}\n})\n```\n``` js\nref.update({\"pm25\":432})\n```\n-----\n\n## forEach()\n\n定义\n\nforEach ( callback )\n\n说明\n\n遍历快照中每一个子节点,执行回调函数\n\n参数\n\ncallback `function(snap)`， snap:子节点快照\n\n示例\n\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on(\"value\",function(snapshot){\n\t\tsnapshot.forEach(function(snap){\n\t\tconsole.log(\"the\",snap.key(),\"of Bejing is:\",snap.val());\n     });\n});\n\n```\n``` js\nref.update({\"pm25\":432})\n```\n\n----\n\n## hasChild()\n\n定义\n\nhasChild ( key )\n\n说明\n\n检查是否存在某个子节点\n\n参数\n\nkey 输入参数,关注子节点的key\n\n返回值 \n `boolean`   `true` 子节点存在；`false` 子节点不存在\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse {\n\t\tif(snapshot.hasChild('pm25')){\n\t\t\tvar pm25=snapshot.child('pm25');\n\t\t\tconsole.log(\"The pm25 of Bejing is\",pm25.val());\n\t\t}\t\n\t}\n})\n```\n\n``` js\nref.update({\"pm25\":432})\n```\n\n----\n\n## hasChildren()\n\n定义\n\nhasChildren()\n\n说明\n\n如果 `Datasnapshot` 有任何子节点返回true，否则false。\n\n返回值\n\n`boolean` 如果snapshot 有任何子节点 `true` ,否则 `false`\n\n示例\n\n假设我们已经有如下的数据\n\n``` json\n{\n  \"name\": {\n    \"first\": \"Jim\",\n    \"last\": \"Gordon\"\n  }\n}\n\n```\n\n我们可以用 `hasChildren` 检测 `DataSnapshot` 是否包含任何子节点：\n\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/samplechat/users/jim\");\n\nref.once(\"value\", function(snapshot) {\n  var a = snapshot.hasChildren();\n  // a === true\n\n  var b = snapshot.child(\"name\").hasChildren();\n  // b === true\n\n  var c = snapshot.child(\"name/first\").hasChildren();\n  // c === false (because \"Fred\" is a string and therefore has no children)\n});\n```\n----\n\n## key()\n\n定义\n\n key()\n\n说明\n\n返回当前节点的key\n\n返回值 \n\n`string` 当前节点的key值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse {\n\t\tif(snapshot.hasChild('pm25')){\n\t\t\tvar pm25=snapshot.child('pm25');\n\t\t\tvar key=snapshot.key();\n\t\t\tconsole.log(\"The \",pm25.key() ,\" of Bejing is\",pm25.val());\n\t\t}\t\n\t}\n})\n```\n----\n\n## numChildren()\n\n定义\n\nnumChildren()\n\n说明\n\n返回当前节点中子节点的个数\n\n返回值\n \n`string` 子节点的个数\n\n----\n\n## ref()\n\n定义\n\nref()\n\n说明\n\n返回当前Wilddog实例的引用\n\n返回值 \n\n当前Wilddog实例的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse {\n\t\tif(snapshot.hasChild('pm25')){\n\t\t\tvar pm25=snapshot.child('pm25');\n\t\t\tvar key=snapshot.key();\n\t\t\tvar _ref=pm25.ref();\n\t\t\tif(pm25.val()>500){\n\t\t\t\t_ref.set(500);\n\t\t\t}\t\n\t\t}\t\n\t}\n})\n```\n\n----\n\n## getPriority()\n\n定义\n\ngetPriority()\n\n说明\n\n获取当前节点的优先级\n\n返回值\n\nStirng , Number , Null 优先级，或者不存在\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/samplechat/users\");\n\nref.setWithPriority(\"fred\", 500, function(error) {\n  ref.once(\"value\", function(snapshot) {\n    var priority = snapshot.getPriority();\n    // priority === 500\n  });\n});\n```\n----\n\n\n## exportVal()\n\n\n定义\n\nexportVal()\n\n说明\n\n导出DataSnapshot中的内容到Javascript 对象，与 `val()`类似，不同之处在于exportVal 导出的数据包含优先级。\n\n返回值\n\nDataSnapshot 的内容\n\n示例\n\n``` js\nref.setWithPriority(\"hello\", 500, function(error) {\n  ref.once(\"value\", function(snapshot) {\n    var data = snapshot.exportVal();\n    // data is { \".value\": \"hello\", \".priority\": 500 }\n    // data[\".value\"] === \"hello\"\n    // data[\".priority\"] ===  500\n  });\n});\n```\n\n\n\n\n\n","source":"api/sync/web.md","raw":"title:  完整 API 文档\n---\n\n# Wilddog (*Methods*)\n\n## wilddog init\n\n定义\n\nwilddog.initializeApp(config)\n\n说明\n\n初始化一个Wilddog客户端。\n\n参数\n\nwilddogUrl `string` 应用url 如：`https://<appId>.wilddogio.com`\nauthDomain `string` Auth域 目前只支持`<appId>.wilddog.com`\n\n 返回值\n\nWilddog 对象的引用\n\n 示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar rootRef = wilddog.sync().ref();\n//Good, 我们已经创建了一个野狗客户端。\n\n```\n----\n\n## child()\n\n定义\n\nchild ( path )\n\n说明\n\n根据相对路径，来获取当前节点下子节点的引用\n\n参数\n\npath `String` \n\npath为相对路径，多层级间需要使用\"/\"分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。\n\n返回值\n\n`Wilddog`子节点的引用。\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"city\");\n//ref refer to node <appId>.wilddogio.com/city\n\nchild_ref = ref.child(\"Beijing\");\n//now child_ref refer to \"<appId>.wilddogio.com/city/Beijing\"\n```\n\n----\n\n## parent()\n\n定义\n\nparent()\n\n说明\n\n获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。\n\n返回值\n\n`String` Wilddog 父节点的引用\n\n示例\n\n```js\nvar parent_ref = ref.parent();\n//返回值 the refer to the father node of current\n```\n\n----\n\n## root()\n\n定义\n\nroot()\n\n说明\n\n获得`wilddog`根结点的引用\n\n返回值\n\n`String` wilddog根节点的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"city\");\n//ref refer to node <appId>.wilddogio.com/city\n\nvar root_ref = ref.root();\nvar path = root_ref.toString();\n//path is now 'https://<appId>.wilddogio.com'\n\n```\n\n\n-----\n\n## key()\n\n定义\n\nkey()\n\n说明\n\n获得当前路径下节点的名称。\n\n返回值\n\n`String` 节点名称\n\n示例\n\n\n```js\nchild_ref = ref.child(\"Beijing\");\n\n//返回值 the key to current node\nvar key = child_ref.key();\n//key is 'Bejing'\n```\n----\n\n## toString()\n\n定义\n\ntoString()\n\n说明\n获取当前节点的应用URL。\n\n返回值\n\n`String` 当前节点的应用URL。\n\n示例\n\n```js\nchild_ref = ref.child(\"/city/Beijing\");\n//返回值 the key to current node\n\nvar url = child_ref.toString();\n//url should be https://<appId>.wilddogio.com/city/Beijing\n```\n----\n\n## set()\n\n定义\n\n set ( value , [oncomplete] )\n\n说明\n\n设置一个节点的值。\n如果`value != null` ,当前节点上的数据会被value覆盖，如果中间路径不存在,Wilddog 会自动将中间路径补全。如果`value == null`,效果等同于remove操作。\n\n参数\n\n* value `object|string|number|boolean|null` 将被写入的值。\n* onComplete `function(error)` 如果操作成功 `error`为`null`；否则,error为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\n//the initial value is {\"temp\":23,\"humidity\":30,\"wind\":2}\n\nref.set({\"temp\":10,\"pm25\":500});\n//the expected value of https://<appId>.wilddogio.com/city/Beijing should be {\"temp\":10,\"pm25\":500}\n// or \nref.set({\n    \"temp\":10,\n    \"pm25\":500\n}, function(error) {\n    if (error == null){\n        // set 数据到野狗云端成功\n    }\n});\n\n```\n\n----\n\n## update()\n\n定义\n\nupdate ( value , [onComplete] )\n\n说明\n\n将输入对象的子节点合并到当前数据中。不存在的子节点将会被新增，存在子节点将会被替换。\n与`set`操作不同,`update` 不会直接覆盖原来的节点,而是将`value` 中的所有子节点插入到已有的节点中,如果已有的节点中已经有同名子节点,则覆盖原有的子节点。\n<br>\ne.g. update之前 `{\"l1\":\"on\",\"l3\":\"off\"}` ,`value={\"l1\":\"off\",\"l2\":\"on\"}` update 后期望的数据是 `{\"l1\":\"off\",\"l2\":\"on\",\"l3\":\"off\"}`。\n\n\n参数\n\n* value `object`包含要合并子节点的对象\n* onComplete `function(error)` 如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n//the initial value is {\"temp\":23,\"humidity\":30,\"wind\":2}\n\nref.update({\"temp\":10,\"pm25\":500});\n//the expected value of https://<appId>.wilddogio.com/city/Beijing should be {\"temp\":10,\"pm25\":500,\"humidity\":30,\"wind\":2}\n```\n----\n\n## remove()\n\n定义\n\nremove ( [onComplete] )\n\n说明\n\n删除当前节点,效果等同于 `set(null,[onComplete])`,\n如果父级节点只有当前节点一个子节点, 会递归删除父级节点。\n\n参数\n\nonComplete `function(error)`  如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\n//the initial value of https://<appId>.wilddogio.com is \n//{\"city\":{\"Beijing\":{\"temp\":23,\"humidity\":30,\"wind\":2}}}\n\nref.remove()\n// value of https://<appId>.wilddogio.com is {}\n\n```\n----\n\n## push()\n\n定义\n\npush (value , [oncomplete] )\n\n说明\n\n在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。\n\n参数\n\n* value `object|string|number|boolean|null` 用户希望在当前节点下新增的数据.\n* onComplete `function(error)`  如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n返回值\n\n`String` 新插入子节点的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"users\");\n\nvar childref = ref.push({\"name\":\"Thor\",\"planet\":\"Asgard\"});\n\nvar newKey = childref.key();\n//newKey shoud look like a base64-like series eg -JmRhjbYk73IFRZ7\n//th url of newKey shoud be https://<appId>.wilddogio.com/users/-JmRhjbYk73IFRZ7\n\n```\n--------\n\n## setWithPriority()\n\n定义\n\nsetWithPriority ( value , priority , [oncomplete] )\n\n说明\n\n把数据写到当前位置，类似set,不同之处是需要指定一个优先级。默认排序按照优先级排序。(参考排序规则的 [orderByPriority](/guide/sync/web/retrieve-data.html#排序规则) )\n\n参数\n\n* value `Object|String|Number|Boolean|Null` 将被写入的值。\n* priority `String|Number` 优先级数据，节点的优先级是默认排序的依据。\n* onComplete `function(error)`  如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/users/jack\");\n\nvar user = {\n  name: {\n    first: 'jack',\n    last: 'Lee'\n  }\n};\n\nref.setWithPriority(user,100);\n```\n\n----\n\n## setPriority()\n\n定义\n\nsetPriority ( priority , [onComplete] )\n\n说明\n\n设置当前节点的优先级，优先级可以是`Number`,也可以是`String` 。用来改当前节点在兄弟节点中的排序位置。这个排序会影响Snapshot.forEach()的顺序，同样也会影响`child_added`和`child_moved`事件中`prevChildName`参数。\n\n**节点按照如下规则排序**\n\n* 没有priority的排最先\n* 有数字 priority的次之，按照数值排序\n* 有字符串 priority的排最后，按照字母表的顺序排列\n* 当两个子节点有相同的 priority，它们按照名字进行排列，数字排在最先，字符串排最后\n\n参数\n\n* priority `String|Number` 优先级\n* onComplete `function(error)` 如果操作成功 `error`为`null`；否则,error 为包含错误码`code`的对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/users/jack\");\n\nref.setPriority(1000);\n```\n\n----\n\n## transaction()\n\n定义\n\ntransaction(updateFunction, [onComplete], [applyLocally])\n\n说明\n\n在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，transaction() 能够确保不同客户端在相同时间没有修改冲突。\n\n为了到达目的， 你通过 transaction() 的更新函数将的作用是把 current value 转换成 new value。当另外一个客户端在你之前先成功，你的更新函数将重新调用并带有 new current value。这过程一直重复直到写入成功或者不返回 value 来中止事务。\n\n如果需要， 你的 onComplete callback 将在事务完成后异步被调用。\n\n注意：在相同的路径上 使用 set() 和 transaction() , 极端情况下将出现不可预料的结果。\n\n参数\n\n* updateFunction `function`\n  更新数据的函数\n\n\n* onComplete `function(error, committed, snapshot)` \n 如果操作成功 `error`为`null`；否则,err为包含错误码`code`的对象。\n committed `boolean`  提交成功。\n snapshot `DataSnapShot` 事务完成后的数据快照。\n\n示例\n\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/users/fred/rank\");\n\nref.transaction(function(currentRank) {\n        // If /users/fred/rank 没有设置数据，currentRank 将会是 null 。\n\treturn currentRank+1;\n});\n```\n\n```js\n// 试图创建 wilma 的用户， 如果你的用户 'wilma' 已经存在，那退出事务\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar wilmaRef = wilddog.sync().ref(\"/samplechat/users/wilma\");\n\nwilmaRef.transaction(function(currentData) {\n  if (currentData === null) {\n    return { name: { first: 'Wilma', last: 'Flintstone' } };\n  } else {\n    console.log('用户 wilma 已经存在。');\n    return; // 退出事务\n  }\n}, function(error, committed, snapshot) {\n  if (error) {\n    console.log('Transaction 失败了!', error);\n  } else if (!committed) {\n    console.log('我们退出事务，因为用户wilma 已经存在。');\n  } else {\n    console.log('用户 wilma 已经添加!');\n  }\n  console.log(\"Wilma's data: \", snapshot.val());\n});\n```\n-----\n\n## goOnline()\n\n定义\n\nWilddog.goOnline()\n\n说明\n\n手动建立连接，开启自动重连。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\n\nwilddog.sync().goOffline(); // All local Wilddog instances are disconnected\nwilddog.sync().goOnline(); // All local Wildodg instances automatically reconnect\n```\n\n-----\n\n## goOffline()\n定义\n\nWilddog.goOffline()\n\n说明\n\n手动断开连接，关闭自动重连。\n\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\n\nwilddog.sync().goOffline(); // All local Wilddog instances are disconnected\n```\n---\n\n# Query (*Methods*)\n\n## on()\n\n定义\n\non ( type , callback , [cancelCallback] ， [context] )\n\n说明\n\n监听某个事件,注册回调函数。\n\n参数\n\n* type `String`\n\n>|事件|说明|\n|----|----|\n|value| 当有数据请求或有任何数据发生变化时触发|\n|child_added| 当有新增子节点时触发|\n|child_changed|当某个子节点发生变化时触发 |\n|child_removed|当有子节点被删除时触发 |\n|child_moved|当有子节排序发生变化时触发 |\n\n\n**callback** `function(snapshot[,prev])` \n`snapshot`  为`Snapshot` 类型,当监听到某事件时callback 会被执行. 在child_* 事件中会有prev参数。表示当前节点的上一个节点的key\n\n**cancelCallback** `function(error)`\n如果操作失败，这个函数会被调用。传入一个 `Error` 对象，包含为何失败的信息。\n\n**context** `Object`\n如果指定，你的回调函数中的this将代表这个对象\n\n示例\n\n```js\nref.on('child_added',function(snapshot,prev){\n  console.log(snapshot.val());\n  console.log(\"the previous key is\",prev)\n});\n```\n--------\n\n## off()\n\n定义\n\noff ( [type] , [callback] , [context] )\n\n说明\n\n取消监听事件。取消之前用`on()`注册的回调函数。\n\n参数\n\n* type `String` `value`,`child_added`,`child_changed`,`child_removed`,`child_moved`  之一\n* callback `function(snapshot)`  `on()` 中被传入的函数\n* context `Object`  `on()` 中被传入的context\n\n示例\n\n```js\nvar onValueChange = function(dataSnapshot) { /* handle... */ };\nwilddogRef.on('value', onValueChange);\n// Sometime later...\nwilddogRef.off('value', onValueChange);\n```\n```js\nvar onValueChange = wilddogRef.on('value', function(dataSnapshot) { /* handle... */ });\n// Sometime later...\nwilddogRef.off('value', onValueChange);\n```\n\n------\n\n## once()\n\n定义\n\nonce ( type , callback , [cancelCallbak] , [context] )\n\n说明\n\n同on 类似,不同之处在于 once中的回调函数只被执行一次。\n\n参数\n\n* type `String`\n\n>|事件|说明|\n|----|----|\n|value| 当有数据请求或有任何数据发生变化时触发|\n|child_added| 当有新增子节点时触发|\n|child_changed|当某个子节点发生变化时触发 |\n|child_removed|当有子节点被删除时触发 |\n|child_moved|当有子节排序发生变化时触发 |\n\n\n\n**callback** `function(snapshot[,prev])` \n`snapshot`  为`Snapshot` 类型,当监听到某事件时callback 会被执行. 在child_* 事件中会有prev参数。表示当前节点的上一个节点的key\n**cancelCallback** `function(error)`\n如果操作失败，这个函数会被调用。传入一个 `Error` 对象，包含为何失败的信息。\n**context** `Object`\n 如果指定，你的回调函数中的this将代表这个对象\n\n示例\n\n```js\nref.once('child_added',function(snapshot){\n  console.log(snapshot.val());\n});\n```\n\n----\n\n## orderByChild() \n\n定义\n\norderByChild ( key )\n\n说明\n\n产生一个新`Query`对象，按照特定子节点的值进行排序。排序的详情请参考[数据排序](/guide/sync/web/retrieve-data.html#数据排序)。\n\n参数\n\n* key `String`\n\n指定用来排序的子节点的key\n\n返回值\n\n* 新生成的`Query` 对象的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByChild(\"height\").on(\"child_added\",function(snapshot){\n  console.log(snapshot.key() + \"is\" + snapshot.val().height +\"meters tall\");\n});\n\n```\n----\n\n## orderByKey()\n\n定义\n\norderByKey()\n\n说明\n\n产生一个新`Query`对象，按照当前节点的key进行排序。\n\n返回值\n\n新生成的`Query` 对象的引用\n\n示例\n\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## orderByValue() \n\n定义\n\norderByValue()\n\n说明\n\n产生一个新`Query`对象，按照当前节点的值进行排序。排序的详情请参考[数据排序](/guide/sync/web/retrieve-data.html#数据排序)。\n\n返回值\n\n* 新生成的`Query` 对象的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"dinosaur-facts.wilddog.com\",\n  syncURL: \"https://dinosaur-facts.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar scoresRef = wilddog.sync().ref(\"scores\");\n\nscoresRef.orderByValue().limitToLast(3).on(\"value\", function(snapshot) {\n  snapshot.forEach(function(data) {\n    console.log(\"The \" + data.key() + \" score is \" + data.val());\n  });\n}\n\n```\n\n----\n\n## orderByPriority()\n\n定义\n\norderByPriority()\n\n说明\n\n产生一个新`Query`对象，按照当前节点的优先级排序。\n\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\nref.orderByPriority().on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key());\n});\n```\n----\n\n## startAt()\n\n定义\n\nstartAt ( value , [key] )\n\n说明\n\n创建一个大于等于的范围查询，可配合orderBy方式使用。\n\n参数\n\n* value `String |Number|Null|Boolean`  查询的起始值，类型取决于这个查询用到的 `orderBy*()`函数。如果与`orderByKey()` 组合的话，`value` 一定是一个`String`。\n* key `String`  起始子节点的key，只有在 `orderByPriority()`时有效。\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().startAt('jack').on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## endAt()\n\n定义\n\nendAt ( value , [key] )\n\n说明\n\n创建一个小于等于的范围查询，可配合orderBy方式使用。\n\n参数\n\n* value `String|Number|Null|Boolean` 查询的结束值，类型取决于这个查询用到的 `orderBy*()`函数。如果与`orderByKey()` 组合的话，`value` 一定时一个`String`。\n* key `String` 起始子节点的key，只有在 `orderByPriority()`时有效。\n\n\n返回值\n\n新生成的`Query` 对象\n\n示例\n\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().endAt('jack').on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## equalTo()\n\n定义\n\nequalTo ( value , [key] )\n\n说明\n\n创建一个等于的精确查询。\n\n参数\n\n* value `String|Number|Null|Boolean` 需要匹配的数值，类型取决于这个查询用到的 `orderBy*()`函数。如果与`orderByKey()` 组合的话，`value` 一定是一个`String`。\n* key `String` 起始子节点的key，只有在 `orderByPriority()`时有效。\n\n\n返回值\n\n新生成的`Query` 对象。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.orderByKey().equalTo('jack').on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## limitToFirst()\n\n定义\n\nlimitToFirst ( limit )\n\n说明\n\n创建一个新`Query`对象，获取从第一条（或startAt指定的位置）开始指定数量的子节点。\n\n参数\n\nlimit `Number` 这次查询能够获取的子节点的最大数量。\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n示例\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.limitToFirst(10).on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n\n----\n\n## limitToLast()\n\n定义\n\nlimitToLast ( limit )\n\n说明\n\n创建一个新`Query`对象，获取从最后一条（或endAt指定的位置）开始向前指定数量的子节点。\n\n参数\n\nlimit `Number` 这次查询能够获取的子节点的最大数量。\n\n\n返回值\n\n新生成的`Query` 对象的引用。\n\n\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nref.limitToLast(10).on(\"child_added\",function(snapshot){\n  console.log(snapshot.key());\n});\n```\n\n----\n\n## ref()\n\n定义\n\nref()\n\n说明\n\n获取这个查询的 `Wilddog` 引用\n\n返回值\n\n `Wilddog` 引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"student\");\n\nvar query=ref.limitToLast(10);\nvar locationRef=query.ref();//ref==locationRef\n```\n\n-----\n\n# Wilddog.onDisconnect (*Methods*)\n\n## set()\n\n定义\n\nset (value,[onComplete])\n\n说明\n\n当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。\n\n参数\n\n* value `Object,String,Number,Boolean,Null` 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）\n* onComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n返回值\n\n没有返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().set('I disconnected!');\n```\n----\n\n## update()\n\n定义\n\nupdate(value,[onComplete])\n\n说明\n\n当客户端断开连接后，指定的子节点将被写入到当前位置的子节点集合中。\n\n参数\n\n* value `Object` 包含要写入当前位置子节点的集合。\n* onComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().update({message:'I disconnected!'});\n```\n\n----\n\n## remove()\n\n定义\n\nremove([onComplete])\n\n说明\n\n当客户端断开连接后，删除当前位置上的数据。\n\n参数\n\nonComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().remove();\n```\n\n----\n\n## setWithPriority()\n\n定义\n\nsetWithPriority(value, priority, [onComplete])\n\n说明\n当客户端断开连接后，指定的数据和其优先级会被写入当前位置。\n\n\n参数\n\n* value `Object`, `String`, `Number`, `Boolean`, `Null` 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）\n* priority `String`,`Number` value的优先级\n* onComplete `Function *optional` 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar disconnectRef = wilddog.sync().ref(\"disconnectMessage\");\n\ndisconnectRef.onDisconnect().setWithPriority('I disconnected', 10);\n```\n\n----\n\n## cancel()\n\n定义\n\ncancel()\n\n说明\n\n取消之前所有注册的离线操作。\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar fredOnlineRef = wilddog.sync().ref(\"/users/fred/online\");\n\nfredOnlineRef.onDisconnect().set(false);\n// cancel the previously set onDisconnect().set() event\nfredOnlineRef.onDisconnect().cancel();\n```\n\n-----\n\n# Wilddog.ServerValue (*Constants*)\n\n## TIMESTAMP\n\n定义\n\nwilddog.sync().ServerValue.TIMESTAMP\n\n说明\n\n获取当前服务端的时间戳。\n\n\n返回值\n\n无返回值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar sessionsRef = wilddog.sync().ref(\"sessions\");\n\nvar mySessionRef = sessionsRef.push();\nmySessionRef.onDisconnect().update({ endedAt: wilddog.sync().ServerValue.TIMESTAMP });\nmySessionRef.update({ startedAt: wilddog.sync().ServerValue.TIMESTAMP });\n```\n----\n\n\n# DataSnapshot (*Methods*)\n\nDataSnapshot是当前时间,某个节点数据的副本,Snapshot不会随当前节点数据的变化而发生改变.\n用户不会主动创建一个DataSnapshot,而是和 on或once 配合使用.\n\n## exists()\n\n定义\n\nexists()\n\n说明\n\n如果Datasnapshot对象包含数据返回 true，否则返回false\n\n返回值\n\nDatasnapshot是否包含数据\n\n示例\n\n假如我们有以下数据：\n\n``` json\n{\n  \"name\" : {\n    \"first\" : \"Jim\",\n    \"last\" : \"Gordon\"\n  } \n}\n\n```\n\n我们可以用exists检测是否包含特定字节点\n\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/samplechat/users/jim\");\n\nref.once(\"value\", function(snapshot) {\n  var a = snapshot.exists();\n  // a === true\n\n  var b = snapshot.child(\"name\").exists();\n  // b === true\n\n  var c = snapshot.child(\"name/first\").exists();\n  // c === true\n\n  var d = snapshot.child(\"name/middle\").exists();\n  // d === false (because there is no \"name/middle\" child in the data snapshot)\n});\n\n\n```\n\n----\n\n## val()\n\n定义\n\nval()\n\n说明\n\n返回当前快照的数据\n\n返回值 \n\n`object|string|null|number|boolean` 当前快照的真实数据。\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tconsole.log(snapshot.val());\n\t//should output {\"pm25\":432}\n})\n```\n\n``` js\nref.update({\"pm25\":432})\n```\n----------\n\n## child()\n\n定义\n\nchild ( path )\n\n说明\n\n根据相对路径，来获取当前节点下子节点的快照。\n\n参数\n\npath `string` path为相对路径，多层级间需要使用\"/\"分隔，例如“a/b”。\n\n返回值 \n\n子节点的快照\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse{\n\t\tvar pm25=snapshot.child('pm25');\n\t\tconsole.log(\"The pm25 of Bejing is\",pm25.val())\n\t}\n})\n```\n``` js\nref.update({\"pm25\":432})\n```\n-----\n\n## forEach()\n\n定义\n\nforEach ( callback )\n\n说明\n\n遍历快照中每一个子节点,执行回调函数\n\n参数\n\ncallback `function(snap)`， snap:子节点快照\n\n示例\n\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on(\"value\",function(snapshot){\n\t\tsnapshot.forEach(function(snap){\n\t\tconsole.log(\"the\",snap.key(),\"of Bejing is:\",snap.val());\n     });\n});\n\n```\n``` js\nref.update({\"pm25\":432})\n```\n\n----\n\n## hasChild()\n\n定义\n\nhasChild ( key )\n\n说明\n\n检查是否存在某个子节点\n\n参数\n\nkey 输入参数,关注子节点的key\n\n返回值 \n `boolean`   `true` 子节点存在；`false` 子节点不存在\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse {\n\t\tif(snapshot.hasChild('pm25')){\n\t\t\tvar pm25=snapshot.child('pm25');\n\t\t\tconsole.log(\"The pm25 of Bejing is\",pm25.val());\n\t\t}\t\n\t}\n})\n```\n\n``` js\nref.update({\"pm25\":432})\n```\n\n----\n\n## hasChildren()\n\n定义\n\nhasChildren()\n\n说明\n\n如果 `Datasnapshot` 有任何子节点返回true，否则false。\n\n返回值\n\n`boolean` 如果snapshot 有任何子节点 `true` ,否则 `false`\n\n示例\n\n假设我们已经有如下的数据\n\n``` json\n{\n  \"name\": {\n    \"first\": \"Jim\",\n    \"last\": \"Gordon\"\n  }\n}\n\n```\n\n我们可以用 `hasChildren` 检测 `DataSnapshot` 是否包含任何子节点：\n\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/samplechat/users/jim\");\n\nref.once(\"value\", function(snapshot) {\n  var a = snapshot.hasChildren();\n  // a === true\n\n  var b = snapshot.child(\"name\").hasChildren();\n  // b === true\n\n  var c = snapshot.child(\"name/first\").hasChildren();\n  // c === false (because \"Fred\" is a string and therefore has no children)\n});\n```\n----\n\n## key()\n\n定义\n\n key()\n\n说明\n\n返回当前节点的key\n\n返回值 \n\n`string` 当前节点的key值\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse {\n\t\tif(snapshot.hasChild('pm25')){\n\t\t\tvar pm25=snapshot.child('pm25');\n\t\t\tvar key=snapshot.key();\n\t\t\tconsole.log(\"The \",pm25.key() ,\" of Bejing is\",pm25.val());\n\t\t}\t\n\t}\n})\n```\n----\n\n## numChildren()\n\n定义\n\nnumChildren()\n\n说明\n\n返回当前节点中子节点的个数\n\n返回值\n \n`string` 子节点的个数\n\n----\n\n## ref()\n\n定义\n\nref()\n\n说明\n\n返回当前Wilddog实例的引用\n\n返回值 \n\n当前Wilddog实例的引用\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/city/Beijing\");\n\nref.on('child_changed',function(snapshot){\n\tif(snapshot.val() == null){\n\t\t//has been deleted\n\t}\n\telse {\n\t\tif(snapshot.hasChild('pm25')){\n\t\t\tvar pm25=snapshot.child('pm25');\n\t\t\tvar key=snapshot.key();\n\t\t\tvar _ref=pm25.ref();\n\t\t\tif(pm25.val()>500){\n\t\t\t\t_ref.set(500);\n\t\t\t}\t\n\t\t}\t\n\t}\n})\n```\n\n----\n\n## getPriority()\n\n定义\n\ngetPriority()\n\n说明\n\n获取当前节点的优先级\n\n返回值\n\nStirng , Number , Null 优先级，或者不存在\n\n示例\n\n```js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/samplechat/users\");\n\nref.setWithPriority(\"fred\", 500, function(error) {\n  ref.once(\"value\", function(snapshot) {\n    var priority = snapshot.getPriority();\n    // priority === 500\n  });\n});\n```\n----\n\n\n## exportVal()\n\n\n定义\n\nexportVal()\n\n说明\n\n导出DataSnapshot中的内容到Javascript 对象，与 `val()`类似，不同之处在于exportVal 导出的数据包含优先级。\n\n返回值\n\nDataSnapshot 的内容\n\n示例\n\n``` js\nref.setWithPriority(\"hello\", 500, function(error) {\n  ref.once(\"value\", function(snapshot) {\n    var data = snapshot.exportVal();\n    // data is { \".value\": \"hello\", \".priority\": 500 }\n    // data[\".value\"] === \"hello\"\n    // data[\".priority\"] ===  500\n  });\n});\n```\n\n\n\n\n\n","date":"2016-09-06T03:38:22.517Z","updated":"2016-09-06T03:38:22.517Z","path":"api/sync/web.html","comments":1,"layout":"page","_id":"cisswi9jq000gz4fwj2d3petm","content":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"wilddog-init\"><a href=\"#wilddog-init\" class=\"headerlink\" title=\"wilddog init\"></a>wilddog init</h2><p>定义</p>\n<p>wilddog.initializeApp(config)</p>\n<p>说明</p>\n<p>初始化一个Wilddog客户端。</p>\n<p>参数</p>\n<p>wilddogUrl <code>string</code> 应用url 如：<code>https://&lt;appId&gt;.wilddogio.com</code><br>authDomain <code>string</code> Auth域 目前只支持<code>&lt;appId&gt;.wilddog.com</code></p>\n<p> 返回值</p>\n<p>Wilddog 对象的引用</p>\n<p> 示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> rootRef = wilddog.sync().ref();</div><div class=\"line\"><span class=\"comment\">//Good, 我们已经创建了一个野狗客户端。</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义</p>\n<p>child ( path )</p>\n<p>说明</p>\n<p>根据相对路径，来获取当前节点下子节点的引用</p>\n<p>参数</p>\n<p>path <code>String</code> </p>\n<p>path为相对路径，多层级间需要使用”/“分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。</p>\n<p>返回值</p>\n<p><code>Wilddog</code>子节点的引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"city\"</span>);</div><div class=\"line\"><span class=\"comment\">//ref refer to node &lt;appId&gt;.wilddogio.com/city</span></div><div class=\"line\"></div><div class=\"line\">child_ref = ref.child(<span class=\"string\">\"Beijing\"</span>);</div><div class=\"line\"><span class=\"comment\">//now child_ref refer to \"&lt;appId&gt;.wilddogio.com/city/Beijing\"</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent()\"></a>parent()</h2><p>定义</p>\n<p>parent()</p>\n<p>说明</p>\n<p>获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。</p>\n<p>返回值</p>\n<p><code>String</code> Wilddog 父节点的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent_ref = ref.parent();</div><div class=\"line\"><span class=\"comment\">//返回值 the refer to the father node of current</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"root()\"></a>root()</h2><p>定义</p>\n<p>root()</p>\n<p>说明</p>\n<p>获得<code>wilddog</code>根结点的引用</p>\n<p>返回值</p>\n<p><code>String</code> wilddog根节点的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"city\"</span>);</div><div class=\"line\"><span class=\"comment\">//ref refer to node &lt;appId&gt;.wilddogio.com/city</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> root_ref = ref.root();</div><div class=\"line\"><span class=\"keyword\">var</span> path = root_ref.toString();</div><div class=\"line\"><span class=\"comment\">//path is now 'https://&lt;appId&gt;.wilddogio.com'</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key()\"></a>key()</h2><p>定义</p>\n<p>key()</p>\n<p>说明</p>\n<p>获得当前路径下节点的名称。</p>\n<p>返回值</p>\n<p><code>String</code> 节点名称</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">child_ref = ref.child(<span class=\"string\">\"Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//返回值 the key to current node</span></div><div class=\"line\"><span class=\"keyword\">var</span> key = child_ref.key();</div><div class=\"line\"><span class=\"comment\">//key is 'Bejing'</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><p>定义</p>\n<p>toString()</p>\n<p>说明<br>获取当前节点的应用URL。</p>\n<p>返回值</p>\n<p><code>String</code> 当前节点的应用URL。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">child_ref = ref.child(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"><span class=\"comment\">//返回值 the key to current node</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> url = child_ref.toString();</div><div class=\"line\"><span class=\"comment\">//url should be https://&lt;appId&gt;.wilddogio.com/city/Beijing</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h2><p>定义</p>\n<p> set ( value , [oncomplete] )</p>\n<p>说明</p>\n<p>设置一个节点的值。<br>如果<code>value != null</code> ,当前节点上的数据会被value覆盖，如果中间路径不存在,Wilddog 会自动将中间路径补全。如果<code>value == null</code>,效果等同于remove操作。</p>\n<p>参数</p>\n<ul>\n<li>value <code>object|string|number|boolean|null</code> 将被写入的值。</li>\n<li>onComplete <code>function(error)</code> 如果操作成功 <code>error</code>为<code>null</code>；否则,error为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//the initial value is &#123;\"temp\":23,\"humidity\":30,\"wind\":2&#125;</span></div><div class=\"line\"></div><div class=\"line\">ref.set(&#123;<span class=\"string\">\"temp\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"pm25\"</span>:<span class=\"number\">500</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//the expected value of https://&lt;appId&gt;.wilddogio.com/city/Beijing should be &#123;\"temp\":10,\"pm25\":500&#125;</span></div><div class=\"line\"><span class=\"comment\">// or </span></div><div class=\"line\">ref.set(&#123;</div><div class=\"line\">    <span class=\"string\">\"temp\"</span>:<span class=\"number\">10</span>,</div><div class=\"line\">    <span class=\"string\">\"pm25\"</span>:<span class=\"number\">500</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">// set 数据到野狗云端成功</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update()\"></a>update()</h2><p>定义</p>\n<p>update ( value , [onComplete] )</p>\n<p>说明</p>\n<p>将输入对象的子节点合并到当前数据中。不存在的子节点将会被新增，存在子节点将会被替换。<br>与<code>set</code>操作不同,<code>update</code> 不会直接覆盖原来的节点,而是将<code>value</code> 中的所有子节点插入到已有的节点中,如果已有的节点中已经有同名子节点,则覆盖原有的子节点。<br><br><br>e.g. update之前 <code>{&quot;l1&quot;:&quot;on&quot;,&quot;l3&quot;:&quot;off&quot;}</code> ,<code>value={&quot;l1&quot;:&quot;off&quot;,&quot;l2&quot;:&quot;on&quot;}</code> update 后期望的数据是 <code>{&quot;l1&quot;:&quot;off&quot;,&quot;l2&quot;:&quot;on&quot;,&quot;l3&quot;:&quot;off&quot;}</code>。</p>\n<p>参数</p>\n<ul>\n<li>value <code>object</code>包含要合并子节点的对象</li>\n<li>onComplete <code>function(error)</code> 如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"><span class=\"comment\">//the initial value is &#123;\"temp\":23,\"humidity\":30,\"wind\":2&#125;</span></div><div class=\"line\"></div><div class=\"line\">ref.update(&#123;<span class=\"string\">\"temp\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"pm25\"</span>:<span class=\"number\">500</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//the expected value of https://&lt;appId&gt;.wilddogio.com/city/Beijing should be &#123;\"temp\":10,\"pm25\":500,\"humidity\":30,\"wind\":2&#125;</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p>定义</p>\n<p>remove ( [onComplete] )</p>\n<p>说明</p>\n<p>删除当前节点,效果等同于 <code>set(null,[onComplete])</code>,<br>如果父级节点只有当前节点一个子节点, 会递归删除父级节点。</p>\n<p>参数</p>\n<p>onComplete <code>function(error)</code>  如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//the initial value of https://&lt;appId&gt;.wilddogio.com is </span></div><div class=\"line\"><span class=\"comment\">//&#123;\"city\":&#123;\"Beijing\":&#123;\"temp\":23,\"humidity\":30,\"wind\":2&#125;&#125;&#125;</span></div><div class=\"line\"></div><div class=\"line\">ref.remove()</div><div class=\"line\"><span class=\"comment\">// value of https://&lt;appId&gt;.wilddogio.com is &#123;&#125;</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2><p>定义</p>\n<p>push (value , [oncomplete] )</p>\n<p>说明</p>\n<p>在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。</p>\n<p>参数</p>\n<ul>\n<li>value <code>object|string|number|boolean|null</code> 用户希望在当前节点下新增的数据.</li>\n<li>onComplete <code>function(error)</code>  如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>返回值</p>\n<p><code>String</code> 新插入子节点的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"users\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> childref = ref.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Thor\"</span>,<span class=\"string\">\"planet\"</span>:<span class=\"string\">\"Asgard\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> newKey = childref.key();</div><div class=\"line\"><span class=\"comment\">//newKey shoud look like a base64-like series eg -JmRhjbYk73IFRZ7</span></div><div class=\"line\"><span class=\"comment\">//th url of newKey shoud be https://&lt;appId&gt;.wilddogio.com/users/-JmRhjbYk73IFRZ7</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setWithPriority\"><a href=\"#setWithPriority\" class=\"headerlink\" title=\"setWithPriority()\"></a>setWithPriority()</h2><p>定义</p>\n<p>setWithPriority ( value , priority , [oncomplete] )</p>\n<p>说明</p>\n<p>把数据写到当前位置，类似set,不同之处是需要指定一个优先级。默认排序按照优先级排序。(参考排序规则的 <a href=\"/guide/sync/web/retrieve-data.html#排序规则\">orderByPriority</a> )</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object|String|Number|Boolean|Null</code> 将被写入的值。</li>\n<li>priority <code>String|Number</code> 优先级数据，节点的优先级是默认排序的依据。</li>\n<li>onComplete <code>function(error)</code>  如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/users/jack\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> user = &#123;</div><div class=\"line\">  name: &#123;</div><div class=\"line\">    first: <span class=\"string\">'jack'</span>,</div><div class=\"line\">    last: <span class=\"string\">'Lee'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ref.setWithPriority(user,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setPriority\"><a href=\"#setPriority\" class=\"headerlink\" title=\"setPriority()\"></a>setPriority()</h2><p>定义</p>\n<p>setPriority ( priority , [onComplete] )</p>\n<p>说明</p>\n<p>设置当前节点的优先级，优先级可以是<code>Number</code>,也可以是<code>String</code> 。用来改当前节点在兄弟节点中的排序位置。这个排序会影响Snapshot.forEach()的顺序，同样也会影响<code>child_added</code>和<code>child_moved</code>事件中<code>prevChildName</code>参数。</p>\n<p><strong>节点按照如下规则排序</strong></p>\n<ul>\n<li>没有priority的排最先</li>\n<li>有数字 priority的次之，按照数值排序</li>\n<li>有字符串 priority的排最后，按照字母表的顺序排列</li>\n<li>当两个子节点有相同的 priority，它们按照名字进行排列，数字排在最先，字符串排最后</li>\n</ul>\n<p>参数</p>\n<ul>\n<li>priority <code>String|Number</code> 优先级</li>\n<li>onComplete <code>function(error)</code> 如果操作成功 <code>error</code>为<code>null</code>；否则,error 为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/users/jack\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.setPriority(<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"transaction\"><a href=\"#transaction\" class=\"headerlink\" title=\"transaction()\"></a>transaction()</h2><p>定义</p>\n<p>transaction(updateFunction, [onComplete], [applyLocally])</p>\n<p>说明</p>\n<p>在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，transaction() 能够确保不同客户端在相同时间没有修改冲突。</p>\n<p>为了到达目的， 你通过 transaction() 的更新函数将的作用是把 current value 转换成 new value。当另外一个客户端在你之前先成功，你的更新函数将重新调用并带有 new current value。这过程一直重复直到写入成功或者不返回 value 来中止事务。</p>\n<p>如果需要， 你的 onComplete callback 将在事务完成后异步被调用。</p>\n<p>注意：在相同的路径上 使用 set() 和 transaction() , 极端情况下将出现不可预料的结果。</p>\n<p>参数</p>\n<ul>\n<li>updateFunction <code>function</code><br>更新数据的函数</li>\n</ul>\n<ul>\n<li>onComplete <code>function(error, committed, snapshot)</code><br>如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。<br>committed <code>boolean</code>  提交成功。<br>snapshot <code>DataSnapShot</code> 事务完成后的数据快照。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/users/fred/rank\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.transaction(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentRank</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// If /users/fred/rank 没有设置数据，currentRank 将会是 null 。</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> currentRank+<span class=\"number\">1</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 试图创建 wilma 的用户， 如果你的用户 'wilma' 已经存在，那退出事务</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> wilmaRef = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users/wilma\"</span>);</div><div class=\"line\"></div><div class=\"line\">wilmaRef.transaction(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (currentData === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; name: &#123; first: <span class=\"string\">'Wilma'</span>, last: <span class=\"string\">'Flintstone'</span> &#125; &#125;;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'用户 wilma 已经存在。'</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span>; <span class=\"comment\">// 退出事务</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, committed, snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Transaction 失败了!'</span>, error);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!committed) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'我们退出事务，因为用户wilma 已经存在。'</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'用户 wilma 已经添加!'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wilma's data: \"</span>, snapshot.val());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"goOnline\"><a href=\"#goOnline\" class=\"headerlink\" title=\"goOnline()\"></a>goOnline()</h2><p>定义</p>\n<p>Wilddog.goOnline()</p>\n<p>说明</p>\n<p>手动建立连接，开启自动重连。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"></div><div class=\"line\">wilddog.sync().goOffline(); <span class=\"comment\">// All local Wilddog instances are disconnected</span></div><div class=\"line\">wilddog.sync().goOnline(); <span class=\"comment\">// All local Wildodg instances automatically reconnect</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"goOffline\"><a href=\"#goOffline\" class=\"headerlink\" title=\"goOffline()\"></a>goOffline()</h2><p>定义</p>\n<p>Wilddog.goOffline()</p>\n<p>说明</p>\n<p>手动断开连接，关闭自动重连。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"></div><div class=\"line\">wilddog.sync().goOffline(); <span class=\"comment\">// All local Wilddog instances are disconnected</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Query-Methods\"><a href=\"#Query-Methods\" class=\"headerlink\" title=\"Query (Methods)\"></a>Query (<em>Methods</em>)</h1><h2 id=\"on\"><a href=\"#on\" class=\"headerlink\" title=\"on()\"></a>on()</h2><p>定义</p>\n<p>on ( type , callback , [cancelCallback] ， [context] )</p>\n<p>说明</p>\n<p>监听某个事件,注册回调函数。</p>\n<p>参数</p>\n<ul>\n<li>type <code>String</code></li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>当有数据请求或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>child_added</td>\n<td>当有新增子节点时触发</td>\n</tr>\n<tr>\n<td>child_changed</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>child_removed</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>child_moved</td>\n<td>当有子节排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>callback</strong> <code>function(snapshot[,prev])</code><br><code>snapshot</code>  为<code>Snapshot</code> 类型,当监听到某事件时callback 会被执行. 在child_* 事件中会有prev参数。表示当前节点的上一个节点的key</p>\n<p><strong>cancelCallback</strong> <code>function(error)</code><br>如果操作失败，这个函数会被调用。传入一个 <code>Error</code> 对象，包含为何失败的信息。</p>\n<p><strong>context</strong> <code>Object</code><br>如果指定，你的回调函数中的this将代表这个对象</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.on(<span class=\"string\">'child_added'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot,prev</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"the previous key is\"</span>,prev)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"off\"><a href=\"#off\" class=\"headerlink\" title=\"off()\"></a>off()</h2><p>定义</p>\n<p>off ( [type] , [callback] , [context] )</p>\n<p>说明</p>\n<p>取消监听事件。取消之前用<code>on()</code>注册的回调函数。</p>\n<p>参数</p>\n<ul>\n<li>type <code>String</code> <code>value</code>,<code>child_added</code>,<code>child_changed</code>,<code>child_removed</code>,<code>child_moved</code>  之一</li>\n<li>callback <code>function(snapshot)</code>  <code>on()</code> 中被传入的函数</li>\n<li>context <code>Object</code>  <code>on()</code> 中被传入的context</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> onValueChange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dataSnapshot</span>) </span>&#123; <span class=\"comment\">/* handle... */</span> &#125;;</div><div class=\"line\">wilddogRef.on(<span class=\"string\">'value'</span>, onValueChange);</div><div class=\"line\"><span class=\"comment\">// Sometime later...</span></div><div class=\"line\">wilddogRef.off(<span class=\"string\">'value'</span>, onValueChange);</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> onValueChange = wilddogRef.on(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dataSnapshot</span>) </span>&#123; <span class=\"comment\">/* handle... */</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// Sometime later...</span></div><div class=\"line\">wilddogRef.off(<span class=\"string\">'value'</span>, onValueChange);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"once\"><a href=\"#once\" class=\"headerlink\" title=\"once()\"></a>once()</h2><p>定义</p>\n<p>once ( type , callback , [cancelCallbak] , [context] )</p>\n<p>说明</p>\n<p>同on 类似,不同之处在于 once中的回调函数只被执行一次。</p>\n<p>参数</p>\n<ul>\n<li>type <code>String</code></li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>当有数据请求或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>child_added</td>\n<td>当有新增子节点时触发</td>\n</tr>\n<tr>\n<td>child_changed</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>child_removed</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>child_moved</td>\n<td>当有子节排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>callback</strong> <code>function(snapshot[,prev])</code><br><code>snapshot</code>  为<code>Snapshot</code> 类型,当监听到某事件时callback 会被执行. 在child_<em> 事件中会有prev参数。表示当前节点的上一个节点的key<br><strong>cancelCallback</strong> <code>function(error)</code><br>如果操作失败，这个函数会被调用。传入一个 <code>Error</code> 对象，包含为何失败的信息。<br><em>*context</em></em> <code>Object</code><br> 如果指定，你的回调函数中的this将代表这个对象</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.once(<span class=\"string\">'child_added'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByChild\"><a href=\"#orderByChild\" class=\"headerlink\" title=\"orderByChild()\"></a>orderByChild()</h2><p>定义</p>\n<p>orderByChild ( key )</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照特定子节点的值进行排序。排序的详情请参考<a href=\"/guide/sync/web/retrieve-data.html#数据排序\">数据排序</a>。</p>\n<p>参数</p>\n<ul>\n<li>key <code>String</code></li>\n</ul>\n<p>指定用来排序的子节点的key</p>\n<p>返回值</p>\n<ul>\n<li>新生成的<code>Query</code> 对象的引用</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByChild(<span class=\"string\">\"height\"</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\"is\"</span> + snapshot.val().height +<span class=\"string\">\"meters tall\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByKey\"><a href=\"#orderByKey\" class=\"headerlink\" title=\"orderByKey()\"></a>orderByKey()</h2><p>定义</p>\n<p>orderByKey()</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照当前节点的key进行排序。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByValue\"><a href=\"#orderByValue\" class=\"headerlink\" title=\"orderByValue()\"></a>orderByValue()</h2><p>定义</p>\n<p>orderByValue()</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照当前节点的值进行排序。排序的详情请参考<a href=\"/guide/sync/web/retrieve-data.html#数据排序\">数据排序</a>。</p>\n<p>返回值</p>\n<ul>\n<li>新生成的<code>Query</code> 对象的引用</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"dinosaur-facts.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://dinosaur-facts.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> scoresRef = wilddog.sync().ref(<span class=\"string\">\"scores\"</span>);</div><div class=\"line\"></div><div class=\"line\">scoresRef.orderByValue().limitToLast(<span class=\"number\">3</span>).on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  snapshot.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"The \"</span> + data.key() + <span class=\"string\">\" score is \"</span> + data.val());</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByPriority\"><a href=\"#orderByPriority\" class=\"headerlink\" title=\"orderByPriority()\"></a>orderByPriority()</h2><p>定义</p>\n<p>orderByPriority()</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照当前节点的优先级排序。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\">ref.orderByPriority().on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"startAt\"><a href=\"#startAt\" class=\"headerlink\" title=\"startAt()\"></a>startAt()</h2><p>定义</p>\n<p>startAt ( value , [key] )</p>\n<p>说明</p>\n<p>创建一个大于等于的范围查询，可配合orderBy方式使用。</p>\n<p>参数</p>\n<ul>\n<li>value <code>String |Number|Null|Boolean</code>  查询的起始值，类型取决于这个查询用到的 <code>orderBy*()</code>函数。如果与<code>orderByKey()</code> 组合的话，<code>value</code> 一定是一个<code>String</code>。</li>\n<li>key <code>String</code>  起始子节点的key，只有在 <code>orderByPriority()</code>时有效。</li>\n</ul>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().startAt(<span class=\"string\">'jack'</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"endAt\"><a href=\"#endAt\" class=\"headerlink\" title=\"endAt()\"></a>endAt()</h2><p>定义</p>\n<p>endAt ( value , [key] )</p>\n<p>说明</p>\n<p>创建一个小于等于的范围查询，可配合orderBy方式使用。</p>\n<p>参数</p>\n<ul>\n<li>value <code>String|Number|Null|Boolean</code> 查询的结束值，类型取决于这个查询用到的 <code>orderBy*()</code>函数。如果与<code>orderByKey()</code> 组合的话，<code>value</code> 一定时一个<code>String</code>。</li>\n<li>key <code>String</code> 起始子节点的key，只有在 <code>orderByPriority()</code>时有效。</li>\n</ul>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().endAt(<span class=\"string\">'jack'</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"equalTo\"><a href=\"#equalTo\" class=\"headerlink\" title=\"equalTo()\"></a>equalTo()</h2><p>定义</p>\n<p>equalTo ( value , [key] )</p>\n<p>说明</p>\n<p>创建一个等于的精确查询。</p>\n<p>参数</p>\n<ul>\n<li>value <code>String|Number|Null|Boolean</code> 需要匹配的数值，类型取决于这个查询用到的 <code>orderBy*()</code>函数。如果与<code>orderByKey()</code> 组合的话，<code>value</code> 一定是一个<code>String</code>。</li>\n<li>key <code>String</code> 起始子节点的key，只有在 <code>orderByPriority()</code>时有效。</li>\n</ul>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().equalTo(<span class=\"string\">'jack'</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"limitToFirst\"><a href=\"#limitToFirst\" class=\"headerlink\" title=\"limitToFirst()\"></a>limitToFirst()</h2><p>定义</p>\n<p>limitToFirst ( limit )</p>\n<p>说明</p>\n<p>创建一个新<code>Query</code>对象，获取从第一条（或startAt指定的位置）开始指定数量的子节点。</p>\n<p>参数</p>\n<p>limit <code>Number</code> 这次查询能够获取的子节点的最大数量。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.limitToFirst(<span class=\"number\">10</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"limitToLast\"><a href=\"#limitToLast\" class=\"headerlink\" title=\"limitToLast()\"></a>limitToLast()</h2><p>定义</p>\n<p>limitToLast ( limit )</p>\n<p>说明</p>\n<p>创建一个新<code>Query</code>对象，获取从最后一条（或endAt指定的位置）开始向前指定数量的子节点。</p>\n<p>参数</p>\n<p>limit <code>Number</code> 这次查询能够获取的子节点的最大数量。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.limitToLast(<span class=\"number\">10</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref()\"></a>ref()</h2><p>定义</p>\n<p>ref()</p>\n<p>说明</p>\n<p>获取这个查询的 <code>Wilddog</code> 引用</p>\n<p>返回值</p>\n<p> <code>Wilddog</code> 引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> query=ref.limitToLast(<span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> locationRef=query.ref();<span class=\"comment\">//ref==locationRef</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Wilddog-onDisconnect-Methods\"><a href=\"#Wilddog-onDisconnect-Methods\" class=\"headerlink\" title=\"Wilddog.onDisconnect (Methods)\"></a>Wilddog.onDisconnect (<em>Methods</em>)</h1><h2 id=\"set-1\"><a href=\"#set-1\" class=\"headerlink\" title=\"set()\"></a>set()</h2><p>定义</p>\n<p>set (value,[onComplete])</p>\n<p>说明</p>\n<p>当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object,String,Number,Boolean,Null</code> 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）</li>\n<li>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</li>\n</ul>\n<p>返回值</p>\n<p>没有返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().set(<span class=\"string\">'I disconnected!'</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"update-1\"><a href=\"#update-1\" class=\"headerlink\" title=\"update()\"></a>update()</h2><p>定义</p>\n<p>update(value,[onComplete])</p>\n<p>说明</p>\n<p>当客户端断开连接后，指定的子节点将被写入到当前位置的子节点集合中。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object</code> 包含要写入当前位置子节点的集合。</li>\n<li>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</li>\n</ul>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().update(&#123;message:<span class=\"string\">'I disconnected!'</span>&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"remove-1\"><a href=\"#remove-1\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p>定义</p>\n<p>remove([onComplete])</p>\n<p>说明</p>\n<p>当客户端断开连接后，删除当前位置上的数据。</p>\n<p>参数</p>\n<p>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</p>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().remove();</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setWithPriority-1\"><a href=\"#setWithPriority-1\" class=\"headerlink\" title=\"setWithPriority()\"></a>setWithPriority()</h2><p>定义</p>\n<p>setWithPriority(value, priority, [onComplete])</p>\n<p>说明<br>当客户端断开连接后，指定的数据和其优先级会被写入当前位置。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object</code>, <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Null</code> 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）</li>\n<li>priority <code>String</code>,<code>Number</code> value的优先级</li>\n<li>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</li>\n</ul>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().setWithPriority(<span class=\"string\">'I disconnected'</span>, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"cancel\"><a href=\"#cancel\" class=\"headerlink\" title=\"cancel()\"></a>cancel()</h2><p>定义</p>\n<p>cancel()</p>\n<p>说明</p>\n<p>取消之前所有注册的离线操作。</p>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> fredOnlineRef = wilddog.sync().ref(<span class=\"string\">\"/users/fred/online\"</span>);</div><div class=\"line\"></div><div class=\"line\">fredOnlineRef.onDisconnect().set(<span class=\"literal\">false</span>);</div><div class=\"line\"><span class=\"comment\">// cancel the previously set onDisconnect().set() event</span></div><div class=\"line\">fredOnlineRef.onDisconnect().cancel();</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Wilddog-ServerValue-Constants\"><a href=\"#Wilddog-ServerValue-Constants\" class=\"headerlink\" title=\"Wilddog.ServerValue (Constants)\"></a>Wilddog.ServerValue (<em>Constants</em>)</h1><h2 id=\"TIMESTAMP\"><a href=\"#TIMESTAMP\" class=\"headerlink\" title=\"TIMESTAMP\"></a>TIMESTAMP</h2><p>定义</p>\n<p>wilddog.sync().ServerValue.TIMESTAMP</p>\n<p>说明</p>\n<p>获取当前服务端的时间戳。</p>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> sessionsRef = wilddog.sync().ref(<span class=\"string\">\"sessions\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> mySessionRef = sessionsRef.push();</div><div class=\"line\">mySessionRef.onDisconnect().update(&#123; endedAt: wilddog.sync().ServerValue.TIMESTAMP &#125;);</div><div class=\"line\">mySessionRef.update(&#123; startedAt: wilddog.sync().ServerValue.TIMESTAMP &#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"DataSnapshot-Methods\"><a href=\"#DataSnapshot-Methods\" class=\"headerlink\" title=\"DataSnapshot (Methods)\"></a>DataSnapshot (<em>Methods</em>)</h1><p>DataSnapshot是当前时间,某个节点数据的副本,Snapshot不会随当前节点数据的变化而发生改变.<br>用户不会主动创建一个DataSnapshot,而是和 on或once 配合使用.</p>\n<h2 id=\"exists\"><a href=\"#exists\" class=\"headerlink\" title=\"exists()\"></a>exists()</h2><p>定义</p>\n<p>exists()</p>\n<p>说明</p>\n<p>如果Datasnapshot对象包含数据返回 true，否则返回false</p>\n<p>返回值</p>\n<p>Datasnapshot是否包含数据</p>\n<p>示例</p>\n<p>假如我们有以下数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span> : &#123;</div><div class=\"line\">    <span class=\"attr\">\"first\"</span> : <span class=\"string\">\"Jim\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"last\"</span> : <span class=\"string\">\"Gordon\"</span></div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以用exists检测是否包含特定字节点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users/jim\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = snapshot.exists();</div><div class=\"line\">  <span class=\"comment\">// a === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> b = snapshot.child(<span class=\"string\">\"name\"</span>).exists();</div><div class=\"line\">  <span class=\"comment\">// b === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> c = snapshot.child(<span class=\"string\">\"name/first\"</span>).exists();</div><div class=\"line\">  <span class=\"comment\">// c === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> d = snapshot.child(<span class=\"string\">\"name/middle\"</span>).exists();</div><div class=\"line\">  <span class=\"comment\">// d === false (because there is no \"name/middle\" child in the data snapshot)</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val()\"></a>val()</h2><p>定义</p>\n<p>val()</p>\n<p>说明</p>\n<p>返回当前快照的数据</p>\n<p>返回值 </p>\n<p><code>object|string|null|number|boolean</code> 当前快照的真实数据。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">\t<span class=\"comment\">//should output &#123;\"pm25\":432&#125;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"child-1\"><a href=\"#child-1\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义</p>\n<p>child ( path )</p>\n<p>说明</p>\n<p>根据相对路径，来获取当前节点下子节点的快照。</p>\n<p>参数</p>\n<p>path <code>string</code> path为相对路径，多层级间需要使用”/“分隔，例如“a/b”。</p>\n<p>返回值 </p>\n<p>子节点的快照</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"The pm25 of Bejing is\"</span>,pm25.val())</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h2><p>定义</p>\n<p>forEach ( callback )</p>\n<p>说明</p>\n<p>遍历快照中每一个子节点,执行回调函数</p>\n<p>参数</p>\n<p>callback <code>function(snap)</code>， snap:子节点快照</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">\"value\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t\tsnapshot.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"the\"</span>,snap.key(),<span class=\"string\">\"of Bejing is:\"</span>,snap.val());</div><div class=\"line\">     &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"hasChild\"><a href=\"#hasChild\" class=\"headerlink\" title=\"hasChild()\"></a>hasChild()</h2><p>定义</p>\n<p>hasChild ( key )</p>\n<p>说明</p>\n<p>检查是否存在某个子节点</p>\n<p>参数</p>\n<p>key 输入参数,关注子节点的key</p>\n<p>返回值<br> <code>boolean</code>   <code>true</code> 子节点存在；<code>false</code> 子节点不存在</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(snapshot.hasChild(<span class=\"string\">'pm25'</span>))&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"The pm25 of Bejing is\"</span>,pm25.val());</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"hasChildren\"><a href=\"#hasChildren\" class=\"headerlink\" title=\"hasChildren()\"></a>hasChildren()</h2><p>定义</p>\n<p>hasChildren()</p>\n<p>说明</p>\n<p>如果 <code>Datasnapshot</code> 有任何子节点返回true，否则false。</p>\n<p>返回值</p>\n<p><code>boolean</code> 如果snapshot 有任何子节点 <code>true</code> ,否则 <code>false</code></p>\n<p>示例</p>\n<p>假设我们已经有如下的数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Jim\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Gordon\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以用 <code>hasChildren</code> 检测 <code>DataSnapshot</code> 是否包含任何子节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users/jim\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = snapshot.hasChildren();</div><div class=\"line\">  <span class=\"comment\">// a === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> b = snapshot.child(<span class=\"string\">\"name\"</span>).hasChildren();</div><div class=\"line\">  <span class=\"comment\">// b === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> c = snapshot.child(<span class=\"string\">\"name/first\"</span>).hasChildren();</div><div class=\"line\">  <span class=\"comment\">// c === false (because \"Fred\" is a string and therefore has no children)</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"key-1\"><a href=\"#key-1\" class=\"headerlink\" title=\"key()\"></a>key()</h2><p>定义</p>\n<p> key()</p>\n<p>说明</p>\n<p>返回当前节点的key</p>\n<p>返回值 </p>\n<p><code>string</code> 当前节点的key值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(snapshot.hasChild(<span class=\"string\">'pm25'</span>))&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> key=snapshot.key();</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"The \"</span>,pm25.key() ,<span class=\"string\">\" of Bejing is\"</span>,pm25.val());</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"numChildren\"><a href=\"#numChildren\" class=\"headerlink\" title=\"numChildren()\"></a>numChildren()</h2><p>定义</p>\n<p>numChildren()</p>\n<p>说明</p>\n<p>返回当前节点中子节点的个数</p>\n<p>返回值</p>\n<p><code>string</code> 子节点的个数</p>\n<hr>\n<h2 id=\"ref-1\"><a href=\"#ref-1\" class=\"headerlink\" title=\"ref()\"></a>ref()</h2><p>定义</p>\n<p>ref()</p>\n<p>说明</p>\n<p>返回当前Wilddog实例的引用</p>\n<p>返回值 </p>\n<p>当前Wilddog实例的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(snapshot.hasChild(<span class=\"string\">'pm25'</span>))&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> key=snapshot.key();</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> _ref=pm25.ref();</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(pm25.val()&gt;<span class=\"number\">500</span>)&#123;</div><div class=\"line\">\t\t\t\t_ref.set(<span class=\"number\">500</span>);</div><div class=\"line\">\t\t\t&#125;\t</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"getPriority\"><a href=\"#getPriority\" class=\"headerlink\" title=\"getPriority()\"></a>getPriority()</h2><p>定义</p>\n<p>getPriority()</p>\n<p>说明</p>\n<p>获取当前节点的优先级</p>\n<p>返回值</p>\n<p>Stirng , Number , Null 优先级，或者不存在</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.setWithPriority(<span class=\"string\">\"fred\"</span>, <span class=\"number\">500</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> priority = snapshot.getPriority();</div><div class=\"line\">    <span class=\"comment\">// priority === 500</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"exportVal\"><a href=\"#exportVal\" class=\"headerlink\" title=\"exportVal()\"></a>exportVal()</h2><p>定义</p>\n<p>exportVal()</p>\n<p>说明</p>\n<p>导出DataSnapshot中的内容到Javascript 对象，与 <code>val()</code>类似，不同之处在于exportVal 导出的数据包含优先级。</p>\n<p>返回值</p>\n<p>DataSnapshot 的内容</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.setWithPriority(<span class=\"string\">\"hello\"</span>, <span class=\"number\">500</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = snapshot.exportVal();</div><div class=\"line\">    <span class=\"comment\">// data is &#123; \".value\": \"hello\", \".priority\": 500 &#125;</span></div><div class=\"line\">    <span class=\"comment\">// data[\".value\"] === \"hello\"</span></div><div class=\"line\">    <span class=\"comment\">// data[\".priority\"] ===  500</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Wilddog-Methods\"><a href=\"#Wilddog-Methods\" class=\"headerlink\" title=\"Wilddog (Methods)\"></a>Wilddog (<em>Methods</em>)</h1><h2 id=\"wilddog-init\"><a href=\"#wilddog-init\" class=\"headerlink\" title=\"wilddog init\"></a>wilddog init</h2><p>定义</p>\n<p>wilddog.initializeApp(config)</p>\n<p>说明</p>\n<p>初始化一个Wilddog客户端。</p>\n<p>参数</p>\n<p>wilddogUrl <code>string</code> 应用url 如：<code>https://&lt;appId&gt;.wilddogio.com</code><br>authDomain <code>string</code> Auth域 目前只支持<code>&lt;appId&gt;.wilddog.com</code></p>\n<p> 返回值</p>\n<p>Wilddog 对象的引用</p>\n<p> 示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> rootRef = wilddog.sync().ref();</div><div class=\"line\"><span class=\"comment\">//Good, 我们已经创建了一个野狗客户端。</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义</p>\n<p>child ( path )</p>\n<p>说明</p>\n<p>根据相对路径，来获取当前节点下子节点的引用</p>\n<p>参数</p>\n<p>path <code>String</code> </p>\n<p>path为相对路径，多层级间需要使用”/“分隔，例如“a/b”。如果path为空或null则返回当前引用。如果直接选取下一级节点，可以使用无分隔符(/)的节点名称表示，例如“a”。如果定位的path不存在，依然可以定位，后续数据操作的时候，将延迟动态创建不存在的路径节点。</p>\n<p>返回值</p>\n<p><code>Wilddog</code>子节点的引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"city\"</span>);</div><div class=\"line\"><span class=\"comment\">//ref refer to node &lt;appId&gt;.wilddogio.com/city</span></div><div class=\"line\"></div><div class=\"line\">child_ref = ref.child(<span class=\"string\">\"Beijing\"</span>);</div><div class=\"line\"><span class=\"comment\">//now child_ref refer to \"&lt;appId&gt;.wilddogio.com/city/Beijing\"</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent()\"></a>parent()</h2><p>定义</p>\n<p>parent()</p>\n<p>说明</p>\n<p>获取父节点的引用。如果当前节点就是root节点，方法执行后返回的依然是root节点的引用。</p>\n<p>返回值</p>\n<p><code>String</code> Wilddog 父节点的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> parent_ref = ref.parent();</div><div class=\"line\"><span class=\"comment\">//返回值 the refer to the father node of current</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"root\"><a href=\"#root\" class=\"headerlink\" title=\"root()\"></a>root()</h2><p>定义</p>\n<p>root()</p>\n<p>说明</p>\n<p>获得<code>wilddog</code>根结点的引用</p>\n<p>返回值</p>\n<p><code>String</code> wilddog根节点的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"city\"</span>);</div><div class=\"line\"><span class=\"comment\">//ref refer to node &lt;appId&gt;.wilddogio.com/city</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> root_ref = ref.root();</div><div class=\"line\"><span class=\"keyword\">var</span> path = root_ref.toString();</div><div class=\"line\"><span class=\"comment\">//path is now 'https://&lt;appId&gt;.wilddogio.com'</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key()\"></a>key()</h2><p>定义</p>\n<p>key()</p>\n<p>说明</p>\n<p>获得当前路径下节点的名称。</p>\n<p>返回值</p>\n<p><code>String</code> 节点名称</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">child_ref = ref.child(<span class=\"string\">\"Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//返回值 the key to current node</span></div><div class=\"line\"><span class=\"keyword\">var</span> key = child_ref.key();</div><div class=\"line\"><span class=\"comment\">//key is 'Bejing'</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><p>定义</p>\n<p>toString()</p>\n<p>说明<br>获取当前节点的应用URL。</p>\n<p>返回值</p>\n<p><code>String</code> 当前节点的应用URL。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">child_ref = ref.child(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"><span class=\"comment\">//返回值 the key to current node</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> url = child_ref.toString();</div><div class=\"line\"><span class=\"comment\">//url should be https://&lt;appId&gt;.wilddogio.com/city/Beijing</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h2><p>定义</p>\n<p> set ( value , [oncomplete] )</p>\n<p>说明</p>\n<p>设置一个节点的值。<br>如果<code>value != null</code> ,当前节点上的数据会被value覆盖，如果中间路径不存在,Wilddog 会自动将中间路径补全。如果<code>value == null</code>,效果等同于remove操作。</p>\n<p>参数</p>\n<ul>\n<li>value <code>object|string|number|boolean|null</code> 将被写入的值。</li>\n<li>onComplete <code>function(error)</code> 如果操作成功 <code>error</code>为<code>null</code>；否则,error为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//the initial value is &#123;\"temp\":23,\"humidity\":30,\"wind\":2&#125;</span></div><div class=\"line\"></div><div class=\"line\">ref.set(&#123;<span class=\"string\">\"temp\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"pm25\"</span>:<span class=\"number\">500</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//the expected value of https://&lt;appId&gt;.wilddogio.com/city/Beijing should be &#123;\"temp\":10,\"pm25\":500&#125;</span></div><div class=\"line\"><span class=\"comment\">// or </span></div><div class=\"line\">ref.set(&#123;</div><div class=\"line\">    <span class=\"string\">\"temp\"</span>:<span class=\"number\">10</span>,</div><div class=\"line\">    <span class=\"string\">\"pm25\"</span>:<span class=\"number\">500</span></div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">// set 数据到野狗云端成功</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update()\"></a>update()</h2><p>定义</p>\n<p>update ( value , [onComplete] )</p>\n<p>说明</p>\n<p>将输入对象的子节点合并到当前数据中。不存在的子节点将会被新增，存在子节点将会被替换。<br>与<code>set</code>操作不同,<code>update</code> 不会直接覆盖原来的节点,而是将<code>value</code> 中的所有子节点插入到已有的节点中,如果已有的节点中已经有同名子节点,则覆盖原有的子节点。<br><br><br>e.g. update之前 <code>{&quot;l1&quot;:&quot;on&quot;,&quot;l3&quot;:&quot;off&quot;}</code> ,<code>value={&quot;l1&quot;:&quot;off&quot;,&quot;l2&quot;:&quot;on&quot;}</code> update 后期望的数据是 <code>{&quot;l1&quot;:&quot;off&quot;,&quot;l2&quot;:&quot;on&quot;,&quot;l3&quot;:&quot;off&quot;}</code>。</p>\n<p>参数</p>\n<ul>\n<li>value <code>object</code>包含要合并子节点的对象</li>\n<li>onComplete <code>function(error)</code> 如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"><span class=\"comment\">//the initial value is &#123;\"temp\":23,\"humidity\":30,\"wind\":2&#125;</span></div><div class=\"line\"></div><div class=\"line\">ref.update(&#123;<span class=\"string\">\"temp\"</span>:<span class=\"number\">10</span>,<span class=\"string\">\"pm25\"</span>:<span class=\"number\">500</span>&#125;);</div><div class=\"line\"><span class=\"comment\">//the expected value of https://&lt;appId&gt;.wilddogio.com/city/Beijing should be &#123;\"temp\":10,\"pm25\":500,\"humidity\":30,\"wind\":2&#125;</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p>定义</p>\n<p>remove ( [onComplete] )</p>\n<p>说明</p>\n<p>删除当前节点,效果等同于 <code>set(null,[onComplete])</code>,<br>如果父级节点只有当前节点一个子节点, 会递归删除父级节点。</p>\n<p>参数</p>\n<p>onComplete <code>function(error)</code>  如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//the initial value of https://&lt;appId&gt;.wilddogio.com is </span></div><div class=\"line\"><span class=\"comment\">//&#123;\"city\":&#123;\"Beijing\":&#123;\"temp\":23,\"humidity\":30,\"wind\":2&#125;&#125;&#125;</span></div><div class=\"line\"></div><div class=\"line\">ref.remove()</div><div class=\"line\"><span class=\"comment\">// value of https://&lt;appId&gt;.wilddogio.com is &#123;&#125;</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2><p>定义</p>\n<p>push (value , [oncomplete] )</p>\n<p>说明</p>\n<p>在当前节点下生成一个子节点，并返回子节点的引用。子节点的key利用服务端的当前时间生成，可作为排序使用。</p>\n<p>参数</p>\n<ul>\n<li>value <code>object|string|number|boolean|null</code> 用户希望在当前节点下新增的数据.</li>\n<li>onComplete <code>function(error)</code>  如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>返回值</p>\n<p><code>String</code> 新插入子节点的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"users\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> childref = ref.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"Thor\"</span>,<span class=\"string\">\"planet\"</span>:<span class=\"string\">\"Asgard\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> newKey = childref.key();</div><div class=\"line\"><span class=\"comment\">//newKey shoud look like a base64-like series eg -JmRhjbYk73IFRZ7</span></div><div class=\"line\"><span class=\"comment\">//th url of newKey shoud be https://&lt;appId&gt;.wilddogio.com/users/-JmRhjbYk73IFRZ7</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setWithPriority\"><a href=\"#setWithPriority\" class=\"headerlink\" title=\"setWithPriority()\"></a>setWithPriority()</h2><p>定义</p>\n<p>setWithPriority ( value , priority , [oncomplete] )</p>\n<p>说明</p>\n<p>把数据写到当前位置，类似set,不同之处是需要指定一个优先级。默认排序按照优先级排序。(参考排序规则的 <a href=\"/guide/sync/web/retrieve-data.html#排序规则\">orderByPriority</a> )</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object|String|Number|Boolean|Null</code> 将被写入的值。</li>\n<li>priority <code>String|Number</code> 优先级数据，节点的优先级是默认排序的依据。</li>\n<li>onComplete <code>function(error)</code>  如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/users/jack\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> user = &#123;</div><div class=\"line\">  name: &#123;</div><div class=\"line\">    first: <span class=\"string\">'jack'</span>,</div><div class=\"line\">    last: <span class=\"string\">'Lee'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ref.setWithPriority(user,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setPriority\"><a href=\"#setPriority\" class=\"headerlink\" title=\"setPriority()\"></a>setPriority()</h2><p>定义</p>\n<p>setPriority ( priority , [onComplete] )</p>\n<p>说明</p>\n<p>设置当前节点的优先级，优先级可以是<code>Number</code>,也可以是<code>String</code> 。用来改当前节点在兄弟节点中的排序位置。这个排序会影响Snapshot.forEach()的顺序，同样也会影响<code>child_added</code>和<code>child_moved</code>事件中<code>prevChildName</code>参数。</p>\n<p><strong>节点按照如下规则排序</strong></p>\n<ul>\n<li>没有priority的排最先</li>\n<li>有数字 priority的次之，按照数值排序</li>\n<li>有字符串 priority的排最后，按照字母表的顺序排列</li>\n<li>当两个子节点有相同的 priority，它们按照名字进行排列，数字排在最先，字符串排最后</li>\n</ul>\n<p>参数</p>\n<ul>\n<li>priority <code>String|Number</code> 优先级</li>\n<li>onComplete <code>function(error)</code> 如果操作成功 <code>error</code>为<code>null</code>；否则,error 为包含错误码<code>code</code>的对象。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/users/jack\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.setPriority(<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"transaction\"><a href=\"#transaction\" class=\"headerlink\" title=\"transaction()\"></a>transaction()</h2><p>定义</p>\n<p>transaction(updateFunction, [onComplete], [applyLocally])</p>\n<p>说明</p>\n<p>在当前路径下，自动修改数据。与 set() 不同，直接覆盖以前的数据，transaction() 能够确保不同客户端在相同时间没有修改冲突。</p>\n<p>为了到达目的， 你通过 transaction() 的更新函数将的作用是把 current value 转换成 new value。当另外一个客户端在你之前先成功，你的更新函数将重新调用并带有 new current value。这过程一直重复直到写入成功或者不返回 value 来中止事务。</p>\n<p>如果需要， 你的 onComplete callback 将在事务完成后异步被调用。</p>\n<p>注意：在相同的路径上 使用 set() 和 transaction() , 极端情况下将出现不可预料的结果。</p>\n<p>参数</p>\n<ul>\n<li>updateFunction <code>function</code><br>更新数据的函数</li>\n</ul>\n<ul>\n<li>onComplete <code>function(error, committed, snapshot)</code><br>如果操作成功 <code>error</code>为<code>null</code>；否则,err为包含错误码<code>code</code>的对象。<br>committed <code>boolean</code>  提交成功。<br>snapshot <code>DataSnapShot</code> 事务完成后的数据快照。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/users/fred/rank\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.transaction(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentRank</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// If /users/fred/rank 没有设置数据，currentRank 将会是 null 。</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> currentRank+<span class=\"number\">1</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 试图创建 wilma 的用户， 如果你的用户 'wilma' 已经存在，那退出事务</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> wilmaRef = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users/wilma\"</span>);</div><div class=\"line\"></div><div class=\"line\">wilmaRef.transaction(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentData</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (currentData === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123; name: &#123; first: <span class=\"string\">'Wilma'</span>, last: <span class=\"string\">'Flintstone'</span> &#125; &#125;;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'用户 wilma 已经存在。'</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span>; <span class=\"comment\">// 退出事务</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, committed, snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Transaction 失败了!'</span>, error);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!committed) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'我们退出事务，因为用户wilma 已经存在。'</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'用户 wilma 已经添加!'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Wilma's data: \"</span>, snapshot.val());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"goOnline\"><a href=\"#goOnline\" class=\"headerlink\" title=\"goOnline()\"></a>goOnline()</h2><p>定义</p>\n<p>Wilddog.goOnline()</p>\n<p>说明</p>\n<p>手动建立连接，开启自动重连。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"></div><div class=\"line\">wilddog.sync().goOffline(); <span class=\"comment\">// All local Wilddog instances are disconnected</span></div><div class=\"line\">wilddog.sync().goOnline(); <span class=\"comment\">// All local Wildodg instances automatically reconnect</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"goOffline\"><a href=\"#goOffline\" class=\"headerlink\" title=\"goOffline()\"></a>goOffline()</h2><p>定义</p>\n<p>Wilddog.goOffline()</p>\n<p>说明</p>\n<p>手动断开连接，关闭自动重连。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"></div><div class=\"line\">wilddog.sync().goOffline(); <span class=\"comment\">// All local Wilddog instances are disconnected</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Query-Methods\"><a href=\"#Query-Methods\" class=\"headerlink\" title=\"Query (Methods)\"></a>Query (<em>Methods</em>)</h1><h2 id=\"on\"><a href=\"#on\" class=\"headerlink\" title=\"on()\"></a>on()</h2><p>定义</p>\n<p>on ( type , callback , [cancelCallback] ， [context] )</p>\n<p>说明</p>\n<p>监听某个事件,注册回调函数。</p>\n<p>参数</p>\n<ul>\n<li>type <code>String</code></li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>当有数据请求或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>child_added</td>\n<td>当有新增子节点时触发</td>\n</tr>\n<tr>\n<td>child_changed</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>child_removed</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>child_moved</td>\n<td>当有子节排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>callback</strong> <code>function(snapshot[,prev])</code><br><code>snapshot</code>  为<code>Snapshot</code> 类型,当监听到某事件时callback 会被执行. 在child_* 事件中会有prev参数。表示当前节点的上一个节点的key</p>\n<p><strong>cancelCallback</strong> <code>function(error)</code><br>如果操作失败，这个函数会被调用。传入一个 <code>Error</code> 对象，包含为何失败的信息。</p>\n<p><strong>context</strong> <code>Object</code><br>如果指定，你的回调函数中的this将代表这个对象</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.on(<span class=\"string\">'child_added'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot,prev</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"the previous key is\"</span>,prev)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"off\"><a href=\"#off\" class=\"headerlink\" title=\"off()\"></a>off()</h2><p>定义</p>\n<p>off ( [type] , [callback] , [context] )</p>\n<p>说明</p>\n<p>取消监听事件。取消之前用<code>on()</code>注册的回调函数。</p>\n<p>参数</p>\n<ul>\n<li>type <code>String</code> <code>value</code>,<code>child_added</code>,<code>child_changed</code>,<code>child_removed</code>,<code>child_moved</code>  之一</li>\n<li>callback <code>function(snapshot)</code>  <code>on()</code> 中被传入的函数</li>\n<li>context <code>Object</code>  <code>on()</code> 中被传入的context</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> onValueChange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dataSnapshot</span>) </span>&#123; <span class=\"comment\">/* handle... */</span> &#125;;</div><div class=\"line\">wilddogRef.on(<span class=\"string\">'value'</span>, onValueChange);</div><div class=\"line\"><span class=\"comment\">// Sometime later...</span></div><div class=\"line\">wilddogRef.off(<span class=\"string\">'value'</span>, onValueChange);</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> onValueChange = wilddogRef.on(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dataSnapshot</span>) </span>&#123; <span class=\"comment\">/* handle... */</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// Sometime later...</span></div><div class=\"line\">wilddogRef.off(<span class=\"string\">'value'</span>, onValueChange);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"once\"><a href=\"#once\" class=\"headerlink\" title=\"once()\"></a>once()</h2><p>定义</p>\n<p>once ( type , callback , [cancelCallbak] , [context] )</p>\n<p>说明</p>\n<p>同on 类似,不同之处在于 once中的回调函数只被执行一次。</p>\n<p>参数</p>\n<ul>\n<li>type <code>String</code></li>\n</ul>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>当有数据请求或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>child_added</td>\n<td>当有新增子节点时触发</td>\n</tr>\n<tr>\n<td>child_changed</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>child_removed</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>child_moved</td>\n<td>当有子节排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>callback</strong> <code>function(snapshot[,prev])</code><br><code>snapshot</code>  为<code>Snapshot</code> 类型,当监听到某事件时callback 会被执行. 在child_<em> 事件中会有prev参数。表示当前节点的上一个节点的key<br><strong>cancelCallback</strong> <code>function(error)</code><br>如果操作失败，这个函数会被调用。传入一个 <code>Error</code> 对象，包含为何失败的信息。<br><em>*context</em></em> <code>Object</code><br> 如果指定，你的回调函数中的this将代表这个对象</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.once(<span class=\"string\">'child_added'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByChild\"><a href=\"#orderByChild\" class=\"headerlink\" title=\"orderByChild()\"></a>orderByChild()</h2><p>定义</p>\n<p>orderByChild ( key )</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照特定子节点的值进行排序。排序的详情请参考<a href=\"/guide/sync/web/retrieve-data.html#数据排序\">数据排序</a>。</p>\n<p>参数</p>\n<ul>\n<li>key <code>String</code></li>\n</ul>\n<p>指定用来排序的子节点的key</p>\n<p>返回值</p>\n<ul>\n<li>新生成的<code>Query</code> 对象的引用</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByChild(<span class=\"string\">\"height\"</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\"is\"</span> + snapshot.val().height +<span class=\"string\">\"meters tall\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByKey\"><a href=\"#orderByKey\" class=\"headerlink\" title=\"orderByKey()\"></a>orderByKey()</h2><p>定义</p>\n<p>orderByKey()</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照当前节点的key进行排序。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByValue\"><a href=\"#orderByValue\" class=\"headerlink\" title=\"orderByValue()\"></a>orderByValue()</h2><p>定义</p>\n<p>orderByValue()</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照当前节点的值进行排序。排序的详情请参考<a href=\"/guide/sync/web/retrieve-data.html#数据排序\">数据排序</a>。</p>\n<p>返回值</p>\n<ul>\n<li>新生成的<code>Query</code> 对象的引用</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"dinosaur-facts.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://dinosaur-facts.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> scoresRef = wilddog.sync().ref(<span class=\"string\">\"scores\"</span>);</div><div class=\"line\"></div><div class=\"line\">scoresRef.orderByValue().limitToLast(<span class=\"number\">3</span>).on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  snapshot.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"The \"</span> + data.key() + <span class=\"string\">\" score is \"</span> + data.val());</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"orderByPriority\"><a href=\"#orderByPriority\" class=\"headerlink\" title=\"orderByPriority()\"></a>orderByPriority()</h2><p>定义</p>\n<p>orderByPriority()</p>\n<p>说明</p>\n<p>产生一个新<code>Query</code>对象，按照当前节点的优先级排序。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\">ref.orderByPriority().on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"startAt\"><a href=\"#startAt\" class=\"headerlink\" title=\"startAt()\"></a>startAt()</h2><p>定义</p>\n<p>startAt ( value , [key] )</p>\n<p>说明</p>\n<p>创建一个大于等于的范围查询，可配合orderBy方式使用。</p>\n<p>参数</p>\n<ul>\n<li>value <code>String |Number|Null|Boolean</code>  查询的起始值，类型取决于这个查询用到的 <code>orderBy*()</code>函数。如果与<code>orderByKey()</code> 组合的话，<code>value</code> 一定是一个<code>String</code>。</li>\n<li>key <code>String</code>  起始子节点的key，只有在 <code>orderByPriority()</code>时有效。</li>\n</ul>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().startAt(<span class=\"string\">'jack'</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"endAt\"><a href=\"#endAt\" class=\"headerlink\" title=\"endAt()\"></a>endAt()</h2><p>定义</p>\n<p>endAt ( value , [key] )</p>\n<p>说明</p>\n<p>创建一个小于等于的范围查询，可配合orderBy方式使用。</p>\n<p>参数</p>\n<ul>\n<li>value <code>String|Number|Null|Boolean</code> 查询的结束值，类型取决于这个查询用到的 <code>orderBy*()</code>函数。如果与<code>orderByKey()</code> 组合的话，<code>value</code> 一定时一个<code>String</code>。</li>\n<li>key <code>String</code> 起始子节点的key，只有在 <code>orderByPriority()</code>时有效。</li>\n</ul>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().endAt(<span class=\"string\">'jack'</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"equalTo\"><a href=\"#equalTo\" class=\"headerlink\" title=\"equalTo()\"></a>equalTo()</h2><p>定义</p>\n<p>equalTo ( value , [key] )</p>\n<p>说明</p>\n<p>创建一个等于的精确查询。</p>\n<p>参数</p>\n<ul>\n<li>value <code>String|Number|Null|Boolean</code> 需要匹配的数值，类型取决于这个查询用到的 <code>orderBy*()</code>函数。如果与<code>orderByKey()</code> 组合的话，<code>value</code> 一定是一个<code>String</code>。</li>\n<li>key <code>String</code> 起始子节点的key，只有在 <code>orderByPriority()</code>时有效。</li>\n</ul>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.orderByKey().equalTo(<span class=\"string\">'jack'</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"limitToFirst\"><a href=\"#limitToFirst\" class=\"headerlink\" title=\"limitToFirst()\"></a>limitToFirst()</h2><p>定义</p>\n<p>limitToFirst ( limit )</p>\n<p>说明</p>\n<p>创建一个新<code>Query</code>对象，获取从第一条（或startAt指定的位置）开始指定数量的子节点。</p>\n<p>参数</p>\n<p>limit <code>Number</code> 这次查询能够获取的子节点的最大数量。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.limitToFirst(<span class=\"number\">10</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"limitToLast\"><a href=\"#limitToLast\" class=\"headerlink\" title=\"limitToLast()\"></a>limitToLast()</h2><p>定义</p>\n<p>limitToLast ( limit )</p>\n<p>说明</p>\n<p>创建一个新<code>Query</code>对象，获取从最后一条（或endAt指定的位置）开始向前指定数量的子节点。</p>\n<p>参数</p>\n<p>limit <code>Number</code> 这次查询能够获取的子节点的最大数量。</p>\n<p>返回值</p>\n<p>新生成的<code>Query</code> 对象的引用。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.limitToLast(<span class=\"number\">10</span>).on(<span class=\"string\">\"child_added\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref()\"></a>ref()</h2><p>定义</p>\n<p>ref()</p>\n<p>说明</p>\n<p>获取这个查询的 <code>Wilddog</code> 引用</p>\n<p>返回值</p>\n<p> <code>Wilddog</code> 引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"student\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> query=ref.limitToLast(<span class=\"number\">10</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> locationRef=query.ref();<span class=\"comment\">//ref==locationRef</span></div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Wilddog-onDisconnect-Methods\"><a href=\"#Wilddog-onDisconnect-Methods\" class=\"headerlink\" title=\"Wilddog.onDisconnect (Methods)\"></a>Wilddog.onDisconnect (<em>Methods</em>)</h1><h2 id=\"set-1\"><a href=\"#set-1\" class=\"headerlink\" title=\"set()\"></a>set()</h2><p>定义</p>\n<p>set (value,[onComplete])</p>\n<p>说明</p>\n<p>当客户端断开连接后，保证在地址上的数据被设置到一个指定的值。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object,String,Number,Boolean,Null</code> 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）</li>\n<li>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</li>\n</ul>\n<p>返回值</p>\n<p>没有返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().set(<span class=\"string\">'I disconnected!'</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"update-1\"><a href=\"#update-1\" class=\"headerlink\" title=\"update()\"></a>update()</h2><p>定义</p>\n<p>update(value,[onComplete])</p>\n<p>说明</p>\n<p>当客户端断开连接后，指定的子节点将被写入到当前位置的子节点集合中。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object</code> 包含要写入当前位置子节点的集合。</li>\n<li>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</li>\n</ul>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().update(&#123;message:<span class=\"string\">'I disconnected!'</span>&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"remove-1\"><a href=\"#remove-1\" class=\"headerlink\" title=\"remove()\"></a>remove()</h2><p>定义</p>\n<p>remove([onComplete])</p>\n<p>说明</p>\n<p>当客户端断开连接后，删除当前位置上的数据。</p>\n<p>参数</p>\n<p>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</p>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().remove();</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"setWithPriority-1\"><a href=\"#setWithPriority-1\" class=\"headerlink\" title=\"setWithPriority()\"></a>setWithPriority()</h2><p>定义</p>\n<p>setWithPriority(value, priority, [onComplete])</p>\n<p>说明<br>当客户端断开连接后，指定的数据和其优先级会被写入当前位置。</p>\n<p>参数</p>\n<ul>\n<li>value <code>Object</code>, <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Null</code> 在连接中断时需要写入当前位置的值（可以是对象，数组，字符串，数组，布尔型或null）</li>\n<li>priority <code>String</code>,<code>Number</code> value的优先级</li>\n<li>onComplete <code>Function *optional</code> 一个可选参数。当与服务端同步结束后会被调用，函数被调用时会传入一个参数：传入null代表成功，传入一个Error对象代表失败。</li>\n</ul>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> disconnectRef = wilddog.sync().ref(<span class=\"string\">\"disconnectMessage\"</span>);</div><div class=\"line\"></div><div class=\"line\">disconnectRef.onDisconnect().setWithPriority(<span class=\"string\">'I disconnected'</span>, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"cancel\"><a href=\"#cancel\" class=\"headerlink\" title=\"cancel()\"></a>cancel()</h2><p>定义</p>\n<p>cancel()</p>\n<p>说明</p>\n<p>取消之前所有注册的离线操作。</p>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> fredOnlineRef = wilddog.sync().ref(<span class=\"string\">\"/users/fred/online\"</span>);</div><div class=\"line\"></div><div class=\"line\">fredOnlineRef.onDisconnect().set(<span class=\"literal\">false</span>);</div><div class=\"line\"><span class=\"comment\">// cancel the previously set onDisconnect().set() event</span></div><div class=\"line\">fredOnlineRef.onDisconnect().cancel();</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Wilddog-ServerValue-Constants\"><a href=\"#Wilddog-ServerValue-Constants\" class=\"headerlink\" title=\"Wilddog.ServerValue (Constants)\"></a>Wilddog.ServerValue (<em>Constants</em>)</h1><h2 id=\"TIMESTAMP\"><a href=\"#TIMESTAMP\" class=\"headerlink\" title=\"TIMESTAMP\"></a>TIMESTAMP</h2><p>定义</p>\n<p>wilddog.sync().ServerValue.TIMESTAMP</p>\n<p>说明</p>\n<p>获取当前服务端的时间戳。</p>\n<p>返回值</p>\n<p>无返回值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> sessionsRef = wilddog.sync().ref(<span class=\"string\">\"sessions\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> mySessionRef = sessionsRef.push();</div><div class=\"line\">mySessionRef.onDisconnect().update(&#123; endedAt: wilddog.sync().ServerValue.TIMESTAMP &#125;);</div><div class=\"line\">mySessionRef.update(&#123; startedAt: wilddog.sync().ServerValue.TIMESTAMP &#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"DataSnapshot-Methods\"><a href=\"#DataSnapshot-Methods\" class=\"headerlink\" title=\"DataSnapshot (Methods)\"></a>DataSnapshot (<em>Methods</em>)</h1><p>DataSnapshot是当前时间,某个节点数据的副本,Snapshot不会随当前节点数据的变化而发生改变.<br>用户不会主动创建一个DataSnapshot,而是和 on或once 配合使用.</p>\n<h2 id=\"exists\"><a href=\"#exists\" class=\"headerlink\" title=\"exists()\"></a>exists()</h2><p>定义</p>\n<p>exists()</p>\n<p>说明</p>\n<p>如果Datasnapshot对象包含数据返回 true，否则返回false</p>\n<p>返回值</p>\n<p>Datasnapshot是否包含数据</p>\n<p>示例</p>\n<p>假如我们有以下数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span> : &#123;</div><div class=\"line\">    <span class=\"attr\">\"first\"</span> : <span class=\"string\">\"Jim\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"last\"</span> : <span class=\"string\">\"Gordon\"</span></div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以用exists检测是否包含特定字节点</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users/jim\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = snapshot.exists();</div><div class=\"line\">  <span class=\"comment\">// a === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> b = snapshot.child(<span class=\"string\">\"name\"</span>).exists();</div><div class=\"line\">  <span class=\"comment\">// b === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> c = snapshot.child(<span class=\"string\">\"name/first\"</span>).exists();</div><div class=\"line\">  <span class=\"comment\">// c === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> d = snapshot.child(<span class=\"string\">\"name/middle\"</span>).exists();</div><div class=\"line\">  <span class=\"comment\">// d === false (because there is no \"name/middle\" child in the data snapshot)</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val()\"></a>val()</h2><p>定义</p>\n<p>val()</p>\n<p>说明</p>\n<p>返回当前快照的数据</p>\n<p>返回值 </p>\n<p><code>object|string|null|number|boolean</code> 当前快照的真实数据。</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">\t<span class=\"comment\">//should output &#123;\"pm25\":432&#125;</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"child-1\"><a href=\"#child-1\" class=\"headerlink\" title=\"child()\"></a>child()</h2><p>定义</p>\n<p>child ( path )</p>\n<p>说明</p>\n<p>根据相对路径，来获取当前节点下子节点的快照。</p>\n<p>参数</p>\n<p>path <code>string</code> path为相对路径，多层级间需要使用”/“分隔，例如“a/b”。</p>\n<p>返回值 </p>\n<p>子节点的快照</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"The pm25 of Bejing is\"</span>,pm25.val())</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h2><p>定义</p>\n<p>forEach ( callback )</p>\n<p>说明</p>\n<p>遍历快照中每一个子节点,执行回调函数</p>\n<p>参数</p>\n<p>callback <code>function(snap)</code>， snap:子节点快照</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">\"value\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t\tsnapshot.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"the\"</span>,snap.key(),<span class=\"string\">\"of Bejing is:\"</span>,snap.val());</div><div class=\"line\">     &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"hasChild\"><a href=\"#hasChild\" class=\"headerlink\" title=\"hasChild()\"></a>hasChild()</h2><p>定义</p>\n<p>hasChild ( key )</p>\n<p>说明</p>\n<p>检查是否存在某个子节点</p>\n<p>参数</p>\n<p>key 输入参数,关注子节点的key</p>\n<p>返回值<br> <code>boolean</code>   <code>true</code> 子节点存在；<code>false</code> 子节点不存在</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(snapshot.hasChild(<span class=\"string\">'pm25'</span>))&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"The pm25 of Bejing is\"</span>,pm25.val());</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.update(&#123;<span class=\"string\">\"pm25\"</span>:<span class=\"number\">432</span>&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"hasChildren\"><a href=\"#hasChildren\" class=\"headerlink\" title=\"hasChildren()\"></a>hasChildren()</h2><p>定义</p>\n<p>hasChildren()</p>\n<p>说明</p>\n<p>如果 <code>Datasnapshot</code> 有任何子节点返回true，否则false。</p>\n<p>返回值</p>\n<p><code>boolean</code> 如果snapshot 有任何子节点 <code>true</code> ,否则 <code>false</code></p>\n<p>示例</p>\n<p>假设我们已经有如下的数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"first\"</span>: <span class=\"string\">\"Jim\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"last\"</span>: <span class=\"string\">\"Gordon\"</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以用 <code>hasChildren</code> 检测 <code>DataSnapshot</code> 是否包含任何子节点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users/jim\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = snapshot.hasChildren();</div><div class=\"line\">  <span class=\"comment\">// a === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> b = snapshot.child(<span class=\"string\">\"name\"</span>).hasChildren();</div><div class=\"line\">  <span class=\"comment\">// b === true</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> c = snapshot.child(<span class=\"string\">\"name/first\"</span>).hasChildren();</div><div class=\"line\">  <span class=\"comment\">// c === false (because \"Fred\" is a string and therefore has no children)</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"key-1\"><a href=\"#key-1\" class=\"headerlink\" title=\"key()\"></a>key()</h2><p>定义</p>\n<p> key()</p>\n<p>说明</p>\n<p>返回当前节点的key</p>\n<p>返回值 </p>\n<p><code>string</code> 当前节点的key值</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(snapshot.hasChild(<span class=\"string\">'pm25'</span>))&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> key=snapshot.key();</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"The \"</span>,pm25.key() ,<span class=\"string\">\" of Bejing is\"</span>,pm25.val());</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"numChildren\"><a href=\"#numChildren\" class=\"headerlink\" title=\"numChildren()\"></a>numChildren()</h2><p>定义</p>\n<p>numChildren()</p>\n<p>说明</p>\n<p>返回当前节点中子节点的个数</p>\n<p>返回值</p>\n<p><code>string</code> 子节点的个数</p>\n<hr>\n<h2 id=\"ref-1\"><a href=\"#ref-1\" class=\"headerlink\" title=\"ref()\"></a>ref()</h2><p>定义</p>\n<p>ref()</p>\n<p>说明</p>\n<p>返回当前Wilddog实例的引用</p>\n<p>返回值 </p>\n<p>当前Wilddog实例的引用</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/city/Beijing\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'child_changed'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(snapshot.val() == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//has been deleted</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(snapshot.hasChild(<span class=\"string\">'pm25'</span>))&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> pm25=snapshot.child(<span class=\"string\">'pm25'</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> key=snapshot.key();</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> _ref=pm25.ref();</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(pm25.val()&gt;<span class=\"number\">500</span>)&#123;</div><div class=\"line\">\t\t\t\t_ref.set(<span class=\"number\">500</span>);</div><div class=\"line\">\t\t\t&#125;\t</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"getPriority\"><a href=\"#getPriority\" class=\"headerlink\" title=\"getPriority()\"></a>getPriority()</h2><p>定义</p>\n<p>getPriority()</p>\n<p>说明</p>\n<p>获取当前节点的优先级</p>\n<p>返回值</p>\n<p>Stirng , Number , Null 优先级，或者不存在</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/samplechat/users\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.setWithPriority(<span class=\"string\">\"fred\"</span>, <span class=\"number\">500</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> priority = snapshot.getPriority();</div><div class=\"line\">    <span class=\"comment\">// priority === 500</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"exportVal\"><a href=\"#exportVal\" class=\"headerlink\" title=\"exportVal()\"></a>exportVal()</h2><p>定义</p>\n<p>exportVal()</p>\n<p>说明</p>\n<p>导出DataSnapshot中的内容到Javascript 对象，与 <code>val()</code>类似，不同之处在于exportVal 导出的数据包含优先级。</p>\n<p>返回值</p>\n<p>DataSnapshot 的内容</p>\n<p>示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.setWithPriority(<span class=\"string\">\"hello\"</span>, <span class=\"number\">500</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = snapshot.exportVal();</div><div class=\"line\">    <span class=\"comment\">// data is &#123; \".value\": \"hello\", \".priority\": 500 &#125;</span></div><div class=\"line\">    <span class=\"comment\">// data[\".value\"] === \"hello\"</span></div><div class=\"line\">    <span class=\"comment\">// data[\".priority\"] ===  500</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"快速入门","_content":"\n## 一、先决条件 \n\n开始之前，需要查看你的环境和了解支持版本：  \n*\tXcode 7.0 或更高版本。\n*\t支持 iOS 7.0 或更高版本。\n\t\n如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个[快速入门示例](https://github.com/WildDogTeam/wilddog-ios-quickstart)。\n注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的[iOS 升级指南](https://z.wilddog.com/upgrade/iosupgrade)开始升级。\n\n## 二、SDK 导入\n\nSDK 的导入方式有两种，你可以选择下面方式的其中一种：\n\n### 第一种：使用 CocoaPods \n要将 Wilddog SDK 导入到你的工程中，推荐使用 [CocoaPods](https://cocoapods.org/)，如果没用过 CocoaPods，请先访问 [CocoaPods getting started](https://guides.cocoapods.org/using/getting-started.html)。 \n\n\n打开工程目录，新建一个 Podfile 文件\n\n\t$ cd your-project-directory\n\t$ pod init\n\t$ open -a Xcode Podfile # opens your Podfile in XCode\n\n然后在 Podfile 文件中添加以下语句\n\n\tpod 'Wilddog/Auth'\n\t\n最后安装 SDK\n\n\t$ pod install\n\t$ open your-project.xcworkspace\n\t\n### 第二种：手动集成 \n\n1、下载 SDK。[下载地址](https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogAuth.framework-2.0.0.zip)         \n2、把 WilddogAuth.framework 拖到工程目录中。  \n3、选中 Copy items if needed 、Create Groups，点击 Finish。  \n\n## 三、开发应用\n成功集成 SDK 之后，我们就可以开发应用了。\n\n### 第一步 初始化\n\n#### 1、引入头文件\n\nObjective-C \n\n\t@import WilddogAuth;\n\n\nSwift\n\n\timport WilddogAuth\n\n#### 2、初始化 Auth\n\nObjective-C \n\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n\n```\n\nSwift\n\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n\n```\n\n### 第二步 用户认证\n\n#### 1、创建基于密码的帐户\n\n我们可以选择创建基于邮箱密码方式的帐户，然后用其登录；也可以直接匿名登录、第三方登录（微信、QQ、微博）或者自定义身份登录。\n\n下面我们先介绍下基于邮箱密码方式的创建用户和登录。创建邮箱账号或者用邮箱方式登录，首先要在控制面板中打开允许“邮箱登录”的权限，如图所示：  \n![](/images/openemail.png)\n\n示例代码如下：\nObjective-C \n\n```objectivec\n//创建一个基于密码的帐户，创建成功后会自动登录\n[auth createUserWithEmail:@\"user@example.com\" password:@\"password\" completion:^(WDGUser * _Nullable user, NSError * _Nullable error) {\n   //...\n}];\n\n```\n\nSwift\n\n```swift\n//创建一个基于密码的帐户，创建成功后会自动登录\nauth?.createUserWithEmail(\"user@example.com\", password:\"password\", completion: { (user, error) in\n    //...\n})\n\n```\n#### 2、邮箱密码登录\n\n虽然上一个步骤中，创建账号成功时也默认该用户已登录。但是在下一次启动应用中，可能你的应用需要刚才注册的邮箱重新登录，那么你可以这样做：\n\n```objectivec\n[auth signInWithEmail:email\n             password:password\n           completion:^(WDGUser *user, NSError *error) {\n           // ...\n}];\n\n```\n\nSwift\n\n```swift\nauth?.signInWithEmail(email, password: password) { (user, error) in\n  // ...\n}\n\n```\n\n### 第三步 退出登录\n\n你可以使用 `signOut:` 方法退出当前登录用户。例如：\n\nObjective-C \n\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\n\nSwift\n\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n","source":"quickstart/auth/ios.md","raw":"title: 快速入门\n---\n\n## 一、先决条件 \n\n开始之前，需要查看你的环境和了解支持版本：  \n*\tXcode 7.0 或更高版本。\n*\t支持 iOS 7.0 或更高版本。\n\t\n如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个[快速入门示例](https://github.com/WildDogTeam/wilddog-ios-quickstart)。\n注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的[iOS 升级指南](https://z.wilddog.com/upgrade/iosupgrade)开始升级。\n\n## 二、SDK 导入\n\nSDK 的导入方式有两种，你可以选择下面方式的其中一种：\n\n### 第一种：使用 CocoaPods \n要将 Wilddog SDK 导入到你的工程中，推荐使用 [CocoaPods](https://cocoapods.org/)，如果没用过 CocoaPods，请先访问 [CocoaPods getting started](https://guides.cocoapods.org/using/getting-started.html)。 \n\n\n打开工程目录，新建一个 Podfile 文件\n\n\t$ cd your-project-directory\n\t$ pod init\n\t$ open -a Xcode Podfile # opens your Podfile in XCode\n\n然后在 Podfile 文件中添加以下语句\n\n\tpod 'Wilddog/Auth'\n\t\n最后安装 SDK\n\n\t$ pod install\n\t$ open your-project.xcworkspace\n\t\n### 第二种：手动集成 \n\n1、下载 SDK。[下载地址](https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogAuth.framework-2.0.0.zip)         \n2、把 WilddogAuth.framework 拖到工程目录中。  \n3、选中 Copy items if needed 、Create Groups，点击 Finish。  \n\n## 三、开发应用\n成功集成 SDK 之后，我们就可以开发应用了。\n\n### 第一步 初始化\n\n#### 1、引入头文件\n\nObjective-C \n\n\t@import WilddogAuth;\n\n\nSwift\n\n\timport WilddogAuth\n\n#### 2、初始化 Auth\n\nObjective-C \n\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n\n```\n\nSwift\n\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n\n```\n\n### 第二步 用户认证\n\n#### 1、创建基于密码的帐户\n\n我们可以选择创建基于邮箱密码方式的帐户，然后用其登录；也可以直接匿名登录、第三方登录（微信、QQ、微博）或者自定义身份登录。\n\n下面我们先介绍下基于邮箱密码方式的创建用户和登录。创建邮箱账号或者用邮箱方式登录，首先要在控制面板中打开允许“邮箱登录”的权限，如图所示：  \n![](/images/openemail.png)\n\n示例代码如下：\nObjective-C \n\n```objectivec\n//创建一个基于密码的帐户，创建成功后会自动登录\n[auth createUserWithEmail:@\"user@example.com\" password:@\"password\" completion:^(WDGUser * _Nullable user, NSError * _Nullable error) {\n   //...\n}];\n\n```\n\nSwift\n\n```swift\n//创建一个基于密码的帐户，创建成功后会自动登录\nauth?.createUserWithEmail(\"user@example.com\", password:\"password\", completion: { (user, error) in\n    //...\n})\n\n```\n#### 2、邮箱密码登录\n\n虽然上一个步骤中，创建账号成功时也默认该用户已登录。但是在下一次启动应用中，可能你的应用需要刚才注册的邮箱重新登录，那么你可以这样做：\n\n```objectivec\n[auth signInWithEmail:email\n             password:password\n           completion:^(WDGUser *user, NSError *error) {\n           // ...\n}];\n\n```\n\nSwift\n\n```swift\nauth?.signInWithEmail(email, password: password) { (user, error) in\n  // ...\n}\n\n```\n\n### 第三步 退出登录\n\n你可以使用 `signOut:` 方法退出当前登录用户。例如：\n\nObjective-C \n\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\n\nSwift\n\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n","date":"2016-09-06T03:38:22.549Z","updated":"2016-09-06T03:38:22.549Z","path":"quickstart/auth/ios.html","comments":1,"layout":"page","_id":"cisswi9jq000hz4fw0ddg67p3","content":"<h2 id=\"一、先决条件\"><a href=\"#一、先决条件\" class=\"headerlink\" title=\"一、先决条件\"></a>一、先决条件</h2><p>开始之前，需要查看你的环境和了解支持版本：  </p>\n<ul>\n<li>Xcode 7.0 或更高版本。</li>\n<li>支持 iOS 7.0 或更高版本。</li>\n</ul>\n<p>如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个<a href=\"https://github.com/WildDogTeam/wilddog-ios-quickstart\" target=\"_blank\" rel=\"external\">快速入门示例</a>。<br>注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的<a href=\"https://z.wilddog.com/upgrade/iosupgrade\" target=\"_blank\" rel=\"external\">iOS 升级指南</a>开始升级。</p>\n<h2 id=\"二、SDK-导入\"><a href=\"#二、SDK-导入\" class=\"headerlink\" title=\"二、SDK 导入\"></a>二、SDK 导入</h2><p>SDK 的导入方式有两种，你可以选择下面方式的其中一种：</p>\n<h3 id=\"第一种：使用-CocoaPods\"><a href=\"#第一种：使用-CocoaPods\" class=\"headerlink\" title=\"第一种：使用 CocoaPods\"></a>第一种：使用 CocoaPods</h3><p>要将 Wilddog SDK 导入到你的工程中，推荐使用 <a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">CocoaPods</a>，如果没用过 CocoaPods，请先访问 <a href=\"https://guides.cocoapods.org/using/getting-started.html\" target=\"_blank\" rel=\"external\">CocoaPods getting started</a>。 </p>\n<p>打开工程目录，新建一个 Podfile 文件</p>\n<pre><code>$ cd your-project-directory\n$ pod init\n$ open -a Xcode Podfile # opens your Podfile in XCode\n</code></pre><p>然后在 Podfile 文件中添加以下语句</p>\n<pre><code>pod &apos;Wilddog/Auth&apos;\n</code></pre><p>最后安装 SDK</p>\n<pre><code>$ pod install\n$ open your-project.xcworkspace\n</code></pre><h3 id=\"第二种：手动集成\"><a href=\"#第二种：手动集成\" class=\"headerlink\" title=\"第二种：手动集成\"></a>第二种：手动集成</h3><p>1、下载 SDK。<a href=\"https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogAuth.framework-2.0.0.zip\" target=\"_blank\" rel=\"external\">下载地址</a><br>2、把 WilddogAuth.framework 拖到工程目录中。<br>3、选中 Copy items if needed 、Create Groups，点击 Finish。  </p>\n<h2 id=\"三、开发应用\"><a href=\"#三、开发应用\" class=\"headerlink\" title=\"三、开发应用\"></a>三、开发应用</h2><p>成功集成 SDK 之后，我们就可以开发应用了。</p>\n<h3 id=\"第一步-初始化\"><a href=\"#第一步-初始化\" class=\"headerlink\" title=\"第一步 初始化\"></a>第一步 初始化</h3><h4 id=\"1、引入头文件\"><a href=\"#1、引入头文件\" class=\"headerlink\" title=\"1、引入头文件\"></a>1、引入头文件</h4><p>Objective-C </p>\n<pre><code>@import WilddogAuth;\n</code></pre><p>Swift</p>\n<pre><code>import WilddogAuth\n</code></pre><h4 id=\"2、初始化-Auth\"><a href=\"#2、初始化-Auth\" class=\"headerlink\" title=\"2、初始化 Auth\"></a>2、初始化 Auth</h4><p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"第二步-用户认证\"><a href=\"#第二步-用户认证\" class=\"headerlink\" title=\"第二步 用户认证\"></a>第二步 用户认证</h3><h4 id=\"1、创建基于密码的帐户\"><a href=\"#1、创建基于密码的帐户\" class=\"headerlink\" title=\"1、创建基于密码的帐户\"></a>1、创建基于密码的帐户</h4><p>我们可以选择创建基于邮箱密码方式的帐户，然后用其登录；也可以直接匿名登录、第三方登录（微信、QQ、微博）或者自定义身份登录。</p>\n<p>下面我们先介绍下基于邮箱密码方式的创建用户和登录。创建邮箱账号或者用邮箱方式登录，首先要在控制面板中打开允许“邮箱登录”的权限，如图所示：<br><img src=\"/images/openemail.png\" alt=\"\"></p>\n<p>示例代码如下：<br>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个基于密码的帐户，创建成功后会自动登录</span></div><div class=\"line\">[auth createUserWithEmail:<span class=\"string\">@\"user@example.com\"</span> password:<span class=\"string\">@\"password\"</span> completion:^(WDGUser * _Nullable user, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</div><div class=\"line\">   <span class=\"comment\">//...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个基于密码的帐户，创建成功后会自动登录</span></div><div class=\"line\">auth?.createUserWithEmail(<span class=\"string\">\"user@example.com\"</span>, password:<span class=\"string\">\"password\"</span>, completion: &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"2、邮箱密码登录\"><a href=\"#2、邮箱密码登录\" class=\"headerlink\" title=\"2、邮箱密码登录\"></a>2、邮箱密码登录</h4><p>虽然上一个步骤中，创建账号成功时也默认该用户已登录。但是在下一次启动应用中，可能你的应用需要刚才注册的邮箱重新登录，那么你可以这样做：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithEmail:email</div><div class=\"line\">             password:password</div><div class=\"line\">           completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">           <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithEmail(email, password: password) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第三步-退出登录\"><a href=\"#第三步-退出登录\" class=\"headerlink\" title=\"第三步 退出登录\"></a>第三步 退出登录</h3><p>你可以使用 <code>signOut:</code> 方法退出当前登录用户。例如：</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"一、先决条件\"><a href=\"#一、先决条件\" class=\"headerlink\" title=\"一、先决条件\"></a>一、先决条件</h2><p>开始之前，需要查看你的环境和了解支持版本：  </p>\n<ul>\n<li>Xcode 7.0 或更高版本。</li>\n<li>支持 iOS 7.0 或更高版本。</li>\n</ul>\n<p>如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个<a href=\"https://github.com/WildDogTeam/wilddog-ios-quickstart\">快速入门示例</a>。<br>注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的<a href=\"https://z.wilddog.com/upgrade/iosupgrade\">iOS 升级指南</a>开始升级。</p>\n<h2 id=\"二、SDK-导入\"><a href=\"#二、SDK-导入\" class=\"headerlink\" title=\"二、SDK 导入\"></a>二、SDK 导入</h2><p>SDK 的导入方式有两种，你可以选择下面方式的其中一种：</p>\n<h3 id=\"第一种：使用-CocoaPods\"><a href=\"#第一种：使用-CocoaPods\" class=\"headerlink\" title=\"第一种：使用 CocoaPods\"></a>第一种：使用 CocoaPods</h3><p>要将 Wilddog SDK 导入到你的工程中，推荐使用 <a href=\"https://cocoapods.org/\">CocoaPods</a>，如果没用过 CocoaPods，请先访问 <a href=\"https://guides.cocoapods.org/using/getting-started.html\">CocoaPods getting started</a>。 </p>\n<p>打开工程目录，新建一个 Podfile 文件</p>\n<pre><code>$ cd your-project-directory\n$ pod init\n$ open -a Xcode Podfile # opens your Podfile in XCode\n</code></pre><p>然后在 Podfile 文件中添加以下语句</p>\n<pre><code>pod &apos;Wilddog/Auth&apos;\n</code></pre><p>最后安装 SDK</p>\n<pre><code>$ pod install\n$ open your-project.xcworkspace\n</code></pre><h3 id=\"第二种：手动集成\"><a href=\"#第二种：手动集成\" class=\"headerlink\" title=\"第二种：手动集成\"></a>第二种：手动集成</h3><p>1、下载 SDK。<a href=\"https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogAuth.framework-2.0.0.zip\">下载地址</a><br>2、把 WilddogAuth.framework 拖到工程目录中。<br>3、选中 Copy items if needed 、Create Groups，点击 Finish。  </p>\n<h2 id=\"三、开发应用\"><a href=\"#三、开发应用\" class=\"headerlink\" title=\"三、开发应用\"></a>三、开发应用</h2><p>成功集成 SDK 之后，我们就可以开发应用了。</p>\n<h3 id=\"第一步-初始化\"><a href=\"#第一步-初始化\" class=\"headerlink\" title=\"第一步 初始化\"></a>第一步 初始化</h3><h4 id=\"1、引入头文件\"><a href=\"#1、引入头文件\" class=\"headerlink\" title=\"1、引入头文件\"></a>1、引入头文件</h4><p>Objective-C </p>\n<pre><code>@import WilddogAuth;\n</code></pre><p>Swift</p>\n<pre><code>import WilddogAuth\n</code></pre><h4 id=\"2、初始化-Auth\"><a href=\"#2、初始化-Auth\" class=\"headerlink\" title=\"2、初始化 Auth\"></a>2、初始化 Auth</h4><p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"第二步-用户认证\"><a href=\"#第二步-用户认证\" class=\"headerlink\" title=\"第二步 用户认证\"></a>第二步 用户认证</h3><h4 id=\"1、创建基于密码的帐户\"><a href=\"#1、创建基于密码的帐户\" class=\"headerlink\" title=\"1、创建基于密码的帐户\"></a>1、创建基于密码的帐户</h4><p>我们可以选择创建基于邮箱密码方式的帐户，然后用其登录；也可以直接匿名登录、第三方登录（微信、QQ、微博）或者自定义身份登录。</p>\n<p>下面我们先介绍下基于邮箱密码方式的创建用户和登录。创建邮箱账号或者用邮箱方式登录，首先要在控制面板中打开允许“邮箱登录”的权限，如图所示：<br><img src=\"/images/openemail.png\" alt=\"\"></p>\n<p>示例代码如下：<br>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个基于密码的帐户，创建成功后会自动登录</span></div><div class=\"line\">[auth createUserWithEmail:<span class=\"string\">@\"user@example.com\"</span> password:<span class=\"string\">@\"password\"</span> completion:^(WDGUser * _Nullable user, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</div><div class=\"line\">   <span class=\"comment\">//...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个基于密码的帐户，创建成功后会自动登录</span></div><div class=\"line\">auth?.createUserWithEmail(<span class=\"string\">\"user@example.com\"</span>, password:<span class=\"string\">\"password\"</span>, completion: &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"2、邮箱密码登录\"><a href=\"#2、邮箱密码登录\" class=\"headerlink\" title=\"2、邮箱密码登录\"></a>2、邮箱密码登录</h4><p>虽然上一个步骤中，创建账号成功时也默认该用户已登录。但是在下一次启动应用中，可能你的应用需要刚才注册的邮箱重新登录，那么你可以这样做：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithEmail:email</div><div class=\"line\">             password:password</div><div class=\"line\">           completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">           <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithEmail(email, password: password) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第三步-退出登录\"><a href=\"#第三步-退出登录\" class=\"headerlink\" title=\"第三步 退出登录\"></a>第三步 退出登录</h3><p>你可以使用 <code>signOut:</code> 方法退出当前登录用户。例如：</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure>\n"},{"title":"快速入门","_content":"\n快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。\n\n## 创建应用\n\n快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读[控制面板-创建应用](/console/creat.html)\n\n现在我们创建了一个新的应用，地址为 **gzztztestapp.wilddogio.com**。这个地址是该应用的根节点。\n\n<img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\">\n\n## 引入 SDK\n\n首先应该在页面中引入我们的 Wilddog Auth SDK\n很简单，只需要在你的页面中加入一行 javascript 标签。\n\n```javascript\n<script src = \"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n```\n\n## 创建 Wilddog 引用\n\n引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。\n\n```javascript\nvar config = {\n  authDomain: \"gzztztestapp.wilddog.com\",\n  syncURL: \"https://gzztztestapp.wilddogio.com\"\n};\nwilddog.initializeApp(config, \"DEFAULT\");\n```\n\n## 使用匿名方式登录\n\n1. 去野狗控制面板中打开匿名登录开关：\n![](/images/openanonymous.png)\n2. 调用 `signInAnonymously()` 方法：\n```js\nwilddog.auth().signInAnonymously().then(function(res){\n\tconsole.log(res);\n}).catch(function (error) {\n      // Handle Errors here.\n      console.log(error);\n      // ...\n});\n```\n如果登录成功，你可以在 `wilddog.auth().currentUser` 对象中获取登录用户的信息。\n```js\nvar isAnonymous = user.anonymous; \nvar uid = user.uid;\n```\n以上就是匿名登录的方式，我们还提供了各种登录方式。具体请看下面对应的文档。\n","source":"quickstart/auth/web.md","raw":"title: 快速入门\n---\n\n快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。\n\n## 创建应用\n\n快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读[控制面板-创建应用](/console/creat.html)\n\n现在我们创建了一个新的应用，地址为 **gzztztestapp.wilddogio.com**。这个地址是该应用的根节点。\n\n<img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\">\n\n## 引入 SDK\n\n首先应该在页面中引入我们的 Wilddog Auth SDK\n很简单，只需要在你的页面中加入一行 javascript 标签。\n\n```javascript\n<script src = \"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n```\n\n## 创建 Wilddog 引用\n\n引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。\n\n```javascript\nvar config = {\n  authDomain: \"gzztztestapp.wilddog.com\",\n  syncURL: \"https://gzztztestapp.wilddogio.com\"\n};\nwilddog.initializeApp(config, \"DEFAULT\");\n```\n\n## 使用匿名方式登录\n\n1. 去野狗控制面板中打开匿名登录开关：\n![](/images/openanonymous.png)\n2. 调用 `signInAnonymously()` 方法：\n```js\nwilddog.auth().signInAnonymously().then(function(res){\n\tconsole.log(res);\n}).catch(function (error) {\n      // Handle Errors here.\n      console.log(error);\n      // ...\n});\n```\n如果登录成功，你可以在 `wilddog.auth().currentUser` 对象中获取登录用户的信息。\n```js\nvar isAnonymous = user.anonymous; \nvar uid = user.uid;\n```\n以上就是匿名登录的方式，我们还提供了各种登录方式。具体请看下面对应的文档。\n","date":"2016-09-06T11:15:39.572Z","updated":"2016-09-06T11:15:39.572Z","path":"quickstart/auth/web.html","comments":1,"layout":"page","_id":"cisswi9jq000iz4fwu81mxenn","content":"<p>快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。</p>\n<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><p>快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制面板-创建应用</a></p>\n<p>现在我们创建了一个新的应用，地址为 <strong>gzztztestapp.wilddogio.com</strong>。这个地址是该应用的根节点。</p>\n<p><img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\"></p>\n<h2 id=\"引入-SDK\"><a href=\"#引入-SDK\" class=\"headerlink\" title=\"引入 SDK\"></a>引入 SDK</h2><p>首先应该在页面中引入我们的 Wilddog Auth SDK<br>很简单，只需要在你的页面中加入一行 javascript 标签。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script src = <span class=\"string\">\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"创建-Wilddog-引用\"><a href=\"#创建-Wilddog-引用\" class=\"headerlink\" title=\"创建 Wilddog 引用\"></a>创建 Wilddog 引用</h2><p>引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"gzztztestapp.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://gzztztestapp.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, <span class=\"string\">\"DEFAULT\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"使用匿名方式登录\"><a href=\"#使用匿名方式登录\" class=\"headerlink\" title=\"使用匿名方式登录\"></a>使用匿名方式登录</h2><ol>\n<li>去野狗控制面板中打开匿名登录开关：<br><img src=\"/images/openanonymous.png\" alt=\"\"></li>\n<li>调用 <code>signInAnonymously()</code> 方法：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInAnonymously().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// Handle Errors here.</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error);</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果登录成功，你可以在 <code>wilddog.auth().currentUser</code> 对象中获取登录用户的信息。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> isAnonymous = user.anonymous; </div><div class=\"line\"><span class=\"keyword\">var</span> uid = user.uid;</div></pre></td></tr></table></figure></p>\n<p>以上就是匿名登录的方式，我们还提供了各种登录方式。具体请看下面对应的文档。</p>\n","excerpt":"","more":"<p>快速入门可以让你快速掌握 Wilddog 身份认证的基本用法。</p>\n<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><p>快速入门之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制面板-创建应用</a></p>\n<p>现在我们创建了一个新的应用，地址为 <strong>gzztztestapp.wilddogio.com</strong>。这个地址是该应用的根节点。</p>\n<p><img src=\"/images/testApp.jpeg\" alt=\"testApp\" width=\"300\"></p>\n<h2 id=\"引入-SDK\"><a href=\"#引入-SDK\" class=\"headerlink\" title=\"引入 SDK\"></a>引入 SDK</h2><p>首先应该在页面中引入我们的 Wilddog Auth SDK<br>很简单，只需要在你的页面中加入一行 javascript 标签。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script src = <span class=\"string\">\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"创建-Wilddog-引用\"><a href=\"#创建-Wilddog-引用\" class=\"headerlink\" title=\"创建 Wilddog 引用\"></a>创建 Wilddog 引用</h2><p>引入 Wilddog Auth SDK 之后我们需要初始化 Wilddog 应用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"gzztztestapp.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://gzztztestapp.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, <span class=\"string\">\"DEFAULT\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"使用匿名方式登录\"><a href=\"#使用匿名方式登录\" class=\"headerlink\" title=\"使用匿名方式登录\"></a>使用匿名方式登录</h2><ol>\n<li>去野狗控制面板中打开匿名登录开关：<br><img src=\"/images/openanonymous.png\" alt=\"\"></li>\n<li>调用 <code>signInAnonymously()</code> 方法：<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInAnonymously().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(res);</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// Handle Errors here.</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(error);</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果登录成功，你可以在 <code>wilddog.auth().currentUser</code> 对象中获取登录用户的信息。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> isAnonymous = user.anonymous; </div><div class=\"line\"><span class=\"keyword\">var</span> uid = user.uid;</div></pre></td></tr></table></figure></p>\n<p>以上就是匿名登录的方式，我们还提供了各种登录方式。具体请看下面对应的文档。</p>\n"},{"title":"快速入门","_content":"\n快速起步可以让你快速掌握 Wilddog 实时数据同步的基本用法。如果你要用于实际开发，还需要阅读下面的[完整指南](/guide/sync/android/structure-data.html)以及 [API 文档](/api/sync/android.html)了解更多，或许还需要掌握使用 [规则表达式](/guide/sync/rules/introduce.html) 来保证你的数据安全。\n\n我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。\n通过这个例子，你将会学到：\n\n1. 向数据库中保存数据。\n2. 读取并且实时监听数据。\n\n\n### 1. 创建应用\n\n快速起步之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读[控制台指南—创建应用](/console/creat.html)\n\n现在我们创建了一个新的 App，地址为 **gzztztestapp.wilddogio.com**。这个地址是该 App 的根节点。\n\n![testApp](http://7u2r36.com1.z0.glb.clouddn.com/aoo.png?imageView/2/w/300/q/100)\n\n### 2. 引入 SDK\n**使用Maven获得 Android SDK：**\n\n```xml\n<dependency>\n    <groupId>com.wilddog.client</groupId>\n    <artifactId>wilddog-sync-android</artifactId>\n    <version>2.0.0</version>\n</dependency> \n```\n\n**使用Gradle获得 Android SDK：**\n要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：\n\n```xml\ndependencies {\n    compile 'com.wilddog.client:wilddog-sync-android:2.0.0'\n}\n```\n\n如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：\n\n```xml\nandroid {\n    ...\n    packagingOptions {\n        exclude 'META-INF/LICENSE'\n        exclude 'META-INF/NOTICE'\n    }\n}\n\n```\n\n### 3. Android 权限配置\n\n在 Android 上需要 android.permission.INTERNET 权限。 你需要在 AndroidMainfest.xml 文件添加：\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n### 4. 初始化 AndroidContext\n\n在创建 Wilddog 实例之前，必须先进行一次初始化，设置 AndroidContext。你可以在 android.app.Application 或者 Activity的onCreate 方法中设置 AndroidContext:\n\n```java\n@Override\npublic void onCreate() {\n    super.onCreate();\n    Wilddog.setAndroidContext(this);\n}\n```\n\n### 5. 创建 Wilddog 引用\n\n引入 Wilddog SDK 之后我们需要创建 Wilddog 引用。有了 Wilddog 引用，我们才能对数据进行操作。\n让我们来创建一个 Wilddog 引用对象。\n\n```java\n\nWilddog Wilddog = new Wilddog(\"https://<appId>.wilddogio.com\");\n\n```\n\n这样就创建完成了。Wilddog 就是我们的 Wilddog 引用，当然，你可以换成你想要的命名。\n创建对象的时候，需要传入数据库的数据路径。上面的代码定位在数据库的根节点，\n你也可以传入更具体的数据路径，Url与数据节点的关系如下图所示：\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2316950.jpg)\n比如我要在成都的天气下传入数据，那么我可以将输入的 Url定位为成都的 weather 节点下\n\n```java\n\nWilddog child = Wilddog.child(\"/成都/weather\");\n\n```\n\n现在我们操作的数据都在 weather 节点下了。\n\n### 6. 保存数据\n\n创建了 Wilddog 对象之后，我们就能利用它对数据进行操作了。让我们先从写入数据开始。\n我们可以通过 Wilddog 提供的 setValue() 方法，写入各种类型数据。\n\n注意wilddog 的数据是以 [JSON](http://www.json.org) 格式存储的，并没有传统关系型数据库中的表和记录的概念。\n\n**没有的节点将会新增，重复节点下的数据会覆盖。**\n\n假设我们要在数据库中的根节点下存入 成都的天气 信息：\n\n```java\nMap data = new HashMap();\ndata.put(\"city\",\"成都\");\ndata.put(\"weather\",\"晴天\");\nchild.setValue(data);\n```\n\n信息就直接存入数据库了，非常方便。\n\n**删除数据**和**更新数据**等更多操作数据的用法于此类似，不过我们先不在此介绍，稍后可以在开发者指南或者 API 文档中查看具体用法。\n\n### 7. 读取与监听数据\n我们上一步已经把 成都的天气 的信息存入了数据库，那么我们就可以使用 `addValueEventListener()`函数来读取存入的信息。\n\n例如我们要知道成都的天气信息，我们通过 `addValueEventListener()` 来读取 weather 字段：\n\n    ```\n    child.addValueEventListener(new ValueEventListener() {\n            @Override\n            public void onDataChange(DataSnapshot dataSnapshot) {\n                if(dataSnapshot.getValue()!=null){\n                Log.d(\"onDataChange\",dataSnapshot.toString());\n                }\n            }\n\n            @Override\n            public void onCancelled(WilddogError wilddogError) {\n                if(wilddogError!=null){\n             Log.d(\"onCancelled\",wilddogError.toString());}\n            }\n        });\n    ```\n\n\n这样就能读出根节点下的所有数据了,`dataSnapshot.getValue()`函数返回的就是取出的所有天气数据。\n\n如果你想读取某个节点的数据，比如只想看成都的天气，那么我们只需要在引用对象与 `addValueEventListener()` 之间后面加上 child(节点名称),就能够返回该节点的所有数据。\n\n\n    ```\n    Wilddog.child(\"成都\").addValueEventListener(new ValueEventListener() {\n        @Override\n        public void onDataChange(DataSnapshot dataSnapshot) {\n            if(dataSnapshot.getValue()!=null){\n                Log.d(\"onDataChange\",dataSnapshot.toString());\n\n            }\n        }\n\n        @Override\n        public void onCancelled(WilddogError wilddogError) {\n            if(wilddogError!=null){\n                Log.d(\"onCancelled\",wilddogError.toString());\n            }\n        }\n    });\n    ```\n这样就能够从数据库中取出 weather 的数据了，并且保持监听着数据的变化，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新！\n\n上边这个例子中，使用 `addValueEventListener()`函数读取数据， `addValueEventListener()` 这个事件会在初次读取到数据的时候被触发一次，并且此后每当数据发生改变的时候都会被触发。如果你在数据库中修改了数据，其他平台的数据会同步更新。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/AQujQROxAxUc3Bxp.gif%21thumbnail.gif)\n\n读取数据是通过绑定回调函数来实现的，我们使用 `addValueEventListener()`函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 `DataSnapshot` 对象类型，调用它的`getValue()`函数能够读取到返回的数据。\n\n如果你只想读取一次，以后每次数据发生变化的时候将不再同步，那么你可以使用`addListenerForSingleValueEvent()`函数替代 `addValueEventListener()`函数。\n\n\n\n### 8. 保护数据安全\n\n到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的 App权限初始权限都为 **所有人都可以读写**，用于实际生产环境将会非常危险。\n\n我们提供了强大的规则表达式来保障你的应用安全。规则表达式能够实现：\n\n- 读写权限设置\n- 用户授权\n- 数据校验\n- 提高查询效率\n\n结合野狗提供的[身份认证服务](/overview/auth.html)，你可以实现多种认证方式，极大地提高你的应用安全。\n\n你可以在应用中的实时数据同步配置规则表达式。虽然规则表达式配置灵活简单，但是要完全利用规则表达式的功能还需要一定的学习，你可以在[规则表达式简介](/guide/sync/rules/introduce.html)中开始学习如何配置规则表达式。\n\n![](http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)\n\n","source":"quickstart/sync/android.md","raw":"title: 快速入门\n---\n\n快速起步可以让你快速掌握 Wilddog 实时数据同步的基本用法。如果你要用于实际开发，还需要阅读下面的[完整指南](/guide/sync/android/structure-data.html)以及 [API 文档](/api/sync/android.html)了解更多，或许还需要掌握使用 [规则表达式](/guide/sync/rules/introduce.html) 来保证你的数据安全。\n\n我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。\n通过这个例子，你将会学到：\n\n1. 向数据库中保存数据。\n2. 读取并且实时监听数据。\n\n\n### 1. 创建应用\n\n快速起步之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读[控制台指南—创建应用](/console/creat.html)\n\n现在我们创建了一个新的 App，地址为 **gzztztestapp.wilddogio.com**。这个地址是该 App 的根节点。\n\n![testApp](http://7u2r36.com1.z0.glb.clouddn.com/aoo.png?imageView/2/w/300/q/100)\n\n### 2. 引入 SDK\n**使用Maven获得 Android SDK：**\n\n```xml\n<dependency>\n    <groupId>com.wilddog.client</groupId>\n    <artifactId>wilddog-sync-android</artifactId>\n    <version>2.0.0</version>\n</dependency> \n```\n\n**使用Gradle获得 Android SDK：**\n要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：\n\n```xml\ndependencies {\n    compile 'com.wilddog.client:wilddog-sync-android:2.0.0'\n}\n```\n\n如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：\n\n```xml\nandroid {\n    ...\n    packagingOptions {\n        exclude 'META-INF/LICENSE'\n        exclude 'META-INF/NOTICE'\n    }\n}\n\n```\n\n### 3. Android 权限配置\n\n在 Android 上需要 android.permission.INTERNET 权限。 你需要在 AndroidMainfest.xml 文件添加：\n\n```xml\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n```\n### 4. 初始化 AndroidContext\n\n在创建 Wilddog 实例之前，必须先进行一次初始化，设置 AndroidContext。你可以在 android.app.Application 或者 Activity的onCreate 方法中设置 AndroidContext:\n\n```java\n@Override\npublic void onCreate() {\n    super.onCreate();\n    Wilddog.setAndroidContext(this);\n}\n```\n\n### 5. 创建 Wilddog 引用\n\n引入 Wilddog SDK 之后我们需要创建 Wilddog 引用。有了 Wilddog 引用，我们才能对数据进行操作。\n让我们来创建一个 Wilddog 引用对象。\n\n```java\n\nWilddog Wilddog = new Wilddog(\"https://<appId>.wilddogio.com\");\n\n```\n\n这样就创建完成了。Wilddog 就是我们的 Wilddog 引用，当然，你可以换成你想要的命名。\n创建对象的时候，需要传入数据库的数据路径。上面的代码定位在数据库的根节点，\n你也可以传入更具体的数据路径，Url与数据节点的关系如下图所示：\n![](http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2316950.jpg)\n比如我要在成都的天气下传入数据，那么我可以将输入的 Url定位为成都的 weather 节点下\n\n```java\n\nWilddog child = Wilddog.child(\"/成都/weather\");\n\n```\n\n现在我们操作的数据都在 weather 节点下了。\n\n### 6. 保存数据\n\n创建了 Wilddog 对象之后，我们就能利用它对数据进行操作了。让我们先从写入数据开始。\n我们可以通过 Wilddog 提供的 setValue() 方法，写入各种类型数据。\n\n注意wilddog 的数据是以 [JSON](http://www.json.org) 格式存储的，并没有传统关系型数据库中的表和记录的概念。\n\n**没有的节点将会新增，重复节点下的数据会覆盖。**\n\n假设我们要在数据库中的根节点下存入 成都的天气 信息：\n\n```java\nMap data = new HashMap();\ndata.put(\"city\",\"成都\");\ndata.put(\"weather\",\"晴天\");\nchild.setValue(data);\n```\n\n信息就直接存入数据库了，非常方便。\n\n**删除数据**和**更新数据**等更多操作数据的用法于此类似，不过我们先不在此介绍，稍后可以在开发者指南或者 API 文档中查看具体用法。\n\n### 7. 读取与监听数据\n我们上一步已经把 成都的天气 的信息存入了数据库，那么我们就可以使用 `addValueEventListener()`函数来读取存入的信息。\n\n例如我们要知道成都的天气信息，我们通过 `addValueEventListener()` 来读取 weather 字段：\n\n    ```\n    child.addValueEventListener(new ValueEventListener() {\n            @Override\n            public void onDataChange(DataSnapshot dataSnapshot) {\n                if(dataSnapshot.getValue()!=null){\n                Log.d(\"onDataChange\",dataSnapshot.toString());\n                }\n            }\n\n            @Override\n            public void onCancelled(WilddogError wilddogError) {\n                if(wilddogError!=null){\n             Log.d(\"onCancelled\",wilddogError.toString());}\n            }\n        });\n    ```\n\n\n这样就能读出根节点下的所有数据了,`dataSnapshot.getValue()`函数返回的就是取出的所有天气数据。\n\n如果你想读取某个节点的数据，比如只想看成都的天气，那么我们只需要在引用对象与 `addValueEventListener()` 之间后面加上 child(节点名称),就能够返回该节点的所有数据。\n\n\n    ```\n    Wilddog.child(\"成都\").addValueEventListener(new ValueEventListener() {\n        @Override\n        public void onDataChange(DataSnapshot dataSnapshot) {\n            if(dataSnapshot.getValue()!=null){\n                Log.d(\"onDataChange\",dataSnapshot.toString());\n\n            }\n        }\n\n        @Override\n        public void onCancelled(WilddogError wilddogError) {\n            if(wilddogError!=null){\n                Log.d(\"onCancelled\",wilddogError.toString());\n            }\n        }\n    });\n    ```\n这样就能够从数据库中取出 weather 的数据了，并且保持监听着数据的变化，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新！\n\n上边这个例子中，使用 `addValueEventListener()`函数读取数据， `addValueEventListener()` 这个事件会在初次读取到数据的时候被触发一次，并且此后每当数据发生改变的时候都会被触发。如果你在数据库中修改了数据，其他平台的数据会同步更新。\n\n![](http://7u2r36.com1.z0.glb.clouddn.com/AQujQROxAxUc3Bxp.gif%21thumbnail.gif)\n\n读取数据是通过绑定回调函数来实现的，我们使用 `addValueEventListener()`函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 `DataSnapshot` 对象类型，调用它的`getValue()`函数能够读取到返回的数据。\n\n如果你只想读取一次，以后每次数据发生变化的时候将不再同步，那么你可以使用`addListenerForSingleValueEvent()`函数替代 `addValueEventListener()`函数。\n\n\n\n### 8. 保护数据安全\n\n到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的 App权限初始权限都为 **所有人都可以读写**，用于实际生产环境将会非常危险。\n\n我们提供了强大的规则表达式来保障你的应用安全。规则表达式能够实现：\n\n- 读写权限设置\n- 用户授权\n- 数据校验\n- 提高查询效率\n\n结合野狗提供的[身份认证服务](/overview/auth.html)，你可以实现多种认证方式，极大地提高你的应用安全。\n\n你可以在应用中的实时数据同步配置规则表达式。虽然规则表达式配置灵活简单，但是要完全利用规则表达式的功能还需要一定的学习，你可以在[规则表达式简介](/guide/sync/rules/introduce.html)中开始学习如何配置规则表达式。\n\n![](http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)\n\n","date":"2016-09-06T03:38:22.550Z","updated":"2016-09-06T03:38:22.550Z","path":"quickstart/sync/android.html","comments":1,"layout":"page","_id":"cisswi9jq000jz4fwepen3y7h","content":"<p>快速起步可以让你快速掌握 Wilddog 实时数据同步的基本用法。如果你要用于实际开发，还需要阅读下面的<a href=\"/guide/sync/android/structure-data.html\">完整指南</a>以及 <a href=\"/api/sync/android.html\">API 文档</a>了解更多，或许还需要掌握使用 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 来保证你的数据安全。</p>\n<p>我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。<br>通过这个例子，你将会学到：</p>\n<ol>\n<li>向数据库中保存数据。</li>\n<li>读取并且实时监听数据。</li>\n</ol>\n<h3 id=\"1-创建应用\"><a href=\"#1-创建应用\" class=\"headerlink\" title=\"1. 创建应用\"></a>1. 创建应用</h3><p>快速起步之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制台指南—创建应用</a></p>\n<p>现在我们创建了一个新的 App，地址为 <strong>gzztztestapp.wilddogio.com</strong>。这个地址是该 App 的根节点。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/aoo.png?imageView/2/w/300/q/100\" alt=\"testApp\"></p>\n<h3 id=\"2-引入-SDK\"><a href=\"#2-引入-SDK\" class=\"headerlink\" title=\"2. 引入 SDK\"></a>2. 引入 SDK</h3><p><strong>使用Maven获得 Android SDK：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.wilddog.client<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>wilddog-sync-android<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>使用Gradle获得 Android SDK：</strong><br>要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile 'com.wilddog.client:wilddog-sync-android:2.0.0'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    packagingOptions &#123;</div><div class=\"line\">        exclude 'META-INF/LICENSE'</div><div class=\"line\">        exclude 'META-INF/NOTICE'</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-Android-权限配置\"><a href=\"#3-Android-权限配置\" class=\"headerlink\" title=\"3. Android 权限配置\"></a>3. Android 权限配置</h3><p>在 Android 上需要 android.permission.INTERNET 权限。 你需要在 AndroidMainfest.xml 文件添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-初始化-AndroidContext\"><a href=\"#4-初始化-AndroidContext\" class=\"headerlink\" title=\"4. 初始化 AndroidContext\"></a>4. 初始化 AndroidContext</h3><p>在创建 Wilddog 实例之前，必须先进行一次初始化，设置 AndroidContext。你可以在 android.app.Application 或者 Activity的onCreate 方法中设置 AndroidContext:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    Wilddog.setAndroidContext(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-创建-Wilddog-引用\"><a href=\"#5-创建-Wilddog-引用\" class=\"headerlink\" title=\"5. 创建 Wilddog 引用\"></a>5. 创建 Wilddog 引用</h3><p>引入 Wilddog SDK 之后我们需要创建 Wilddog 引用。有了 Wilddog 引用，我们才能对数据进行操作。<br>让我们来创建一个 Wilddog 引用对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Wilddog Wilddog = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span>);</div></pre></td></tr></table></figure>\n<p>这样就创建完成了。Wilddog 就是我们的 Wilddog 引用，当然，你可以换成你想要的命名。<br>创建对象的时候，需要传入数据库的数据路径。上面的代码定位在数据库的根节点，<br>你也可以传入更具体的数据路径，Url与数据节点的关系如下图所示：<br><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2316950.jpg\" alt=\"\"><br>比如我要在成都的天气下传入数据，那么我可以将输入的 Url定位为成都的 weather 节点下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Wilddog child = Wilddog.child(<span class=\"string\">\"/成都/weather\"</span>);</div></pre></td></tr></table></figure>\n<p>现在我们操作的数据都在 weather 节点下了。</p>\n<h3 id=\"6-保存数据\"><a href=\"#6-保存数据\" class=\"headerlink\" title=\"6. 保存数据\"></a>6. 保存数据</h3><p>创建了 Wilddog 对象之后，我们就能利用它对数据进行操作了。让我们先从写入数据开始。<br>我们可以通过 Wilddog 提供的 setValue() 方法，写入各种类型数据。</p>\n<p>注意wilddog 的数据是以 <a href=\"http://www.json.org\" target=\"_blank\" rel=\"external\">JSON</a> 格式存储的，并没有传统关系型数据库中的表和记录的概念。</p>\n<p><strong>没有的节点将会新增，重复节点下的数据会覆盖。</strong></p>\n<p>假设我们要在数据库中的根节点下存入 成都的天气 信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Map data = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">data.put(<span class=\"string\">\"city\"</span>,<span class=\"string\">\"成都\"</span>);</div><div class=\"line\">data.put(<span class=\"string\">\"weather\"</span>,<span class=\"string\">\"晴天\"</span>);</div><div class=\"line\">child.setValue(data);</div></pre></td></tr></table></figure>\n<p>信息就直接存入数据库了，非常方便。</p>\n<p><strong>删除数据</strong>和<strong>更新数据</strong>等更多操作数据的用法于此类似，不过我们先不在此介绍，稍后可以在开发者指南或者 API 文档中查看具体用法。</p>\n<h3 id=\"7-读取与监听数据\"><a href=\"#7-读取与监听数据\" class=\"headerlink\" title=\"7. 读取与监听数据\"></a>7. 读取与监听数据</h3><p>我们上一步已经把 成都的天气 的信息存入了数据库，那么我们就可以使用 <code>addValueEventListener()</code>函数来读取存入的信息。</p>\n<p>例如我们要知道成都的天气信息，我们通过 <code>addValueEventListener()</code> 来读取 weather 字段：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">child.addValueEventListener(new ValueEventListener() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void onDataChange(DataSnapshot dataSnapshot) &#123;</div><div class=\"line\">            if(dataSnapshot.getValue()!=null)&#123;</div><div class=\"line\">            Log.d(&quot;onDataChange&quot;,dataSnapshot.toString());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onCancelled(WilddogError wilddogError) &#123;</div><div class=\"line\">            if(wilddogError!=null)&#123;</div><div class=\"line\">         Log.d(&quot;onCancelled&quot;,wilddogError.toString());&#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n</code></pre><p>这样就能读出根节点下的所有数据了,<code>dataSnapshot.getValue()</code>函数返回的就是取出的所有天气数据。</p>\n<p>如果你想读取某个节点的数据，比如只想看成都的天气，那么我们只需要在引用对象与 <code>addValueEventListener()</code> 之间后面加上 child(节点名称),就能够返回该节点的所有数据。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog.child(&quot;成都&quot;).addValueEventListener(new ValueEventListener() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onDataChange(DataSnapshot dataSnapshot) &#123;</div><div class=\"line\">        if(dataSnapshot.getValue()!=null)&#123;</div><div class=\"line\">            Log.d(&quot;onDataChange&quot;,dataSnapshot.toString());</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onCancelled(WilddogError wilddogError) &#123;</div><div class=\"line\">        if(wilddogError!=null)&#123;</div><div class=\"line\">            Log.d(&quot;onCancelled&quot;,wilddogError.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</code></pre><p>这样就能够从数据库中取出 weather 的数据了，并且保持监听着数据的变化，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新！</p>\n<p>上边这个例子中，使用 <code>addValueEventListener()</code>函数读取数据， <code>addValueEventListener()</code> 这个事件会在初次读取到数据的时候被触发一次，并且此后每当数据发生改变的时候都会被触发。如果你在数据库中修改了数据，其他平台的数据会同步更新。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/AQujQROxAxUc3Bxp.gif%21thumbnail.gif\" alt=\"\"></p>\n<p>读取数据是通过绑定回调函数来实现的，我们使用 <code>addValueEventListener()</code>函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 <code>DataSnapshot</code> 对象类型，调用它的<code>getValue()</code>函数能够读取到返回的数据。</p>\n<p>如果你只想读取一次，以后每次数据发生变化的时候将不再同步，那么你可以使用<code>addListenerForSingleValueEvent()</code>函数替代 <code>addValueEventListener()</code>函数。</p>\n<h3 id=\"8-保护数据安全\"><a href=\"#8-保护数据安全\" class=\"headerlink\" title=\"8. 保护数据安全\"></a>8. 保护数据安全</h3><p>到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的 App权限初始权限都为 <strong>所有人都可以读写</strong>，用于实际生产环境将会非常危险。</p>\n<p>我们提供了强大的规则表达式来保障你的应用安全。规则表达式能够实现：</p>\n<ul>\n<li>读写权限设置</li>\n<li>用户授权</li>\n<li>数据校验</li>\n<li>提高查询效率</li>\n</ul>\n<p>结合野狗提供的<a href=\"/overview/auth.html\">身份认证服务</a>，你可以实现多种认证方式，极大地提高你的应用安全。</p>\n<p>你可以在应用中的实时数据同步配置规则表达式。虽然规则表达式配置灵活简单，但是要完全利用规则表达式的功能还需要一定的学习，你可以在<a href=\"/guide/sync/rules/introduce.html\">规则表达式简介</a>中开始学习如何配置规则表达式。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"\"></p>\n","excerpt":"","more":"<p>快速起步可以让你快速掌握 Wilddog 实时数据同步的基本用法。如果你要用于实际开发，还需要阅读下面的<a href=\"/guide/sync/android/structure-data.html\">完整指南</a>以及 <a href=\"/api/sync/android.html\">API 文档</a>了解更多，或许还需要掌握使用 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 来保证你的数据安全。</p>\n<p>我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。<br>通过这个例子，你将会学到：</p>\n<ol>\n<li>向数据库中保存数据。</li>\n<li>读取并且实时监听数据。</li>\n</ol>\n<h3 id=\"1-创建应用\"><a href=\"#1-创建应用\" class=\"headerlink\" title=\"1. 创建应用\"></a>1. 创建应用</h3><p>快速起步之前，需要先创建你的应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制台指南—创建应用</a></p>\n<p>现在我们创建了一个新的 App，地址为 <strong>gzztztestapp.wilddogio.com</strong>。这个地址是该 App 的根节点。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/aoo.png?imageView/2/w/300/q/100\" alt=\"testApp\"></p>\n<h3 id=\"2-引入-SDK\"><a href=\"#2-引入-SDK\" class=\"headerlink\" title=\"2. 引入 SDK\"></a>2. 引入 SDK</h3><p><strong>使用Maven获得 Android SDK：</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.wilddog.client<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>wilddog-sync-android<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>使用Gradle获得 Android SDK：</strong><br>要使用在 Android application使用 Gradle 或 Maven 添加 Wilddog 的依赖。 在你的build.gradle添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile 'com.wilddog.client:wilddog-sync-android:2.0.0'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果出现由于文件重复的导致的编译错误，可以选择在build.grade中添加packingOptions：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    packagingOptions &#123;</div><div class=\"line\">        exclude 'META-INF/LICENSE'</div><div class=\"line\">        exclude 'META-INF/NOTICE'</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-Android-权限配置\"><a href=\"#3-Android-权限配置\" class=\"headerlink\" title=\"3. Android 权限配置\"></a>3. Android 权限配置</h3><p>在 Android 上需要 android.permission.INTERNET 权限。 你需要在 AndroidMainfest.xml 文件添加：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-初始化-AndroidContext\"><a href=\"#4-初始化-AndroidContext\" class=\"headerlink\" title=\"4. 初始化 AndroidContext\"></a>4. 初始化 AndroidContext</h3><p>在创建 Wilddog 实例之前，必须先进行一次初始化，设置 AndroidContext。你可以在 android.app.Application 或者 Activity的onCreate 方法中设置 AndroidContext:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate();</div><div class=\"line\">    Wilddog.setAndroidContext(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-创建-Wilddog-引用\"><a href=\"#5-创建-Wilddog-引用\" class=\"headerlink\" title=\"5. 创建 Wilddog 引用\"></a>5. 创建 Wilddog 引用</h3><p>引入 Wilddog SDK 之后我们需要创建 Wilddog 引用。有了 Wilddog 引用，我们才能对数据进行操作。<br>让我们来创建一个 Wilddog 引用对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Wilddog Wilddog = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span>);</div></pre></td></tr></table></figure>\n<p>这样就创建完成了。Wilddog 就是我们的 Wilddog 引用，当然，你可以换成你想要的命名。<br>创建对象的时候，需要传入数据库的数据路径。上面的代码定位在数据库的根节点，<br>你也可以传入更具体的数据路径，Url与数据节点的关系如下图所示：<br><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/16-8-18/2316950.jpg\" alt=\"\"><br>比如我要在成都的天气下传入数据，那么我可以将输入的 Url定位为成都的 weather 节点下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Wilddog child = Wilddog.child(<span class=\"string\">\"/成都/weather\"</span>);</div></pre></td></tr></table></figure>\n<p>现在我们操作的数据都在 weather 节点下了。</p>\n<h3 id=\"6-保存数据\"><a href=\"#6-保存数据\" class=\"headerlink\" title=\"6. 保存数据\"></a>6. 保存数据</h3><p>创建了 Wilddog 对象之后，我们就能利用它对数据进行操作了。让我们先从写入数据开始。<br>我们可以通过 Wilddog 提供的 setValue() 方法，写入各种类型数据。</p>\n<p>注意wilddog 的数据是以 <a href=\"http://www.json.org\">JSON</a> 格式存储的，并没有传统关系型数据库中的表和记录的概念。</p>\n<p><strong>没有的节点将会新增，重复节点下的数据会覆盖。</strong></p>\n<p>假设我们要在数据库中的根节点下存入 成都的天气 信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Map data = <span class=\"keyword\">new</span> HashMap();</div><div class=\"line\">data.put(<span class=\"string\">\"city\"</span>,<span class=\"string\">\"成都\"</span>);</div><div class=\"line\">data.put(<span class=\"string\">\"weather\"</span>,<span class=\"string\">\"晴天\"</span>);</div><div class=\"line\">child.setValue(data);</div></pre></td></tr></table></figure>\n<p>信息就直接存入数据库了，非常方便。</p>\n<p><strong>删除数据</strong>和<strong>更新数据</strong>等更多操作数据的用法于此类似，不过我们先不在此介绍，稍后可以在开发者指南或者 API 文档中查看具体用法。</p>\n<h3 id=\"7-读取与监听数据\"><a href=\"#7-读取与监听数据\" class=\"headerlink\" title=\"7. 读取与监听数据\"></a>7. 读取与监听数据</h3><p>我们上一步已经把 成都的天气 的信息存入了数据库，那么我们就可以使用 <code>addValueEventListener()</code>函数来读取存入的信息。</p>\n<p>例如我们要知道成都的天气信息，我们通过 <code>addValueEventListener()</code> 来读取 weather 字段：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">child.addValueEventListener(new ValueEventListener() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void onDataChange(DataSnapshot dataSnapshot) &#123;</div><div class=\"line\">            if(dataSnapshot.getValue()!=null)&#123;</div><div class=\"line\">            Log.d(&quot;onDataChange&quot;,dataSnapshot.toString());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void onCancelled(WilddogError wilddogError) &#123;</div><div class=\"line\">            if(wilddogError!=null)&#123;</div><div class=\"line\">         Log.d(&quot;onCancelled&quot;,wilddogError.toString());&#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n</code></pre><p>这样就能读出根节点下的所有数据了,<code>dataSnapshot.getValue()</code>函数返回的就是取出的所有天气数据。</p>\n<p>如果你想读取某个节点的数据，比如只想看成都的天气，那么我们只需要在引用对象与 <code>addValueEventListener()</code> 之间后面加上 child(节点名称),就能够返回该节点的所有数据。</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog.child(&quot;成都&quot;).addValueEventListener(new ValueEventListener() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void onDataChange(DataSnapshot dataSnapshot) &#123;</div><div class=\"line\">        if(dataSnapshot.getValue()!=null)&#123;</div><div class=\"line\">            Log.d(&quot;onDataChange&quot;,dataSnapshot.toString());</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onCancelled(WilddogError wilddogError) &#123;</div><div class=\"line\">        if(wilddogError!=null)&#123;</div><div class=\"line\">            Log.d(&quot;onCancelled&quot;,wilddogError.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</code></pre><p>这样就能够从数据库中取出 weather 的数据了，并且保持监听着数据的变化，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新！</p>\n<p>上边这个例子中，使用 <code>addValueEventListener()</code>函数读取数据， <code>addValueEventListener()</code> 这个事件会在初次读取到数据的时候被触发一次，并且此后每当数据发生改变的时候都会被触发。如果你在数据库中修改了数据，其他平台的数据会同步更新。</p>\n<p><img src=\"http://7u2r36.com1.z0.glb.clouddn.com/AQujQROxAxUc3Bxp.gif%21thumbnail.gif\" alt=\"\"></p>\n<p>读取数据是通过绑定回调函数来实现的，我们使用 <code>addValueEventListener()</code>函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 <code>DataSnapshot</code> 对象类型，调用它的<code>getValue()</code>函数能够读取到返回的数据。</p>\n<p>如果你只想读取一次，以后每次数据发生变化的时候将不再同步，那么你可以使用<code>addListenerForSingleValueEvent()</code>函数替代 <code>addValueEventListener()</code>函数。</p>\n<h3 id=\"8-保护数据安全\"><a href=\"#8-保护数据安全\" class=\"headerlink\" title=\"8. 保护数据安全\"></a>8. 保护数据安全</h3><p>到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的 App权限初始权限都为 <strong>所有人都可以读写</strong>，用于实际生产环境将会非常危险。</p>\n<p>我们提供了强大的规则表达式来保障你的应用安全。规则表达式能够实现：</p>\n<ul>\n<li>读写权限设置</li>\n<li>用户授权</li>\n<li>数据校验</li>\n<li>提高查询效率</li>\n</ul>\n<p>结合野狗提供的<a href=\"/overview/auth.html\">身份认证服务</a>，你可以实现多种认证方式，极大地提高你的应用安全。</p>\n<p>你可以在应用中的实时数据同步配置规则表达式。虽然规则表达式配置灵活简单，但是要完全利用规则表达式的功能还需要一定的学习，你可以在<a href=\"/guide/sync/rules/introduce.html\">规则表达式简介</a>中开始学习如何配置规则表达式。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"\"></p>\n"},{"title":"快速入门","_content":"\n## 环境准备\n\n### 先决条件\n- 具备 C 的基础知识。\n- 有一个 Wilddog 应用。如果还没有，请去[控制面板](https://www.wilddog.com/dashboard/)创建一个。或者使用我们提供的测试应用 [c_test](https://c_test.wilddogio.com)\n- 从该网页下载 SDK： [https://www.wilddog.com/download/](https://www.wilddog.com/download/)\n\nWilddog C/嵌入式 SDK 分为 C/RTOS、OpenWRT、Arduino 三种，具体支持的平台如下：\n\n名称 | 支持的平台\n---- | ----\n | Linux : 支持POSIX标准的平台，例如 Ubuntu、树莓派。\nC / RTOS SDK | Broadcom WICED : 例如 Broadcom 的 BCM943362WCD4、AMPAK 的 WSDB733、WSDB750。\n | 乐鑫 Espressif：例如 ESP8266。\n | 庆科 MICO：例如 EMW3162。\nOpenWRT SDK | ar71xx 系列。\nArduino SDK | Arduino Yun。\n\n在大部分平台下 C/嵌入式 SDK API 接口一致（Arduino 平台除外），因此下面我们以 Linux 平台为例，快速了解 SDK 的基本 API，其他平台可以参考 SDK 中的 docs 目录和 README。\n\n### 编译 SDK\n\nLinux 平台下，编译 SDK 后生成的库文件在 SDK 的 lib 目录下。使用时需要在源文件中包含 wilddog.h ，将 SDK 的 include 文件夹拷贝到你的工程中，且在编译选项中增加该 lib 库。\n\n    $ cd wilddog-client-c\n    $ make \n \n\n## 入门 Demo 教程\n本教程旨在让你在短时间内零基础学会在你的嵌入式设备上使用 Wilddog C/嵌入式 SDK 读写和同步 Wilddog 云端数据。\n**第一步：创建 Wdilddog 云端引用**\n\n要读写 Wilddog 云端数据，必须先创建 Wilddog 云端引用：\n```c\nWilddog_T ref = wilddog_initWithUrl(\"https://<appId>.wilddogio.com/\");\n```\n创建引用的时候，需要传入数据的 URL 做为参数，把`<appId>`替换成你应用的 appId 。上面的代码定位到了数据库的根节点。URL 地址也可以包含数据路径，例如：\n```c\nWilddog_T ref = wilddog_initWithUrl(\"https://<appId>.wilddogio.com/users/Jack\");\n```\n上面的代码定位到了数据库的`/users/Jack`节点上。\n\nSDK 提供了许多用于读写数据的方法。例如通过`wilddog_setValue()`、`wilddog_push()`、`wilddog_removeValue()`修改数据； 通过`wilddog_getValue()`读取数据；`wilddog_addObserver()`读取数据并监听该节点数据的变化。\n\n<hr>\n\n**第二步：写入数据**\n\nSDK 提供了一系列节点操作 API 对节点数据进行操作，在这里使用节点 create 函数族将`/users/Jack`节点值设置为字符串\"beauty\",并通过`wilddog_setValue()`将这个值写入到云端。你可以在 SDK 的`examples/linux`目录下新建一个 C 源文件，将下面代码复制进去,修改 `<appId>` 为你自己的 appId ，并在 SDK 根目录执行`make example`。生成的可执行文件在 SDK 的 bin 目录下。为了简略，下面代码未检查返回值。\n```c\n#include \"wilddog.h\"\nvoid callback(void* arg, Wilddog_Return_T err){\n    *(BOOL*)arg = TRUE;\n    if(err >= 200 || err < 400){\n        wilddog_debug(\"setValue success!\");\n    }\n\n    return;\n}\nint main(void){\n    //作为设置是否完成的标志为传入回调函数中.\n    BOOL isFinish = FALSE;\n    //初始化 Wilddog 引用，需要将 <appId> 修改为你自己的 appId\n    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)\"https://<appId>.wilddogio.com/users/Jack\");\n    //将Jack节点的值设为\"beauty\"\n    Wilddog_Node_T *node = wilddog_node_createUString(NULL, (Wilddog_Str_T*)\"beauty\");\n    //向云端写入\n    wilddog_setValue(ref, node, callback, (void*)&isFinish);\n    //设置完毕，释放空间\n    wilddog_node_delete(node);\n    while(1){\n        //和云端同步\n        wilddog_trySync();\n        if(TRUE == isFinish)//设置完成，退出\n            break;\n    }\n    wilddog_destroy(&ref);\n    return 0;\n}\n```\n当收到云端返回或者超时后，回调函数 callback 会被触发。\n\n<hr>\n\n**第三步：读取数据**\n\n读取数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么可以使用`wilddog_getValue()`来读取`Jack`节点的值。\n```c\n#include \"wilddog.h\"\nvoid callback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    *(BOOL*)arg = TRUE;\n    if(p_snapshot){\n        wilddog_debug_printnode(p_snapshot);\n        printf(\"\\ngetValue success!\\n\");\n    }\n    return;\n}\nint main(void){\n    //作为设置是否完成的标志为传入回调函数中.\n    BOOL isFinish = FALSE;\n    //初始化Wilddog引用，需要将<appId>修改为你自己的appId\n    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)\"https://<appId>.wilddogio.com/users/Jack\");\n    //从云端读取\n    wilddog_getValue(ref, callback, (void*)&isFinish);\n    while(1){\n        //和云端同步\n        wilddog_trySync();\n        if(TRUE == isFinish)//设置完成，退出\n            break;\n    }\n    wilddog_destroy(&ref);\n    return 0;\n}\n```\n<hr>\n\n**第四步：同步数据**\n\n同步数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么就可以使用`widdog_addObserver()`函数来实时同步`/users/Jack`的值。\n```c\n#include \"wilddog.h\"\nvoid callback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    if(p_snapshot){\n        wilddog_debug_printnode(p_snapshot);//打印出节点的值\n        printf(\"\\n\");\n    }\n    return;\n}\nint main(){\n    //初始化Wilddog引用，需要将<appId>修改为你自己的appId\n    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)\"https://<appId>.wilddogio.com/users/Jack\");\n    //向云端订阅该节点数据变化\n    wilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, NULL);\n    while(1){\n        wilddog_trySync();\n    }\n    wilddog_destroy(&ref);\n}\n```\n当从云端第一次同步数据，以及数据发生变化时，回调函数 callback 会被触发。每当我们对云端数据进行修改，SDK 就会收到通知。\n\n","source":"quickstart/sync/c.md","raw":"title: 快速入门\n---\n\n## 环境准备\n\n### 先决条件\n- 具备 C 的基础知识。\n- 有一个 Wilddog 应用。如果还没有，请去[控制面板](https://www.wilddog.com/dashboard/)创建一个。或者使用我们提供的测试应用 [c_test](https://c_test.wilddogio.com)\n- 从该网页下载 SDK： [https://www.wilddog.com/download/](https://www.wilddog.com/download/)\n\nWilddog C/嵌入式 SDK 分为 C/RTOS、OpenWRT、Arduino 三种，具体支持的平台如下：\n\n名称 | 支持的平台\n---- | ----\n | Linux : 支持POSIX标准的平台，例如 Ubuntu、树莓派。\nC / RTOS SDK | Broadcom WICED : 例如 Broadcom 的 BCM943362WCD4、AMPAK 的 WSDB733、WSDB750。\n | 乐鑫 Espressif：例如 ESP8266。\n | 庆科 MICO：例如 EMW3162。\nOpenWRT SDK | ar71xx 系列。\nArduino SDK | Arduino Yun。\n\n在大部分平台下 C/嵌入式 SDK API 接口一致（Arduino 平台除外），因此下面我们以 Linux 平台为例，快速了解 SDK 的基本 API，其他平台可以参考 SDK 中的 docs 目录和 README。\n\n### 编译 SDK\n\nLinux 平台下，编译 SDK 后生成的库文件在 SDK 的 lib 目录下。使用时需要在源文件中包含 wilddog.h ，将 SDK 的 include 文件夹拷贝到你的工程中，且在编译选项中增加该 lib 库。\n\n    $ cd wilddog-client-c\n    $ make \n \n\n## 入门 Demo 教程\n本教程旨在让你在短时间内零基础学会在你的嵌入式设备上使用 Wilddog C/嵌入式 SDK 读写和同步 Wilddog 云端数据。\n**第一步：创建 Wdilddog 云端引用**\n\n要读写 Wilddog 云端数据，必须先创建 Wilddog 云端引用：\n```c\nWilddog_T ref = wilddog_initWithUrl(\"https://<appId>.wilddogio.com/\");\n```\n创建引用的时候，需要传入数据的 URL 做为参数，把`<appId>`替换成你应用的 appId 。上面的代码定位到了数据库的根节点。URL 地址也可以包含数据路径，例如：\n```c\nWilddog_T ref = wilddog_initWithUrl(\"https://<appId>.wilddogio.com/users/Jack\");\n```\n上面的代码定位到了数据库的`/users/Jack`节点上。\n\nSDK 提供了许多用于读写数据的方法。例如通过`wilddog_setValue()`、`wilddog_push()`、`wilddog_removeValue()`修改数据； 通过`wilddog_getValue()`读取数据；`wilddog_addObserver()`读取数据并监听该节点数据的变化。\n\n<hr>\n\n**第二步：写入数据**\n\nSDK 提供了一系列节点操作 API 对节点数据进行操作，在这里使用节点 create 函数族将`/users/Jack`节点值设置为字符串\"beauty\",并通过`wilddog_setValue()`将这个值写入到云端。你可以在 SDK 的`examples/linux`目录下新建一个 C 源文件，将下面代码复制进去,修改 `<appId>` 为你自己的 appId ，并在 SDK 根目录执行`make example`。生成的可执行文件在 SDK 的 bin 目录下。为了简略，下面代码未检查返回值。\n```c\n#include \"wilddog.h\"\nvoid callback(void* arg, Wilddog_Return_T err){\n    *(BOOL*)arg = TRUE;\n    if(err >= 200 || err < 400){\n        wilddog_debug(\"setValue success!\");\n    }\n\n    return;\n}\nint main(void){\n    //作为设置是否完成的标志为传入回调函数中.\n    BOOL isFinish = FALSE;\n    //初始化 Wilddog 引用，需要将 <appId> 修改为你自己的 appId\n    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)\"https://<appId>.wilddogio.com/users/Jack\");\n    //将Jack节点的值设为\"beauty\"\n    Wilddog_Node_T *node = wilddog_node_createUString(NULL, (Wilddog_Str_T*)\"beauty\");\n    //向云端写入\n    wilddog_setValue(ref, node, callback, (void*)&isFinish);\n    //设置完毕，释放空间\n    wilddog_node_delete(node);\n    while(1){\n        //和云端同步\n        wilddog_trySync();\n        if(TRUE == isFinish)//设置完成，退出\n            break;\n    }\n    wilddog_destroy(&ref);\n    return 0;\n}\n```\n当收到云端返回或者超时后，回调函数 callback 会被触发。\n\n<hr>\n\n**第三步：读取数据**\n\n读取数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么可以使用`wilddog_getValue()`来读取`Jack`节点的值。\n```c\n#include \"wilddog.h\"\nvoid callback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    *(BOOL*)arg = TRUE;\n    if(p_snapshot){\n        wilddog_debug_printnode(p_snapshot);\n        printf(\"\\ngetValue success!\\n\");\n    }\n    return;\n}\nint main(void){\n    //作为设置是否完成的标志为传入回调函数中.\n    BOOL isFinish = FALSE;\n    //初始化Wilddog引用，需要将<appId>修改为你自己的appId\n    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)\"https://<appId>.wilddogio.com/users/Jack\");\n    //从云端读取\n    wilddog_getValue(ref, callback, (void*)&isFinish);\n    while(1){\n        //和云端同步\n        wilddog_trySync();\n        if(TRUE == isFinish)//设置完成，退出\n            break;\n    }\n    wilddog_destroy(&ref);\n    return 0;\n}\n```\n<hr>\n\n**第四步：同步数据**\n\n同步数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么就可以使用`widdog_addObserver()`函数来实时同步`/users/Jack`的值。\n```c\n#include \"wilddog.h\"\nvoid callback(const Wilddog_Node_T* p_snapshot, void* arg, Wilddog_Return_T err){\n    if(p_snapshot){\n        wilddog_debug_printnode(p_snapshot);//打印出节点的值\n        printf(\"\\n\");\n    }\n    return;\n}\nint main(){\n    //初始化Wilddog引用，需要将<appId>修改为你自己的appId\n    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)\"https://<appId>.wilddogio.com/users/Jack\");\n    //向云端订阅该节点数据变化\n    wilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, NULL);\n    while(1){\n        wilddog_trySync();\n    }\n    wilddog_destroy(&ref);\n}\n```\n当从云端第一次同步数据，以及数据发生变化时，回调函数 callback 会被触发。每当我们对云端数据进行修改，SDK 就会收到通知。\n\n","date":"2016-09-06T03:38:22.551Z","updated":"2016-09-06T03:38:22.551Z","path":"quickstart/sync/c.html","comments":1,"layout":"page","_id":"cisswi9jq000kz4fwgyt4jc16","content":"<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><h3 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h3><ul>\n<li>具备 C 的基础知识。</li>\n<li>有一个 Wilddog 应用。如果还没有，请去<a href=\"https://www.wilddog.com/dashboard/\" target=\"_blank\" rel=\"external\">控制面板</a>创建一个。或者使用我们提供的测试应用 <a href=\"https://c_test.wilddogio.com\" target=\"_blank\" rel=\"external\">c_test</a></li>\n<li>从该网页下载 SDK： <a href=\"https://www.wilddog.com/download/\" target=\"_blank\" rel=\"external\">https://www.wilddog.com/download/</a></li>\n</ul>\n<p>Wilddog C/嵌入式 SDK 分为 C/RTOS、OpenWRT、Arduino 三种，具体支持的平台如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>支持的平台</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>Linux : 支持POSIX标准的平台，例如 Ubuntu、树莓派。</td>\n</tr>\n<tr>\n<td>C / RTOS SDK</td>\n<td>Broadcom WICED : 例如 Broadcom 的 BCM943362WCD4、AMPAK 的 WSDB733、WSDB750。</td>\n</tr>\n<tr>\n<td></td>\n<td>乐鑫 Espressif：例如 ESP8266。</td>\n</tr>\n<tr>\n<td></td>\n<td>庆科 MICO：例如 EMW3162。</td>\n</tr>\n<tr>\n<td>OpenWRT SDK</td>\n<td>ar71xx 系列。</td>\n</tr>\n<tr>\n<td>Arduino SDK</td>\n<td>Arduino Yun。</td>\n</tr>\n</tbody>\n</table>\n<p>在大部分平台下 C/嵌入式 SDK API 接口一致（Arduino 平台除外），因此下面我们以 Linux 平台为例，快速了解 SDK 的基本 API，其他平台可以参考 SDK 中的 docs 目录和 README。</p>\n<h3 id=\"编译-SDK\"><a href=\"#编译-SDK\" class=\"headerlink\" title=\"编译 SDK\"></a>编译 SDK</h3><p>Linux 平台下，编译 SDK 后生成的库文件在 SDK 的 lib 目录下。使用时需要在源文件中包含 wilddog.h ，将 SDK 的 include 文件夹拷贝到你的工程中，且在编译选项中增加该 lib 库。</p>\n<pre><code>$ cd wilddog-client-c\n$ make \n</code></pre><h2 id=\"入门-Demo-教程\"><a href=\"#入门-Demo-教程\" class=\"headerlink\" title=\"入门 Demo 教程\"></a>入门 Demo 教程</h2><p>本教程旨在让你在短时间内零基础学会在你的嵌入式设备上使用 Wilddog C/嵌入式 SDK 读写和同步 Wilddog 云端数据。<br><strong>第一步：创建 Wdilddog 云端引用</strong></p>\n<p>要读写 Wilddog 云端数据，必须先创建 Wilddog 云端引用：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_T ref = wilddog_initWithUrl(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/\"</span>);</div></pre></td></tr></table></figure></p>\n<p>创建引用的时候，需要传入数据的 URL 做为参数，把<code>&lt;appId&gt;</code>替换成你应用的 appId 。上面的代码定位到了数据库的根节点。URL 地址也可以包含数据路径，例如：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_T ref = wilddog_initWithUrl(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div></pre></td></tr></table></figure></p>\n<p>上面的代码定位到了数据库的<code>/users/Jack</code>节点上。</p>\n<p>SDK 提供了许多用于读写数据的方法。例如通过<code>wilddog_setValue()</code>、<code>wilddog_push()</code>、<code>wilddog_removeValue()</code>修改数据； 通过<code>wilddog_getValue()</code>读取数据；<code>wilddog_addObserver()</code>读取数据并监听该节点数据的变化。</p>\n<hr>\n\n<p><strong>第二步：写入数据</strong></p>\n<p>SDK 提供了一系列节点操作 API 对节点数据进行操作，在这里使用节点 create 函数族将<code>/users/Jack</code>节点值设置为字符串”beauty”,并通过<code>wilddog_setValue()</code>将这个值写入到云端。你可以在 SDK 的<code>examples/linux</code>目录下新建一个 C 源文件，将下面代码复制进去,修改 <code>&lt;appId&gt;</code> 为你自己的 appId ，并在 SDK 根目录执行<code>make example</code>。生成的可执行文件在 SDK 的 bin 目录下。为了简略，下面代码未检查返回值。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"wilddog.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &gt;= <span class=\"number\">200</span> || err &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"setValue success!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//作为设置是否完成的标志为传入回调函数中.</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    <span class=\"comment\">//初始化 Wilddog 引用，需要将 &lt;appId&gt; 修改为你自己的 appId</span></div><div class=\"line\">    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div><div class=\"line\">    <span class=\"comment\">//将Jack节点的值设为\"beauty\"</span></div><div class=\"line\">    Wilddog_Node_T *node = wilddog_node_createUString(<span class=\"literal\">NULL</span>, (Wilddog_Str_T*)<span class=\"string\">\"beauty\"</span>);</div><div class=\"line\">    <span class=\"comment\">//向云端写入</span></div><div class=\"line\">    wilddog_setValue(ref, node, callback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    <span class=\"comment\">//设置完毕，释放空间</span></div><div class=\"line\">    wilddog_node_delete(node);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">//和云端同步</span></div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)<span class=\"comment\">//设置完成，退出</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;ref);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当收到云端返回或者超时后，回调函数 callback 会被触发。</p>\n<hr>\n\n<p><strong>第三步：读取数据</strong></p>\n<p>读取数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么可以使用<code>wilddog_getValue()</code>来读取<code>Jack</code>节点的值。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"wilddog.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">if</span>(p_snapshot)&#123;</div><div class=\"line\">        wilddog_debug_printnode(p_snapshot);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ngetValue success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//作为设置是否完成的标志为传入回调函数中.</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    <span class=\"comment\">//初始化Wilddog引用，需要将&lt;appId&gt;修改为你自己的appId</span></div><div class=\"line\">    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div><div class=\"line\">    <span class=\"comment\">//从云端读取</span></div><div class=\"line\">    wilddog_getValue(ref, callback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">//和云端同步</span></div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)<span class=\"comment\">//设置完成，退出</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;ref);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n\n<p><strong>第四步：同步数据</strong></p>\n<p>同步数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么就可以使用<code>widdog_addObserver()</code>函数来实时同步<code>/users/Jack</code>的值。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"wilddog.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(p_snapshot)&#123;</div><div class=\"line\">        wilddog_debug_printnode(p_snapshot);<span class=\"comment\">//打印出节点的值</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化Wilddog引用，需要将&lt;appId&gt;修改为你自己的appId</span></div><div class=\"line\">    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div><div class=\"line\">    <span class=\"comment\">//向云端订阅该节点数据变化</span></div><div class=\"line\">    wilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, <span class=\"literal\">NULL</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;ref);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当从云端第一次同步数据，以及数据发生变化时，回调函数 callback 会被触发。每当我们对云端数据进行修改，SDK 就会收到通知。</p>\n","excerpt":"","more":"<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><h3 id=\"先决条件\"><a href=\"#先决条件\" class=\"headerlink\" title=\"先决条件\"></a>先决条件</h3><ul>\n<li>具备 C 的基础知识。</li>\n<li>有一个 Wilddog 应用。如果还没有，请去<a href=\"https://www.wilddog.com/dashboard/\">控制面板</a>创建一个。或者使用我们提供的测试应用 <a href=\"https://c_test.wilddogio.com\">c_test</a></li>\n<li>从该网页下载 SDK： <a href=\"https://www.wilddog.com/download/\">https://www.wilddog.com/download/</a></li>\n</ul>\n<p>Wilddog C/嵌入式 SDK 分为 C/RTOS、OpenWRT、Arduino 三种，具体支持的平台如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>支持的平台</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>Linux : 支持POSIX标准的平台，例如 Ubuntu、树莓派。</td>\n</tr>\n<tr>\n<td>C / RTOS SDK</td>\n<td>Broadcom WICED : 例如 Broadcom 的 BCM943362WCD4、AMPAK 的 WSDB733、WSDB750。</td>\n</tr>\n<tr>\n<td></td>\n<td>乐鑫 Espressif：例如 ESP8266。</td>\n</tr>\n<tr>\n<td></td>\n<td>庆科 MICO：例如 EMW3162。</td>\n</tr>\n<tr>\n<td>OpenWRT SDK</td>\n<td>ar71xx 系列。</td>\n</tr>\n<tr>\n<td>Arduino SDK</td>\n<td>Arduino Yun。</td>\n</tr>\n</tbody>\n</table>\n<p>在大部分平台下 C/嵌入式 SDK API 接口一致（Arduino 平台除外），因此下面我们以 Linux 平台为例，快速了解 SDK 的基本 API，其他平台可以参考 SDK 中的 docs 目录和 README。</p>\n<h3 id=\"编译-SDK\"><a href=\"#编译-SDK\" class=\"headerlink\" title=\"编译 SDK\"></a>编译 SDK</h3><p>Linux 平台下，编译 SDK 后生成的库文件在 SDK 的 lib 目录下。使用时需要在源文件中包含 wilddog.h ，将 SDK 的 include 文件夹拷贝到你的工程中，且在编译选项中增加该 lib 库。</p>\n<pre><code>$ cd wilddog-client-c\n$ make \n</code></pre><h2 id=\"入门-Demo-教程\"><a href=\"#入门-Demo-教程\" class=\"headerlink\" title=\"入门 Demo 教程\"></a>入门 Demo 教程</h2><p>本教程旨在让你在短时间内零基础学会在你的嵌入式设备上使用 Wilddog C/嵌入式 SDK 读写和同步 Wilddog 云端数据。<br><strong>第一步：创建 Wdilddog 云端引用</strong></p>\n<p>要读写 Wilddog 云端数据，必须先创建 Wilddog 云端引用：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_T ref = wilddog_initWithUrl(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/\"</span>);</div></pre></td></tr></table></figure></p>\n<p>创建引用的时候，需要传入数据的 URL 做为参数，把<code>&lt;appId&gt;</code>替换成你应用的 appId 。上面的代码定位到了数据库的根节点。URL 地址也可以包含数据路径，例如：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_T ref = wilddog_initWithUrl(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div></pre></td></tr></table></figure></p>\n<p>上面的代码定位到了数据库的<code>/users/Jack</code>节点上。</p>\n<p>SDK 提供了许多用于读写数据的方法。例如通过<code>wilddog_setValue()</code>、<code>wilddog_push()</code>、<code>wilddog_removeValue()</code>修改数据； 通过<code>wilddog_getValue()</code>读取数据；<code>wilddog_addObserver()</code>读取数据并监听该节点数据的变化。</p>\n<hr>\n\n<p><strong>第二步：写入数据</strong></p>\n<p>SDK 提供了一系列节点操作 API 对节点数据进行操作，在这里使用节点 create 函数族将<code>/users/Jack</code>节点值设置为字符串”beauty”,并通过<code>wilddog_setValue()</code>将这个值写入到云端。你可以在 SDK 的<code>examples/linux</code>目录下新建一个 C 源文件，将下面代码复制进去,修改 <code>&lt;appId&gt;</code> 为你自己的 appId ，并在 SDK 根目录执行<code>make example</code>。生成的可执行文件在 SDK 的 bin 目录下。为了简略，下面代码未检查返回值。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"wilddog.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &gt;= <span class=\"number\">200</span> || err &lt; <span class=\"number\">400</span>)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"setValue success!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//作为设置是否完成的标志为传入回调函数中.</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    <span class=\"comment\">//初始化 Wilddog 引用，需要将 &lt;appId&gt; 修改为你自己的 appId</span></div><div class=\"line\">    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div><div class=\"line\">    <span class=\"comment\">//将Jack节点的值设为\"beauty\"</span></div><div class=\"line\">    Wilddog_Node_T *node = wilddog_node_createUString(<span class=\"literal\">NULL</span>, (Wilddog_Str_T*)<span class=\"string\">\"beauty\"</span>);</div><div class=\"line\">    <span class=\"comment\">//向云端写入</span></div><div class=\"line\">    wilddog_setValue(ref, node, callback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    <span class=\"comment\">//设置完毕，释放空间</span></div><div class=\"line\">    wilddog_node_delete(node);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">//和云端同步</span></div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)<span class=\"comment\">//设置完成，退出</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;ref);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当收到云端返回或者超时后，回调函数 callback 会被触发。</p>\n<hr>\n\n<p><strong>第三步：读取数据</strong></p>\n<p>读取数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么可以使用<code>wilddog_getValue()</code>来读取<code>Jack</code>节点的值。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"wilddog.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">if</span>(p_snapshot)&#123;</div><div class=\"line\">        wilddog_debug_printnode(p_snapshot);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ngetValue success!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//作为设置是否完成的标志为传入回调函数中.</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    <span class=\"comment\">//初始化Wilddog引用，需要将&lt;appId&gt;修改为你自己的appId</span></div><div class=\"line\">    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div><div class=\"line\">    <span class=\"comment\">//从云端读取</span></div><div class=\"line\">    wilddog_getValue(ref, callback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">//和云端同步</span></div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)<span class=\"comment\">//设置完成，退出</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;ref);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n\n<p><strong>第四步：同步数据</strong></p>\n<p>同步数据也是通过绑定回调函数来实现的。假设我们按照上面的代码写入了数据，那么就可以使用<code>widdog_addObserver()</code>函数来实时同步<code>/users/Jack</code>的值。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"wilddog.h\"</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">(<span class=\"keyword\">const</span> Wilddog_Node_T* p_snapshot, <span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(p_snapshot)&#123;</div><div class=\"line\">        wilddog_debug_printnode(p_snapshot);<span class=\"comment\">//打印出节点的值</span></div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//初始化Wilddog引用，需要将&lt;appId&gt;修改为你自己的appId</span></div><div class=\"line\">    Wilddog_T ref = wilddog_initWithUrl((Wilddog_Str_T*)<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/users/Jack\"</span>);</div><div class=\"line\">    <span class=\"comment\">//向云端订阅该节点数据变化</span></div><div class=\"line\">    wilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, <span class=\"literal\">NULL</span>);</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;ref);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当从云端第一次同步数据，以及数据发生变化时，回调函数 callback 会被触发。每当我们对云端数据进行修改，SDK 就会收到通知。</p>\n"},{"title":"快速入门","_content":"\n## 一、先决条件 \n\n开始之前，需要查看你的环境和了解支持版本：  \n*\tXcode 7.0 或更高版本。\n*\t支持 iOS 7.0 或更高版本。\n\t\n如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个[快速入门示例](https://github.com/WildDogTeam/demo-ios-swiftchat)。\n注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的[iOS 升级指南](https://z.wilddog.com/upgrade/iosupgrade)开始升级。\n\n## 二、SDK 导入\n\nSDK 的导入方式有两种，你可以选择下面方式的其中一种：\n\n### 第一种：使用 CocoaPods \n要将 Wilddog SDK 导入到你的工程中，推荐使用 [CocoaPods](https://cocoapods.org/)，如果没用过 CocoaPods，请先访问 [CocoaPods getting started](https://guides.cocoapods.org/using/getting-started.html)。 \n\n\n打开工程目录，新建一个 Podfile 文件\n\n\t$ cd your-project-directory\n\t$ pod init\n\t$ open -a Xcode Podfile # opens your Podfile in XCode\n\n然后在 Podfile 文件中添加以下语句\n\n\tpod 'Wilddog/Sync'\n\t\n最后安装 SDK\n\n\t$ pod install\n\t$ open your-project.xcworkspace\n\t\n### 第二种：手动集成 \n\n1、下载 SDK。[下载地址](https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip)         \n2、把 WilddogSync.Framework 拖到工程目录中。  \n3、选中 Copy items if needed 、Create Groups，点击 Finish。  \n4、点击工程文件 -> TARGETS -> General，在 Linked Frameworks and Libraries 选项中点击 '+'，将 JavaScriptCore.framework、 libsqlite3 加入列表中。\n\n## 三、开发应用\n成功集成 SDK 之后，我们就可以开发应用了。\n\n### 第一步 初始化\n\n#### 1、引入头文件\n\nObjective-C \n\n\t#import \"Wilddog.h\"\n\n\nSwift\n\n\timport Wilddog\n\n#### 2、初始化\n\nObjective-C \n\n```objectivec\n// 创建一个引用到我们的数据库\nWilddog *myRootRef = [[Wilddog alloc] initWithUrl:@\"https://<appId>.wilddogio.com\"];\n```\n\nSwift\n\n```swift\n// 创建一个引用到我们的数据库\nvar myRootRef = Wilddog(url:\"https://<appId>.wilddogio.com\")\n```\n\n### 第二步 读写数据\n\n#### 1、写数据\n\n数据写到 Wilddog 数据库是比较简单的。我们可以使用 `setValue` 写入任何合法的 JSON 数据。\n\n\nObjective-C \n\n```objectivec\n// 写数据\n[myRootRef setValue:@\"Do you have data? You'll love Wilddog.\"];\n\n```\n\nSwift\n\n```swift\n// 写数据\nmyRootRef.setValue(\"Do you have data? You'll love Wilddog.\")\n\n```\n\n\n#### 2、读数据\n\nWilddog 服务器把数据实时同步给每一个正在监听的客户端。我们用 observeEventType 方法监听数据变化，然后会有一个 block 回调一个 WDataSnapshot 对象，它里面包含我们所需数据。\n\nObjective-C \n\n```objectivec\n// 读数据并监听数据变化\n[myRootRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"%@ -> %@\", snapshot.key, snapshot.value);\n}];\n\n```\n\nSwift\n```swift\n// 读数据并监听数据变化\nmyRootRef.observeEventType(.Value, withBlock: {\n  snapshot in\n  print(\"\\(snapshot.key) -> \\(snapshot.value)\")\n})\n\n```\n\n上述例子中，监听 value 这个事件，在初次获取数据的时候回调会触发一次，此后每当 myRootRef 节点下面的数据发生改变，回调都会被触发。了解关于更多的事件类型和如何处理事件数据，请参见 [查询数据](/guide/sync/ios/retrieve-data.html) 。\n\n\n### 第三步 保护数据安全\n\n到这一步，基本的读写数据操作已完成。  \n但是对于每一个新创建的 App， 它的权限默认为 **所有人都可以读写**。用于实际生产环境会非常危险！\n\n因此，我们提供了强大的[规则表达式简介](/guide/sync/rules/guide.html)，用于保证你的数据安全，主要功能是你可以自定义每个节点下数据的读写权限。\n规则表达式非常强大、灵活。根据你的需求，如果你的应用数据和登录用户有所关联，请结合我们的[身份认证服务](/quickstart/auth/ios.html) 一起使用。\n\n\n![](http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)\n\n\n\n","source":"quickstart/sync/ios.md","raw":"title: 快速入门\n---\n\n## 一、先决条件 \n\n开始之前，需要查看你的环境和了解支持版本：  \n*\tXcode 7.0 或更高版本。\n*\t支持 iOS 7.0 或更高版本。\n\t\n如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个[快速入门示例](https://github.com/WildDogTeam/demo-ios-swiftchat)。\n注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的[iOS 升级指南](https://z.wilddog.com/upgrade/iosupgrade)开始升级。\n\n## 二、SDK 导入\n\nSDK 的导入方式有两种，你可以选择下面方式的其中一种：\n\n### 第一种：使用 CocoaPods \n要将 Wilddog SDK 导入到你的工程中，推荐使用 [CocoaPods](https://cocoapods.org/)，如果没用过 CocoaPods，请先访问 [CocoaPods getting started](https://guides.cocoapods.org/using/getting-started.html)。 \n\n\n打开工程目录，新建一个 Podfile 文件\n\n\t$ cd your-project-directory\n\t$ pod init\n\t$ open -a Xcode Podfile # opens your Podfile in XCode\n\n然后在 Podfile 文件中添加以下语句\n\n\tpod 'Wilddog/Sync'\n\t\n最后安装 SDK\n\n\t$ pod install\n\t$ open your-project.xcworkspace\n\t\n### 第二种：手动集成 \n\n1、下载 SDK。[下载地址](https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip)         \n2、把 WilddogSync.Framework 拖到工程目录中。  \n3、选中 Copy items if needed 、Create Groups，点击 Finish。  \n4、点击工程文件 -> TARGETS -> General，在 Linked Frameworks and Libraries 选项中点击 '+'，将 JavaScriptCore.framework、 libsqlite3 加入列表中。\n\n## 三、开发应用\n成功集成 SDK 之后，我们就可以开发应用了。\n\n### 第一步 初始化\n\n#### 1、引入头文件\n\nObjective-C \n\n\t#import \"Wilddog.h\"\n\n\nSwift\n\n\timport Wilddog\n\n#### 2、初始化\n\nObjective-C \n\n```objectivec\n// 创建一个引用到我们的数据库\nWilddog *myRootRef = [[Wilddog alloc] initWithUrl:@\"https://<appId>.wilddogio.com\"];\n```\n\nSwift\n\n```swift\n// 创建一个引用到我们的数据库\nvar myRootRef = Wilddog(url:\"https://<appId>.wilddogio.com\")\n```\n\n### 第二步 读写数据\n\n#### 1、写数据\n\n数据写到 Wilddog 数据库是比较简单的。我们可以使用 `setValue` 写入任何合法的 JSON 数据。\n\n\nObjective-C \n\n```objectivec\n// 写数据\n[myRootRef setValue:@\"Do you have data? You'll love Wilddog.\"];\n\n```\n\nSwift\n\n```swift\n// 写数据\nmyRootRef.setValue(\"Do you have data? You'll love Wilddog.\")\n\n```\n\n\n#### 2、读数据\n\nWilddog 服务器把数据实时同步给每一个正在监听的客户端。我们用 observeEventType 方法监听数据变化，然后会有一个 block 回调一个 WDataSnapshot 对象，它里面包含我们所需数据。\n\nObjective-C \n\n```objectivec\n// 读数据并监听数据变化\n[myRootRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"%@ -> %@\", snapshot.key, snapshot.value);\n}];\n\n```\n\nSwift\n```swift\n// 读数据并监听数据变化\nmyRootRef.observeEventType(.Value, withBlock: {\n  snapshot in\n  print(\"\\(snapshot.key) -> \\(snapshot.value)\")\n})\n\n```\n\n上述例子中，监听 value 这个事件，在初次获取数据的时候回调会触发一次，此后每当 myRootRef 节点下面的数据发生改变，回调都会被触发。了解关于更多的事件类型和如何处理事件数据，请参见 [查询数据](/guide/sync/ios/retrieve-data.html) 。\n\n\n### 第三步 保护数据安全\n\n到这一步，基本的读写数据操作已完成。  \n但是对于每一个新创建的 App， 它的权限默认为 **所有人都可以读写**。用于实际生产环境会非常危险！\n\n因此，我们提供了强大的[规则表达式简介](/guide/sync/rules/guide.html)，用于保证你的数据安全，主要功能是你可以自定义每个节点下数据的读写权限。\n规则表达式非常强大、灵活。根据你的需求，如果你的应用数据和登录用户有所关联，请结合我们的[身份认证服务](/quickstart/auth/ios.html) 一起使用。\n\n\n![](http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)\n\n\n\n","date":"2016-09-06T03:38:22.551Z","updated":"2016-09-06T03:38:22.551Z","path":"quickstart/sync/ios.html","comments":1,"layout":"page","_id":"cisswi9jq000lz4fw4055gul2","content":"<h2 id=\"一、先决条件\"><a href=\"#一、先决条件\" class=\"headerlink\" title=\"一、先决条件\"></a>一、先决条件</h2><p>开始之前，需要查看你的环境和了解支持版本：  </p>\n<ul>\n<li>Xcode 7.0 或更高版本。</li>\n<li>支持 iOS 7.0 或更高版本。</li>\n</ul>\n<p>如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个<a href=\"https://github.com/WildDogTeam/demo-ios-swiftchat\" target=\"_blank\" rel=\"external\">快速入门示例</a>。<br>注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的<a href=\"https://z.wilddog.com/upgrade/iosupgrade\" target=\"_blank\" rel=\"external\">iOS 升级指南</a>开始升级。</p>\n<h2 id=\"二、SDK-导入\"><a href=\"#二、SDK-导入\" class=\"headerlink\" title=\"二、SDK 导入\"></a>二、SDK 导入</h2><p>SDK 的导入方式有两种，你可以选择下面方式的其中一种：</p>\n<h3 id=\"第一种：使用-CocoaPods\"><a href=\"#第一种：使用-CocoaPods\" class=\"headerlink\" title=\"第一种：使用 CocoaPods\"></a>第一种：使用 CocoaPods</h3><p>要将 Wilddog SDK 导入到你的工程中，推荐使用 <a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">CocoaPods</a>，如果没用过 CocoaPods，请先访问 <a href=\"https://guides.cocoapods.org/using/getting-started.html\" target=\"_blank\" rel=\"external\">CocoaPods getting started</a>。 </p>\n<p>打开工程目录，新建一个 Podfile 文件</p>\n<pre><code>$ cd your-project-directory\n$ pod init\n$ open -a Xcode Podfile # opens your Podfile in XCode\n</code></pre><p>然后在 Podfile 文件中添加以下语句</p>\n<pre><code>pod &apos;Wilddog/Sync&apos;\n</code></pre><p>最后安装 SDK</p>\n<pre><code>$ pod install\n$ open your-project.xcworkspace\n</code></pre><h3 id=\"第二种：手动集成\"><a href=\"#第二种：手动集成\" class=\"headerlink\" title=\"第二种：手动集成\"></a>第二种：手动集成</h3><p>1、下载 SDK。<a href=\"https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip\" target=\"_blank\" rel=\"external\">下载地址</a><br>2、把 WilddogSync.Framework 拖到工程目录中。<br>3、选中 Copy items if needed 、Create Groups，点击 Finish。<br>4、点击工程文件 -&gt; TARGETS -&gt; General，在 Linked Frameworks and Libraries 选项中点击 ‘+’，将 JavaScriptCore.framework、 libsqlite3 加入列表中。</p>\n<h2 id=\"三、开发应用\"><a href=\"#三、开发应用\" class=\"headerlink\" title=\"三、开发应用\"></a>三、开发应用</h2><p>成功集成 SDK 之后，我们就可以开发应用了。</p>\n<h3 id=\"第一步-初始化\"><a href=\"#第一步-初始化\" class=\"headerlink\" title=\"第一步 初始化\"></a>第一步 初始化</h3><h4 id=\"1、引入头文件\"><a href=\"#1、引入头文件\" class=\"headerlink\" title=\"1、引入头文件\"></a>1、引入头文件</h4><p>Objective-C </p>\n<pre><code>#import &quot;Wilddog.h&quot;\n</code></pre><p>Swift</p>\n<pre><code>import Wilddog\n</code></pre><h4 id=\"2、初始化\"><a href=\"#2、初始化\" class=\"headerlink\" title=\"2、初始化\"></a>2、初始化</h4><p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个引用到我们的数据库</span></div><div class=\"line\">Wilddog *myRootRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;appId&gt;.wilddogio.com\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个引用到我们的数据库</span></div><div class=\"line\"><span class=\"keyword\">var</span> myRootRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"第二步-读写数据\"><a href=\"#第二步-读写数据\" class=\"headerlink\" title=\"第二步 读写数据\"></a>第二步 读写数据</h3><h4 id=\"1、写数据\"><a href=\"#1、写数据\" class=\"headerlink\" title=\"1、写数据\"></a>1、写数据</h4><p>数据写到 Wilddog 数据库是比较简单的。我们可以使用 <code>setValue</code> 写入任何合法的 JSON 数据。</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写数据</span></div><div class=\"line\">[myRootRef setValue:<span class=\"string\">@\"Do you have data? You'll love Wilddog.\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写数据</span></div><div class=\"line\">myRootRef.setValue(<span class=\"string\">\"Do you have data? You'll love Wilddog.\"</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"2、读数据\"><a href=\"#2、读数据\" class=\"headerlink\" title=\"2、读数据\"></a>2、读数据</h4><p>Wilddog 服务器把数据实时同步给每一个正在监听的客户端。我们用 observeEventType 方法监听数据变化，然后会有一个 block 回调一个 WDataSnapshot 对象，它里面包含我们所需数据。</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 读数据并监听数据变化</span></div><div class=\"line\">[myRootRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -&gt; %@\"</span>, snapshot.key, snapshot.value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 读数据并监听数据变化</span></div><div class=\"line\">myRootRef.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123;</div><div class=\"line\">  snapshot <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"\\(snapshot.key) -&gt; \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>上述例子中，监听 value 这个事件，在初次获取数据的时候回调会触发一次，此后每当 myRootRef 节点下面的数据发生改变，回调都会被触发。了解关于更多的事件类型和如何处理事件数据，请参见 <a href=\"/guide/sync/ios/retrieve-data.html\">查询数据</a> 。</p>\n<h3 id=\"第三步-保护数据安全\"><a href=\"#第三步-保护数据安全\" class=\"headerlink\" title=\"第三步 保护数据安全\"></a>第三步 保护数据安全</h3><p>到这一步，基本的读写数据操作已完成。<br>但是对于每一个新创建的 App， 它的权限默认为 <strong>所有人都可以读写</strong>。用于实际生产环境会非常危险！</p>\n<p>因此，我们提供了强大的<a href=\"/guide/sync/rules/guide.html\">规则表达式简介</a>，用于保证你的数据安全，主要功能是你可以自定义每个节点下数据的读写权限。<br>规则表达式非常强大、灵活。根据你的需求，如果你的应用数据和登录用户有所关联，请结合我们的<a href=\"/quickstart/auth/ios.html\">身份认证服务</a> 一起使用。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"\"></p>\n","excerpt":"","more":"<h2 id=\"一、先决条件\"><a href=\"#一、先决条件\" class=\"headerlink\" title=\"一、先决条件\"></a>一、先决条件</h2><p>开始之前，需要查看你的环境和了解支持版本：  </p>\n<ul>\n<li>Xcode 7.0 或更高版本。</li>\n<li>支持 iOS 7.0 或更高版本。</li>\n</ul>\n<p>如果你尚无 Xcode 项目，而只想试用一下 Wilddog 功能，请下载一个<a href=\"https://github.com/WildDogTeam/demo-ios-swiftchat\">快速入门示例</a>。<br>注：如准备从 1.X 版升级 Wilddog SDK，请参阅我们的<a href=\"https://z.wilddog.com/upgrade/iosupgrade\">iOS 升级指南</a>开始升级。</p>\n<h2 id=\"二、SDK-导入\"><a href=\"#二、SDK-导入\" class=\"headerlink\" title=\"二、SDK 导入\"></a>二、SDK 导入</h2><p>SDK 的导入方式有两种，你可以选择下面方式的其中一种：</p>\n<h3 id=\"第一种：使用-CocoaPods\"><a href=\"#第一种：使用-CocoaPods\" class=\"headerlink\" title=\"第一种：使用 CocoaPods\"></a>第一种：使用 CocoaPods</h3><p>要将 Wilddog SDK 导入到你的工程中，推荐使用 <a href=\"https://cocoapods.org/\">CocoaPods</a>，如果没用过 CocoaPods，请先访问 <a href=\"https://guides.cocoapods.org/using/getting-started.html\">CocoaPods getting started</a>。 </p>\n<p>打开工程目录，新建一个 Podfile 文件</p>\n<pre><code>$ cd your-project-directory\n$ pod init\n$ open -a Xcode Podfile # opens your Podfile in XCode\n</code></pre><p>然后在 Podfile 文件中添加以下语句</p>\n<pre><code>pod &apos;Wilddog/Sync&apos;\n</code></pre><p>最后安装 SDK</p>\n<pre><code>$ pod install\n$ open your-project.xcworkspace\n</code></pre><h3 id=\"第二种：手动集成\"><a href=\"#第二种：手动集成\" class=\"headerlink\" title=\"第二种：手动集成\"></a>第二种：手动集成</h3><p>1、下载 SDK。<a href=\"https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip\">下载地址</a><br>2、把 WilddogSync.Framework 拖到工程目录中。<br>3、选中 Copy items if needed 、Create Groups，点击 Finish。<br>4、点击工程文件 -&gt; TARGETS -&gt; General，在 Linked Frameworks and Libraries 选项中点击 ‘+’，将 JavaScriptCore.framework、 libsqlite3 加入列表中。</p>\n<h2 id=\"三、开发应用\"><a href=\"#三、开发应用\" class=\"headerlink\" title=\"三、开发应用\"></a>三、开发应用</h2><p>成功集成 SDK 之后，我们就可以开发应用了。</p>\n<h3 id=\"第一步-初始化\"><a href=\"#第一步-初始化\" class=\"headerlink\" title=\"第一步 初始化\"></a>第一步 初始化</h3><h4 id=\"1、引入头文件\"><a href=\"#1、引入头文件\" class=\"headerlink\" title=\"1、引入头文件\"></a>1、引入头文件</h4><p>Objective-C </p>\n<pre><code>#import &quot;Wilddog.h&quot;\n</code></pre><p>Swift</p>\n<pre><code>import Wilddog\n</code></pre><h4 id=\"2、初始化\"><a href=\"#2、初始化\" class=\"headerlink\" title=\"2、初始化\"></a>2、初始化</h4><p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个引用到我们的数据库</span></div><div class=\"line\">Wilddog *myRootRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;appId&gt;.wilddogio.com\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个引用到我们的数据库</span></div><div class=\"line\"><span class=\"keyword\">var</span> myRootRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"第二步-读写数据\"><a href=\"#第二步-读写数据\" class=\"headerlink\" title=\"第二步 读写数据\"></a>第二步 读写数据</h3><h4 id=\"1、写数据\"><a href=\"#1、写数据\" class=\"headerlink\" title=\"1、写数据\"></a>1、写数据</h4><p>数据写到 Wilddog 数据库是比较简单的。我们可以使用 <code>setValue</code> 写入任何合法的 JSON 数据。</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写数据</span></div><div class=\"line\">[myRootRef setValue:<span class=\"string\">@\"Do you have data? You'll love Wilddog.\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写数据</span></div><div class=\"line\">myRootRef.setValue(<span class=\"string\">\"Do you have data? You'll love Wilddog.\"</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"2、读数据\"><a href=\"#2、读数据\" class=\"headerlink\" title=\"2、读数据\"></a>2、读数据</h4><p>Wilddog 服务器把数据实时同步给每一个正在监听的客户端。我们用 observeEventType 方法监听数据变化，然后会有一个 block 回调一个 WDataSnapshot 对象，它里面包含我们所需数据。</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 读数据并监听数据变化</span></div><div class=\"line\">[myRootRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -&gt; %@\"</span>, snapshot.key, snapshot.value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 读数据并监听数据变化</span></div><div class=\"line\">myRootRef.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123;</div><div class=\"line\">  snapshot <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"\\(snapshot.key) -&gt; \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>上述例子中，监听 value 这个事件，在初次获取数据的时候回调会触发一次，此后每当 myRootRef 节点下面的数据发生改变，回调都会被触发。了解关于更多的事件类型和如何处理事件数据，请参见 <a href=\"/guide/sync/ios/retrieve-data.html\">查询数据</a> 。</p>\n<h3 id=\"第三步-保护数据安全\"><a href=\"#第三步-保护数据安全\" class=\"headerlink\" title=\"第三步 保护数据安全\"></a>第三步 保护数据安全</h3><p>到这一步，基本的读写数据操作已完成。<br>但是对于每一个新创建的 App， 它的权限默认为 <strong>所有人都可以读写</strong>。用于实际生产环境会非常危险！</p>\n<p>因此，我们提供了强大的<a href=\"/guide/sync/rules/guide.html\">规则表达式简介</a>，用于保证你的数据安全，主要功能是你可以自定义每个节点下数据的读写权限。<br>规则表达式非常强大、灵活。根据你的需求，如果你的应用数据和登录用户有所关联，请结合我们的<a href=\"/quickstart/auth/ios.html\">身份认证服务</a> 一起使用。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"\"></p>\n"},{"title":"快速入门","_content":"\n\n## 1. 创建账号和应用\n\n首先，注册并登录Wilddog账号，进入[控制面板](https://www.wilddog.com/dashboard)。然后，在控制面板中，添加一个新的应用。 你会得到一个应用的URL `https://<appid>.wilddogio.com/`，其中<appid>就是你的应用ID。\n\n## 2. 读写数据\n\n我们可以在任何Wilddog的数据地址之后加上`.json`来作为URL，发送标准的HTTPS REST请求，实现对数据的读写操作。在本文档中，我们使用[CURL](https://en.wikipedia.org/wiki/CURL)工具发送HTTPS请求。\n\nREST API中最基本的写入操作是`PUT`，使用`PUT`请求写入数据:\n\n```\ncurl -X PUT -d '{ \"alanisawesome\": { \"name\": \"Alan Turing\", \"birthday\": \"June 23, 1912\" } }' 'https://docs-examples.wilddogio.com/rest/quickstart/users.json'\n\n```\n\n必须使用https。为了保障安全，Wilddog只支持加密的传输方式。 成功的请求会收到http状态码200 OK，响应中会包含我们写入Wilddog的数据。\n\n```\n{\n  \"alanisawesome\": {\n    \"birthday\": \"June 23, 1912\",\n    \"name\": \"Alan Turing\"\n  }\n}\n\n```\n\n在任何支持HTTPS的平台和编程语言中，都可以使用wilddog REST API。将来我们也会提供各种编程语言的库，使得REST API的使用更加简单和方便。\n\n现在你已经知道了REST API的基础知识，更多细节请参见 [完整指南](old/sync/rest/guide-rest.html)。","source":"quickstart/sync/rest.md","raw":"title: 快速入门\n---\n\n\n## 1. 创建账号和应用\n\n首先，注册并登录Wilddog账号，进入[控制面板](https://www.wilddog.com/dashboard)。然后，在控制面板中，添加一个新的应用。 你会得到一个应用的URL `https://<appid>.wilddogio.com/`，其中<appid>就是你的应用ID。\n\n## 2. 读写数据\n\n我们可以在任何Wilddog的数据地址之后加上`.json`来作为URL，发送标准的HTTPS REST请求，实现对数据的读写操作。在本文档中，我们使用[CURL](https://en.wikipedia.org/wiki/CURL)工具发送HTTPS请求。\n\nREST API中最基本的写入操作是`PUT`，使用`PUT`请求写入数据:\n\n```\ncurl -X PUT -d '{ \"alanisawesome\": { \"name\": \"Alan Turing\", \"birthday\": \"June 23, 1912\" } }' 'https://docs-examples.wilddogio.com/rest/quickstart/users.json'\n\n```\n\n必须使用https。为了保障安全，Wilddog只支持加密的传输方式。 成功的请求会收到http状态码200 OK，响应中会包含我们写入Wilddog的数据。\n\n```\n{\n  \"alanisawesome\": {\n    \"birthday\": \"June 23, 1912\",\n    \"name\": \"Alan Turing\"\n  }\n}\n\n```\n\n在任何支持HTTPS的平台和编程语言中，都可以使用wilddog REST API。将来我们也会提供各种编程语言的库，使得REST API的使用更加简单和方便。\n\n现在你已经知道了REST API的基础知识，更多细节请参见 [完整指南](old/sync/rest/guide-rest.html)。","date":"2016-09-06T03:38:22.551Z","updated":"2016-09-06T03:38:22.551Z","path":"quickstart/sync/rest.html","comments":1,"layout":"page","_id":"cisswi9jq000mz4fwnusql8fr","content":"<h2 id=\"1-创建账号和应用\"><a href=\"#1-创建账号和应用\" class=\"headerlink\" title=\"1. 创建账号和应用\"></a>1. 创建账号和应用</h2><p>首先，注册并登录Wilddog账号，进入<a href=\"https://www.wilddog.com/dashboard\" target=\"_blank\" rel=\"external\">控制面板</a>。然后，在控制面板中，添加一个新的应用。 你会得到一个应用的URL <code>https://&lt;appid&gt;.wilddogio.com/</code>，其中<appid>就是你的应用ID。</appid></p>\n<h2 id=\"2-读写数据\"><a href=\"#2-读写数据\" class=\"headerlink\" title=\"2. 读写数据\"></a>2. 读写数据</h2><p>我们可以在任何Wilddog的数据地址之后加上<code>.json</code>来作为URL，发送标准的HTTPS REST请求，实现对数据的读写操作。在本文档中，我们使用<a href=\"https://en.wikipedia.org/wiki/CURL\" target=\"_blank\" rel=\"external\">CURL</a>工具发送HTTPS请求。</p>\n<p>REST API中最基本的写入操作是<code>PUT</code>，使用<code>PUT</code>请求写入数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123; &quot;alanisawesome&quot;: &#123; &quot;name&quot;: &quot;Alan Turing&quot;, &quot;birthday&quot;: &quot;June 23, 1912&quot; &#125; &#125;&apos; &apos;https://docs-examples.wilddogio.com/rest/quickstart/users.json&apos;</div></pre></td></tr></table></figure>\n<p>必须使用https。为了保障安全，Wilddog只支持加密的传输方式。 成功的请求会收到http状态码200 OK，响应中会包含我们写入Wilddog的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;alanisawesome&quot;: &#123;</div><div class=\"line\">    &quot;birthday&quot;: &quot;June 23, 1912&quot;,</div><div class=\"line\">    &quot;name&quot;: &quot;Alan Turing&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在任何支持HTTPS的平台和编程语言中，都可以使用wilddog REST API。将来我们也会提供各种编程语言的库，使得REST API的使用更加简单和方便。</p>\n<p>现在你已经知道了REST API的基础知识，更多细节请参见 <a href=\"old/sync/rest/guide-rest.html\">完整指南</a>。</p>\n","excerpt":"","more":"<h2 id=\"1-创建账号和应用\"><a href=\"#1-创建账号和应用\" class=\"headerlink\" title=\"1. 创建账号和应用\"></a>1. 创建账号和应用</h2><p>首先，注册并登录Wilddog账号，进入<a href=\"https://www.wilddog.com/dashboard\">控制面板</a>。然后，在控制面板中，添加一个新的应用。 你会得到一个应用的URL <code>https://&lt;appid&gt;.wilddogio.com/</code>，其中<appid>就是你的应用ID。</p>\n<h2 id=\"2-读写数据\"><a href=\"#2-读写数据\" class=\"headerlink\" title=\"2. 读写数据\"></a>2. 读写数据</h2><p>我们可以在任何Wilddog的数据地址之后加上<code>.json</code>来作为URL，发送标准的HTTPS REST请求，实现对数据的读写操作。在本文档中，我们使用<a href=\"https://en.wikipedia.org/wiki/CURL\">CURL</a>工具发送HTTPS请求。</p>\n<p>REST API中最基本的写入操作是<code>PUT</code>，使用<code>PUT</code>请求写入数据:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123; &quot;alanisawesome&quot;: &#123; &quot;name&quot;: &quot;Alan Turing&quot;, &quot;birthday&quot;: &quot;June 23, 1912&quot; &#125; &#125;&apos; &apos;https://docs-examples.wilddogio.com/rest/quickstart/users.json&apos;</div></pre></td></tr></table></figure>\n<p>必须使用https。为了保障安全，Wilddog只支持加密的传输方式。 成功的请求会收到http状态码200 OK，响应中会包含我们写入Wilddog的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;alanisawesome&quot;: &#123;</div><div class=\"line\">    &quot;birthday&quot;: &quot;June 23, 1912&quot;,</div><div class=\"line\">    &quot;name&quot;: &quot;Alan Turing&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在任何支持HTTPS的平台和编程语言中，都可以使用wilddog REST API。将来我们也会提供各种编程语言的库，使得REST API的使用更加简单和方便。</p>\n<p>现在你已经知道了REST API的基础知识，更多细节请参见 <a href=\"old/sync/rest/guide-rest.html\">完整指南</a>。</p>\n"},{"title":"快速入门","_content":"\n我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。\n\n## 1. 创建应用\n\n你首先需要在控制面板中创建应用，如果你还不知道如何创建应用，请先阅读[控制面板-创建应用](/console/creat.html)。\n\n创建好的应用如下图，每个应用都有一个URL地址，这个地址是该应用的根节点位置。下面的示例应用地址为 yourapp.wilddogio.com，\"yourapp” 是该应用的 appId。\n\n<img src=\"/images/demoapp.png\" alt=\"yourApp\" width=\"300\">\n\n## 2. 引入 SDK\n首先引入 Wilddog SDK，只需要在你的页面中加入一行 javascript 标签。\n\n```html\n<script src = \"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\" ></script>\n```\n\n## 3. 创建 Wilddog 引用\n\n引入 Wilddog SDK 之后需要创建 Wilddog 引用，有了 Wilddog 引用才能对数据进行操作。\n\n创建 Wilddog引用对象:\n\n```javascript\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n```\n\nref 就是我们的 Wilddog 引用，你也可以换成你想要的命名。syncURL是你想定位的节点路径。\n\n上面的路径定位在数据库的根节点，你也可以传入更具体的数据路径，路径与数据节点的关系如下图所示：\n\n<img src=\"/images/routeapp.png\" alt=\"yourApp\" width=\"400\">\n\n比如我们想定位 Shanghai 的天气，那么我们可以将输入的 URL 定位在 Weather 的 Shanghai 节点下：\n\n```javascript\nvar childRef = ref.child(\"/weather/shanghai\");\n```\n\n\n\n## 4. 保存数据\n\n创建了 Wilddog 引用之后可以通过该引用对数据进行操作。\n\n Wilddog 提供了set() 方法向节点写入 JSON 数据。 Wilddog的数据是以 [JSON](http://json.org) 格式存储的，并没有传统关系型数据库中的表和记录的概念。 \n\n假设我们要存入北京和上海的天气信息：\n\n- **可以先定位在根节点下。**\n\n``` javascript\nsyncURL : https://yourapp.wilddogio.com\n```\n\n然后存入整个结构的 JSON 数据。\n\n```javascript\nref.set({\n  \"weather\":{\n    \"beijing\" : \"rain\",\n    \"shanghai\" : \"sunny\"    \n  }\n});\n```\n\n- **也可以先定位在 weather 节点下。**\n\n```javascript\nsyncURL : https://yourapp.wilddogio.com/weather\n```\n\n然后存入城市的天气信息。\n\n```javascript\nref.set({\n   \"beijing\" : \"rain\",\n   \"shanghai\" : \"sunny\"    \n});\n```\n\n 这两者的存入的内容是一样的。\n\n <img src=\"/images/saveapp.png\" alt=\"yourApp\" width=\"300\">\n\n**删除数据**和**更新数据**等更多操作数据的用法与此类似，你可以在[开发者指南](/guide/sync/web/retrieve-data.html)或者 [API 文档](/api/sync/web.html)中查看具体用法。\n\n## 5. 读取与监听数据\nWilddog 提供 on() 函数来读取并监听节点的数据。\n\n例如我们要想获取天气信息，我们通过 on() 函数来来读取：\n\n```javascript\nref.on(\"value\", function(snapshot) {\nconsole.log(snapshot.val());\n}\n```\n\n\n这样就能读出该节点下的所有数据。如果你想读取某个子节点的数据，比如只想看上海的天气，那么我们只需要在引用对象后面加上 child(节点名称)，就能够返回该节点的所有数据。\n\n```javascript\nref.child(\"shanghai\").on(\"value\", function(snapshot) {\nconsole.log(snapshot.val());\n}\n```\n\n读取数据是通过绑定回调函数来实现的，我们使用 on()函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 snapshot 对象类型，调用它的 val() 函数能够读取到返回的数据。\n\n取出的数据会一直保持同步，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新。如果你只想读取一次，不监听数据变化，那么你可以使用once()函数替代on()函数。\n\n## 6. 保护数据安全\n\n到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的应用权限初始权限都为 **所有人都可以读写**，用于实际生产环境将会非常危险。\n\nWilddog提供了强大的规则表达式来保障你的应用安全，规则表达式能够实现：\n\n- 读写权限设置\n- 用户授权\n- 数据校验\n- 提高查询效率\n\n你可以在应用里的**实时数据同步—读写权限**中配置规则表达式。具体的配置方法请参考文档[规则表达式](/guide/sync/rules/introduce.html)。\n\n![](http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)\n\n\n\n\n\n\n\n\n\n\n\n","source":"quickstart/sync/web.md","raw":"\ntitle: 快速入门\n---\n\n我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。\n\n## 1. 创建应用\n\n你首先需要在控制面板中创建应用，如果你还不知道如何创建应用，请先阅读[控制面板-创建应用](/console/creat.html)。\n\n创建好的应用如下图，每个应用都有一个URL地址，这个地址是该应用的根节点位置。下面的示例应用地址为 yourapp.wilddogio.com，\"yourapp” 是该应用的 appId。\n\n<img src=\"/images/demoapp.png\" alt=\"yourApp\" width=\"300\">\n\n## 2. 引入 SDK\n首先引入 Wilddog SDK，只需要在你的页面中加入一行 javascript 标签。\n\n```html\n<script src = \"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\" ></script>\n```\n\n## 3. 创建 Wilddog 引用\n\n引入 Wilddog SDK 之后需要创建 Wilddog 引用，有了 Wilddog 引用才能对数据进行操作。\n\n创建 Wilddog引用对象:\n\n```javascript\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n```\n\nref 就是我们的 Wilddog 引用，你也可以换成你想要的命名。syncURL是你想定位的节点路径。\n\n上面的路径定位在数据库的根节点，你也可以传入更具体的数据路径，路径与数据节点的关系如下图所示：\n\n<img src=\"/images/routeapp.png\" alt=\"yourApp\" width=\"400\">\n\n比如我们想定位 Shanghai 的天气，那么我们可以将输入的 URL 定位在 Weather 的 Shanghai 节点下：\n\n```javascript\nvar childRef = ref.child(\"/weather/shanghai\");\n```\n\n\n\n## 4. 保存数据\n\n创建了 Wilddog 引用之后可以通过该引用对数据进行操作。\n\n Wilddog 提供了set() 方法向节点写入 JSON 数据。 Wilddog的数据是以 [JSON](http://json.org) 格式存储的，并没有传统关系型数据库中的表和记录的概念。 \n\n假设我们要存入北京和上海的天气信息：\n\n- **可以先定位在根节点下。**\n\n``` javascript\nsyncURL : https://yourapp.wilddogio.com\n```\n\n然后存入整个结构的 JSON 数据。\n\n```javascript\nref.set({\n  \"weather\":{\n    \"beijing\" : \"rain\",\n    \"shanghai\" : \"sunny\"    \n  }\n});\n```\n\n- **也可以先定位在 weather 节点下。**\n\n```javascript\nsyncURL : https://yourapp.wilddogio.com/weather\n```\n\n然后存入城市的天气信息。\n\n```javascript\nref.set({\n   \"beijing\" : \"rain\",\n   \"shanghai\" : \"sunny\"    \n});\n```\n\n 这两者的存入的内容是一样的。\n\n <img src=\"/images/saveapp.png\" alt=\"yourApp\" width=\"300\">\n\n**删除数据**和**更新数据**等更多操作数据的用法与此类似，你可以在[开发者指南](/guide/sync/web/retrieve-data.html)或者 [API 文档](/api/sync/web.html)中查看具体用法。\n\n## 5. 读取与监听数据\nWilddog 提供 on() 函数来读取并监听节点的数据。\n\n例如我们要想获取天气信息，我们通过 on() 函数来来读取：\n\n```javascript\nref.on(\"value\", function(snapshot) {\nconsole.log(snapshot.val());\n}\n```\n\n\n这样就能读出该节点下的所有数据。如果你想读取某个子节点的数据，比如只想看上海的天气，那么我们只需要在引用对象后面加上 child(节点名称)，就能够返回该节点的所有数据。\n\n```javascript\nref.child(\"shanghai\").on(\"value\", function(snapshot) {\nconsole.log(snapshot.val());\n}\n```\n\n读取数据是通过绑定回调函数来实现的，我们使用 on()函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 snapshot 对象类型，调用它的 val() 函数能够读取到返回的数据。\n\n取出的数据会一直保持同步，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新。如果你只想读取一次，不监听数据变化，那么你可以使用once()函数替代on()函数。\n\n## 6. 保护数据安全\n\n到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的应用权限初始权限都为 **所有人都可以读写**，用于实际生产环境将会非常危险。\n\nWilddog提供了强大的规则表达式来保障你的应用安全，规则表达式能够实现：\n\n- 读写权限设置\n- 用户授权\n- 数据校验\n- 提高查询效率\n\n你可以在应用里的**实时数据同步—读写权限**中配置规则表达式。具体的配置方法请参考文档[规则表达式](/guide/sync/rules/introduce.html)。\n\n![](http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png)\n\n\n\n\n\n\n\n\n\n\n\n","date":"2016-09-07T13:24:23.171Z","updated":"2016-09-07T13:24:23.171Z","path":"quickstart/sync/web.html","_id":"cisswi9jq000nz4fw2cdw2yfa","comments":1,"layout":"page","content":"<p>我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。</p>\n<h2 id=\"1-创建应用\"><a href=\"#1-创建应用\" class=\"headerlink\" title=\"1. 创建应用\"></a>1. 创建应用</h2><p>你首先需要在控制面板中创建应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制面板-创建应用</a>。</p>\n<p>创建好的应用如下图，每个应用都有一个URL地址，这个地址是该应用的根节点位置。下面的示例应用地址为 yourapp.wilddogio.com，”yourapp” 是该应用的 appId。</p>\n<p><img src=\"/images/demoapp.png\" alt=\"yourApp\" width=\"300\"></p>\n<h2 id=\"2-引入-SDK\"><a href=\"#2-引入-SDK\" class=\"headerlink\" title=\"2. 引入 SDK\"></a>2. 引入 SDK</h2><p>首先引入 Wilddog SDK，只需要在你的页面中加入一行 javascript 标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span> = <span class=\"string\">\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\"</span> &gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"3-创建-Wilddog-引用\"><a href=\"#3-创建-Wilddog-引用\" class=\"headerlink\" title=\"3. 创建 Wilddog 引用\"></a>3. 创建 Wilddog 引用</h2><p>引入 Wilddog SDK 之后需要创建 Wilddog 引用，有了 Wilddog 引用才能对数据进行操作。</p>\n<p>创建 Wilddog引用对象:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div></pre></td></tr></table></figure>\n<p>ref 就是我们的 Wilddog 引用，你也可以换成你想要的命名。syncURL是你想定位的节点路径。</p>\n<p>上面的路径定位在数据库的根节点，你也可以传入更具体的数据路径，路径与数据节点的关系如下图所示：</p>\n<p><img src=\"/images/routeapp.png\" alt=\"yourApp\" width=\"400\"></p>\n<p>比如我们想定位 Shanghai 的天气，那么我们可以将输入的 URL 定位在 Weather 的 Shanghai 节点下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> childRef = ref.child(<span class=\"string\">\"/weather/shanghai\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"4-保存数据\"><a href=\"#4-保存数据\" class=\"headerlink\" title=\"4. 保存数据\"></a>4. 保存数据</h2><p>创建了 Wilddog 引用之后可以通过该引用对数据进行操作。</p>\n<p> Wilddog 提供了set() 方法向节点写入 JSON 数据。 Wilddog的数据是以 <a href=\"http://json.org\" target=\"_blank\" rel=\"external\">JSON</a> 格式存储的，并没有传统关系型数据库中的表和记录的概念。 </p>\n<p>假设我们要存入北京和上海的天气信息：</p>\n<ul>\n<li><strong>可以先定位在根节点下。</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">syncURL : https:<span class=\"comment\">//yourapp.wilddogio.com</span></div></pre></td></tr></table></figure>\n<p>然后存入整个结构的 JSON 数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.set(&#123;</div><div class=\"line\">  <span class=\"string\">\"weather\"</span>:&#123;</div><div class=\"line\">    <span class=\"string\">\"beijing\"</span> : <span class=\"string\">\"rain\"</span>,</div><div class=\"line\">    <span class=\"string\">\"shanghai\"</span> : <span class=\"string\">\"sunny\"</span>    </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>也可以先定位在 weather 节点下。</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">syncURL : https:<span class=\"comment\">//yourapp.wilddogio.com/weather</span></div></pre></td></tr></table></figure>\n<p>然后存入城市的天气信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.set(&#123;</div><div class=\"line\">   <span class=\"string\">\"beijing\"</span> : <span class=\"string\">\"rain\"</span>,</div><div class=\"line\">   <span class=\"string\">\"shanghai\"</span> : <span class=\"string\">\"sunny\"</span>    </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 这两者的存入的内容是一样的。</p>\n<p> <img src=\"/images/saveapp.png\" alt=\"yourApp\" width=\"300\"></p>\n<p><strong>删除数据</strong>和<strong>更新数据</strong>等更多操作数据的用法与此类似，你可以在<a href=\"/guide/sync/web/retrieve-data.html\">开发者指南</a>或者 <a href=\"/api/sync/web.html\">API 文档</a>中查看具体用法。</p>\n<h2 id=\"5-读取与监听数据\"><a href=\"#5-读取与监听数据\" class=\"headerlink\" title=\"5. 读取与监听数据\"></a>5. 读取与监听数据</h2><p>Wilddog 提供 on() 函数来读取并监听节点的数据。</p>\n<p>例如我们要想获取天气信息，我们通过 on() 函数来来读取：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就能读出该节点下的所有数据。如果你想读取某个子节点的数据，比如只想看上海的天气，那么我们只需要在引用对象后面加上 child(节点名称)，就能够返回该节点的所有数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.child(<span class=\"string\">\"shanghai\"</span>).on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>读取数据是通过绑定回调函数来实现的，我们使用 on()函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 snapshot 对象类型，调用它的 val() 函数能够读取到返回的数据。</p>\n<p>取出的数据会一直保持同步，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新。如果你只想读取一次，不监听数据变化，那么你可以使用once()函数替代on()函数。</p>\n<h2 id=\"6-保护数据安全\"><a href=\"#6-保护数据安全\" class=\"headerlink\" title=\"6. 保护数据安全\"></a>6. 保护数据安全</h2><p>到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的应用权限初始权限都为 <strong>所有人都可以读写</strong>，用于实际生产环境将会非常危险。</p>\n<p>Wilddog提供了强大的规则表达式来保障你的应用安全，规则表达式能够实现：</p>\n<ul>\n<li>读写权限设置</li>\n<li>用户授权</li>\n<li>数据校验</li>\n<li>提高查询效率</li>\n</ul>\n<p>你可以在应用里的<strong>实时数据同步—读写权限</strong>中配置规则表达式。具体的配置方法请参考文档<a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"\"></p>\n","excerpt":"","more":"<p>我们通过编写一个简单的天气应用例子来了解实时数据同步是如何使用的。</p>\n<h2 id=\"1-创建应用\"><a href=\"#1-创建应用\" class=\"headerlink\" title=\"1. 创建应用\"></a>1. 创建应用</h2><p>你首先需要在控制面板中创建应用，如果你还不知道如何创建应用，请先阅读<a href=\"/console/creat.html\">控制面板-创建应用</a>。</p>\n<p>创建好的应用如下图，每个应用都有一个URL地址，这个地址是该应用的根节点位置。下面的示例应用地址为 yourapp.wilddogio.com，”yourapp” 是该应用的 appId。</p>\n<p><img src=\"/images/demoapp.png\" alt=\"yourApp\" width=\"300\"></p>\n<h2 id=\"2-引入-SDK\"><a href=\"#2-引入-SDK\" class=\"headerlink\" title=\"2. 引入 SDK\"></a>2. 引入 SDK</h2><p>首先引入 Wilddog SDK，只需要在你的页面中加入一行 javascript 标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span> = <span class=\"string\">\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\"</span> &gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"3-创建-Wilddog-引用\"><a href=\"#3-创建-Wilddog-引用\" class=\"headerlink\" title=\"3. 创建 Wilddog 引用\"></a>3. 创建 Wilddog 引用</h2><p>引入 Wilddog SDK 之后需要创建 Wilddog 引用，有了 Wilddog 引用才能对数据进行操作。</p>\n<p>创建 Wilddog引用对象:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div></pre></td></tr></table></figure>\n<p>ref 就是我们的 Wilddog 引用，你也可以换成你想要的命名。syncURL是你想定位的节点路径。</p>\n<p>上面的路径定位在数据库的根节点，你也可以传入更具体的数据路径，路径与数据节点的关系如下图所示：</p>\n<p><img src=\"/images/routeapp.png\" alt=\"yourApp\" width=\"400\"></p>\n<p>比如我们想定位 Shanghai 的天气，那么我们可以将输入的 URL 定位在 Weather 的 Shanghai 节点下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> childRef = ref.child(<span class=\"string\">\"/weather/shanghai\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"4-保存数据\"><a href=\"#4-保存数据\" class=\"headerlink\" title=\"4. 保存数据\"></a>4. 保存数据</h2><p>创建了 Wilddog 引用之后可以通过该引用对数据进行操作。</p>\n<p> Wilddog 提供了set() 方法向节点写入 JSON 数据。 Wilddog的数据是以 <a href=\"http://json.org\">JSON</a> 格式存储的，并没有传统关系型数据库中的表和记录的概念。 </p>\n<p>假设我们要存入北京和上海的天气信息：</p>\n<ul>\n<li><strong>可以先定位在根节点下。</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">syncURL : https:<span class=\"comment\">//yourapp.wilddogio.com</span></div></pre></td></tr></table></figure>\n<p>然后存入整个结构的 JSON 数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.set(&#123;</div><div class=\"line\">  <span class=\"string\">\"weather\"</span>:&#123;</div><div class=\"line\">    <span class=\"string\">\"beijing\"</span> : <span class=\"string\">\"rain\"</span>,</div><div class=\"line\">    <span class=\"string\">\"shanghai\"</span> : <span class=\"string\">\"sunny\"</span>    </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>也可以先定位在 weather 节点下。</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">syncURL : https:<span class=\"comment\">//yourapp.wilddogio.com/weather</span></div></pre></td></tr></table></figure>\n<p>然后存入城市的天气信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.set(&#123;</div><div class=\"line\">   <span class=\"string\">\"beijing\"</span> : <span class=\"string\">\"rain\"</span>,</div><div class=\"line\">   <span class=\"string\">\"shanghai\"</span> : <span class=\"string\">\"sunny\"</span>    </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 这两者的存入的内容是一样的。</p>\n<p> <img src=\"/images/saveapp.png\" alt=\"yourApp\" width=\"300\"></p>\n<p><strong>删除数据</strong>和<strong>更新数据</strong>等更多操作数据的用法与此类似，你可以在<a href=\"/guide/sync/web/retrieve-data.html\">开发者指南</a>或者 <a href=\"/api/sync/web.html\">API 文档</a>中查看具体用法。</p>\n<h2 id=\"5-读取与监听数据\"><a href=\"#5-读取与监听数据\" class=\"headerlink\" title=\"5. 读取与监听数据\"></a>5. 读取与监听数据</h2><p>Wilddog 提供 on() 函数来读取并监听节点的数据。</p>\n<p>例如我们要想获取天气信息，我们通过 on() 函数来来读取：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就能读出该节点下的所有数据。如果你想读取某个子节点的数据，比如只想看上海的天气，那么我们只需要在引用对象后面加上 child(节点名称)，就能够返回该节点的所有数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.child(<span class=\"string\">\"shanghai\"</span>).on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(snapshot.val());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>读取数据是通过绑定回调函数来实现的，我们使用 on()函数读取数据的时候使用了一个回调函数，回调函数的参数是一个 snapshot 对象类型，调用它的 val() 函数能够读取到返回的数据。</p>\n<p>取出的数据会一直保持同步，当存储的数据更改的时候，不需要重新读取数据，终端的数据会自动更新。如果你只想读取一次，不监听数据变化，那么你可以使用once()函数替代on()函数。</p>\n<h2 id=\"6-保护数据安全\"><a href=\"#6-保护数据安全\" class=\"headerlink\" title=\"6. 保护数据安全\"></a>6. 保护数据安全</h2><p>到这一步，你已经可以完成基本的数据操作了，但是如果要将你的应用用于生产环境，你还需要注意应用的安全问题。每一个新创建的应用权限初始权限都为 <strong>所有人都可以读写</strong>，用于实际生产环境将会非常危险。</p>\n<p>Wilddog提供了强大的规则表达式来保障你的应用安全，规则表达式能够实现：</p>\n<ul>\n<li>读写权限设置</li>\n<li>用户授权</li>\n<li>数据校验</li>\n<li>提高查询效率</li>\n</ul>\n<p>你可以在应用里的<strong>实时数据同步—读写权限</strong>中配置规则表达式。具体的配置方法请参考文档<a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>。</p>\n<p><img src=\"http://ocpo37x5v.bkt.clouddn.com/2016-09-01-%E8%A7%84%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"\"></p>\n"},{"title":"绑定多种登录方式","_content":"\n通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。\n\n## 开始前的准备工作\n\n在野狗控制面板中打开多种登录方式（可以是匿名登录）。\n\n## 给帐号链接多种登录方式\n\n完成以下步骤为已有帐号添加多种登录方式：\n1.以任意一种登录方式登录一个帐号。\n\n2.准备一个未在认证的应用上登录过的邮箱或者第三方登录方式。\n\n3.通过一种登录方式获取 'AuthCredential'登录凭据。\n\n\n## QQ 登录\n\n```java\nAuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(\"access_token\"));\n```\n\n## 微信登录\n\n```java\nAuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);\n```\n\n## 微博登录\n\n```java\nAuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);\n```\n\n## 邮箱登录\n\n```java\nAuthCredential emailAuthCredential= EmailAuthProvider.getCredential(\"12345678@qq.com\",\"password123\");\n```\n\n4.使用 `linkWithCredential` 方法来完成完成链接如果链接的凭据已经链接到其它帐号上，则会返回失败：\n\n```java\nuser.linkWithCredential(authCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n     if(var1.isSuccessful()){\n         Log.d(\"success\",\"Link success\");\n     }else {\n         Log.d(\"failure\",\"Link failure\"+var1.getException().toString());\n     }\n    }\n});\n```\n \n如果调用 `linkWithCredential` 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。  \n\n## 解除一种登录方式\n\n如果不想再使用某种登录方式，你可以解除链接。\n为帐号解除登录方式，通过传递参数 provider ID 给 `unlink` 方法，你可以从 providerData 属性中获取到 provider ID。\n\n```java\nuser.unlink(\"providerId\");\n```    \n    \n    ","source":"guide/auth/android/link.md","raw":"title: 绑定多种登录方式\n---\n\n通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。\n\n## 开始前的准备工作\n\n在野狗控制面板中打开多种登录方式（可以是匿名登录）。\n\n## 给帐号链接多种登录方式\n\n完成以下步骤为已有帐号添加多种登录方式：\n1.以任意一种登录方式登录一个帐号。\n\n2.准备一个未在认证的应用上登录过的邮箱或者第三方登录方式。\n\n3.通过一种登录方式获取 'AuthCredential'登录凭据。\n\n\n## QQ 登录\n\n```java\nAuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(\"access_token\"));\n```\n\n## 微信登录\n\n```java\nAuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);\n```\n\n## 微博登录\n\n```java\nAuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);\n```\n\n## 邮箱登录\n\n```java\nAuthCredential emailAuthCredential= EmailAuthProvider.getCredential(\"12345678@qq.com\",\"password123\");\n```\n\n4.使用 `linkWithCredential` 方法来完成完成链接如果链接的凭据已经链接到其它帐号上，则会返回失败：\n\n```java\nuser.linkWithCredential(authCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n     if(var1.isSuccessful()){\n         Log.d(\"success\",\"Link success\");\n     }else {\n         Log.d(\"failure\",\"Link failure\"+var1.getException().toString());\n     }\n    }\n});\n```\n \n如果调用 `linkWithCredential` 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。  \n\n## 解除一种登录方式\n\n如果不想再使用某种登录方式，你可以解除链接。\n为帐号解除登录方式，通过传递参数 provider ID 给 `unlink` 方法，你可以从 providerData 属性中获取到 provider ID。\n\n```java\nuser.unlink(\"providerId\");\n```    \n    \n    ","date":"2016-09-06T03:38:22.520Z","updated":"2016-09-06T03:38:22.520Z","path":"guide/auth/android/link.html","comments":1,"layout":"page","_id":"cisswi9k5000oz4fwf0csahhh","content":"<p>通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>在野狗控制面板中打开多种登录方式（可以是匿名登录）。</p>\n<h2 id=\"给帐号链接多种登录方式\"><a href=\"#给帐号链接多种登录方式\" class=\"headerlink\" title=\"给帐号链接多种登录方式\"></a>给帐号链接多种登录方式</h2><p>完成以下步骤为已有帐号添加多种登录方式：<br>1.以任意一种登录方式登录一个帐号。</p>\n<p>2.准备一个未在认证的应用上登录过的邮箱或者第三方登录方式。</p>\n<p>3.通过一种登录方式获取 ‘AuthCredential’登录凭据。</p>\n<h2 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);</div></pre></td></tr></table></figure>\n<h2 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);</div></pre></td></tr></table></figure>\n<h2 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential emailAuthCredential= EmailAuthProvider.getCredential(<span class=\"string\">\"12345678@qq.com\"</span>,<span class=\"string\">\"password123\"</span>);</div></pre></td></tr></table></figure>\n<p>4.使用 <code>linkWithCredential</code> 方法来完成完成链接如果链接的凭据已经链接到其它帐号上，则会返回失败：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">user.linkWithCredential(authCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span>(var1.isSuccessful())&#123;</div><div class=\"line\">         Log.d(<span class=\"string\">\"success\"</span>,<span class=\"string\">\"Link success\"</span>);</div><div class=\"line\">     &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         Log.d(<span class=\"string\">\"failure\"</span>,<span class=\"string\">\"Link failure\"</span>+var1.getException().toString());</div><div class=\"line\">     &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果调用 <code>linkWithCredential</code> 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。  </p>\n<h2 id=\"解除一种登录方式\"><a href=\"#解除一种登录方式\" class=\"headerlink\" title=\"解除一种登录方式\"></a>解除一种登录方式</h2><p>如果不想再使用某种登录方式，你可以解除链接。<br>为帐号解除登录方式，通过传递参数 provider ID 给 <code>unlink</code> 方法，你可以从 providerData 属性中获取到 provider ID。</p>\n<pre><code class=\"java\">user.unlink(<span class=\"string\">\"providerId\"</span>);\n</code></pre>\n","excerpt":"","more":"<p>通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>在野狗控制面板中打开多种登录方式（可以是匿名登录）。</p>\n<h2 id=\"给帐号链接多种登录方式\"><a href=\"#给帐号链接多种登录方式\" class=\"headerlink\" title=\"给帐号链接多种登录方式\"></a>给帐号链接多种登录方式</h2><p>完成以下步骤为已有帐号添加多种登录方式：<br>1.以任意一种登录方式登录一个帐号。</p>\n<p>2.准备一个未在认证的应用上登录过的邮箱或者第三方登录方式。</p>\n<p>3.通过一种登录方式获取 ‘AuthCredential’登录凭据。</p>\n<h2 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);</div></pre></td></tr></table></figure>\n<h2 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);</div></pre></td></tr></table></figure>\n<h2 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential emailAuthCredential= EmailAuthProvider.getCredential(<span class=\"string\">\"12345678@qq.com\"</span>,<span class=\"string\">\"password123\"</span>);</div></pre></td></tr></table></figure>\n<p>4.使用 <code>linkWithCredential</code> 方法来完成完成链接如果链接的凭据已经链接到其它帐号上，则会返回失败：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">user.linkWithCredential(authCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span>(var1.isSuccessful())&#123;</div><div class=\"line\">         Log.d(<span class=\"string\">\"success\"</span>,<span class=\"string\">\"Link success\"</span>);</div><div class=\"line\">     &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         Log.d(<span class=\"string\">\"failure\"</span>,<span class=\"string\">\"Link failure\"</span>+var1.getException().toString());</div><div class=\"line\">     &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果调用 <code>linkWithCredential</code> 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。  </p>\n<h2 id=\"解除一种登录方式\"><a href=\"#解除一种登录方式\" class=\"headerlink\" title=\"解除一种登录方式\"></a>解除一种登录方式</h2><p>如果不想再使用某种登录方式，你可以解除链接。<br>为帐号解除登录方式，通过传递参数 provider ID 给 <code>unlink</code> 方法，你可以从 providerData 属性中获取到 provider ID。</p>\n<pre><code class=\"java\">user.unlink(<span class=\"string\">\"providerId\"</span>);\n</code></pre>\n"},{"title":"匿名用户身份认证","_content":"你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，可以绑定其它登录方式。\n\n## 开始前的准备工作\n\n1.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n    \n2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n3.打开匿名登录方式:\n\n   * 在野狗控制面板中选择身份认证选项。\n   * 在`登录方式`标签中打开匿名登录方式。\n\n\n## 使用 Wilddog 匿名登录认证\n\n当一个未登录的用户想想使用一个 `Wilddog` 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：\n\n1.初始化WilddogAuth对象.\n\n```java\nWilddogAuth mauth=WilddogAuth.getInstance(\"YOURAPPID\",context);\n```\n\n2.调用匿名登录方法\n\n```java    \nmauth.signInAnonymously().addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n        processResult(var1);\n            if(var1.isSuccessful()){\n       Log.d(\"success\",\"Login success!\");\n        Log.d(\"Anonymous\",String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));\n        }else {\n        Log.d(\"failure\",\"reason:\"+var1.getException());\n        }\n    }\n});\n```\n\n## 将匿名帐号转变成永久帐号  \n使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：\n准备一个未在你的应用上登录过的邮箱或者第三方登录方式。\n通过一种登录方式获取 AuthCredential：\n\n## QQ 登录\n\n```java\nAuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(\"access_token\"));\n```\n\n## 微信登录\n\n```java\nAuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);\n```\n\n## 微博登录\n\n```java\nAuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);\n```\n\n## 邮箱登录\n\n```java\nAuthCredential emailAuthCredential= EmailAuthProvider.getCredential(\"12345678@qq.com\",\"password123\");\n```\n\n## 使用 `linkWithCredential` 方法来完成完成链接：\n\n```java\nuser.linkWithCredential(authCredential);\n```\n\n如果调用 `linkWithCredential` 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。\n\n注： 这项技术可以链接任意两个类型的帐号。\n","source":"guide/auth/android/anonymous.md","raw":"title: 匿名用户身份认证\n---\n你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，可以绑定其它登录方式。\n\n## 开始前的准备工作\n\n1.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n    \n2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n3.打开匿名登录方式:\n\n   * 在野狗控制面板中选择身份认证选项。\n   * 在`登录方式`标签中打开匿名登录方式。\n\n\n## 使用 Wilddog 匿名登录认证\n\n当一个未登录的用户想想使用一个 `Wilddog` 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：\n\n1.初始化WilddogAuth对象.\n\n```java\nWilddogAuth mauth=WilddogAuth.getInstance(\"YOURAPPID\",context);\n```\n\n2.调用匿名登录方法\n\n```java    \nmauth.signInAnonymously().addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n        processResult(var1);\n            if(var1.isSuccessful()){\n       Log.d(\"success\",\"Login success!\");\n        Log.d(\"Anonymous\",String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));\n        }else {\n        Log.d(\"failure\",\"reason:\"+var1.getException());\n        }\n    }\n});\n```\n\n## 将匿名帐号转变成永久帐号  \n使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：\n准备一个未在你的应用上登录过的邮箱或者第三方登录方式。\n通过一种登录方式获取 AuthCredential：\n\n## QQ 登录\n\n```java\nAuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(\"access_token\"));\n```\n\n## 微信登录\n\n```java\nAuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);\n```\n\n## 微博登录\n\n```java\nAuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);\n```\n\n## 邮箱登录\n\n```java\nAuthCredential emailAuthCredential= EmailAuthProvider.getCredential(\"12345678@qq.com\",\"password123\");\n```\n\n## 使用 `linkWithCredential` 方法来完成完成链接：\n\n```java\nuser.linkWithCredential(authCredential);\n```\n\n如果调用 `linkWithCredential` 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。\n\n注： 这项技术可以链接任意两个类型的帐号。\n","date":"2016-09-06T03:38:22.520Z","updated":"2016-09-06T03:38:22.520Z","path":"guide/auth/android/anonymous.html","comments":1,"layout":"page","_id":"cisswi9k5000pz4fwj0ndvbjc","content":"<p>你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，可以绑定其它登录方式。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>3.打开匿名登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证选项。</li>\n<li>在<code>登录方式</code>标签中打开匿名登录方式。</li>\n</ul>\n<h2 id=\"使用-Wilddog-匿名登录认证\"><a href=\"#使用-Wilddog-匿名登录认证\" class=\"headerlink\" title=\"使用 Wilddog 匿名登录认证\"></a>使用 Wilddog 匿名登录认证</h2><p>当一个未登录的用户想想使用一个 <code>Wilddog</code> 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：</p>\n<p>1.初始化WilddogAuth对象.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth mauth=WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,context);</div></pre></td></tr></table></figure>\n<p>2.调用匿名登录方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInAnonymously().addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">        processResult(var1);</div><div class=\"line\">            <span class=\"keyword\">if</span>(var1.isSuccessful())&#123;</div><div class=\"line\">       Log.d(<span class=\"string\">\"success\"</span>,<span class=\"string\">\"Login success!\"</span>);</div><div class=\"line\">        Log.d(<span class=\"string\">\"Anonymous\"</span>,String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        Log.d(<span class=\"string\">\"failure\"</span>,<span class=\"string\">\"reason:\"</span>+var1.getException());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"将匿名帐号转变成永久帐号\"><a href=\"#将匿名帐号转变成永久帐号\" class=\"headerlink\" title=\"将匿名帐号转变成永久帐号\"></a>将匿名帐号转变成永久帐号</h2><p>使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：<br>准备一个未在你的应用上登录过的邮箱或者第三方登录方式。<br>通过一种登录方式获取 AuthCredential：</p>\n<h2 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);</div></pre></td></tr></table></figure>\n<h2 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);</div></pre></td></tr></table></figure>\n<h2 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential emailAuthCredential= EmailAuthProvider.getCredential(<span class=\"string\">\"12345678@qq.com\"</span>,<span class=\"string\">\"password123\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"使用-linkWithCredential-方法来完成完成链接：\"><a href=\"#使用-linkWithCredential-方法来完成完成链接：\" class=\"headerlink\" title=\"使用 linkWithCredential 方法来完成完成链接：\"></a>使用 <code>linkWithCredential</code> 方法来完成完成链接：</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">user.linkWithCredential(authCredential);</div></pre></td></tr></table></figure>\n<p>如果调用 <code>linkWithCredential</code> 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。</p>\n<p>注： 这项技术可以链接任意两个类型的帐号。</p>\n","excerpt":"","more":"<p>你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，可以绑定其它登录方式。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>3.打开匿名登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证选项。</li>\n<li>在<code>登录方式</code>标签中打开匿名登录方式。</li>\n</ul>\n<h2 id=\"使用-Wilddog-匿名登录认证\"><a href=\"#使用-Wilddog-匿名登录认证\" class=\"headerlink\" title=\"使用 Wilddog 匿名登录认证\"></a>使用 Wilddog 匿名登录认证</h2><p>当一个未登录的用户想想使用一个 <code>Wilddog</code> 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：</p>\n<p>1.初始化WilddogAuth对象.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth mauth=WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,context);</div></pre></td></tr></table></figure>\n<p>2.调用匿名登录方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInAnonymously().addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">        processResult(var1);</div><div class=\"line\">            <span class=\"keyword\">if</span>(var1.isSuccessful())&#123;</div><div class=\"line\">       Log.d(<span class=\"string\">\"success\"</span>,<span class=\"string\">\"Login success!\"</span>);</div><div class=\"line\">        Log.d(<span class=\"string\">\"Anonymous\"</span>,String.valueOf(var1.getResult().getWilddogUser().isAnonymous()));</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        Log.d(<span class=\"string\">\"failure\"</span>,<span class=\"string\">\"reason:\"</span>+var1.getException());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"将匿名帐号转变成永久帐号\"><a href=\"#将匿名帐号转变成永久帐号\" class=\"headerlink\" title=\"将匿名帐号转变成永久帐号\"></a>将匿名帐号转变成永久帐号</h2><p>使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：<br>准备一个未在你的应用上登录过的邮箱或者第三方登录方式。<br>通过一种登录方式获取 AuthCredential：</p>\n<h2 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiXinAuthCredential= WeiXinAuthProvider.getCredential(code);</div></pre></td></tr></table></figure>\n<h2 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiboAuthCredential= WeiboAuthProvider.getCredential(access_token,openid);</div></pre></td></tr></table></figure>\n<h2 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential emailAuthCredential= EmailAuthProvider.getCredential(<span class=\"string\">\"12345678@qq.com\"</span>,<span class=\"string\">\"password123\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"使用-linkWithCredential-方法来完成完成链接：\"><a href=\"#使用-linkWithCredential-方法来完成完成链接：\" class=\"headerlink\" title=\"使用 linkWithCredential 方法来完成完成链接：\"></a>使用 <code>linkWithCredential</code> 方法来完成完成链接：</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">user.linkWithCredential(authCredential);</div></pre></td></tr></table></figure>\n<p>如果调用 <code>linkWithCredential</code> 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。</p>\n<p>注： 这项技术可以链接任意两个类型的帐号。</p>\n"},{"title":"QQ 登录","_content":"通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n\n## 开始前的准备工作\n\n1.将 WilddogAuth 添加至你的 Android 项目。\n\n2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n4.在 [QQ 开放平台管理中心](http://op.open.qq.com/)，获取应用的 App ID 和 App Secret。\n\n5.在野狗应用控制面板中打开QQ登录方式:\n\n  *  在野狗控制面板中选择 ”身份认证“->登录方式。\n  *  点击 QQ 登录开关，点击配置，输入 QQ 帐号 APP ID 和 App Secret。\n\n## Wilddog 身份认证\n\n1.参考[QQ API 调用说明](http://wiki.open.qq.com/wiki/Android_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E) 将 QQ 登录集成到你的应用中。 初始化Tencent对象，并且在\nIUiListener对象中获取登录的token。\n\n\n```java\nTencent mTencent = Tencent.createInstance(\"YOURTENCENTAPPID\", getApplicationContext());\nIUiListener loginListener = new IUiListener() {\n\n    @Override\n    public void onComplete(Object o) {\n        JSONObject jsonObject = (JSONObject) o;\n\n        try {\n            Log.d(\"accesstoken\", jsonObject.getString(\"access_token\"));\n            mTencent.setAccessToken(jsonObject.getString(\"access_token\"), jsonObject.getString(\"expires_in\"));\n            mTencent.setOpenId(jsonObject.getString(\"openid\"));\n            // TODO WilddogQQLogin\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    @Override\n    public void onError(UiError uiError) {\n    }\n\n    @Override\n    public void onCancel() {\n    }\n\n};\n\n// QQ登录方法\nprivate void qqlogin() {\n    mTencent = TestWilddogAuthApplication.getTencent();\n    if (!mTencent.isSessionValid()) {\n        mTencent.login(this, \"all\", loginListener);\n    }\n}\n\n// QQ 处理回调\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n    mTencent.onActivityResult(requestCode, resultCode, data);\n    if (requestCode == Constants.REQUEST_LOGIN) {\n        if (resultCode == Constants.ACTIVITY_OK) {\n            Tencent.handleResultData(data, loginListener);\n        } else if (resultCode == Constants.ACTIVITY_CANCEL) {\n\n        }\n    }\n}\n```\n\n2.QQ 授权登录成功后，获取QQ access token 来生成 Wilddog 凭据：\n\n```java\nAuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(\"access_token\"));\n```\n\n3.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\n```java\nmauth.signInWithCredential(qqAuthCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n        processResult(var1);\n    }\n});\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","source":"guide/auth/android/qq.md","raw":"title:  QQ 登录\n---\n通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n\n## 开始前的准备工作\n\n1.将 WilddogAuth 添加至你的 Android 项目。\n\n2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n4.在 [QQ 开放平台管理中心](http://op.open.qq.com/)，获取应用的 App ID 和 App Secret。\n\n5.在野狗应用控制面板中打开QQ登录方式:\n\n  *  在野狗控制面板中选择 ”身份认证“->登录方式。\n  *  点击 QQ 登录开关，点击配置，输入 QQ 帐号 APP ID 和 App Secret。\n\n## Wilddog 身份认证\n\n1.参考[QQ API 调用说明](http://wiki.open.qq.com/wiki/Android_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E) 将 QQ 登录集成到你的应用中。 初始化Tencent对象，并且在\nIUiListener对象中获取登录的token。\n\n\n```java\nTencent mTencent = Tencent.createInstance(\"YOURTENCENTAPPID\", getApplicationContext());\nIUiListener loginListener = new IUiListener() {\n\n    @Override\n    public void onComplete(Object o) {\n        JSONObject jsonObject = (JSONObject) o;\n\n        try {\n            Log.d(\"accesstoken\", jsonObject.getString(\"access_token\"));\n            mTencent.setAccessToken(jsonObject.getString(\"access_token\"), jsonObject.getString(\"expires_in\"));\n            mTencent.setOpenId(jsonObject.getString(\"openid\"));\n            // TODO WilddogQQLogin\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    @Override\n    public void onError(UiError uiError) {\n    }\n\n    @Override\n    public void onCancel() {\n    }\n\n};\n\n// QQ登录方法\nprivate void qqlogin() {\n    mTencent = TestWilddogAuthApplication.getTencent();\n    if (!mTencent.isSessionValid()) {\n        mTencent.login(this, \"all\", loginListener);\n    }\n}\n\n// QQ 处理回调\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\n    mTencent.onActivityResult(requestCode, resultCode, data);\n    if (requestCode == Constants.REQUEST_LOGIN) {\n        if (resultCode == Constants.ACTIVITY_OK) {\n            Tencent.handleResultData(data, loginListener);\n        } else if (resultCode == Constants.ACTIVITY_CANCEL) {\n\n        }\n    }\n}\n```\n\n2.QQ 授权登录成功后，获取QQ access token 来生成 Wilddog 凭据：\n\n```java\nAuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(\"access_token\"));\n```\n\n3.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\n```java\nmauth.signInWithCredential(qqAuthCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n        processResult(var1);\n    }\n});\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","date":"2016-09-06T03:38:22.522Z","updated":"2016-09-06T03:38:22.522Z","path":"guide/auth/android/qq.html","comments":1,"layout":"page","_id":"cisswi9k5000qz4fwfkekh4ek","content":"<p>通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。<br>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 WilddogAuth 添加至你的 Android 项目。</p>\n<p>2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>4.在 <a href=\"http://op.open.qq.com/\" target=\"_blank\" rel=\"external\">QQ 开放平台管理中心</a>，获取应用的 App ID 和 App Secret。</p>\n<p>5.在野狗应用控制面板中打开QQ登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击 QQ 登录开关，点击配置，输入 QQ 帐号 APP ID 和 App Secret。</li>\n</ul>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1.参考<a href=\"http://wiki.open.qq.com/wiki/Android_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E\" target=\"_blank\" rel=\"external\">QQ API 调用说明</a> 将 QQ 登录集成到你的应用中。 初始化Tencent对象，并且在<br>IUiListener对象中获取登录的token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Tencent mTencent = Tencent.createInstance(<span class=\"string\">\"YOURTENCENTAPPID\"</span>, getApplicationContext());</div><div class=\"line\">IUiListener loginListener = <span class=\"keyword\">new</span> IUiListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">        JSONObject jsonObject = (JSONObject) o;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Log.d(<span class=\"string\">\"accesstoken\"</span>, jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div><div class=\"line\">            mTencent.setAccessToken(jsonObject.getString(<span class=\"string\">\"access_token\"</span>), jsonObject.getString(<span class=\"string\">\"expires_in\"</span>));</div><div class=\"line\">            mTencent.setOpenId(jsonObject.getString(<span class=\"string\">\"openid\"</span>));</div><div class=\"line\">            <span class=\"comment\">// TODO WilddogQQLogin</span></div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(UiError uiError)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// QQ登录方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">qqlogin</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    mTencent = TestWilddogAuthApplication.getTencent();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!mTencent.isSessionValid()) &#123;</div><div class=\"line\">        mTencent.login(<span class=\"keyword\">this</span>, <span class=\"string\">\"all\"</span>, loginListener);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// QQ 处理回调</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    mTencent.onActivityResult(requestCode, resultCode, data);</div><div class=\"line\">    <span class=\"keyword\">if</span> (requestCode == Constants.REQUEST_LOGIN) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (resultCode == Constants.ACTIVITY_OK) &#123;</div><div class=\"line\">            Tencent.handleResultData(data, loginListener);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (resultCode == Constants.ACTIVITY_CANCEL) &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.QQ 授权登录成功后，获取QQ access token 来生成 Wilddog 凭据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div></pre></td></tr></table></figure>\n<p>3.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCredential(qqAuthCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">        processResult(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n","excerpt":"","more":"<p>通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。<br>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 WilddogAuth 添加至你的 Android 项目。</p>\n<p>2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>4.在 <a href=\"http://op.open.qq.com/\">QQ 开放平台管理中心</a>，获取应用的 App ID 和 App Secret。</p>\n<p>5.在野狗应用控制面板中打开QQ登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击 QQ 登录开关，点击配置，输入 QQ 帐号 APP ID 和 App Secret。</li>\n</ul>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1.参考<a href=\"http://wiki.open.qq.com/wiki/Android_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E\">QQ API 调用说明</a> 将 QQ 登录集成到你的应用中。 初始化Tencent对象，并且在<br>IUiListener对象中获取登录的token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Tencent mTencent = Tencent.createInstance(<span class=\"string\">\"YOURTENCENTAPPID\"</span>, getApplicationContext());</div><div class=\"line\">IUiListener loginListener = <span class=\"keyword\">new</span> IUiListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Object o)</span> </span>&#123;</div><div class=\"line\">        JSONObject jsonObject = (JSONObject) o;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Log.d(<span class=\"string\">\"accesstoken\"</span>, jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div><div class=\"line\">            mTencent.setAccessToken(jsonObject.getString(<span class=\"string\">\"access_token\"</span>), jsonObject.getString(<span class=\"string\">\"expires_in\"</span>));</div><div class=\"line\">            mTencent.setOpenId(jsonObject.getString(<span class=\"string\">\"openid\"</span>));</div><div class=\"line\">            <span class=\"comment\">// TODO WilddogQQLogin</span></div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(UiError uiError)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// QQ登录方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">qqlogin</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    mTencent = TestWilddogAuthApplication.getTencent();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!mTencent.isSessionValid()) &#123;</div><div class=\"line\">        mTencent.login(<span class=\"keyword\">this</span>, <span class=\"string\">\"all\"</span>, loginListener);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// QQ 处理回调</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityResult</span><span class=\"params\">(<span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    mTencent.onActivityResult(requestCode, resultCode, data);</div><div class=\"line\">    <span class=\"keyword\">if</span> (requestCode == Constants.REQUEST_LOGIN) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (resultCode == Constants.ACTIVITY_OK) &#123;</div><div class=\"line\">            Tencent.handleResultData(data, loginListener);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (resultCode == Constants.ACTIVITY_CANCEL) &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>2.QQ 授权登录成功后，获取QQ access token 来生成 Wilddog 凭据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential qqAuthCredential= QQAuthProvider.getCredential(jsonObject.getString(<span class=\"string\">\"access_token\"</span>));</div></pre></td></tr></table></figure>\n<p>3.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCredential(qqAuthCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">        processResult(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n"},{"title":"管理用户","_content":"\n## 创建用户\n\n通过调用 `createUserWithEmailAndPassword` 方法或首次使用第三方登录方式（如 `signInWithCredential(qqAuthCredential)`等）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。\n\n\n您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。\n\n\n## 获取当前登录的用户\n\n获取当前用户的推荐方法是在 WilddogAuth 对象上设置一个侦听器：\n\n```java\nWilddogAuth auth=WilddogAuth.getInstance(\"YOURAPPID\"，context);\nWilddogAuth.AuthStateListener authStateListener=new WilddogAuth.AuthStateListener(){\n    @Override\n    public void onAuthStateChanged(WilddogAuth wilddogAuth) {\n        WilddogUser user=wilddogauth.getCurrentUser();\n        if(user!=null){\n         // User is signed in.\n          Log.d(TAG, \"onAuthStateChanged:signed_in:\" + user.getUid());\n        }else{\n         // No user is signed in.\n           Log.d(TAG, \"onAuthStateChanged:signed_out\");\n        }\n    }\n};\nauth.addAuthStateListener(authStateListener);\n```\n\n使用侦听器可保证在您获取当前用户时 `WilddogAuth` 对象不会处于中间状态如初始化。\n您也可以使用 `getCurrentUser` 方法获取当前已登录的用户。 如果用户没有登录，`currentUser` 则为空：\n\n```java\nWilddogUser user=auth.getCurrentUser();\nif(user!=null){\n // User is signed in.\n}else{\n // No user is signed in.\n}\n```\n\n注：getCurrentUser 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。\n\n## 获取用户个人资料\n\n要获取用户的个人资料信息，请使用 `WilddogUser` 实例的访问器方法。 例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\nif (user != null) {\n    // User is signed in.\n    // The uid properties and providerId will never be empty.\n    // The user's ID, unique to the Wilddog\n    // project. Do NOT use this value to\n    // authenticate with your backend server, if\n    // you have one. Use\n    // user.getToken: instead.\n    String uid = user.getUid();\n    String providerId = user.getProviderId();\n    // The displayName and photoUrl in QQ or Weichat login will not be\n    // empty.\n    String name = user.getDisplayName();\n    Uri photoUrl = user.getPhotoUrl();\n    // The email will not be empty only by email login.\n    String email = user.getEmail();\n} else {\n    // No user is signed in.\n}\n```\n\n## 获取用户的第三方登录的个人资料信息\n\n要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\nif (user != null) {\n    // User is signed in.\n    String uid = user.getUid();\n    List<WilddogUser> userProviderInfos = user.getProviderData();\n    for (UserInfo profile : userProviderInfos) {\n        // Id of the provider (ex: qq)\n        String providerId = profile.getProviderId();\n\n        // UID specific to the provider\n        String uid = profile.getUid();\n\n        // Name, email address, and profile photo Url\n        String name = profile.getDisplayName();\n        String email = profile.getEmail();\n        Uri photoUrl = profile.getPhotoUrl();\n    }\n    ;\n} else {\n    // No user is signed in.\n}\n```\n\n## 更新用户个人资料\n\n您可以使用 `updateProfile` 方法更新用户的基本个人资料信息—用户的显示名称和个人资料照片网址。 例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\nUserProfileChangeRequest profileUpdates = new  UserProfileChangeRequest.Builder()\n    .setDisplayName(\"xiaofei\")\n    .setPhotoUri(Uri.parse(\"https://example.com/jane-q-user/profile.jpg\"))\n    .build();\n\nuser.updateProfile(profileUpdates)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User profile updated.\");\n            }\n\n        }\n    });\n```\n\n## 设置用户的电子邮件地址\n\n您可以使用 `updateEmail` 方法设置用户的电子邮件地址。例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\nuser.updateEmail(\"user@example.com\")\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User email address updated.\");\n            }\n        }\n    });\n```\n\n重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 设置用户密码\n您可以使用 'updatePassword' 方法设置用户密码。例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\nString newPassword = \"SOME-SECURE-PASSWORD\";\n\nuser.updatePassword(newPassword)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User password updated.\");\n            }\n        }\n    });\n```\n\n重要说明：要设置用户密码，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 发送重设密码电子邮件\n您可以用 `sendPasswordResetEmail` 方法向用户发送一封重设密码电子邮件。 例如：\n\n```java\nString emailAddress = \"user@example.com\";\n\nauth.sendPasswordResetEmail(emailAddress)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"Email sent.\");\n            }\n        }\n    });\n```\n\n您可以在 `Wilddog` 控制台 的“用户认证”部分的“邮件模板”页面中自定义使用的电子邮件模板。\n\n您也可以从 `Wilddog` 控制面板中发送重设密码电子邮件。\n\n\n## 删除用户\n您可以使用 `delete` 方法删除用户帐户。例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\nuser.delete()\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User account deleted.\");\n            }\n        }\n    });\n```\n\n重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。\n\n\n## 对用户重新进行身份认证\n有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。\n\n如果您执行一项这种操作，而该用户只是在很久以前登录过，该操作便会失败并引发 `WilddogAuthRecentLoginRequiredException`。发生这种错误时，请从用户获取新登录凭据并将该凭据传输至 `reauthenticate`，对该用户重新进行身份认证。\n\n例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\n// Get auth credentials from the user for re-authentication. The example below shows\n// email and password credentials but there are multiple possible providers,\n// such as QQAuthProvider or WeixinAuthProvider.\nAuthCredential credential = EmailAuthProvider\n    .getCredential(\"user@example.com\", \"password1234\");\n\n// Prompt the user to re-provide their sign-in credentials\nuser.reauthenticate(credential)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete( Task<Void> task) {\n            Log.d(TAG, \"User re-authenticated.\");\n        }\n    });\n```\n","source":"guide/auth/android/manageuser.md","raw":"title: 管理用户\n---\n\n## 创建用户\n\n通过调用 `createUserWithEmailAndPassword` 方法或首次使用第三方登录方式（如 `signInWithCredential(qqAuthCredential)`等）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。\n\n\n您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。\n\n\n## 获取当前登录的用户\n\n获取当前用户的推荐方法是在 WilddogAuth 对象上设置一个侦听器：\n\n```java\nWilddogAuth auth=WilddogAuth.getInstance(\"YOURAPPID\"，context);\nWilddogAuth.AuthStateListener authStateListener=new WilddogAuth.AuthStateListener(){\n    @Override\n    public void onAuthStateChanged(WilddogAuth wilddogAuth) {\n        WilddogUser user=wilddogauth.getCurrentUser();\n        if(user!=null){\n         // User is signed in.\n          Log.d(TAG, \"onAuthStateChanged:signed_in:\" + user.getUid());\n        }else{\n         // No user is signed in.\n           Log.d(TAG, \"onAuthStateChanged:signed_out\");\n        }\n    }\n};\nauth.addAuthStateListener(authStateListener);\n```\n\n使用侦听器可保证在您获取当前用户时 `WilddogAuth` 对象不会处于中间状态如初始化。\n您也可以使用 `getCurrentUser` 方法获取当前已登录的用户。 如果用户没有登录，`currentUser` 则为空：\n\n```java\nWilddogUser user=auth.getCurrentUser();\nif(user!=null){\n // User is signed in.\n}else{\n // No user is signed in.\n}\n```\n\n注：getCurrentUser 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。\n\n## 获取用户个人资料\n\n要获取用户的个人资料信息，请使用 `WilddogUser` 实例的访问器方法。 例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\nif (user != null) {\n    // User is signed in.\n    // The uid properties and providerId will never be empty.\n    // The user's ID, unique to the Wilddog\n    // project. Do NOT use this value to\n    // authenticate with your backend server, if\n    // you have one. Use\n    // user.getToken: instead.\n    String uid = user.getUid();\n    String providerId = user.getProviderId();\n    // The displayName and photoUrl in QQ or Weichat login will not be\n    // empty.\n    String name = user.getDisplayName();\n    Uri photoUrl = user.getPhotoUrl();\n    // The email will not be empty only by email login.\n    String email = user.getEmail();\n} else {\n    // No user is signed in.\n}\n```\n\n## 获取用户的第三方登录的个人资料信息\n\n要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\nif (user != null) {\n    // User is signed in.\n    String uid = user.getUid();\n    List<WilddogUser> userProviderInfos = user.getProviderData();\n    for (UserInfo profile : userProviderInfos) {\n        // Id of the provider (ex: qq)\n        String providerId = profile.getProviderId();\n\n        // UID specific to the provider\n        String uid = profile.getUid();\n\n        // Name, email address, and profile photo Url\n        String name = profile.getDisplayName();\n        String email = profile.getEmail();\n        Uri photoUrl = profile.getPhotoUrl();\n    }\n    ;\n} else {\n    // No user is signed in.\n}\n```\n\n## 更新用户个人资料\n\n您可以使用 `updateProfile` 方法更新用户的基本个人资料信息—用户的显示名称和个人资料照片网址。 例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\nUserProfileChangeRequest profileUpdates = new  UserProfileChangeRequest.Builder()\n    .setDisplayName(\"xiaofei\")\n    .setPhotoUri(Uri.parse(\"https://example.com/jane-q-user/profile.jpg\"))\n    .build();\n\nuser.updateProfile(profileUpdates)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User profile updated.\");\n            }\n\n        }\n    });\n```\n\n## 设置用户的电子邮件地址\n\n您可以使用 `updateEmail` 方法设置用户的电子邮件地址。例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\nuser.updateEmail(\"user@example.com\")\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User email address updated.\");\n            }\n        }\n    });\n```\n\n重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 设置用户密码\n您可以使用 'updatePassword' 方法设置用户密码。例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\nString newPassword = \"SOME-SECURE-PASSWORD\";\n\nuser.updatePassword(newPassword)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User password updated.\");\n            }\n        }\n    });\n```\n\n重要说明：要设置用户密码，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 发送重设密码电子邮件\n您可以用 `sendPasswordResetEmail` 方法向用户发送一封重设密码电子邮件。 例如：\n\n```java\nString emailAddress = \"user@example.com\";\n\nauth.sendPasswordResetEmail(emailAddress)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"Email sent.\");\n            }\n        }\n    });\n```\n\n您可以在 `Wilddog` 控制台 的“用户认证”部分的“邮件模板”页面中自定义使用的电子邮件模板。\n\n您也可以从 `Wilddog` 控制面板中发送重设密码电子邮件。\n\n\n## 删除用户\n您可以使用 `delete` 方法删除用户帐户。例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\nuser.delete()\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(Task<Void> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"User account deleted.\");\n            }\n        }\n    });\n```\n\n重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。\n\n\n## 对用户重新进行身份认证\n有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。\n\n如果您执行一项这种操作，而该用户只是在很久以前登录过，该操作便会失败并引发 `WilddogAuthRecentLoginRequiredException`。发生这种错误时，请从用户获取新登录凭据并将该凭据传输至 `reauthenticate`，对该用户重新进行身份认证。\n\n例如：\n\n```java\nWilddogUser user = auth.getCurrentUser();\n\n// Get auth credentials from the user for re-authentication. The example below shows\n// email and password credentials but there are multiple possible providers,\n// such as QQAuthProvider or WeixinAuthProvider.\nAuthCredential credential = EmailAuthProvider\n    .getCredential(\"user@example.com\", \"password1234\");\n\n// Prompt the user to re-provide their sign-in credentials\nuser.reauthenticate(credential)\n    .addOnCompleteListener(new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete( Task<Void> task) {\n            Log.d(TAG, \"User re-authenticated.\");\n        }\n    });\n```\n","date":"2016-09-06T03:38:22.521Z","updated":"2016-09-06T03:38:22.521Z","path":"guide/auth/android/manageuser.html","comments":1,"layout":"page","_id":"cisswi9kl000rz4fwhet97fo6","content":"<h2 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h2><p>通过调用 <code>createUserWithEmailAndPassword</code> 方法或首次使用第三方登录方式（如 <code>signInWithCredential(qqAuthCredential)</code>等）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。</p>\n<p>您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。</p>\n<h2 id=\"获取当前登录的用户\"><a href=\"#获取当前登录的用户\" class=\"headerlink\" title=\"获取当前登录的用户\"></a>获取当前登录的用户</h2><p>获取当前用户的推荐方法是在 WilddogAuth 对象上设置一个侦听器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth auth=WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>，context);</div><div class=\"line\">WilddogAuth.AuthStateListener authStateListener=<span class=\"keyword\">new</span> WilddogAuth.AuthStateListener()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthStateChanged</span><span class=\"params\">(WilddogAuth wilddogAuth)</span> </span>&#123;</div><div class=\"line\">        WilddogUser user=wilddogauth.getCurrentUser();</div><div class=\"line\">        <span class=\"keyword\">if</span>(user!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">         <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">          Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_in:\"</span> + user.getUid());</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">         <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">           Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_out\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">auth.addAuthStateListener(authStateListener);</div></pre></td></tr></table></figure>\n<p>使用侦听器可保证在您获取当前用户时 <code>WilddogAuth</code> 对象不会处于中间状态如初始化。<br>您也可以使用 <code>getCurrentUser</code> 方法获取当前已登录的用户。 如果用户没有登录，<code>currentUser</code> 则为空：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user=auth.getCurrentUser();</div><div class=\"line\"><span class=\"keyword\">if</span>(user!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\"> <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\"> <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：getCurrentUser 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。</p>\n<h2 id=\"获取用户个人资料\"><a href=\"#获取用户个人资料\" class=\"headerlink\" title=\"获取用户个人资料\"></a>获取用户个人资料</h2><p>要获取用户的个人资料信息，请使用 <code>WilddogUser</code> 实例的访问器方法。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">    <span class=\"comment\">// The uid properties and providerId will never be empty.</span></div><div class=\"line\">    <span class=\"comment\">// The user's ID, unique to the Wilddog</span></div><div class=\"line\">    <span class=\"comment\">// project. Do NOT use this value to</span></div><div class=\"line\">    <span class=\"comment\">// authenticate with your backend server, if</span></div><div class=\"line\">    <span class=\"comment\">// you have one. Use</span></div><div class=\"line\">    <span class=\"comment\">// user.getToken: instead.</span></div><div class=\"line\">    String uid = user.getUid();</div><div class=\"line\">    String providerId = user.getProviderId();</div><div class=\"line\">    <span class=\"comment\">// The displayName and photoUrl in QQ or Weichat login will not be</span></div><div class=\"line\">    <span class=\"comment\">// empty.</span></div><div class=\"line\">    String name = user.getDisplayName();</div><div class=\"line\">    Uri photoUrl = user.getPhotoUrl();</div><div class=\"line\">    <span class=\"comment\">// The email will not be empty only by email login.</span></div><div class=\"line\">    String email = user.getEmail();</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"获取用户的第三方登录的个人资料信息\"><a href=\"#获取用户的第三方登录的个人资料信息\" class=\"headerlink\" title=\"获取用户的第三方登录的个人资料信息\"></a>获取用户的第三方登录的个人资料信息</h2><p>要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">    String uid = user.getUid();</div><div class=\"line\">    List&lt;WilddogUser&gt; userProviderInfos = user.getProviderData();</div><div class=\"line\">    <span class=\"keyword\">for</span> (UserInfo profile : userProviderInfos) &#123;</div><div class=\"line\">        <span class=\"comment\">// Id of the provider (ex: qq)</span></div><div class=\"line\">        String providerId = profile.getProviderId();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// UID specific to the provider</span></div><div class=\"line\">        String uid = profile.getUid();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Name, email address, and profile photo Url</span></div><div class=\"line\">        String name = profile.getDisplayName();</div><div class=\"line\">        String email = profile.getEmail();</div><div class=\"line\">        Uri photoUrl = profile.getPhotoUrl();</div><div class=\"line\">    &#125;</div><div class=\"line\">    ;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"更新用户个人资料\"><a href=\"#更新用户个人资料\" class=\"headerlink\" title=\"更新用户个人资料\"></a>更新用户个人资料</h2><p>您可以使用 <code>updateProfile</code> 方法更新用户的基本个人资料信息—用户的显示名称和个人资料照片网址。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\">UserProfileChangeRequest profileUpdates = <span class=\"keyword\">new</span>  UserProfileChangeRequest.Builder()</div><div class=\"line\">    .setDisplayName(<span class=\"string\">\"xiaofei\"</span>)</div><div class=\"line\">    .setPhotoUri(Uri.parse(<span class=\"string\">\"https://example.com/jane-q-user/profile.jpg\"</span>))</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">user.updateProfile(profileUpdates)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User profile updated.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"设置用户的电子邮件地址\"><a href=\"#设置用户的电子邮件地址\" class=\"headerlink\" title=\"设置用户的电子邮件地址\"></a>设置用户的电子邮件地址</h2><p>您可以使用 <code>updateEmail</code> 方法设置用户的电子邮件地址。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\">user.updateEmail(<span class=\"string\">\"user@example.com\"</span>)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User email address updated.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h2><p>您可以使用 ‘updatePassword’ 方法设置用户密码。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\">String newPassword = <span class=\"string\">\"SOME-SECURE-PASSWORD\"</span>;</div><div class=\"line\"></div><div class=\"line\">user.updatePassword(newPassword)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User password updated.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：要设置用户密码，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"发送重设密码电子邮件\"><a href=\"#发送重设密码电子邮件\" class=\"headerlink\" title=\"发送重设密码电子邮件\"></a>发送重设密码电子邮件</h2><p>您可以用 <code>sendPasswordResetEmail</code> 方法向用户发送一封重设密码电子邮件。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">String emailAddress = <span class=\"string\">\"user@example.com\"</span>;</div><div class=\"line\"></div><div class=\"line\">auth.sendPasswordResetEmail(emailAddress)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"Email sent.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>您可以在 <code>Wilddog</code> 控制台 的“用户认证”部分的“邮件模板”页面中自定义使用的电子邮件模板。</p>\n<p>您也可以从 <code>Wilddog</code> 控制面板中发送重设密码电子邮件。</p>\n<h2 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h2><p>您可以使用 <code>delete</code> 方法删除用户帐户。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\">user.delete()</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User account deleted.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<p>您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。</p>\n<h2 id=\"对用户重新进行身份认证\"><a href=\"#对用户重新进行身份认证\" class=\"headerlink\" title=\"对用户重新进行身份认证\"></a>对用户重新进行身份认证</h2><p>有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。</p>\n<p>如果您执行一项这种操作，而该用户只是在很久以前登录过，该操作便会失败并引发 <code>WilddogAuthRecentLoginRequiredException</code>。发生这种错误时，请从用户获取新登录凭据并将该凭据传输至 <code>reauthenticate</code>，对该用户重新进行身份认证。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Get auth credentials from the user for re-authentication. The example below shows</span></div><div class=\"line\"><span class=\"comment\">// email and password credentials but there are multiple possible providers,</span></div><div class=\"line\"><span class=\"comment\">// such as QQAuthProvider or WeixinAuthProvider.</span></div><div class=\"line\">AuthCredential credential = EmailAuthProvider</div><div class=\"line\">    .getCredential(<span class=\"string\">\"user@example.com\"</span>, <span class=\"string\">\"password1234\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prompt the user to re-provide their sign-in credentials</span></div><div class=\"line\">user.reauthenticate(credential)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">( Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"User re-authenticated.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h2><p>通过调用 <code>createUserWithEmailAndPassword</code> 方法或首次使用第三方登录方式（如 <code>signInWithCredential(qqAuthCredential)</code>等）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。</p>\n<p>您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。</p>\n<h2 id=\"获取当前登录的用户\"><a href=\"#获取当前登录的用户\" class=\"headerlink\" title=\"获取当前登录的用户\"></a>获取当前登录的用户</h2><p>获取当前用户的推荐方法是在 WilddogAuth 对象上设置一个侦听器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth auth=WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>，context);</div><div class=\"line\">WilddogAuth.AuthStateListener authStateListener=<span class=\"keyword\">new</span> WilddogAuth.AuthStateListener()&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthStateChanged</span><span class=\"params\">(WilddogAuth wilddogAuth)</span> </span>&#123;</div><div class=\"line\">        WilddogUser user=wilddogauth.getCurrentUser();</div><div class=\"line\">        <span class=\"keyword\">if</span>(user!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">         <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">          Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_in:\"</span> + user.getUid());</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">         <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">           Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_out\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">auth.addAuthStateListener(authStateListener);</div></pre></td></tr></table></figure>\n<p>使用侦听器可保证在您获取当前用户时 <code>WilddogAuth</code> 对象不会处于中间状态如初始化。<br>您也可以使用 <code>getCurrentUser</code> 方法获取当前已登录的用户。 如果用户没有登录，<code>currentUser</code> 则为空：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user=auth.getCurrentUser();</div><div class=\"line\"><span class=\"keyword\">if</span>(user!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\"> <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\"> <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：getCurrentUser 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。</p>\n<h2 id=\"获取用户个人资料\"><a href=\"#获取用户个人资料\" class=\"headerlink\" title=\"获取用户个人资料\"></a>获取用户个人资料</h2><p>要获取用户的个人资料信息，请使用 <code>WilddogUser</code> 实例的访问器方法。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">    <span class=\"comment\">// The uid properties and providerId will never be empty.</span></div><div class=\"line\">    <span class=\"comment\">// The user's ID, unique to the Wilddog</span></div><div class=\"line\">    <span class=\"comment\">// project. Do NOT use this value to</span></div><div class=\"line\">    <span class=\"comment\">// authenticate with your backend server, if</span></div><div class=\"line\">    <span class=\"comment\">// you have one. Use</span></div><div class=\"line\">    <span class=\"comment\">// user.getToken: instead.</span></div><div class=\"line\">    String uid = user.getUid();</div><div class=\"line\">    String providerId = user.getProviderId();</div><div class=\"line\">    <span class=\"comment\">// The displayName and photoUrl in QQ or Weichat login will not be</span></div><div class=\"line\">    <span class=\"comment\">// empty.</span></div><div class=\"line\">    String name = user.getDisplayName();</div><div class=\"line\">    Uri photoUrl = user.getPhotoUrl();</div><div class=\"line\">    <span class=\"comment\">// The email will not be empty only by email login.</span></div><div class=\"line\">    String email = user.getEmail();</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"获取用户的第三方登录的个人资料信息\"><a href=\"#获取用户的第三方登录的个人资料信息\" class=\"headerlink\" title=\"获取用户的第三方登录的个人资料信息\"></a>获取用户的第三方登录的个人资料信息</h2><p>要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">    String uid = user.getUid();</div><div class=\"line\">    List&lt;WilddogUser&gt; userProviderInfos = user.getProviderData();</div><div class=\"line\">    <span class=\"keyword\">for</span> (UserInfo profile : userProviderInfos) &#123;</div><div class=\"line\">        <span class=\"comment\">// Id of the provider (ex: qq)</span></div><div class=\"line\">        String providerId = profile.getProviderId();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// UID specific to the provider</span></div><div class=\"line\">        String uid = profile.getUid();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Name, email address, and profile photo Url</span></div><div class=\"line\">        String name = profile.getDisplayName();</div><div class=\"line\">        String email = profile.getEmail();</div><div class=\"line\">        Uri photoUrl = profile.getPhotoUrl();</div><div class=\"line\">    &#125;</div><div class=\"line\">    ;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"更新用户个人资料\"><a href=\"#更新用户个人资料\" class=\"headerlink\" title=\"更新用户个人资料\"></a>更新用户个人资料</h2><p>您可以使用 <code>updateProfile</code> 方法更新用户的基本个人资料信息—用户的显示名称和个人资料照片网址。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\">UserProfileChangeRequest profileUpdates = <span class=\"keyword\">new</span>  UserProfileChangeRequest.Builder()</div><div class=\"line\">    .setDisplayName(<span class=\"string\">\"xiaofei\"</span>)</div><div class=\"line\">    .setPhotoUri(Uri.parse(<span class=\"string\">\"https://example.com/jane-q-user/profile.jpg\"</span>))</div><div class=\"line\">    .build();</div><div class=\"line\"></div><div class=\"line\">user.updateProfile(profileUpdates)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User profile updated.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"设置用户的电子邮件地址\"><a href=\"#设置用户的电子邮件地址\" class=\"headerlink\" title=\"设置用户的电子邮件地址\"></a>设置用户的电子邮件地址</h2><p>您可以使用 <code>updateEmail</code> 方法设置用户的电子邮件地址。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\">user.updateEmail(<span class=\"string\">\"user@example.com\"</span>)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User email address updated.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h2><p>您可以使用 ‘updatePassword’ 方法设置用户密码。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\">String newPassword = <span class=\"string\">\"SOME-SECURE-PASSWORD\"</span>;</div><div class=\"line\"></div><div class=\"line\">user.updatePassword(newPassword)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User password updated.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：要设置用户密码，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"发送重设密码电子邮件\"><a href=\"#发送重设密码电子邮件\" class=\"headerlink\" title=\"发送重设密码电子邮件\"></a>发送重设密码电子邮件</h2><p>您可以用 <code>sendPasswordResetEmail</code> 方法向用户发送一封重设密码电子邮件。 例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">String emailAddress = <span class=\"string\">\"user@example.com\"</span>;</div><div class=\"line\"></div><div class=\"line\">auth.sendPasswordResetEmail(emailAddress)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"Email sent.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>您可以在 <code>Wilddog</code> 控制台 的“用户认证”部分的“邮件模板”页面中自定义使用的电子邮件模板。</p>\n<p>您也可以从 <code>Wilddog</code> 控制面板中发送重设密码电子邮件。</p>\n<h2 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h2><p>您可以使用 <code>delete</code> 方法删除用户帐户。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\">user.delete()</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (task.isSuccessful()) &#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"User account deleted.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<p>您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。</p>\n<h2 id=\"对用户重新进行身份认证\"><a href=\"#对用户重新进行身份认证\" class=\"headerlink\" title=\"对用户重新进行身份认证\"></a>对用户重新进行身份认证</h2><p>有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。</p>\n<p>如果您执行一项这种操作，而该用户只是在很久以前登录过，该操作便会失败并引发 <code>WilddogAuthRecentLoginRequiredException</code>。发生这种错误时，请从用户获取新登录凭据并将该凭据传输至 <code>reauthenticate</code>，对该用户重新进行身份认证。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogUser user = auth.getCurrentUser();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Get auth credentials from the user for re-authentication. The example below shows</span></div><div class=\"line\"><span class=\"comment\">// email and password credentials but there are multiple possible providers,</span></div><div class=\"line\"><span class=\"comment\">// such as QQAuthProvider or WeixinAuthProvider.</span></div><div class=\"line\">AuthCredential credential = EmailAuthProvider</div><div class=\"line\">    .getCredential(<span class=\"string\">\"user@example.com\"</span>, <span class=\"string\">\"password1234\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prompt the user to re-provide their sign-in credentials</span></div><div class=\"line\">user.reauthenticate(credential)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;Void&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">( Task&lt;Void&gt; task)</span> </span>&#123;</div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"User re-authenticated.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"自定义身份认证","_content":"\n你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。\n\n## 开始前的准备工作\n1.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n```java\ncompile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n```\n2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n\n3.使用野狗超级密钥生成 Custom Token。\n\n## Wilddog 身份认证\n\n1.初始化WilddogAuth对象\n```java\nWilddogAuth mauth=WilddogAuth.getInstance(\"YOURAPPID\",context);\n```\n    \n2.当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。   \n3.从服务器收到 Custom Token 后，传到 signInWithCustomToken: 方法中进行登录：\n\n```java \nmauth.signInWithCustomToken(\"CUSTOMTOKEN\").addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n         processResult(var1);\n    }\n});\n```\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。\n","source":"guide/auth/android/custom.md","raw":"title: 自定义身份认证\n---\n\n你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。\n\n## 开始前的准备工作\n1.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n```java\ncompile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n```\n2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n\n3.使用野狗超级密钥生成 Custom Token。\n\n## Wilddog 身份认证\n\n1.初始化WilddogAuth对象\n```java\nWilddogAuth mauth=WilddogAuth.getInstance(\"YOURAPPID\",context);\n```\n    \n2.当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。   \n3.从服务器收到 Custom Token 后，传到 signInWithCustomToken: 方法中进行登录：\n\n```java \nmauth.signInWithCustomToken(\"CUSTOMTOKEN\").addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n         processResult(var1);\n    }\n});\n```\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。\n","date":"2016-09-06T03:38:22.520Z","updated":"2016-09-06T03:38:22.520Z","path":"guide/auth/android/custom.html","comments":1,"layout":"page","_id":"cisswi9kl000sz4fwtso9wam7","content":"<p>你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">compile <span class=\"string\">'com.wilddog.client:wilddog-auth-android:2.0.0'</span></div></pre></td></tr></table></figure></p>\n<p>2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>3.使用野狗超级密钥生成 Custom Token。</p>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1.初始化WilddogAuth对象<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth mauth=WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,context);</div></pre></td></tr></table></figure></p>\n<p>2.当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。<br>3.从服务器收到 Custom Token 后，传到 signInWithCustomToken: 方法中进行登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCustomToken(<span class=\"string\">\"CUSTOMTOKEN\"</span>).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">         processResult(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n","excerpt":"","more":"<p>你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">compile <span class=\"string\">'com.wilddog.client:wilddog-auth-android:2.0.0'</span></div></pre></td></tr></table></figure></p>\n<p>2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>3.使用野狗超级密钥生成 Custom Token。</p>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1.初始化WilddogAuth对象<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogAuth mauth=WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,context);</div></pre></td></tr></table></figure></p>\n<p>2.当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。<br>3.从服务器收到 Custom Token 后，传到 signInWithCustomToken: 方法中进行登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCustomToken(<span class=\"string\">\"CUSTOMTOKEN\"</span>).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">         processResult(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n"},{"title":"邮箱密码登录","_content":"\n你可以使用  Wilddog Auth  让你的用户使用电子邮件地址和密码进行 Wilddog 身份认证，并管理你的应用基于密码的帐户。\n\n## 开始前的准备工作\n\n1.将 WilddogAuth 添加至你的 Android 项目。\n\n2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n4.在野狗应用控制面板中打开邮箱登录方式:\n\n  *  在野狗控制面板中选择身份认证选项。\n  *  在'登录方式'标签中打开邮箱登录方式。\n\n\n## 创建基于密码的帐户  \n\n \n 要用密码创建一个新用户帐户，请在你的应用登录 Activity 中完成以下步骤：\n\n在你的注册 Activity 的 onCreate 方法中，获取 WilddogAuth 对象的分享实例：\n\n```java\n    private WilddogAuth mAuth;\n    // ...\n    mAuth = WilddogAuth.getInstance(\"YOURAPPID\",this);\n    设置一个响应用户的登录状态变化的 AuthStateListener：\n    private WilddogAuth.AuthStateListener mAuthListener;\n\n    // ...\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    // ...\n    mAuthListener = new WilddogAuth.AuthStateListener() {\n        @Override\n        public void onAuthStateChanged( WilddogAuth WilddogAuth) {\n            WilddogUser user = WilddogAuth.getCurrentUser();\n            if (user != null) {\n                // User is signed in\n                Log.d(TAG, \"onAuthStateChanged:signed_in:\" + user.getUid());\n            } else {\n                // User is signed out\n                Log.d(TAG, \"onAuthStateChanged:signed_out\");\n            }\n            // ...\n        }\n    };\n    // ...\n    }\n\n    @Override\n    public void onStart() {\n    super.onStart();\n    mAuth.addAuthStateListener(mAuthListener);\n    }\n\n    @Override\n    public void onStop() {\n    super.onStop();\n    if (mAuthListener != null) {\n        mAuth.removeAuthStateListener(mAuthListener);\n    }\n    }\n```    \n在一个新用户使用你的应用注册表单注册时，完成你的应用所需的任何新帐户认证步骤，例如认证新帐户密码键入正确且符合你的复杂度要求。\n\n通过将新用户的电子邮件地址和密码传递到 `createUserWithEmailAndPassword` 来创建新帐户：\n\n```java\n    mAuth.createUserWithEmailAndPassword(email, password)\n        .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n            @Override\n            public void onComplete( Task<AuthResult> task) {\n                Log.d(TAG, \"createUserWithEmail:onComplete:\" + task.isSuccessful());\n\n                // If sign in fails, display a message to the user. If sign in succeeds\n                // the auth state listener will be notified and logic to handle the\n                // signed in user can be handled in the listener.\n                if (!task.isSuccessful()) {\n                    Toast.makeText(EmailPasswordActivity.this, \"Authentication failed.\",\n                            Toast.LENGTH_SHORT).show();\n                }\n\n                // ...\n            }\n        });\n```\n\n如果新帐户创建成功，则也会使该用户登录，并且 AuthStateListener 运行 `onAuthStateChanged` 回调。在此回调中，你可以使用 `getCurrentUser` 方法获取用户的帐户数据。\n\n\n## 用电子邮件地址和密码登录一个用户\n\n用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你的应用的登录 Activity 中，执行以下操作：\n\n1.在登录 Activity 的 onCreate 方法中获取 WilddogAuth 对象的共享实例：\n\n```java\n    private WilddogAuth mAuth;\n    // ...\n    mAuth = WilddogAuth.getInstance(\"YOURAPPID\",this);\n```\n\n2.设置一个响应用户的登录状态变化的 AuthStateListener：\n\n```java\n    private WilddogAuth.AuthStateListener mAuthListener;\n\n    // ...\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    // ...\n    mAuthListener = new WilddogAuth.AuthStateListener() {\n        @Override\n        public void onAuthStateChanged( WilddogAuth WilddogAuth) {\n            WilddogUser user = WilddogAuth.getCurrentUser();\n            if (user != null) {\n                // User is signed in\n                Log.d(TAG, \"onAuthStateChanged:signed_in:\" + user.getUid());\n            } else {\n                // User is signed out\n                Log.d(TAG, \"onAuthStateChanged:signed_out\");\n            }\n            // ...\n        }\n    };\n    // ...\n    }\n\n    @Override\n    public void onStart() {\n    super.onStart();\n    mAuth.addAuthStateListener(mAuthListener);\n    }\n\n    @Override\n    public void onStop() {\n    super.onStop();\n    if (mAuthListener != null) {\n        mAuth.removeAuthStateListener(mAuthListener);\n    }\n    }\n```\n\n当一个用户登录到你的应用时，将该用户的电子邮件地址和密码传递到 `signInWithEmailAndPassword`：\n\n```java\n    mAuth.signInWithEmailAndPassword(email, password)\n        .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n            @Override\n            public void onComplete( Task<AuthResult> task) {\n                Log.d(TAG, \"signInWithEmail:onComplete:\" + task.isSuccessful());\n\n                // If sign in fails, display a message to the user. If sign in succeeds\n                // the auth state listener will be notified and logic to handle the\n                // signed in user can be handled in the listener.\n                if (!task.isSuccessful()) {\n                    Log.w(TAG, \"signInWithEmail\", task.getException());\n                    Toast.makeText(EmailPasswordActivity.this, \"Authentication failed.\",\n                            Toast.LENGTH_SHORT).show();\n                }\n\n                // ...\n            }\n        });\n```\n\n如果登录成功，AuthStateListener 则会运行 `onAuthStateChanged` 回调。 在此回调中，你可以使用 `getCurrentUser` 方法获取该用户的帐户数据。\n\n\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","source":"guide/auth/android/password.md","raw":"title: 邮箱密码登录\n---\n\n你可以使用  Wilddog Auth  让你的用户使用电子邮件地址和密码进行 Wilddog 身份认证，并管理你的应用基于密码的帐户。\n\n## 开始前的准备工作\n\n1.将 WilddogAuth 添加至你的 Android 项目。\n\n2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n4.在野狗应用控制面板中打开邮箱登录方式:\n\n  *  在野狗控制面板中选择身份认证选项。\n  *  在'登录方式'标签中打开邮箱登录方式。\n\n\n## 创建基于密码的帐户  \n\n \n 要用密码创建一个新用户帐户，请在你的应用登录 Activity 中完成以下步骤：\n\n在你的注册 Activity 的 onCreate 方法中，获取 WilddogAuth 对象的分享实例：\n\n```java\n    private WilddogAuth mAuth;\n    // ...\n    mAuth = WilddogAuth.getInstance(\"YOURAPPID\",this);\n    设置一个响应用户的登录状态变化的 AuthStateListener：\n    private WilddogAuth.AuthStateListener mAuthListener;\n\n    // ...\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    // ...\n    mAuthListener = new WilddogAuth.AuthStateListener() {\n        @Override\n        public void onAuthStateChanged( WilddogAuth WilddogAuth) {\n            WilddogUser user = WilddogAuth.getCurrentUser();\n            if (user != null) {\n                // User is signed in\n                Log.d(TAG, \"onAuthStateChanged:signed_in:\" + user.getUid());\n            } else {\n                // User is signed out\n                Log.d(TAG, \"onAuthStateChanged:signed_out\");\n            }\n            // ...\n        }\n    };\n    // ...\n    }\n\n    @Override\n    public void onStart() {\n    super.onStart();\n    mAuth.addAuthStateListener(mAuthListener);\n    }\n\n    @Override\n    public void onStop() {\n    super.onStop();\n    if (mAuthListener != null) {\n        mAuth.removeAuthStateListener(mAuthListener);\n    }\n    }\n```    \n在一个新用户使用你的应用注册表单注册时，完成你的应用所需的任何新帐户认证步骤，例如认证新帐户密码键入正确且符合你的复杂度要求。\n\n通过将新用户的电子邮件地址和密码传递到 `createUserWithEmailAndPassword` 来创建新帐户：\n\n```java\n    mAuth.createUserWithEmailAndPassword(email, password)\n        .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n            @Override\n            public void onComplete( Task<AuthResult> task) {\n                Log.d(TAG, \"createUserWithEmail:onComplete:\" + task.isSuccessful());\n\n                // If sign in fails, display a message to the user. If sign in succeeds\n                // the auth state listener will be notified and logic to handle the\n                // signed in user can be handled in the listener.\n                if (!task.isSuccessful()) {\n                    Toast.makeText(EmailPasswordActivity.this, \"Authentication failed.\",\n                            Toast.LENGTH_SHORT).show();\n                }\n\n                // ...\n            }\n        });\n```\n\n如果新帐户创建成功，则也会使该用户登录，并且 AuthStateListener 运行 `onAuthStateChanged` 回调。在此回调中，你可以使用 `getCurrentUser` 方法获取用户的帐户数据。\n\n\n## 用电子邮件地址和密码登录一个用户\n\n用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你的应用的登录 Activity 中，执行以下操作：\n\n1.在登录 Activity 的 onCreate 方法中获取 WilddogAuth 对象的共享实例：\n\n```java\n    private WilddogAuth mAuth;\n    // ...\n    mAuth = WilddogAuth.getInstance(\"YOURAPPID\",this);\n```\n\n2.设置一个响应用户的登录状态变化的 AuthStateListener：\n\n```java\n    private WilddogAuth.AuthStateListener mAuthListener;\n\n    // ...\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    // ...\n    mAuthListener = new WilddogAuth.AuthStateListener() {\n        @Override\n        public void onAuthStateChanged( WilddogAuth WilddogAuth) {\n            WilddogUser user = WilddogAuth.getCurrentUser();\n            if (user != null) {\n                // User is signed in\n                Log.d(TAG, \"onAuthStateChanged:signed_in:\" + user.getUid());\n            } else {\n                // User is signed out\n                Log.d(TAG, \"onAuthStateChanged:signed_out\");\n            }\n            // ...\n        }\n    };\n    // ...\n    }\n\n    @Override\n    public void onStart() {\n    super.onStart();\n    mAuth.addAuthStateListener(mAuthListener);\n    }\n\n    @Override\n    public void onStop() {\n    super.onStop();\n    if (mAuthListener != null) {\n        mAuth.removeAuthStateListener(mAuthListener);\n    }\n    }\n```\n\n当一个用户登录到你的应用时，将该用户的电子邮件地址和密码传递到 `signInWithEmailAndPassword`：\n\n```java\n    mAuth.signInWithEmailAndPassword(email, password)\n        .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n            @Override\n            public void onComplete( Task<AuthResult> task) {\n                Log.d(TAG, \"signInWithEmail:onComplete:\" + task.isSuccessful());\n\n                // If sign in fails, display a message to the user. If sign in succeeds\n                // the auth state listener will be notified and logic to handle the\n                // signed in user can be handled in the listener.\n                if (!task.isSuccessful()) {\n                    Log.w(TAG, \"signInWithEmail\", task.getException());\n                    Toast.makeText(EmailPasswordActivity.this, \"Authentication failed.\",\n                            Toast.LENGTH_SHORT).show();\n                }\n\n                // ...\n            }\n        });\n```\n\n如果登录成功，AuthStateListener 则会运行 `onAuthStateChanged` 回调。 在此回调中，你可以使用 `getCurrentUser` 方法获取该用户的帐户数据。\n\n\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","date":"2016-09-06T03:38:22.521Z","updated":"2016-09-06T03:38:22.521Z","path":"guide/auth/android/password.html","comments":1,"layout":"page","_id":"cisswi9kl000tz4fwkjdda67e","content":"<p>你可以使用  Wilddog Auth  让你的用户使用电子邮件地址和密码进行 Wilddog 身份认证，并管理你的应用基于密码的帐户。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 WilddogAuth 添加至你的 Android 项目。</p>\n<p>2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>4.在野狗应用控制面板中打开邮箱登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证选项。</li>\n<li>在’登录方式’标签中打开邮箱登录方式。</li>\n</ul>\n<h2 id=\"创建基于密码的帐户\"><a href=\"#创建基于密码的帐户\" class=\"headerlink\" title=\"创建基于密码的帐户\"></a>创建基于密码的帐户</h2><p> 要用密码创建一个新用户帐户，请在你的应用登录 Activity 中完成以下步骤：</p>\n<p>在你的注册 Activity 的 onCreate 方法中，获取 WilddogAuth 对象的分享实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">private</span> WilddogAuth mAuth;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    mAuth = WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,<span class=\"keyword\">this</span>);</div><div class=\"line\">    设置一个响应用户的登录状态变化的 AuthStateListener：</div><div class=\"line\">    <span class=\"keyword\">private</span> WilddogAuth.AuthStateListener mAuthListener;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    mAuthListener = <span class=\"keyword\">new</span> WilddogAuth.AuthStateListener() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthStateChanged</span><span class=\"params\">( WilddogAuth WilddogAuth)</span> </span>&#123;</div><div class=\"line\">            WilddogUser user = WilddogAuth.getCurrentUser();</div><div class=\"line\">            <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// User is signed in</span></div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_in:\"</span> + user.getUid());</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// User is signed out</span></div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_out\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">    mAuth.addAuthStateListener(mAuthListener);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAuthListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mAuth.removeAuthStateListener(mAuthListener);</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">```    </div><div class=\"line\">在一个新用户使用你的应用注册表单注册时，完成你的应用所需的任何新帐户认证步骤，例如认证新帐户密码键入正确且符合你的复杂度要求。</div><div class=\"line\"></div><div class=\"line\">通过将新用户的电子邮件地址和密码传递到 `createUserWithEmailAndPassword` 来创建新帐户：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">    mAuth.createUserWithEmailAndPassword(email, password)</div><div class=\"line\">        .addOnCompleteListener(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">( Task&lt;AuthResult&gt; task)</span> </span>&#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"createUserWithEmail:onComplete:\"</span> + task.isSuccessful());</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If sign in fails, display a message to the user. If sign in succeeds</span></div><div class=\"line\">                <span class=\"comment\">// the auth state listener will be notified and logic to handle the</span></div><div class=\"line\">                <span class=\"comment\">// signed in user can be handled in the listener.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (!task.isSuccessful()) &#123;</div><div class=\"line\">                    Toast.makeText(EmailPasswordActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"Authentication failed.\"</span>,</div><div class=\"line\">                            Toast.LENGTH_SHORT).show();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// ...</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>如果新帐户创建成功，则也会使该用户登录，并且 AuthStateListener 运行 <code>onAuthStateChanged</code> 回调。在此回调中，你可以使用 <code>getCurrentUser</code> 方法获取用户的帐户数据。</p>\n<h2 id=\"用电子邮件地址和密码登录一个用户\"><a href=\"#用电子邮件地址和密码登录一个用户\" class=\"headerlink\" title=\"用电子邮件地址和密码登录一个用户\"></a>用电子邮件地址和密码登录一个用户</h2><p>用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你的应用的登录 Activity 中，执行以下操作：</p>\n<p>1.在登录 Activity 的 onCreate 方法中获取 WilddogAuth 对象的共享实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> WilddogAuth mAuth;</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">mAuth = WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>2.设置一个响应用户的登录状态变化的 AuthStateListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> WilddogAuth.AuthStateListener mAuthListener;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">mAuthListener = <span class=\"keyword\">new</span> WilddogAuth.AuthStateListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthStateChanged</span><span class=\"params\">( WilddogAuth WilddogAuth)</span> </span>&#123;</div><div class=\"line\">        WilddogUser user = WilddogAuth.getCurrentUser();</div><div class=\"line\">        <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// User is signed in</span></div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_in:\"</span> + user.getUid());</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// User is signed out</span></div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_out\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">mAuth.addAuthStateListener(mAuthListener);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"keyword\">super</span>.onStop();</div><div class=\"line\"><span class=\"keyword\">if</span> (mAuthListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mAuth.removeAuthStateListener(mAuthListener);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当一个用户登录到你的应用时，将该用户的电子邮件地址和密码传递到 <code>signInWithEmailAndPassword</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAuth.signInWithEmailAndPassword(email, password)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">( Task&lt;AuthResult&gt; task)</span> </span>&#123;</div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"signInWithEmail:onComplete:\"</span> + task.isSuccessful());</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If sign in fails, display a message to the user. If sign in succeeds</span></div><div class=\"line\">            <span class=\"comment\">// the auth state listener will be notified and logic to handle the</span></div><div class=\"line\">            <span class=\"comment\">// signed in user can be handled in the listener.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!task.isSuccessful()) &#123;</div><div class=\"line\">                Log.w(TAG, <span class=\"string\">\"signInWithEmail\"</span>, task.getException());</div><div class=\"line\">                Toast.makeText(EmailPasswordActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"Authentication failed.\"</span>,</div><div class=\"line\">                        Toast.LENGTH_SHORT).show();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>如果登录成功，AuthStateListener 则会运行 <code>onAuthStateChanged</code> 回调。 在此回调中，你可以使用 <code>getCurrentUser</code> 方法获取该用户的帐户数据。</p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n","excerpt":"","more":"<p>你可以使用  Wilddog Auth  让你的用户使用电子邮件地址和密码进行 Wilddog 身份认证，并管理你的应用基于密码的帐户。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 WilddogAuth 添加至你的 Android 项目。</p>\n<p>2.将 WilddogAuth 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>4.在野狗应用控制面板中打开邮箱登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证选项。</li>\n<li>在’登录方式’标签中打开邮箱登录方式。</li>\n</ul>\n<h2 id=\"创建基于密码的帐户\"><a href=\"#创建基于密码的帐户\" class=\"headerlink\" title=\"创建基于密码的帐户\"></a>创建基于密码的帐户</h2><p> 要用密码创建一个新用户帐户，请在你的应用登录 Activity 中完成以下步骤：</p>\n<p>在你的注册 Activity 的 onCreate 方法中，获取 WilddogAuth 对象的分享实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">private</span> WilddogAuth mAuth;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    mAuth = WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,<span class=\"keyword\">this</span>);</div><div class=\"line\">    设置一个响应用户的登录状态变化的 AuthStateListener：</div><div class=\"line\">    <span class=\"keyword\">private</span> WilddogAuth.AuthStateListener mAuthListener;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    mAuthListener = <span class=\"keyword\">new</span> WilddogAuth.AuthStateListener() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthStateChanged</span><span class=\"params\">( WilddogAuth WilddogAuth)</span> </span>&#123;</div><div class=\"line\">            WilddogUser user = WilddogAuth.getCurrentUser();</div><div class=\"line\">            <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"comment\">// User is signed in</span></div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_in:\"</span> + user.getUid());</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// User is signed out</span></div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_out\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">    mAuth.addAuthStateListener(mAuthListener);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onStop();</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAuthListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mAuth.removeAuthStateListener(mAuthListener);</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">```    </div><div class=\"line\">在一个新用户使用你的应用注册表单注册时，完成你的应用所需的任何新帐户认证步骤，例如认证新帐户密码键入正确且符合你的复杂度要求。</div><div class=\"line\"></div><div class=\"line\">通过将新用户的电子邮件地址和密码传递到 `createUserWithEmailAndPassword` 来创建新帐户：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">    mAuth.createUserWithEmailAndPassword(email, password)</div><div class=\"line\">        .addOnCompleteListener(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">( Task&lt;AuthResult&gt; task)</span> </span>&#123;</div><div class=\"line\">                Log.d(TAG, <span class=\"string\">\"createUserWithEmail:onComplete:\"</span> + task.isSuccessful());</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// If sign in fails, display a message to the user. If sign in succeeds</span></div><div class=\"line\">                <span class=\"comment\">// the auth state listener will be notified and logic to handle the</span></div><div class=\"line\">                <span class=\"comment\">// signed in user can be handled in the listener.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (!task.isSuccessful()) &#123;</div><div class=\"line\">                    Toast.makeText(EmailPasswordActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"Authentication failed.\"</span>,</div><div class=\"line\">                            Toast.LENGTH_SHORT).show();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// ...</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>如果新帐户创建成功，则也会使该用户登录，并且 AuthStateListener 运行 <code>onAuthStateChanged</code> 回调。在此回调中，你可以使用 <code>getCurrentUser</code> 方法获取用户的帐户数据。</p>\n<h2 id=\"用电子邮件地址和密码登录一个用户\"><a href=\"#用电子邮件地址和密码登录一个用户\" class=\"headerlink\" title=\"用电子邮件地址和密码登录一个用户\"></a>用电子邮件地址和密码登录一个用户</h2><p>用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你的应用的登录 Activity 中，执行以下操作：</p>\n<p>1.在登录 Activity 的 onCreate 方法中获取 WilddogAuth 对象的共享实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> WilddogAuth mAuth;</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">mAuth = WilddogAuth.getInstance(<span class=\"string\">\"YOURAPPID\"</span>,<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>2.设置一个响应用户的登录状态变化的 AuthStateListener：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> WilddogAuth.AuthStateListener mAuthListener;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">mAuthListener = <span class=\"keyword\">new</span> WilddogAuth.AuthStateListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthStateChanged</span><span class=\"params\">( WilddogAuth WilddogAuth)</span> </span>&#123;</div><div class=\"line\">        WilddogUser user = WilddogAuth.getCurrentUser();</div><div class=\"line\">        <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// User is signed in</span></div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_in:\"</span> + user.getUid());</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// User is signed out</span></div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"onAuthStateChanged:signed_out\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"keyword\">super</span>.onStart();</div><div class=\"line\">mAuth.addAuthStateListener(mAuthListener);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"keyword\">super</span>.onStop();</div><div class=\"line\"><span class=\"keyword\">if</span> (mAuthListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    mAuth.removeAuthStateListener(mAuthListener);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当一个用户登录到你的应用时，将该用户的电子邮件地址和密码传递到 <code>signInWithEmailAndPassword</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAuth.signInWithEmailAndPassword(email, password)</div><div class=\"line\">    .addOnCompleteListener(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">( Task&lt;AuthResult&gt; task)</span> </span>&#123;</div><div class=\"line\">            Log.d(TAG, <span class=\"string\">\"signInWithEmail:onComplete:\"</span> + task.isSuccessful());</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If sign in fails, display a message to the user. If sign in succeeds</span></div><div class=\"line\">            <span class=\"comment\">// the auth state listener will be notified and logic to handle the</span></div><div class=\"line\">            <span class=\"comment\">// signed in user can be handled in the listener.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!task.isSuccessful()) &#123;</div><div class=\"line\">                Log.w(TAG, <span class=\"string\">\"signInWithEmail\"</span>, task.getException());</div><div class=\"line\">                Toast.makeText(EmailPasswordActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"Authentication failed.\"</span>,</div><div class=\"line\">                        Toast.LENGTH_SHORT).show();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// ...</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>如果登录成功，AuthStateListener 则会运行 <code>onAuthStateChanged</code> 回调。 在此回调中，你可以使用 <code>getCurrentUser</code> 方法获取该用户的帐户数据。</p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n"},{"title":"新浪微博登录","_content":"\n通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n```java \ncompile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n```\n2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n3.在[新浪微博开放平台管理中心](http://open.weibo.com/apps)，获取应用的 App Key 和 App Secret。\n\n4.在野狗应用控制面板中打开新浪微博登录方式:\n\n  *  在野狗控制面板中选择 ”身份认证“->登录方式。\n  *  点击微博登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。\n\n\n## Wilddog 身份认证\n\n1 参考 [新浪微博 Android 接入指南](https://github.com/sinaweibosdk/weibo_android_sdk) 将新浪微博登录集成到你的应用中。\n\n2. 在WeiboAuthListener的`onComplete`方法中可以获取到Oauth2AccessToken对象，然后从里面获取到token和openId。\n    \n```java\nmAuthInfo = new AuthInfo(this, Constants.APP_KEY, Constants.REDIRECT_URL, Constants.SCOPE);\nmSsoHandler = new SsoHandler(WBAuthActivity.this, mAuthInfo);\n\n// SSO 授权, 仅客户端\nfindViewById(R.id.obtain_token_via_sso).setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        mSsoHandler.authorizeClientSso(new AuthListener());\n    }\n});\n```\n```java\n/**\n  * 微博认证授权回调类。\n  * 1. SSO 授权时，需要在 {@link #onActivityResult} 中调用 {@link SsoHandler#authorizeCallBack} 后，\n  *    该回调才会被执行。\n  * 2. 非 SSO 授权时，当授权结束后，该回调就会被执行。\n  * 当授权成功后，请保存该 access_token、expires_in、uid 等信息到 SharedPreferences 中。\n  */\nclass AuthListener implements WeiboAuthListener {\n\n    @Override\n    public void onComplete(Bundle values) {\n        // 从 Bundle 中解析 Token\n        mAccessToken = Oauth2AccessToken.parseAccessToken(values);\n        // token 和openId\n        String token = mAccessToken.getToken();\n        String Uid = mAccessToken.getUid();\n        // 从这里获取用户输入的 电话号码信息\n\n        if (mAccessToken.isSessionValid()) {\n            // 进行WilddogAuth登录\n\n        } else {\n            // 以下几种情况，你会收到 Code：\n            // 1. 当你未在平台上注册的应用程序的包名与签名时；\n            // 2. 当你注册的应用程序包名与签名不正确时；\n            // 3. 当你在平台上注册的包名和签名与你当前测试的应用的包名和签名不匹配时。\n            String code = values.getString(\"code\");\n            String message = getString(R.string.weibosdk_demo_toast_auth_failed);\n            if (!TextUtils.isEmpty(code)) {\n                message = message + \"\\nObtained the code: \" + code;\n            }\n            Toast.makeText(WBAuthActivity.this, message, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    @Override\n    public void onCancel() {\n        Toast.makeText(WBAuthActivity.this, R.string.weibosdk_demo_toast_auth_canceled, Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onWeiboException(WeiboException e) {\n        Toast.makeText(WBAuthActivity.this, \"Auth exception : \" + e.getMessage(), Toast.LENGTH_LONG).show();\n    }\n}\n```\n\n3.新浪微博登录成功后，在 didReceiveWeiboResponse: 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：\n\n```java\nAuthCredential weiboAuthCredential = WeiboAuthProvider.getCredential(mAccessToken.getToken(), mAccessToken.getUid());\n```\n4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\n```java\nmauth.signInWithCredential(weiboAuthCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n          processResult(var1);\n      }\n});\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","source":"guide/auth/android/weibo.md","raw":"title: 新浪微博登录\n---\n\n通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n```java \ncompile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n```\n2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n3.在[新浪微博开放平台管理中心](http://open.weibo.com/apps)，获取应用的 App Key 和 App Secret。\n\n4.在野狗应用控制面板中打开新浪微博登录方式:\n\n  *  在野狗控制面板中选择 ”身份认证“->登录方式。\n  *  点击微博登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。\n\n\n## Wilddog 身份认证\n\n1 参考 [新浪微博 Android 接入指南](https://github.com/sinaweibosdk/weibo_android_sdk) 将新浪微博登录集成到你的应用中。\n\n2. 在WeiboAuthListener的`onComplete`方法中可以获取到Oauth2AccessToken对象，然后从里面获取到token和openId。\n    \n```java\nmAuthInfo = new AuthInfo(this, Constants.APP_KEY, Constants.REDIRECT_URL, Constants.SCOPE);\nmSsoHandler = new SsoHandler(WBAuthActivity.this, mAuthInfo);\n\n// SSO 授权, 仅客户端\nfindViewById(R.id.obtain_token_via_sso).setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        mSsoHandler.authorizeClientSso(new AuthListener());\n    }\n});\n```\n```java\n/**\n  * 微博认证授权回调类。\n  * 1. SSO 授权时，需要在 {@link #onActivityResult} 中调用 {@link SsoHandler#authorizeCallBack} 后，\n  *    该回调才会被执行。\n  * 2. 非 SSO 授权时，当授权结束后，该回调就会被执行。\n  * 当授权成功后，请保存该 access_token、expires_in、uid 等信息到 SharedPreferences 中。\n  */\nclass AuthListener implements WeiboAuthListener {\n\n    @Override\n    public void onComplete(Bundle values) {\n        // 从 Bundle 中解析 Token\n        mAccessToken = Oauth2AccessToken.parseAccessToken(values);\n        // token 和openId\n        String token = mAccessToken.getToken();\n        String Uid = mAccessToken.getUid();\n        // 从这里获取用户输入的 电话号码信息\n\n        if (mAccessToken.isSessionValid()) {\n            // 进行WilddogAuth登录\n\n        } else {\n            // 以下几种情况，你会收到 Code：\n            // 1. 当你未在平台上注册的应用程序的包名与签名时；\n            // 2. 当你注册的应用程序包名与签名不正确时；\n            // 3. 当你在平台上注册的包名和签名与你当前测试的应用的包名和签名不匹配时。\n            String code = values.getString(\"code\");\n            String message = getString(R.string.weibosdk_demo_toast_auth_failed);\n            if (!TextUtils.isEmpty(code)) {\n                message = message + \"\\nObtained the code: \" + code;\n            }\n            Toast.makeText(WBAuthActivity.this, message, Toast.LENGTH_LONG).show();\n        }\n    }\n\n    @Override\n    public void onCancel() {\n        Toast.makeText(WBAuthActivity.this, R.string.weibosdk_demo_toast_auth_canceled, Toast.LENGTH_LONG).show();\n    }\n\n    @Override\n    public void onWeiboException(WeiboException e) {\n        Toast.makeText(WBAuthActivity.this, \"Auth exception : \" + e.getMessage(), Toast.LENGTH_LONG).show();\n    }\n}\n```\n\n3.新浪微博登录成功后，在 didReceiveWeiboResponse: 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：\n\n```java\nAuthCredential weiboAuthCredential = WeiboAuthProvider.getCredential(mAccessToken.getToken(), mAccessToken.getUid());\n```\n4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\n```java\nmauth.signInWithCredential(weiboAuthCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n          processResult(var1);\n      }\n});\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","date":"2016-09-06T03:38:22.522Z","updated":"2016-09-06T03:38:22.522Z","path":"guide/auth/android/weibo.html","comments":1,"layout":"page","_id":"cisswi9kl000uz4fwr5qod0c1","content":"<p>通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">compile <span class=\"string\">'com.wilddog.client:wilddog-auth-android:2.0.0'</span></div></pre></td></tr></table></figure></p>\n<p>2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>3.在<a href=\"http://open.weibo.com/apps\" target=\"_blank\" rel=\"external\">新浪微博开放平台管理中心</a>，获取应用的 App Key 和 App Secret。</p>\n<p>4.在野狗应用控制面板中打开新浪微博登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微博登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。</li>\n</ul>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1 参考 <a href=\"https://github.com/sinaweibosdk/weibo_android_sdk\" target=\"_blank\" rel=\"external\">新浪微博 Android 接入指南</a> 将新浪微博登录集成到你的应用中。</p>\n<ol>\n<li>在WeiboAuthListener的<code>onComplete</code>方法中可以获取到Oauth2AccessToken对象，然后从里面获取到token和openId。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAuthInfo = <span class=\"keyword\">new</span> AuthInfo(<span class=\"keyword\">this</span>, Constants.APP_KEY, Constants.REDIRECT_URL, Constants.SCOPE);</div><div class=\"line\">mSsoHandler = <span class=\"keyword\">new</span> SsoHandler(WBAuthActivity.<span class=\"keyword\">this</span>, mAuthInfo);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// SSO 授权, 仅客户端</span></div><div class=\"line\">findViewById(R.id.obtain_token_via_sso).setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        mSsoHandler.authorizeClientSso(<span class=\"keyword\">new</span> AuthListener());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * 微博认证授权回调类。</div><div class=\"line\">  * 1. SSO 授权时，需要在 &#123;<span class=\"doctag\">@link</span> #onActivityResult&#125; 中调用 &#123;<span class=\"doctag\">@link</span> SsoHandler#authorizeCallBack&#125; 后，</div><div class=\"line\">  *    该回调才会被执行。</div><div class=\"line\">  * 2. 非 SSO 授权时，当授权结束后，该回调就会被执行。</div><div class=\"line\">  * 当授权成功后，请保存该 access_token、expires_in、uid 等信息到 SharedPreferences 中。</div><div class=\"line\">  */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">WeiboAuthListener</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Bundle values)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 从 Bundle 中解析 Token</span></div><div class=\"line\">        mAccessToken = Oauth2AccessToken.parseAccessToken(values);</div><div class=\"line\">        <span class=\"comment\">// token 和openId</span></div><div class=\"line\">        String token = mAccessToken.getToken();</div><div class=\"line\">        String Uid = mAccessToken.getUid();</div><div class=\"line\">        <span class=\"comment\">// 从这里获取用户输入的 电话号码信息</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mAccessToken.isSessionValid()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 进行WilddogAuth登录</span></div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 以下几种情况，你会收到 Code：</span></div><div class=\"line\">            <span class=\"comment\">// 1. 当你未在平台上注册的应用程序的包名与签名时；</span></div><div class=\"line\">            <span class=\"comment\">// 2. 当你注册的应用程序包名与签名不正确时；</span></div><div class=\"line\">            <span class=\"comment\">// 3. 当你在平台上注册的包名和签名与你当前测试的应用的包名和签名不匹配时。</span></div><div class=\"line\">            String code = values.getString(<span class=\"string\">\"code\"</span>);</div><div class=\"line\">            String message = getString(R.string.weibosdk_demo_toast_auth_failed);</div><div class=\"line\">            <span class=\"keyword\">if</span> (!TextUtils.isEmpty(code)) &#123;</div><div class=\"line\">                message = message + <span class=\"string\">\"\\nObtained the code: \"</span> + code;</div><div class=\"line\">            &#125;</div><div class=\"line\">            Toast.makeText(WBAuthActivity.<span class=\"keyword\">this</span>, message, Toast.LENGTH_LONG).show();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Toast.makeText(WBAuthActivity.<span class=\"keyword\">this</span>, R.string.weibosdk_demo_toast_auth_canceled, Toast.LENGTH_LONG).show();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onWeiboException</span><span class=\"params\">(WeiboException e)</span> </span>&#123;</div><div class=\"line\">        Toast.makeText(WBAuthActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"Auth exception : \"</span> + e.getMessage(), Toast.LENGTH_LONG).show();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3.新浪微博登录成功后，在 didReceiveWeiboResponse: 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiboAuthCredential = WeiboAuthProvider.getCredential(mAccessToken.getToken(), mAccessToken.getUid());</div></pre></td></tr></table></figure>\n<p>4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCredential(weiboAuthCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">          processResult(var1);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n","excerpt":"","more":"<p>通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">compile <span class=\"string\">'com.wilddog.client:wilddog-auth-android:2.0.0'</span></div></pre></td></tr></table></figure></p>\n<p>2.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>3.在<a href=\"http://open.weibo.com/apps\">新浪微博开放平台管理中心</a>，获取应用的 App Key 和 App Secret。</p>\n<p>4.在野狗应用控制面板中打开新浪微博登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微博登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。</li>\n</ul>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1 参考 <a href=\"https://github.com/sinaweibosdk/weibo_android_sdk\">新浪微博 Android 接入指南</a> 将新浪微博登录集成到你的应用中。</p>\n<ol>\n<li>在WeiboAuthListener的<code>onComplete</code>方法中可以获取到Oauth2AccessToken对象，然后从里面获取到token和openId。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAuthInfo = <span class=\"keyword\">new</span> AuthInfo(<span class=\"keyword\">this</span>, Constants.APP_KEY, Constants.REDIRECT_URL, Constants.SCOPE);</div><div class=\"line\">mSsoHandler = <span class=\"keyword\">new</span> SsoHandler(WBAuthActivity.<span class=\"keyword\">this</span>, mAuthInfo);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// SSO 授权, 仅客户端</span></div><div class=\"line\">findViewById(R.id.obtain_token_via_sso).setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">        mSsoHandler.authorizeClientSso(<span class=\"keyword\">new</span> AuthListener());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * 微博认证授权回调类。</div><div class=\"line\">  * 1. SSO 授权时，需要在 &#123;<span class=\"doctag\">@link</span> #onActivityResult&#125; 中调用 &#123;<span class=\"doctag\">@link</span> SsoHandler#authorizeCallBack&#125; 后，</div><div class=\"line\">  *    该回调才会被执行。</div><div class=\"line\">  * 2. 非 SSO 授权时，当授权结束后，该回调就会被执行。</div><div class=\"line\">  * 当授权成功后，请保存该 access_token、expires_in、uid 等信息到 SharedPreferences 中。</div><div class=\"line\">  */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">WeiboAuthListener</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Bundle values)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 从 Bundle 中解析 Token</span></div><div class=\"line\">        mAccessToken = Oauth2AccessToken.parseAccessToken(values);</div><div class=\"line\">        <span class=\"comment\">// token 和openId</span></div><div class=\"line\">        String token = mAccessToken.getToken();</div><div class=\"line\">        String Uid = mAccessToken.getUid();</div><div class=\"line\">        <span class=\"comment\">// 从这里获取用户输入的 电话号码信息</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mAccessToken.isSessionValid()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 进行WilddogAuth登录</span></div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 以下几种情况，你会收到 Code：</span></div><div class=\"line\">            <span class=\"comment\">// 1. 当你未在平台上注册的应用程序的包名与签名时；</span></div><div class=\"line\">            <span class=\"comment\">// 2. 当你注册的应用程序包名与签名不正确时；</span></div><div class=\"line\">            <span class=\"comment\">// 3. 当你在平台上注册的包名和签名与你当前测试的应用的包名和签名不匹配时。</span></div><div class=\"line\">            String code = values.getString(<span class=\"string\">\"code\"</span>);</div><div class=\"line\">            String message = getString(R.string.weibosdk_demo_toast_auth_failed);</div><div class=\"line\">            <span class=\"keyword\">if</span> (!TextUtils.isEmpty(code)) &#123;</div><div class=\"line\">                message = message + <span class=\"string\">\"\\nObtained the code: \"</span> + code;</div><div class=\"line\">            &#125;</div><div class=\"line\">            Toast.makeText(WBAuthActivity.<span class=\"keyword\">this</span>, message, Toast.LENGTH_LONG).show();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        Toast.makeText(WBAuthActivity.<span class=\"keyword\">this</span>, R.string.weibosdk_demo_toast_auth_canceled, Toast.LENGTH_LONG).show();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onWeiboException</span><span class=\"params\">(WeiboException e)</span> </span>&#123;</div><div class=\"line\">        Toast.makeText(WBAuthActivity.<span class=\"keyword\">this</span>, <span class=\"string\">\"Auth exception : \"</span> + e.getMessage(), Toast.LENGTH_LONG).show();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3.新浪微博登录成功后，在 didReceiveWeiboResponse: 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weiboAuthCredential = WeiboAuthProvider.getCredential(mAccessToken.getToken(), mAccessToken.getUid());</div></pre></td></tr></table></figure>\n<p>4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCredential(weiboAuthCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">          processResult(var1);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n"},{"title":"Wilddog用户","_content":"\n## 用户属性\n\n终端用户有一组用户的基本属性：Wilddog ID,主邮箱地址,名称,照片地址，这些属性存储在该项目的用户数据库中,并且可以被用户更新。\n\n终端用户直接添加其他属性，当时可以通过Sync中存储附加信息。\n\n一个终端用户初次注册那个应用时,系统使用可用信息填充该用户的个人资料数据：\n* 若该终端用户使用的是电子邮件地址和密码注册,则控制填充电子邮件地址属性。\n\n* 若该终端用户是使用Oauth方式注册,则会使用Oauth提供的账户信息填充终端用户信息。\n\n## 登录提供程序\n\n野狗用户可以使用几种将用户登录到野狗应用:电子邮件地址与密码，Oauth方式登录，以及自定义身份认证。\n同时我们也支持将多种登录方式与一个用户关联:例如,终端用户可以使用电子邮件地址与密码方式和QQ登录方式关联到同一个账户上,那么终端用户可以使用该账户下任意一种登录方式进行登录。\n\n## 当前用户\n\n当一个用户注册或登录时，该用户则变为身份认证实例的当前用户。野狗的身份认证实例保留该用户的状态，所以刷新页面（在浏览器中）或重启应用不会导致该用户的信息丢失。\n\n当用户注销时，身份认证实例停止保存对用户对象的引用，不再保留其状态，所以没有当前用户。\n\n## 用户生命周期\n\n目前野狗使用Auth监听器监听当前用户状态。\nAuth监听器会在以下情况收到通知:\n* 用户进行登录\n* 用户退出\n* 当前的Wilddog ID Token已刷新\n\n其中需要注意：有些操作需要最近获取的Wilddog ID Token,这些操作包括删除账户,设置主电子邮件地址和修改密码。当遇到这种情况下,除了用户重新登录外,还提供一致方式:即从该用户获取新的凭据并通过凭据进行用户对象重新认证。\n\n## 身份认证令牌\n执行野狗身份认证时,我们会出现三种身份认证令牌\n\n\n| Wilddog ID Token | 当用户登录野狗应用时由野狗创建,这个Token 签署了JWT,可在 Wilddog 应用中安全地识别用户。其中Wilddog ID Token包含了用户的基本个人信息,包括 Wilddog ID，其中 Wilddog Id 在对应应用内是唯一的。 |\n| -- | ----- |\n| OAuth的accessToken | 由OAuth提供商创建的一种Token,这些Token可以有不同的格式,但常用的是OAuth的accessToken,creditwilddog应用使用这些 Token来确认用户已成功通过OAuth身份认证,然后将它转换成可供 Wilddog服务使用的credentials|\n| 野狗的 CustomToken | 由自定义身份认证系统创建,用于允许用户可以自己实现身份系统登录野狗的应用。CustomToken是使用服务账户超级秘钥的JWT签名格式的 Token |\n\n注意：Wilddog ID Token 现已升级为新版。新旧版 Wilddog ID Token 对比如下：\n\n旧版 Wilddog ID Token 格式：\n\n```\n{\n  \"v\": 0,\n   \"iat\": 1473131840,\n   \"exp\": 1473131840,\n   \"d\": {\n    \"uid\": \"5fbb360743d26a40420cbb636b2e”,\n    “claim”:{}\n  }\n}\n```\n\n新版 Wilddog ID Token 格式：\n\n```\n{\n    \"v\":1,\n    \"iss\":\"[https://%3Cappid/]https://<appid>.wilddogio.com\"\n    \"iat\":132323223,\n    \"exp\":132323223,\n    \"user_id\":\"3128736827jdmsdsd\",\n    \"provider_id\": \"anonymous\", //只有匿名的时候有\n    \"email\":\"xxx@wilddog.com\",\n    \"email_verified\":false,\n    \"name”:\"xxx\",\n    \"picture\":\"http://picture.com/xxxxxx\",\n    \"wilddog\":{\n        \"identities\": {\n            \"google.com\": [\n                \"23232323243534543\"\n                ],\n            \"password\":[\n                \"juzhen@wilddog.com\"\n                ]\n            },\n        \"sign_in_provider\": \"password\"\n    },\n    <claim1> : {},\n    <claim2> : {},\n    <option> : {}\n}\n```\n旧版的应用不能用新版的 Wilddog ID Token，同时新版的应用不能用旧版的 Wilddog ID Token。如需要升级，请参考文档[ SDK 2.0升级指南](https://z.wilddog.com/upgrade/webupgrade)\n\n## 主邮箱使用\n本次auth升级 定义了主邮箱的定义\n主邮箱的使用场景如下\n\n| 重置账号密码 | 若终端用户忘记密码后,可以通过重置账号密码的方式,主邮箱会收到重置密码邮件 |\n| -- | ----- |\n| **邮箱修改提醒** | **当终端用户的账户修改了主邮箱时,原邮箱会收到一封提示邮件,提示 主邮箱已经修改。若邮箱修改不是本人操作,那么可以通过邮件中的还原邮箱操作进行主邮箱还原。** |\n| **账号邮箱确认** | **用户可以对终端用户发送一封邮箱确认邮件,终端用户可以通过点击邮件中的链接,对个人账户进行确认操作。** |\n\n","source":"guide/auth/core/concept.md","raw":"title: Wilddog用户\n---\n\n## 用户属性\n\n终端用户有一组用户的基本属性：Wilddog ID,主邮箱地址,名称,照片地址，这些属性存储在该项目的用户数据库中,并且可以被用户更新。\n\n终端用户直接添加其他属性，当时可以通过Sync中存储附加信息。\n\n一个终端用户初次注册那个应用时,系统使用可用信息填充该用户的个人资料数据：\n* 若该终端用户使用的是电子邮件地址和密码注册,则控制填充电子邮件地址属性。\n\n* 若该终端用户是使用Oauth方式注册,则会使用Oauth提供的账户信息填充终端用户信息。\n\n## 登录提供程序\n\n野狗用户可以使用几种将用户登录到野狗应用:电子邮件地址与密码，Oauth方式登录，以及自定义身份认证。\n同时我们也支持将多种登录方式与一个用户关联:例如,终端用户可以使用电子邮件地址与密码方式和QQ登录方式关联到同一个账户上,那么终端用户可以使用该账户下任意一种登录方式进行登录。\n\n## 当前用户\n\n当一个用户注册或登录时，该用户则变为身份认证实例的当前用户。野狗的身份认证实例保留该用户的状态，所以刷新页面（在浏览器中）或重启应用不会导致该用户的信息丢失。\n\n当用户注销时，身份认证实例停止保存对用户对象的引用，不再保留其状态，所以没有当前用户。\n\n## 用户生命周期\n\n目前野狗使用Auth监听器监听当前用户状态。\nAuth监听器会在以下情况收到通知:\n* 用户进行登录\n* 用户退出\n* 当前的Wilddog ID Token已刷新\n\n其中需要注意：有些操作需要最近获取的Wilddog ID Token,这些操作包括删除账户,设置主电子邮件地址和修改密码。当遇到这种情况下,除了用户重新登录外,还提供一致方式:即从该用户获取新的凭据并通过凭据进行用户对象重新认证。\n\n## 身份认证令牌\n执行野狗身份认证时,我们会出现三种身份认证令牌\n\n\n| Wilddog ID Token | 当用户登录野狗应用时由野狗创建,这个Token 签署了JWT,可在 Wilddog 应用中安全地识别用户。其中Wilddog ID Token包含了用户的基本个人信息,包括 Wilddog ID，其中 Wilddog Id 在对应应用内是唯一的。 |\n| -- | ----- |\n| OAuth的accessToken | 由OAuth提供商创建的一种Token,这些Token可以有不同的格式,但常用的是OAuth的accessToken,creditwilddog应用使用这些 Token来确认用户已成功通过OAuth身份认证,然后将它转换成可供 Wilddog服务使用的credentials|\n| 野狗的 CustomToken | 由自定义身份认证系统创建,用于允许用户可以自己实现身份系统登录野狗的应用。CustomToken是使用服务账户超级秘钥的JWT签名格式的 Token |\n\n注意：Wilddog ID Token 现已升级为新版。新旧版 Wilddog ID Token 对比如下：\n\n旧版 Wilddog ID Token 格式：\n\n```\n{\n  \"v\": 0,\n   \"iat\": 1473131840,\n   \"exp\": 1473131840,\n   \"d\": {\n    \"uid\": \"5fbb360743d26a40420cbb636b2e”,\n    “claim”:{}\n  }\n}\n```\n\n新版 Wilddog ID Token 格式：\n\n```\n{\n    \"v\":1,\n    \"iss\":\"[https://%3Cappid/]https://<appid>.wilddogio.com\"\n    \"iat\":132323223,\n    \"exp\":132323223,\n    \"user_id\":\"3128736827jdmsdsd\",\n    \"provider_id\": \"anonymous\", //只有匿名的时候有\n    \"email\":\"xxx@wilddog.com\",\n    \"email_verified\":false,\n    \"name”:\"xxx\",\n    \"picture\":\"http://picture.com/xxxxxx\",\n    \"wilddog\":{\n        \"identities\": {\n            \"google.com\": [\n                \"23232323243534543\"\n                ],\n            \"password\":[\n                \"juzhen@wilddog.com\"\n                ]\n            },\n        \"sign_in_provider\": \"password\"\n    },\n    <claim1> : {},\n    <claim2> : {},\n    <option> : {}\n}\n```\n旧版的应用不能用新版的 Wilddog ID Token，同时新版的应用不能用旧版的 Wilddog ID Token。如需要升级，请参考文档[ SDK 2.0升级指南](https://z.wilddog.com/upgrade/webupgrade)\n\n## 主邮箱使用\n本次auth升级 定义了主邮箱的定义\n主邮箱的使用场景如下\n\n| 重置账号密码 | 若终端用户忘记密码后,可以通过重置账号密码的方式,主邮箱会收到重置密码邮件 |\n| -- | ----- |\n| **邮箱修改提醒** | **当终端用户的账户修改了主邮箱时,原邮箱会收到一封提示邮件,提示 主邮箱已经修改。若邮箱修改不是本人操作,那么可以通过邮件中的还原邮箱操作进行主邮箱还原。** |\n| **账号邮箱确认** | **用户可以对终端用户发送一封邮箱确认邮件,终端用户可以通过点击邮件中的链接,对个人账户进行确认操作。** |\n\n","date":"2016-09-06T09:00:14.842Z","updated":"2016-09-06T09:00:14.842Z","path":"guide/auth/core/concept.html","comments":1,"layout":"page","_id":"cisswi9kl000vz4fwi513z8m2","content":"<h2 id=\"用户属性\"><a href=\"#用户属性\" class=\"headerlink\" title=\"用户属性\"></a>用户属性</h2><p>终端用户有一组用户的基本属性：Wilddog ID,主邮箱地址,名称,照片地址，这些属性存储在该项目的用户数据库中,并且可以被用户更新。</p>\n<p>终端用户直接添加其他属性，当时可以通过Sync中存储附加信息。</p>\n<p>一个终端用户初次注册那个应用时,系统使用可用信息填充该用户的个人资料数据：</p>\n<ul>\n<li><p>若该终端用户使用的是电子邮件地址和密码注册,则控制填充电子邮件地址属性。</p>\n</li>\n<li><p>若该终端用户是使用Oauth方式注册,则会使用Oauth提供的账户信息填充终端用户信息。</p>\n</li>\n</ul>\n<h2 id=\"登录提供程序\"><a href=\"#登录提供程序\" class=\"headerlink\" title=\"登录提供程序\"></a>登录提供程序</h2><p>野狗用户可以使用几种将用户登录到野狗应用:电子邮件地址与密码，Oauth方式登录，以及自定义身份认证。<br>同时我们也支持将多种登录方式与一个用户关联:例如,终端用户可以使用电子邮件地址与密码方式和QQ登录方式关联到同一个账户上,那么终端用户可以使用该账户下任意一种登录方式进行登录。</p>\n<h2 id=\"当前用户\"><a href=\"#当前用户\" class=\"headerlink\" title=\"当前用户\"></a>当前用户</h2><p>当一个用户注册或登录时，该用户则变为身份认证实例的当前用户。野狗的身份认证实例保留该用户的状态，所以刷新页面（在浏览器中）或重启应用不会导致该用户的信息丢失。</p>\n<p>当用户注销时，身份认证实例停止保存对用户对象的引用，不再保留其状态，所以没有当前用户。</p>\n<h2 id=\"用户生命周期\"><a href=\"#用户生命周期\" class=\"headerlink\" title=\"用户生命周期\"></a>用户生命周期</h2><p>目前野狗使用Auth监听器监听当前用户状态。<br>Auth监听器会在以下情况收到通知:</p>\n<ul>\n<li>用户进行登录</li>\n<li>用户退出</li>\n<li>当前的Wilddog ID Token已刷新</li>\n</ul>\n<p>其中需要注意：有些操作需要最近获取的Wilddog ID Token,这些操作包括删除账户,设置主电子邮件地址和修改密码。当遇到这种情况下,除了用户重新登录外,还提供一致方式:即从该用户获取新的凭据并通过凭据进行用户对象重新认证。</p>\n<h2 id=\"身份认证令牌\"><a href=\"#身份认证令牌\" class=\"headerlink\" title=\"身份认证令牌\"></a>身份认证令牌</h2><p>执行野狗身份认证时,我们会出现三种身份认证令牌</p>\n<table>\n<thead>\n<tr>\n<th>Wilddog ID Token</th>\n<th>当用户登录野狗应用时由野狗创建,这个Token 签署了JWT,可在 Wilddog 应用中安全地识别用户。其中Wilddog ID Token包含了用户的基本个人信息,包括 Wilddog ID，其中 Wilddog Id 在对应应用内是唯一的。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth的accessToken</td>\n<td>由OAuth提供商创建的一种Token,这些Token可以有不同的格式,但常用的是OAuth的accessToken,creditwilddog应用使用这些 Token来确认用户已成功通过OAuth身份认证,然后将它转换成可供 Wilddog服务使用的credentials</td>\n</tr>\n<tr>\n<td>野狗的 CustomToken</td>\n<td>由自定义身份认证系统创建,用于允许用户可以自己实现身份系统登录野狗的应用。CustomToken是使用服务账户超级秘钥的JWT签名格式的 Token</td>\n</tr>\n</tbody>\n</table>\n<p>注意：Wilddog ID Token 现已升级为新版。新旧版 Wilddog ID Token 对比如下：</p>\n<p>旧版 Wilddog ID Token 格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;v&quot;: 0,</div><div class=\"line\">   &quot;iat&quot;: 1473131840,</div><div class=\"line\">   &quot;exp&quot;: 1473131840,</div><div class=\"line\">   &quot;d&quot;: &#123;</div><div class=\"line\">    &quot;uid&quot;: &quot;5fbb360743d26a40420cbb636b2e”,</div><div class=\"line\">    “claim”:&#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>新版 Wilddog ID Token 格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;v&quot;:1,</div><div class=\"line\">    &quot;iss&quot;:&quot;[https://%3Cappid/]https://&lt;appid&gt;.wilddogio.com&quot;</div><div class=\"line\">    &quot;iat&quot;:132323223,</div><div class=\"line\">    &quot;exp&quot;:132323223,</div><div class=\"line\">    &quot;user_id&quot;:&quot;3128736827jdmsdsd&quot;,</div><div class=\"line\">    &quot;provider_id&quot;: &quot;anonymous&quot;, //只有匿名的时候有</div><div class=\"line\">    &quot;email&quot;:&quot;xxx@wilddog.com&quot;,</div><div class=\"line\">    &quot;email_verified&quot;:false,</div><div class=\"line\">    &quot;name”:&quot;xxx&quot;,</div><div class=\"line\">    &quot;picture&quot;:&quot;http://picture.com/xxxxxx&quot;,</div><div class=\"line\">    &quot;wilddog&quot;:&#123;</div><div class=\"line\">        &quot;identities&quot;: &#123;</div><div class=\"line\">            &quot;google.com&quot;: [</div><div class=\"line\">                &quot;23232323243534543&quot;</div><div class=\"line\">                ],</div><div class=\"line\">            &quot;password&quot;:[</div><div class=\"line\">                &quot;juzhen@wilddog.com&quot;</div><div class=\"line\">                ]</div><div class=\"line\">            &#125;,</div><div class=\"line\">        &quot;sign_in_provider&quot;: &quot;password&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &lt;claim1&gt; : &#123;&#125;,</div><div class=\"line\">    &lt;claim2&gt; : &#123;&#125;,</div><div class=\"line\">    &lt;option&gt; : &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>旧版的应用不能用新版的 Wilddog ID Token，同时新版的应用不能用旧版的 Wilddog ID Token。如需要升级，请参考文档<a href=\"https://z.wilddog.com/upgrade/webupgrade\" target=\"_blank\" rel=\"external\"> SDK 2.0升级指南</a></p>\n<h2 id=\"主邮箱使用\"><a href=\"#主邮箱使用\" class=\"headerlink\" title=\"主邮箱使用\"></a>主邮箱使用</h2><p>本次auth升级 定义了主邮箱的定义<br>主邮箱的使用场景如下</p>\n<table>\n<thead>\n<tr>\n<th>重置账号密码</th>\n<th>若终端用户忘记密码后,可以通过重置账号密码的方式,主邮箱会收到重置密码邮件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>邮箱修改提醒</strong></td>\n<td><strong>当终端用户的账户修改了主邮箱时,原邮箱会收到一封提示邮件,提示 主邮箱已经修改。若邮箱修改不是本人操作,那么可以通过邮件中的还原邮箱操作进行主邮箱还原。</strong></td>\n</tr>\n<tr>\n<td><strong>账号邮箱确认</strong></td>\n<td><strong>用户可以对终端用户发送一封邮箱确认邮件,终端用户可以通过点击邮件中的链接,对个人账户进行确认操作。</strong></td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h2 id=\"用户属性\"><a href=\"#用户属性\" class=\"headerlink\" title=\"用户属性\"></a>用户属性</h2><p>终端用户有一组用户的基本属性：Wilddog ID,主邮箱地址,名称,照片地址，这些属性存储在该项目的用户数据库中,并且可以被用户更新。</p>\n<p>终端用户直接添加其他属性，当时可以通过Sync中存储附加信息。</p>\n<p>一个终端用户初次注册那个应用时,系统使用可用信息填充该用户的个人资料数据：</p>\n<ul>\n<li><p>若该终端用户使用的是电子邮件地址和密码注册,则控制填充电子邮件地址属性。</p>\n</li>\n<li><p>若该终端用户是使用Oauth方式注册,则会使用Oauth提供的账户信息填充终端用户信息。</p>\n</li>\n</ul>\n<h2 id=\"登录提供程序\"><a href=\"#登录提供程序\" class=\"headerlink\" title=\"登录提供程序\"></a>登录提供程序</h2><p>野狗用户可以使用几种将用户登录到野狗应用:电子邮件地址与密码，Oauth方式登录，以及自定义身份认证。<br>同时我们也支持将多种登录方式与一个用户关联:例如,终端用户可以使用电子邮件地址与密码方式和QQ登录方式关联到同一个账户上,那么终端用户可以使用该账户下任意一种登录方式进行登录。</p>\n<h2 id=\"当前用户\"><a href=\"#当前用户\" class=\"headerlink\" title=\"当前用户\"></a>当前用户</h2><p>当一个用户注册或登录时，该用户则变为身份认证实例的当前用户。野狗的身份认证实例保留该用户的状态，所以刷新页面（在浏览器中）或重启应用不会导致该用户的信息丢失。</p>\n<p>当用户注销时，身份认证实例停止保存对用户对象的引用，不再保留其状态，所以没有当前用户。</p>\n<h2 id=\"用户生命周期\"><a href=\"#用户生命周期\" class=\"headerlink\" title=\"用户生命周期\"></a>用户生命周期</h2><p>目前野狗使用Auth监听器监听当前用户状态。<br>Auth监听器会在以下情况收到通知:</p>\n<ul>\n<li>用户进行登录</li>\n<li>用户退出</li>\n<li>当前的Wilddog ID Token已刷新</li>\n</ul>\n<p>其中需要注意：有些操作需要最近获取的Wilddog ID Token,这些操作包括删除账户,设置主电子邮件地址和修改密码。当遇到这种情况下,除了用户重新登录外,还提供一致方式:即从该用户获取新的凭据并通过凭据进行用户对象重新认证。</p>\n<h2 id=\"身份认证令牌\"><a href=\"#身份认证令牌\" class=\"headerlink\" title=\"身份认证令牌\"></a>身份认证令牌</h2><p>执行野狗身份认证时,我们会出现三种身份认证令牌</p>\n<table>\n<thead>\n<tr>\n<th>Wilddog ID Token</th>\n<th>当用户登录野狗应用时由野狗创建,这个Token 签署了JWT,可在 Wilddog 应用中安全地识别用户。其中Wilddog ID Token包含了用户的基本个人信息,包括 Wilddog ID，其中 Wilddog Id 在对应应用内是唯一的。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth的accessToken</td>\n<td>由OAuth提供商创建的一种Token,这些Token可以有不同的格式,但常用的是OAuth的accessToken,creditwilddog应用使用这些 Token来确认用户已成功通过OAuth身份认证,然后将它转换成可供 Wilddog服务使用的credentials</td>\n</tr>\n<tr>\n<td>野狗的 CustomToken</td>\n<td>由自定义身份认证系统创建,用于允许用户可以自己实现身份系统登录野狗的应用。CustomToken是使用服务账户超级秘钥的JWT签名格式的 Token</td>\n</tr>\n</tbody>\n</table>\n<p>注意：Wilddog ID Token 现已升级为新版。新旧版 Wilddog ID Token 对比如下：</p>\n<p>旧版 Wilddog ID Token 格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;v&quot;: 0,</div><div class=\"line\">   &quot;iat&quot;: 1473131840,</div><div class=\"line\">   &quot;exp&quot;: 1473131840,</div><div class=\"line\">   &quot;d&quot;: &#123;</div><div class=\"line\">    &quot;uid&quot;: &quot;5fbb360743d26a40420cbb636b2e”,</div><div class=\"line\">    “claim”:&#123;&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>新版 Wilddog ID Token 格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;v&quot;:1,</div><div class=\"line\">    &quot;iss&quot;:&quot;[https://%3Cappid/]https://&lt;appid&gt;.wilddogio.com&quot;</div><div class=\"line\">    &quot;iat&quot;:132323223,</div><div class=\"line\">    &quot;exp&quot;:132323223,</div><div class=\"line\">    &quot;user_id&quot;:&quot;3128736827jdmsdsd&quot;,</div><div class=\"line\">    &quot;provider_id&quot;: &quot;anonymous&quot;, //只有匿名的时候有</div><div class=\"line\">    &quot;email&quot;:&quot;xxx@wilddog.com&quot;,</div><div class=\"line\">    &quot;email_verified&quot;:false,</div><div class=\"line\">    &quot;name”:&quot;xxx&quot;,</div><div class=\"line\">    &quot;picture&quot;:&quot;http://picture.com/xxxxxx&quot;,</div><div class=\"line\">    &quot;wilddog&quot;:&#123;</div><div class=\"line\">        &quot;identities&quot;: &#123;</div><div class=\"line\">            &quot;google.com&quot;: [</div><div class=\"line\">                &quot;23232323243534543&quot;</div><div class=\"line\">                ],</div><div class=\"line\">            &quot;password&quot;:[</div><div class=\"line\">                &quot;juzhen@wilddog.com&quot;</div><div class=\"line\">                ]</div><div class=\"line\">            &#125;,</div><div class=\"line\">        &quot;sign_in_provider&quot;: &quot;password&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &lt;claim1&gt; : &#123;&#125;,</div><div class=\"line\">    &lt;claim2&gt; : &#123;&#125;,</div><div class=\"line\">    &lt;option&gt; : &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>旧版的应用不能用新版的 Wilddog ID Token，同时新版的应用不能用旧版的 Wilddog ID Token。如需要升级，请参考文档<a href=\"https://z.wilddog.com/upgrade/webupgrade\"> SDK 2.0升级指南</a></p>\n<h2 id=\"主邮箱使用\"><a href=\"#主邮箱使用\" class=\"headerlink\" title=\"主邮箱使用\"></a>主邮箱使用</h2><p>本次auth升级 定义了主邮箱的定义<br>主邮箱的使用场景如下</p>\n<table>\n<thead>\n<tr>\n<th>重置账号密码</th>\n<th>若终端用户忘记密码后,可以通过重置账号密码的方式,主邮箱会收到重置密码邮件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>邮箱修改提醒</strong></td>\n<td><strong>当终端用户的账户修改了主邮箱时,原邮箱会收到一封提示邮件,提示 主邮箱已经修改。若邮箱修改不是本人操作,那么可以通过邮件中的还原邮箱操作进行主邮箱还原。</strong></td>\n</tr>\n<tr>\n<td><strong>账号邮箱确认</strong></td>\n<td><strong>用户可以对终端用户发送一封邮箱确认邮件,终端用户可以通过点击邮件中的链接,对个人账户进行确认操作。</strong></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"匿名身份认证","_content":"\n你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，[可以绑定其它登录方式](/guide/auth/ios/link.html)。\n\n## 开始前的准备工作\n1. 将以下 pod 包含在你的 Podfile 中：\n```\n  pod 'Wilddog/Auth'\n```\n2. 在 Wilddog 控制面板中创建一个应用。\n\n3. 打开匿名登录方式:\n\n  * 在野狗控制面板中选择身份认证\n  * 在｀登录方式｀标签中打开匿名登录方式\n    \n## 使用 Wilddog 匿名登录认证\n当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：\n1、 导入 Wilddog Auth 模块:     \n\t\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 以 Wilddog AppId 初始化 WDGAuth。\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 调用 `signInAnonymouslyWithCompletion:`方法：\n\nObjective-C\n```objectivec\n[auth signInAnonymouslyWithCompletion:^(WDGUser *_Nullable user, NSError *_Nullable error) {\n   // ...\n}];\n```\nSwift\n```swift\nauth?.signInAnonymouslyWithCompletion(){(user, error) in\n   //...\n}\n```\n4、 如果 signInAnonymouslyWithCompletion: 方法调用成功并且没有返回错误信息，你可以在 WDGUser 对象中获取用户数据：\n\nObjective-C\n```objectivec\nBOOL isAnonymous = user.anonymous;  // YES\nNSString *uid = user.uid;\n```\nSwift\n```swift\nlet isAnonymous = user!.anonymous  // true\nlet uid = user!.uid\n```\n## 将匿名帐号转变成永久帐号\n当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：\n\n1、 准备一个未在你的应用上登录过的邮箱或者第三方登录方式。\n2、 通过一种登录方式获取 WDGAuthCredential：\n\n##### QQ 登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];\n```\nSwift\n```swift\nlet credential = WDGQQAuthProvider.credentialWithAccessToken(qqOAuth.accessToken)\n\n```\n##### 微信登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];\n```\nSwift\n```swift\nlet credential = WDGWeiXinAuthProvider.credentialWithCode(weixinOAuth.code)\n\n```\n##### 微博登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken \n                   userID:sinaOAuth.userID];\n```\n\nSwift\n```swift\nlet credential = WDGSinaAuthProvider.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)\n\n```\n##### 邮箱登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential =\n    [WDGEmailPasswordAuthProvider credentialWithEmail:email\n                                             password:password];\n```\n\nSwift\n```swift\nlet credential = WDGEmailPasswordAuthProvider.credentialWithEmail(email, password: password)\n\n```\n\n3、 使用 `linkWithCredential:completion:` 方法来完成完成链接：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n[auth.currentUser linkWithCredential:credential completion:^(WDGUser *_Nullable user,NSError *_Nullable error) {\n      // ...\n}];\n```\n\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\nauth!.currentUser?.linkWithCredential(credential) { (user, error) in\n     // ...\n}\n\n```\n\n如果调用 `linkWithCredential:completion:` 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。\n\n\n>注： 这项技术可以链接任意两个类型的帐号。\n\n\n## 后续步骤\n现在我们已经学会了使用野狗进行用户认证，你可以配置 [规则表达式](/guide/sync/rules/introduce.html) 来控制野狗实时数据的访问权限。","source":"guide/auth/ios/anonymous.md","raw":"title: 匿名身份认证\n---\n\n你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，[可以绑定其它登录方式](/guide/auth/ios/link.html)。\n\n## 开始前的准备工作\n1. 将以下 pod 包含在你的 Podfile 中：\n```\n  pod 'Wilddog/Auth'\n```\n2. 在 Wilddog 控制面板中创建一个应用。\n\n3. 打开匿名登录方式:\n\n  * 在野狗控制面板中选择身份认证\n  * 在｀登录方式｀标签中打开匿名登录方式\n    \n## 使用 Wilddog 匿名登录认证\n当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：\n1、 导入 Wilddog Auth 模块:     \n\t\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 以 Wilddog AppId 初始化 WDGAuth。\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 调用 `signInAnonymouslyWithCompletion:`方法：\n\nObjective-C\n```objectivec\n[auth signInAnonymouslyWithCompletion:^(WDGUser *_Nullable user, NSError *_Nullable error) {\n   // ...\n}];\n```\nSwift\n```swift\nauth?.signInAnonymouslyWithCompletion(){(user, error) in\n   //...\n}\n```\n4、 如果 signInAnonymouslyWithCompletion: 方法调用成功并且没有返回错误信息，你可以在 WDGUser 对象中获取用户数据：\n\nObjective-C\n```objectivec\nBOOL isAnonymous = user.anonymous;  // YES\nNSString *uid = user.uid;\n```\nSwift\n```swift\nlet isAnonymous = user!.anonymous  // true\nlet uid = user!.uid\n```\n## 将匿名帐号转变成永久帐号\n当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：\n\n1、 准备一个未在你的应用上登录过的邮箱或者第三方登录方式。\n2、 通过一种登录方式获取 WDGAuthCredential：\n\n##### QQ 登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];\n```\nSwift\n```swift\nlet credential = WDGQQAuthProvider.credentialWithAccessToken(qqOAuth.accessToken)\n\n```\n##### 微信登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];\n```\nSwift\n```swift\nlet credential = WDGWeiXinAuthProvider.credentialWithCode(weixinOAuth.code)\n\n```\n##### 微博登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken \n                   userID:sinaOAuth.userID];\n```\n\nSwift\n```swift\nlet credential = WDGSinaAuthProvider.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)\n\n```\n##### 邮箱登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential =\n    [WDGEmailPasswordAuthProvider credentialWithEmail:email\n                                             password:password];\n```\n\nSwift\n```swift\nlet credential = WDGEmailPasswordAuthProvider.credentialWithEmail(email, password: password)\n\n```\n\n3、 使用 `linkWithCredential:completion:` 方法来完成完成链接：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n[auth.currentUser linkWithCredential:credential completion:^(WDGUser *_Nullable user,NSError *_Nullable error) {\n      // ...\n}];\n```\n\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\nauth!.currentUser?.linkWithCredential(credential) { (user, error) in\n     // ...\n}\n\n```\n\n如果调用 `linkWithCredential:completion:` 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。\n\n\n>注： 这项技术可以链接任意两个类型的帐号。\n\n\n## 后续步骤\n现在我们已经学会了使用野狗进行用户认证，你可以配置 [规则表达式](/guide/sync/rules/introduce.html) 来控制野狗实时数据的访问权限。","date":"2016-09-06T03:38:22.523Z","updated":"2016-09-06T03:38:22.523Z","path":"guide/auth/ios/anonymous.html","comments":1,"layout":"page","_id":"cisswi9kl000wz4fw3phoavi9","content":"<p>你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，<a href=\"/guide/auth/ios/link.html\">可以绑定其它登录方式</a>。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>将以下 pod 包含在你的 Podfile 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 Wilddog 控制面板中创建一个应用。</p>\n</li>\n<li><p>打开匿名登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证</li>\n<li>在｀登录方式｀标签中打开匿名登录方式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用-Wilddog-匿名登录认证\"><a href=\"#使用-Wilddog-匿名登录认证\" class=\"headerlink\" title=\"使用 Wilddog 匿名登录认证\"></a>使用 Wilddog 匿名登录认证</h2><p>当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：<br>1、 导入 Wilddog Auth 模块:     </p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 以 Wilddog AppId 初始化 WDGAuth。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 调用 <code>signInAnonymouslyWithCompletion:</code>方法：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInAnonymouslyWithCompletion:^(WDGUser *_Nullable user, <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInAnonymouslyWithCompletion()&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">   <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>4、 如果 signInAnonymouslyWithCompletion: 方法调用成功并且没有返回错误信息，你可以在 WDGUser 对象中获取用户数据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> isAnonymous = user.anonymous;  <span class=\"comment\">// YES</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *uid = user.uid;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> isAnonymous = user!.anonymous  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"keyword\">let</span> uid = user!.uid</div></pre></td></tr></table></figure></p>\n<h2 id=\"将匿名帐号转变成永久帐号\"><a href=\"#将匿名帐号转变成永久帐号\" class=\"headerlink\" title=\"将匿名帐号转变成永久帐号\"></a>将匿名帐号转变成永久帐号</h2><p>当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：</p>\n<p>1、 准备一个未在你的应用上登录过的邮箱或者第三方登录方式。<br>2、 通过一种登录方式获取 WDGAuthCredential：</p>\n<h5 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGQQAuthProvider</span>.credentialWithAccessToken(qqOAuth.accessToken)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGWeiXinAuthProvider</span>.credentialWithCode(weixinOAuth.code)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken </div><div class=\"line\">                   userID:sinaOAuth.userID];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGSinaAuthProvider</span>.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)</div></pre></td></tr></table></figure></p>\n<h5 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential =</div><div class=\"line\">    [WDGEmailPasswordAuthProvider credentialWithEmail:email</div><div class=\"line\">                                             password:password];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGEmailPasswordAuthProvider</span>.credentialWithEmail(email, password: password)</div></pre></td></tr></table></figure></p>\n<p>3、 使用 <code>linkWithCredential:completion:</code> 方法来完成完成链接：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div><div class=\"line\">[auth.currentUser linkWithCredential:credential completion:^(WDGUser *_Nullable user,<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div><div class=\"line\">auth!.currentUser?.linkWithCredential(credential) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">     <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果调用 <code>linkWithCredential:completion:</code> 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。</p>\n<blockquote>\n<p>注： 这项技术可以链接任意两个类型的帐号。</p>\n</blockquote>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>现在我们已经学会了使用野狗进行用户认证，你可以配置 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 来控制野狗实时数据的访问权限。</p>\n","excerpt":"","more":"<p>你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，<a href=\"/guide/auth/ios/link.html\">可以绑定其它登录方式</a>。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>将以下 pod 包含在你的 Podfile 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 Wilddog 控制面板中创建一个应用。</p>\n</li>\n<li><p>打开匿名登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证</li>\n<li>在｀登录方式｀标签中打开匿名登录方式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用-Wilddog-匿名登录认证\"><a href=\"#使用-Wilddog-匿名登录认证\" class=\"headerlink\" title=\"使用 Wilddog 匿名登录认证\"></a>使用 Wilddog 匿名登录认证</h2><p>当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：<br>1、 导入 Wilddog Auth 模块:     </p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 以 Wilddog AppId 初始化 WDGAuth。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 调用 <code>signInAnonymouslyWithCompletion:</code>方法：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInAnonymouslyWithCompletion:^(WDGUser *_Nullable user, <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInAnonymouslyWithCompletion()&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">   <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>4、 如果 signInAnonymouslyWithCompletion: 方法调用成功并且没有返回错误信息，你可以在 WDGUser 对象中获取用户数据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> isAnonymous = user.anonymous;  <span class=\"comment\">// YES</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *uid = user.uid;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> isAnonymous = user!.anonymous  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"keyword\">let</span> uid = user!.uid</div></pre></td></tr></table></figure></p>\n<h2 id=\"将匿名帐号转变成永久帐号\"><a href=\"#将匿名帐号转变成永久帐号\" class=\"headerlink\" title=\"将匿名帐号转变成永久帐号\"></a>将匿名帐号转变成永久帐号</h2><p>当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：</p>\n<p>1、 准备一个未在你的应用上登录过的邮箱或者第三方登录方式。<br>2、 通过一种登录方式获取 WDGAuthCredential：</p>\n<h5 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGQQAuthProvider</span>.credentialWithAccessToken(qqOAuth.accessToken)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGWeiXinAuthProvider</span>.credentialWithCode(weixinOAuth.code)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken </div><div class=\"line\">                   userID:sinaOAuth.userID];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGSinaAuthProvider</span>.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)</div></pre></td></tr></table></figure></p>\n<h5 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential =</div><div class=\"line\">    [WDGEmailPasswordAuthProvider credentialWithEmail:email</div><div class=\"line\">                                             password:password];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGEmailPasswordAuthProvider</span>.credentialWithEmail(email, password: password)</div></pre></td></tr></table></figure></p>\n<p>3、 使用 <code>linkWithCredential:completion:</code> 方法来完成完成链接：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div><div class=\"line\">[auth.currentUser linkWithCredential:credential completion:^(WDGUser *_Nullable user,<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">      <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div><div class=\"line\">auth!.currentUser?.linkWithCredential(credential) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">     <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果调用 <code>linkWithCredential:completion:</code> 方法成功，被链接的帐号就可以访问这个匿名帐号的数据了。</p>\n<blockquote>\n<p>注： 这项技术可以链接任意两个类型的帐号。</p>\n</blockquote>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>现在我们已经学会了使用野狗进行用户认证，你可以配置 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 来控制野狗实时数据的访问权限。</p>\n"},{"title":"完整 API 文档","_content":"\n# WDGAuth (*Methods*)\n\n## + authWithApp:\n\n 定义\n\n`+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))`\n\n 说明\n\n以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。\n\n 参数\n\nappID 应用的 appID。\n\n 描述\n\n能确保线程安全。\n\n## currentUser\n \n 定义\n\n`@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser`\n\n 说明\n\n同步的获取当前缓存的用户，如果没有登录用户则为 null。\n\n\n## - fetchProvidersForEmail:completion:\n\n 定义\n\n`- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion`\n\n 说明\n\n通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。\n\n 参数\n\nemail 用户的邮箱。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - signInWithEmail:password:completion:\n\n 定义\n\n`- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以邮箱和密码的方式登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户的登录密码。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n\n## - signInWithCredential:completion:\n\n 定义\n\n`- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）\n\n 参数\n\ncredential 第三方提供的凭证。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。\n - WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示账号被禁用。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - signInAnonymouslyWithCompletion:\n\n 定义\n\n`- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n匿名登录方式。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。  \n可能发生的错误：\n \n -  WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n \n## - signInWithCustomToken:completion:\n\n 定义\n\n`- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以自定义 token 的方式登录。\n\n 参数\n\ntoken 自定义的 token。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。\n - WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key\n belong to different projects.\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - createUserWithEmail:password:completion:\n\n 定义\n`- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n创建一个新用户，创建成功后会自动登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户指定的密码。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。\n - WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。\n - WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - WDGAuthErrorCodeWeakPassword 密码不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n## - sendPasswordResetWithEmail:completion:\n\n 定义\n\n`- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion`\n\n 说明\n\n通过邮箱找回密码。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n- See WDGAuthErrors API 调用可能发生的所有错误。\n\n## - signOut:\n\n 定义\n\n`- (BOOL)signOut:(NSError *_Nullable *_Nullable)error`\n\n 说明\n\n退出登录。\n\n 参数\n\nerror 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。\n\n 返回值\n\nYES 表示退出登录成功。NO 表示失败\n\n## - addAuthStateDidChangeListener:\n\n 定义\n\n`- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener`\n\n 说明\n\n监听用户 auth 状态。发生以下条件时会被调用：\n \n - 第一次调用时，\n - 当前用户切换时，\n - 或者当前用户的 idToken 变化时。\n\n 参数\n\nlistener 状态变化时调用的 block。异步等待，会在主线程中回调。\n\n 返回值\n\n返回这个 block 的唯一标示，用于移除这个 block。\n\n 描述\n\n这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。\n\n## - removeAuthStateDidChangeListener:\n\n 定义\n\n`- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle`\n\n 说明\n\n移除 auth 状态变更监听。\n\n 参数\n\nlistenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。\n\n\n# WDGAuthCredential (*Methods*)\n\n## provider\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *provider`\n\n 说明\n\n获取凭证的 id 名。\n\n\n# WDGEmailPasswordAuthProvider (*Methods*)\n\n## + credentialWithEmail: password:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password`\n\n 说明\n\n创建一个 email & password 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\nemail 用户的 email 地址。  \npassword 用户的登录密码。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 email & password 登录方式凭证。\n\n\n# WDGQQAuthProvider (*Methods*)\n\n## + credentialWithAccessToken:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken`\n\n 说明\n\n创建一个 qq 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken QQ OAuth access token.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 qq 登录凭证。\n\n\n# WDGSinaAuthProvider (*Methods*)\n\n## + credentialWithAccessToken: userID:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID`\n\n 说明\n\n创建一个 Sina 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken Sina OAuth access token.\nuserID Sina OAuth 的 userID。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 Sina 登录凭证。\n\n\n# WDGWeiXinAuthProvider (*Methods*)\n\n## + credentialWithCode:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithCode:(NSString *)code`\n\n 说明\n\n创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\ncode Weixin OAuth code.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 WeiXin 登录凭证。\n\n\n# WDGUser (*Methods*)\n\n## anonymous\n\n 定义\n\n`@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous`\n\n 说明\n\n如果为 YES 则表明为匿名用户。\n\n\n## emailVerified\n \n 定义\n\n`@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified`\n\n 说明\n\n如果为 YES 则表示和这个帐号关联的邮箱已经验证过。\n\n\n## providerData\n \n 定义\n\n`@property(nonatomic, readonly, nonnull) NSArray<id<WDGUserInfo>> *providerData`\n\n 说明\n\n所有登录方式的用户信息。\n\n 描述\n\n不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号\n\n\n## - updateEmail:completion:\n\n 定义\n\n`- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n更新帐号邮箱。如果更新成功，本地缓存也会刷新。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n如果这个邮箱已经创建过用户，则会更新失败。\n可能发生的错误：\n \n - WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。\n - WDGAuthErrorCodeInvalidEmail 邮箱格式错误。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - updatePassword:completion:\n\n 定义\n\n`- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n修改用户密码。如果成功，本地缓存也会被刷新。\n\n 参数\n  \npassword 用户设置的新密码。   \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - WDGAuthErrorCodeWeakPassword 密码设置不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n\n## profileChangeRequest\n\n 定义\n\n`- (WDGUserProfileChangeRequest *)profileChangeRequest`\n\n 说明\n\n创建一个可以改变用户信息的对象。\n\n 描述\n\n修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。\n\n 返回值\n\n返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。\n\n## - reloadWithCompletion:\n\n 定义\n\n`- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n从服务器上获取最新的用户信息。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。\n \n可能发生的错误：  \n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n\n## - reauthenticateWithCredential:completion:\n\n 定义\n\n`- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n重新登录，刷新本地 idToken。\n\n 参数\n\ncredential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。\ncompletion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。\n\n 描述\n \n如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。\n可能发生的错误：\n\n- WDGAuthErrorCodeInvalidCredential 无效的凭证。\n - WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。\n - WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。\n - WDGAuthErrorCodeUserDisabled 用户帐号被禁用。\n - WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。\n - WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - getTokenWithCompletion:\n\n 定义\n`- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion`\n\n 说明\n\n获取用户 token。\n\n 参数\n \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n## - linkWithCredential:completion:\n\n 定义\n\n`- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。\n\n 参数\n\ncredential 一种登录方式的凭证。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。\n - WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。\n - WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。\n - 这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。\n - See 更多错误请参考 WDGAuthErrors。\n\n## - unlinkFromProvider:completion:\n\n 定义\n\n`- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n解绑第三方帐号。\n\n 参数\n\nprovider 需要解绑的登录方式，可能为 qq、weixin、weibo。  \ncompletion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。\n - See 更多错误请参考 WDGAuthErrors。\n\n\n## - sendEmailVerificationWithCompletion:\n\n 定义\n\n`- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion`\n\n 说明\n\n发送邮箱验证。\n\n 参数\n\ncompletion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeUserNotFound 没有这个帐号。\n - See 更多错误请参考 WDGAuthErrors。\n \n\n## - deleteWithCompletion:\n\n 定义\n\n`- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n删除这个帐号（如果是当前用户，则退出登录）。\n\n 参数\n\ncompletion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:\n - See 更多错误请参考 WDGAuthErrors。\n \n \n# WDGUserProfileChangeRequest (*Methods*)\n\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSString *displayName`\n\n 说明\n\n用户名\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n## photoURL\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n## - commitChangesWithCompletion:\n\n 定义\n\n`- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n提交更改\n\n 参数\n\ncompletion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。\n\n 描述\n\n修改属性必须在这个方法调用之前。\n\n\n# WDGUserInfo (*protocol*)\n\n## providerID\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *providerID`\n\n 说明\n\n用户登录方式。\n\n\n## uid\n \n 定义\n\n`@property(nonatomic, copy, readonly) NSString *uid`\n\n 说明\n\n用户 id。\n\n\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *displayName`\n\n 说明\n\n用户名。\n\n\n## photoURL\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像。\n\n\n## email\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *email`\n\n 说明\n\n用户邮箱地址。\n\n\n# WDGAuthErrors (*Methods*)\n\n## WDGAuthErrorCode\n\n 定义\n\n```\ntypedef NS_ENUM(NSInteger, WDGAuthErrorCode) {\n\n    WDGAuthErrorCodeInvalidCustomToken = 17000,\n\n    WDGAuthErrorCodeCustomTokenMismatch = 17002,\n\n    WDGAuthErrorCodeInvalidCredential = 17004,\n\n    WDGAuthErrorCodeUserDisabled = 17005,\n\n    WDGAuthErrorCodeOperationNotAllowed = 17006,\n\n    WDGAuthErrorCodeEmailAlreadyInUse = 17007,\n\n    WDGAuthErrorCodeInvalidEmail = 17008,\n\n    WDGAuthErrorCodeWrongPassword = 17009,\n\n    WDGAuthErrorCodeTooManyRequests = 17010,\n\n    WDGAuthErrorCodeUserNotFound = 17011,\n\n    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrorCodeRequiresRecentLogin = 17014,\n\n    WDGAuthErrorCodeProviderAlreadyLinked = 17015,\n\n    WDGAuthErrorCodeNoSuchProvider = 17016,\n\n    WDGAuthErrorCodeInvalidUserToken = 17017,\n\n    WDGAuthErrorCodeNetworkError = 17020,\n\n    WDGAuthErrorCodeUserTokenExpired = 17021,\n\n    WDGAuthErrorCodeInvalidAPIKey = 17023,\n\n    WDGAuthErrorCodeUserMismatch = 17024,\n\n    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,\n\n    WDGAuthErrorCodeWeakPassword = 17026,\n\n    WDGAuthErrorCodeAppNotAuthorized = 17028,\n    \n    WDGAuthErrorCodeKeychainError = 17995,\n\n    WDGAuthErrorCodeInternalError = 17999,\n};\n\n```\n\n\n 说明\n\nWilddog iOS 身份认证错误。\n\n 参数\n\nWDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误\n\nWDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程\n\nWDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误\n\nWDGAuthErrorCodeUserDisabled 表示用户的帐户已停用\n\nWDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用\n\nWDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用\n\nWDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确\n\nWDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录\n\nWDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试\n\nWDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误\n\nWDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接\n\nWDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于`WDGAuthErrorCodeAccountExistsWithDifferentCredential`，只是拼写错误，只存在向后兼容性\n\nWDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过\n\nWDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户\n\nWDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户\n\nWDGAuthErrorCodeInvalidUserToken 表示 token 失效，你必须提示该用户在此设备重新登录\n\nWDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误\n\nWDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期\n\nWDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效\n\nWDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户\n\nWDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联\n\nWDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱\n\nWDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时\n    \nWDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错\n\nWDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误","source":"guide/auth/ios/api.md","raw":"title:  完整 API 文档\n---\n\n# WDGAuth (*Methods*)\n\n## + authWithApp:\n\n 定义\n\n`+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))`\n\n 说明\n\n以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。\n\n 参数\n\nappID 应用的 appID。\n\n 描述\n\n能确保线程安全。\n\n## currentUser\n \n 定义\n\n`@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser`\n\n 说明\n\n同步的获取当前缓存的用户，如果没有登录用户则为 null。\n\n\n## - fetchProvidersForEmail:completion:\n\n 定义\n\n`- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion`\n\n 说明\n\n通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。\n\n 参数\n\nemail 用户的邮箱。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - signInWithEmail:password:completion:\n\n 定义\n\n`- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以邮箱和密码的方式登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户的登录密码。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n\n## - signInWithCredential:completion:\n\n 定义\n\n`- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）\n\n 参数\n\ncredential 第三方提供的凭证。  \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。\n - WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。\n - WDGAuthErrorCodeUserDisabled 表示账号被禁用。\n - WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - signInAnonymouslyWithCompletion:\n\n 定义\n\n`- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n匿名登录方式。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。  \n可能发生的错误：\n \n -  WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n \n## - signInWithCustomToken:completion:\n\n 定义\n\n`- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n以自定义 token 的方式登录。\n\n 参数\n\ntoken 自定义的 token。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。\n - WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key\n belong to different projects.\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - createUserWithEmail:password:completion:\n\n 定义\n`- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n创建一个新用户，创建成功后会自动登录。\n\n 参数\n\nemail 用户的邮箱地址。  \npassword 用户指定的密码。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。\n - WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。\n - WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。\n - WDGAuthErrorCodeWeakPassword 密码不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n## - sendPasswordResetWithEmail:completion:\n\n 定义\n\n`- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion`\n\n 说明\n\n通过邮箱找回密码。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n- See WDGAuthErrors API 调用可能发生的所有错误。\n\n## - signOut:\n\n 定义\n\n`- (BOOL)signOut:(NSError *_Nullable *_Nullable)error`\n\n 说明\n\n退出登录。\n\n 参数\n\nerror 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。\n\n 返回值\n\nYES 表示退出登录成功。NO 表示失败\n\n## - addAuthStateDidChangeListener:\n\n 定义\n\n`- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener`\n\n 说明\n\n监听用户 auth 状态。发生以下条件时会被调用：\n \n - 第一次调用时，\n - 当前用户切换时，\n - 或者当前用户的 idToken 变化时。\n\n 参数\n\nlistener 状态变化时调用的 block。异步等待，会在主线程中回调。\n\n 返回值\n\n返回这个 block 的唯一标示，用于移除这个 block。\n\n 描述\n\n这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。\n\n## - removeAuthStateDidChangeListener:\n\n 定义\n\n`- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle`\n\n 说明\n\n移除 auth 状态变更监听。\n\n 参数\n\nlistenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。\n\n\n# WDGAuthCredential (*Methods*)\n\n## provider\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *provider`\n\n 说明\n\n获取凭证的 id 名。\n\n\n# WDGEmailPasswordAuthProvider (*Methods*)\n\n## + credentialWithEmail: password:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password`\n\n 说明\n\n创建一个 email & password 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\nemail 用户的 email 地址。  \npassword 用户的登录密码。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 email & password 登录方式凭证。\n\n\n# WDGQQAuthProvider (*Methods*)\n\n## + credentialWithAccessToken:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken`\n\n 说明\n\n创建一个 qq 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken QQ OAuth access token.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 qq 登录凭证。\n\n\n# WDGSinaAuthProvider (*Methods*)\n\n## + credentialWithAccessToken: userID:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID`\n\n 说明\n\n创建一个 Sina 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\naccessToken Sina OAuth access token.\nuserID Sina OAuth 的 userID。\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 Sina 登录凭证。\n\n\n# WDGWeiXinAuthProvider (*Methods*)\n\n## + credentialWithCode:\n\n 定义\n\n`+ (WDGAuthCredential *)credentialWithCode:(NSString *)code`\n\n 说明\n\n创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。\n\n 参数\n\ncode Weixin OAuth code.\n\n 返回值\n\nWDGAuthCredential 对象，里面包含 WeiXin 登录凭证。\n\n\n# WDGUser (*Methods*)\n\n## anonymous\n\n 定义\n\n`@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous`\n\n 说明\n\n如果为 YES 则表明为匿名用户。\n\n\n## emailVerified\n \n 定义\n\n`@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified`\n\n 说明\n\n如果为 YES 则表示和这个帐号关联的邮箱已经验证过。\n\n\n## providerData\n \n 定义\n\n`@property(nonatomic, readonly, nonnull) NSArray<id<WDGUserInfo>> *providerData`\n\n 说明\n\n所有登录方式的用户信息。\n\n 描述\n\n不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号\n\n\n## - updateEmail:completion:\n\n 定义\n\n`- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n更新帐号邮箱。如果更新成功，本地缓存也会刷新。\n\n 参数\n\nemail 用户的邮箱地址。  \ncompletion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。\n\n 描述\n \n如果这个邮箱已经创建过用户，则会更新失败。\n可能发生的错误：\n \n - WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。\n - WDGAuthErrorCodeInvalidEmail 邮箱格式错误。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - updatePassword:completion:\n\n 定义\n\n`- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n修改用户密码。如果成功，本地缓存也会被刷新。\n\n 参数\n  \npassword 用户设置的新密码。   \ncompletion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。\n\n 描述\n \n可能发生的错误：\n \n - WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。\n - WDGAuthErrorCodeWeakPassword 密码设置不符合规定。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n\n## profileChangeRequest\n\n 定义\n\n`- (WDGUserProfileChangeRequest *)profileChangeRequest`\n\n 说明\n\n创建一个可以改变用户信息的对象。\n\n 描述\n\n修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。\n\n 返回值\n\n返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。\n\n## - reloadWithCompletion:\n\n 定义\n\n`- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n从服务器上获取最新的用户信息。\n\n 参数\n\ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。\n \n可能发生的错误：  \n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n\n## - reauthenticateWithCredential:completion:\n\n 定义\n\n`- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n重新登录，刷新本地 idToken。\n\n 参数\n\ncredential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。\ncompletion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。\n\n 描述\n \n如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。\n可能发生的错误：\n\n- WDGAuthErrorCodeInvalidCredential 无效的凭证。\n - WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。\n - WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。\n - WDGAuthErrorCodeUserDisabled 用户帐号被禁用。\n - WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。\n - WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。\n - See WDGAuthErrors API 调用可能发生的所有错误。\n\n\n## - getTokenWithCompletion:\n\n 定义\n`- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion`\n\n 说明\n\n获取用户 token。\n\n 参数\n \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n\n - See WDGAuthErrors API 调用可能发生的所有错误。\n \n## - linkWithCredential:completion:\n\n 定义\n\n`- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。\n\n 参数\n\ncredential 一种登录方式的凭证。    \ncompletion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。\n - WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。\n - WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。\n - 这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。\n - See 更多错误请参考 WDGAuthErrors。\n\n## - unlinkFromProvider:completion:\n\n 定义\n\n`- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion`\n\n 说明\n\n解绑第三方帐号。\n\n 参数\n\nprovider 需要解绑的登录方式，可能为 qq、weixin、weibo。  \ncompletion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。\n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。\n - See 更多错误请参考 WDGAuthErrors。\n\n\n## - sendEmailVerificationWithCompletion:\n\n 定义\n\n`- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion`\n\n 说明\n\n发送邮箱验证。\n\n 参数\n\ncompletion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeUserNotFound 没有这个帐号。\n - See 更多错误请参考 WDGAuthErrors。\n \n\n## - deleteWithCompletion:\n\n 定义\n\n`- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n删除这个帐号（如果是当前用户，则退出登录）。\n\n 参数\n\ncompletion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。\n\n 描述\n\n可能发生的错误：\n \n - WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:\n - See 更多错误请参考 WDGAuthErrors。\n \n \n# WDGUserProfileChangeRequest (*Methods*)\n\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSString *displayName`\n\n 说明\n\n用户名\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n## photoURL\n\n 定义\n\n`@property(nonatomic, copy, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像\n\n 描述\n\n必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。\n\n## - commitChangesWithCompletion:\n\n 定义\n\n`- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion`\n\n 说明\n\n提交更改\n\n 参数\n\ncompletion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。\n\n 描述\n\n修改属性必须在这个方法调用之前。\n\n\n# WDGUserInfo (*protocol*)\n\n## providerID\n\n 定义\n\n`@property(nonatomic, copy, readonly) NSString *providerID`\n\n 说明\n\n用户登录方式。\n\n\n## uid\n \n 定义\n\n`@property(nonatomic, copy, readonly) NSString *uid`\n\n 说明\n\n用户 id。\n\n\n## displayName\n\n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *displayName`\n\n 说明\n\n用户名。\n\n\n## photoURL\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSURL *photoURL`\n\n 说明\n\n用户头像。\n\n\n## email\n \n 定义\n\n`@property(nonatomic, copy, readonly, nullable) NSString *email`\n\n 说明\n\n用户邮箱地址。\n\n\n# WDGAuthErrors (*Methods*)\n\n## WDGAuthErrorCode\n\n 定义\n\n```\ntypedef NS_ENUM(NSInteger, WDGAuthErrorCode) {\n\n    WDGAuthErrorCodeInvalidCustomToken = 17000,\n\n    WDGAuthErrorCodeCustomTokenMismatch = 17002,\n\n    WDGAuthErrorCodeInvalidCredential = 17004,\n\n    WDGAuthErrorCodeUserDisabled = 17005,\n\n    WDGAuthErrorCodeOperationNotAllowed = 17006,\n\n    WDGAuthErrorCodeEmailAlreadyInUse = 17007,\n\n    WDGAuthErrorCodeInvalidEmail = 17008,\n\n    WDGAuthErrorCodeWrongPassword = 17009,\n\n    WDGAuthErrorCodeTooManyRequests = 17010,\n\n    WDGAuthErrorCodeUserNotFound = 17011,\n\n    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,\n\n    WDGAuthErrorCodeRequiresRecentLogin = 17014,\n\n    WDGAuthErrorCodeProviderAlreadyLinked = 17015,\n\n    WDGAuthErrorCodeNoSuchProvider = 17016,\n\n    WDGAuthErrorCodeInvalidUserToken = 17017,\n\n    WDGAuthErrorCodeNetworkError = 17020,\n\n    WDGAuthErrorCodeUserTokenExpired = 17021,\n\n    WDGAuthErrorCodeInvalidAPIKey = 17023,\n\n    WDGAuthErrorCodeUserMismatch = 17024,\n\n    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,\n\n    WDGAuthErrorCodeWeakPassword = 17026,\n\n    WDGAuthErrorCodeAppNotAuthorized = 17028,\n    \n    WDGAuthErrorCodeKeychainError = 17995,\n\n    WDGAuthErrorCodeInternalError = 17999,\n};\n\n```\n\n\n 说明\n\nWilddog iOS 身份认证错误。\n\n 参数\n\nWDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误\n\nWDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程\n\nWDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误\n\nWDGAuthErrorCodeUserDisabled 表示用户的帐户已停用\n\nWDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用\n\nWDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用\n\nWDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确\n\nWDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录\n\nWDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试\n\nWDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误\n\nWDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接\n\nWDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于`WDGAuthErrorCodeAccountExistsWithDifferentCredential`，只是拼写错误，只存在向后兼容性\n\nWDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过\n\nWDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户\n\nWDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户\n\nWDGAuthErrorCodeInvalidUserToken 表示 token 失效，你必须提示该用户在此设备重新登录\n\nWDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误\n\nWDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期\n\nWDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效\n\nWDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户\n\nWDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联\n\nWDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱\n\nWDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时\n    \nWDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错\n\nWDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误","date":"2016-09-06T03:38:22.524Z","updated":"2016-09-06T03:38:22.524Z","path":"guide/auth/ios/api.html","comments":1,"layout":"page","_id":"cisswi9kl000xz4fwhyw3egc6","content":"<h1 id=\"WDGAuth-Methods\"><a href=\"#WDGAuth-Methods\" class=\"headerlink\" title=\"WDGAuth (Methods)\"></a>WDGAuth (<em>Methods</em>)</h1><h2 id=\"authWithApp\"><a href=\"#authWithApp\" class=\"headerlink\" title=\"+ authWithApp:\"></a>+ authWithApp:</h2><p> 定义</p>\n<p><code>+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))</code></p>\n<p> 说明</p>\n<p>以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。</p>\n<p> 参数</p>\n<p>appID 应用的 appID。</p>\n<p> 描述</p>\n<p>能确保线程安全。</p>\n<h2 id=\"currentUser\"><a href=\"#currentUser\" class=\"headerlink\" title=\"currentUser\"></a>currentUser</h2><p> 定义</p>\n<p><code>@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser</code></p>\n<p> 说明</p>\n<p>同步的获取当前缓存的用户，如果没有登录用户则为 null。</p>\n<h2 id=\"fetchProvidersForEmail-completion\"><a href=\"#fetchProvidersForEmail-completion\" class=\"headerlink\" title=\"- fetchProvidersForEmail:completion:\"></a>- fetchProvidersForEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。</p>\n<p> 参数</p>\n<p>email 用户的邮箱。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInWithEmail-password-completion\"><a href=\"#signInWithEmail-password-completion\" class=\"headerlink\" title=\"- signInWithEmail:password:completion:\"></a>- signInWithEmail:password:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以邮箱和密码的方式登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户的登录密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInWithCredential-completion\"><a href=\"#signInWithCredential-completion\" class=\"headerlink\" title=\"- signInWithCredential:completion:\"></a>- signInWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）</p>\n<p> 参数</p>\n<p>credential 第三方提供的凭证。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示账号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInAnonymouslyWithCompletion\"><a href=\"#signInAnonymouslyWithCompletion\" class=\"headerlink\" title=\"- signInAnonymouslyWithCompletion:\"></a>- signInAnonymouslyWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>匿名登录方式。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInWithCustomToken-completion\"><a href=\"#signInWithCustomToken-completion\" class=\"headerlink\" title=\"- signInWithCustomToken:completion:\"></a>- signInWithCustomToken:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以自定义 token 的方式登录。</p>\n<p> 参数</p>\n<p>token 自定义的 token。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。</li>\n<li>WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key<br>belong to different projects.</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"createUserWithEmail-password-completion\"><a href=\"#createUserWithEmail-password-completion\" class=\"headerlink\" title=\"- createUserWithEmail:password:completion:\"></a>- createUserWithEmail:password:completion:</h2><p> 定义<br><code>- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>创建一个新用户，创建成功后会自动登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户指定的密码。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"sendPasswordResetWithEmail-completion\"><a href=\"#sendPasswordResetWithEmail-completion\" class=\"headerlink\" title=\"- sendPasswordResetWithEmail:completion:\"></a>- sendPasswordResetWithEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱找回密码。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signOut\"><a href=\"#signOut\" class=\"headerlink\" title=\"- signOut:\"></a>- signOut:</h2><p> 定义</p>\n<p><code>- (BOOL)signOut:(NSError *_Nullable *_Nullable)error</code></p>\n<p> 说明</p>\n<p>退出登录。</p>\n<p> 参数</p>\n<p>error 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。</p>\n<p> 返回值</p>\n<p>YES 表示退出登录成功。NO 表示失败</p>\n<h2 id=\"addAuthStateDidChangeListener\"><a href=\"#addAuthStateDidChangeListener\" class=\"headerlink\" title=\"- addAuthStateDidChangeListener:\"></a>- addAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener</code></p>\n<p> 说明</p>\n<p>监听用户 auth 状态。发生以下条件时会被调用：</p>\n<ul>\n<li>第一次调用时，</li>\n<li>当前用户切换时，</li>\n<li><p>或者当前用户的 idToken 变化时。</p>\n<p>参数</p>\n</li>\n</ul>\n<p>listener 状态变化时调用的 block。异步等待，会在主线程中回调。</p>\n<p> 返回值</p>\n<p>返回这个 block 的唯一标示，用于移除这个 block。</p>\n<p> 描述</p>\n<p>这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。</p>\n<h2 id=\"removeAuthStateDidChangeListener\"><a href=\"#removeAuthStateDidChangeListener\" class=\"headerlink\" title=\"- removeAuthStateDidChangeListener:\"></a>- removeAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle</code></p>\n<p> 说明</p>\n<p>移除 auth 状态变更监听。</p>\n<p> 参数</p>\n<p>listenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。</p>\n<h1 id=\"WDGAuthCredential-Methods\"><a href=\"#WDGAuthCredential-Methods\" class=\"headerlink\" title=\"WDGAuthCredential (Methods)\"></a>WDGAuthCredential (<em>Methods</em>)</h1><h2 id=\"provider\"><a href=\"#provider\" class=\"headerlink\" title=\"provider\"></a>provider</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *provider</code></p>\n<p> 说明</p>\n<p>获取凭证的 id 名。</p>\n<h1 id=\"WDGEmailPasswordAuthProvider-Methods\"><a href=\"#WDGEmailPasswordAuthProvider-Methods\" class=\"headerlink\" title=\"WDGEmailPasswordAuthProvider (Methods)\"></a>WDGEmailPasswordAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithEmail-password\"><a href=\"#credentialWithEmail-password\" class=\"headerlink\" title=\"+ credentialWithEmail: password:\"></a>+ credentialWithEmail: password:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password</code></p>\n<p> 说明</p>\n<p>创建一个 email &amp; password 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>email 用户的 email 地址。<br>password 用户的登录密码。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 email &amp; password 登录方式凭证。</p>\n<h1 id=\"WDGQQAuthProvider-Methods\"><a href=\"#WDGQQAuthProvider-Methods\" class=\"headerlink\" title=\"WDGQQAuthProvider (Methods)\"></a>WDGQQAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken\"><a href=\"#credentialWithAccessToken\" class=\"headerlink\" title=\"+ credentialWithAccessToken:\"></a>+ credentialWithAccessToken:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken</code></p>\n<p> 说明</p>\n<p>创建一个 qq 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken QQ OAuth access token.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 qq 登录凭证。</p>\n<h1 id=\"WDGSinaAuthProvider-Methods\"><a href=\"#WDGSinaAuthProvider-Methods\" class=\"headerlink\" title=\"WDGSinaAuthProvider (Methods)\"></a>WDGSinaAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken-userID\"><a href=\"#credentialWithAccessToken-userID\" class=\"headerlink\" title=\"+ credentialWithAccessToken: userID:\"></a>+ credentialWithAccessToken: userID:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID</code></p>\n<p> 说明</p>\n<p>创建一个 Sina 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken Sina OAuth access token.<br>userID Sina OAuth 的 userID。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 Sina 登录凭证。</p>\n<h1 id=\"WDGWeiXinAuthProvider-Methods\"><a href=\"#WDGWeiXinAuthProvider-Methods\" class=\"headerlink\" title=\"WDGWeiXinAuthProvider (Methods)\"></a>WDGWeiXinAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithCode\"><a href=\"#credentialWithCode\" class=\"headerlink\" title=\"+ credentialWithCode:\"></a>+ credentialWithCode:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithCode:(NSString *)code</code></p>\n<p> 说明</p>\n<p>创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>code Weixin OAuth code.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 WeiXin 登录凭证。</p>\n<h1 id=\"WDGUser-Methods\"><a href=\"#WDGUser-Methods\" class=\"headerlink\" title=\"WDGUser (Methods)\"></a>WDGUser (<em>Methods</em>)</h1><h2 id=\"anonymous\"><a href=\"#anonymous\" class=\"headerlink\" title=\"anonymous\"></a>anonymous</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表明为匿名用户。</p>\n<h2 id=\"emailVerified\"><a href=\"#emailVerified\" class=\"headerlink\" title=\"emailVerified\"></a>emailVerified</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表示和这个帐号关联的邮箱已经验证过。</p>\n<h2 id=\"providerData\"><a href=\"#providerData\" class=\"headerlink\" title=\"providerData\"></a>providerData</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, nonnull) NSArray&lt;id&lt;WDGUserInfo&gt;&gt; *providerData</code></p>\n<p> 说明</p>\n<p>所有登录方式的用户信息。</p>\n<p> 描述</p>\n<p>不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号</p>\n<h2 id=\"updateEmail-completion\"><a href=\"#updateEmail-completion\" class=\"headerlink\" title=\"- updateEmail:completion:\"></a>- updateEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>更新帐号邮箱。如果更新成功，本地缓存也会刷新。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果这个邮箱已经创建过用户，则会更新失败。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。</li>\n<li>WDGAuthErrorCodeInvalidEmail 邮箱格式错误。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"updatePassword-completion\"><a href=\"#updatePassword-completion\" class=\"headerlink\" title=\"- updatePassword:completion:\"></a>- updatePassword:completion:</h2><p> 定义</p>\n<p><code>- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>修改用户密码。如果成功，本地缓存也会被刷新。</p>\n<p> 参数</p>\n<p>password 用户设置的新密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码设置不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"profileChangeRequest\"><a href=\"#profileChangeRequest\" class=\"headerlink\" title=\"profileChangeRequest\"></a>profileChangeRequest</h2><p> 定义</p>\n<p><code>- (WDGUserProfileChangeRequest *)profileChangeRequest</code></p>\n<p> 说明</p>\n<p>创建一个可以改变用户信息的对象。</p>\n<p> 描述</p>\n<p>修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。</p>\n<p> 返回值</p>\n<p>返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。</p>\n<h2 id=\"reloadWithCompletion\"><a href=\"#reloadWithCompletion\" class=\"headerlink\" title=\"- reloadWithCompletion:\"></a>- reloadWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>从服务器上获取最新的用户信息。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。</p>\n<p>可能发生的错误：  </p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"reauthenticateWithCredential-completion\"><a href=\"#reauthenticateWithCredential-completion\" class=\"headerlink\" title=\"- reauthenticateWithCredential:completion:\"></a>- reauthenticateWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>重新登录，刷新本地 idToken。</p>\n<p> 参数</p>\n<p>credential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。<br>completion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 无效的凭证。<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。</li>\n<li>WDGAuthErrorCodeUserDisabled 用户帐号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。</li>\n<li>WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"getTokenWithCompletion\"><a href=\"#getTokenWithCompletion\" class=\"headerlink\" title=\"- getTokenWithCompletion:\"></a>- getTokenWithCompletion:</h2><p> 定义<br><code>- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion</code></p>\n<p> 说明</p>\n<p>获取用户 token。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"linkWithCredential-completion\"><a href=\"#linkWithCredential-completion\" class=\"headerlink\" title=\"- linkWithCredential:completion:\"></a>- linkWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。</p>\n<p> 参数</p>\n<p>credential 一种登录方式的凭证。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。</li>\n<li>WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。</li>\n<li>这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h2 id=\"unlinkFromProvider-completion\"><a href=\"#unlinkFromProvider-completion\" class=\"headerlink\" title=\"- unlinkFromProvider:completion:\"></a>- unlinkFromProvider:completion:</h2><p> 定义</p>\n<p><code>- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>解绑第三方帐号。</p>\n<p> 参数</p>\n<p>provider 需要解绑的登录方式，可能为 qq、weixin、weibo。<br>completion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h2 id=\"sendEmailVerificationWithCompletion\"><a href=\"#sendEmailVerificationWithCompletion\" class=\"headerlink\" title=\"- sendEmailVerificationWithCompletion:\"></a>- sendEmailVerificationWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion</code></p>\n<p> 说明</p>\n<p>发送邮箱验证。</p>\n<p> 参数</p>\n<p>completion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeUserNotFound 没有这个帐号。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h2 id=\"deleteWithCompletion\"><a href=\"#deleteWithCompletion\" class=\"headerlink\" title=\"- deleteWithCompletion:\"></a>- deleteWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>删除这个帐号（如果是当前用户，则退出登录）。</p>\n<p> 参数</p>\n<p>completion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h1 id=\"WDGUserProfileChangeRequest-Methods\"><a href=\"#WDGUserProfileChangeRequest-Methods\" class=\"headerlink\" title=\"WDGUserProfileChangeRequest (Methods)\"></a>WDGUserProfileChangeRequest (<em>Methods</em>)</h1><h2 id=\"displayName\"><a href=\"#displayName\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<h2 id=\"photoURL\"><a href=\"#photoURL\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<h2 id=\"commitChangesWithCompletion\"><a href=\"#commitChangesWithCompletion\" class=\"headerlink\" title=\"- commitChangesWithCompletion:\"></a>- commitChangesWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>提交更改</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>修改属性必须在这个方法调用之前。</p>\n<h1 id=\"WDGUserInfo-protocol\"><a href=\"#WDGUserInfo-protocol\" class=\"headerlink\" title=\"WDGUserInfo (protocol)\"></a>WDGUserInfo (<em>protocol</em>)</h1><h2 id=\"providerID\"><a href=\"#providerID\" class=\"headerlink\" title=\"providerID\"></a>providerID</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *providerID</code></p>\n<p> 说明</p>\n<p>用户登录方式。</p>\n<h2 id=\"uid\"><a href=\"#uid\" class=\"headerlink\" title=\"uid\"></a>uid</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *uid</code></p>\n<p> 说明</p>\n<p>用户 id。</p>\n<h2 id=\"displayName-1\"><a href=\"#displayName-1\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名。</p>\n<h2 id=\"photoURL-1\"><a href=\"#photoURL-1\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像。</p>\n<h2 id=\"email\"><a href=\"#email\" class=\"headerlink\" title=\"email\"></a>email</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *email</code></p>\n<p> 说明</p>\n<p>用户邮箱地址。</p>\n<h1 id=\"WDGAuthErrors-Methods\"><a href=\"#WDGAuthErrors-Methods\" class=\"headerlink\" title=\"WDGAuthErrors (Methods)\"></a>WDGAuthErrors (<em>Methods</em>)</h1><h2 id=\"WDGAuthErrorCode\"><a href=\"#WDGAuthErrorCode\" class=\"headerlink\" title=\"WDGAuthErrorCode\"></a>WDGAuthErrorCode</h2><p> 定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, WDGAuthErrorCode) &#123;</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCustomToken = 17000,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCustomTokenMismatch = 17002,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCredential = 17004,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserDisabled = 17005,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeOperationNotAllowed = 17006,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeEmailAlreadyInUse = 17007,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidEmail = 17008,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWrongPassword = 17009,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeTooManyRequests = 17010,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserNotFound = 17011,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeRequiresRecentLogin = 17014,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeProviderAlreadyLinked = 17015,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNoSuchProvider = 17016,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidUserToken = 17017,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNetworkError = 17020,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserTokenExpired = 17021,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidAPIKey = 17023,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserMismatch = 17024,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWeakPassword = 17026,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAppNotAuthorized = 17028,</div><div class=\"line\">    </div><div class=\"line\">    WDGAuthErrorCodeKeychainError = 17995,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInternalError = 17999,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p> 说明</p>\n<p>Wilddog iOS 身份认证错误。</p>\n<p> 参数</p>\n<p>WDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误</p>\n<p>WDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程</p>\n<p>WDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误</p>\n<p>WDGAuthErrorCodeUserDisabled 表示用户的帐户已停用</p>\n<p>WDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用</p>\n<p>WDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用</p>\n<p>WDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确</p>\n<p>WDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录</p>\n<p>WDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试</p>\n<p>WDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误</p>\n<p>WDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接</p>\n<p>WDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于<code>WDGAuthErrorCodeAccountExistsWithDifferentCredential</code>，只是拼写错误，只存在向后兼容性</p>\n<p>WDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过</p>\n<p>WDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户</p>\n<p>WDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户</p>\n<p>WDGAuthErrorCodeInvalidUserToken 表示 token 失效，你必须提示该用户在此设备重新登录</p>\n<p>WDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误</p>\n<p>WDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期</p>\n<p>WDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效</p>\n<p>WDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户</p>\n<p>WDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联</p>\n<p>WDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱</p>\n<p>WDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时</p>\n<p>WDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错</p>\n<p>WDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误</p>\n","excerpt":"","more":"<h1 id=\"WDGAuth-Methods\"><a href=\"#WDGAuth-Methods\" class=\"headerlink\" title=\"WDGAuth (Methods)\"></a>WDGAuth (<em>Methods</em>)</h1><h2 id=\"authWithApp\"><a href=\"#authWithApp\" class=\"headerlink\" title=\"+ authWithApp:\"></a>+ authWithApp:</h2><p> 定义</p>\n<p><code>+ (nullable WDGAuth *)authWithAppID:(NSString *)appID NS_SWIFT_NAME(auth(appID:))</code></p>\n<p> 说明</p>\n<p>以 appID 来获取 auth 对象。如果之前没有创建过 auth 对象，会自动创建一个。</p>\n<p> 参数</p>\n<p>appID 应用的 appID。</p>\n<p> 描述</p>\n<p>能确保线程安全。</p>\n<h2 id=\"currentUser\"><a href=\"#currentUser\" class=\"headerlink\" title=\"currentUser\"></a>currentUser</h2><p> 定义</p>\n<p><code>@property(nonatomic, strong, readonly, nullable) WDGUser *currentUser</code></p>\n<p> 说明</p>\n<p>同步的获取当前缓存的用户，如果没有登录用户则为 null。</p>\n<h2 id=\"fetchProvidersForEmail-completion\"><a href=\"#fetchProvidersForEmail-completion\" class=\"headerlink\" title=\"- fetchProvidersForEmail:completion:\"></a>- fetchProvidersForEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)fetchProvidersForEmail:(NSString *)email\n                    completion:(nullable WDGProviderQueryCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱来获取用户的所有登录方式。登录方式可能有（password，qq，weixin，weibo，custom，anonymous）。</p>\n<p> 参数</p>\n<p>email 用户的邮箱。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail - 表示邮箱格式错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInWithEmail-password-completion\"><a href=\"#signInWithEmail-password-completion\" class=\"headerlink\" title=\"- signInWithEmail:password:completion:\"></a>- signInWithEmail:password:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithEmail:(NSString *)email\n               password:(NSString *)password\n             completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以邮箱和密码的方式登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户的登录密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示密码登录的方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示这个用户被禁止登录。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或者密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInWithCredential-completion\"><a href=\"#signInWithCredential-completion\" class=\"headerlink\" title=\"- signInWithCredential:completion:\"></a>- signInWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCredential:(WDGAuthCredential *)credential\n                  completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>使用第三方认证方式登录（e.g. 新浪微博，qq，weixin 授权后使用它们的 Access Token 和 openId 在野狗服务器上生成用户）</p>\n<p> 参数</p>\n<p>credential 第三方提供的凭证。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 表示无效的登录方式。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示这种登录方式没有打开，可以在野狗控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeUserDisabled 表示账号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 表示邮箱或着密码错误。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInAnonymouslyWithCompletion\"><a href=\"#signInAnonymouslyWithCompletion\" class=\"headerlink\" title=\"- signInAnonymouslyWithCompletion:\"></a>- signInAnonymouslyWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)signInAnonymouslyWithCompletion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>匿名登录方式。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果已经有一个匿名用户登录，那么会替换这个用户。如果已经有其他用户登录，那么会先把他退出登录。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signInWithCustomToken-completion\"><a href=\"#signInWithCustomToken-completion\" class=\"headerlink\" title=\"- signInWithCustomToken:completion:\"></a>- signInWithCustomToken:completion:</h2><p> 定义</p>\n<p><code>- (void)signInWithCustomToken:(NSString *)token\n                   completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>以自定义 token 的方式登录。</p>\n<p> 参数</p>\n<p>token 自定义的 token。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCustomToken 无效的 custom token。</li>\n<li>WDGAuthErrorCodeCustomTokenMismatch Indicates the service account and the API key<br>belong to different projects.</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"createUserWithEmail-password-completion\"><a href=\"#createUserWithEmail-password-completion\" class=\"headerlink\" title=\"- createUserWithEmail:password:completion:\"></a>- createUserWithEmail:password:completion:</h2><p> 定义<br><code>- (void)createUserWithEmail:(NSString *)email\n                   password:(NSString *)password\n                 completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>创建一个新用户，创建成功后会自动登录。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>password 用户指定的密码。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidEmail 表示邮箱格式错误。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 表示邮箱已经被注册。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 表示匿名登录方式没有打开，可以在野狗的控制面板中打开这个选项。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"sendPasswordResetWithEmail-completion\"><a href=\"#sendPasswordResetWithEmail-completion\" class=\"headerlink\" title=\"- sendPasswordResetWithEmail:completion:\"></a>- sendPasswordResetWithEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)sendPasswordResetWithEmail:(NSString *)email\n                        completion:(nullable WDGSendPasswordResetCallback)completion</code></p>\n<p> 说明</p>\n<p>通过邮箱找回密码。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"signOut\"><a href=\"#signOut\" class=\"headerlink\" title=\"- signOut:\"></a>- signOut:</h2><p> 定义</p>\n<p><code>- (BOOL)signOut:(NSError *_Nullable *_Nullable)error</code></p>\n<p> 说明</p>\n<p>退出登录。</p>\n<p> 参数</p>\n<p>error 可以为空；如果发生错误，会以 NSError 的方式返回错误描述。nil 表示成功。</p>\n<p> 返回值</p>\n<p>YES 表示退出登录成功。NO 表示失败</p>\n<h2 id=\"addAuthStateDidChangeListener\"><a href=\"#addAuthStateDidChangeListener\" class=\"headerlink\" title=\"- addAuthStateDidChangeListener:\"></a>- addAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (WDGAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerBlock)listener</code></p>\n<p> 说明</p>\n<p>监听用户 auth 状态。发生以下条件时会被调用：</p>\n<ul>\n<li>第一次调用时，</li>\n<li>当前用户切换时，</li>\n<li><p>或者当前用户的 idToken 变化时。</p>\n<p>参数</p>\n</li>\n</ul>\n<p>listener 状态变化时调用的 block。异步等待，会在主线程中回调。</p>\n<p> 返回值</p>\n<p>返回这个 block 的唯一标示，用于移除这个 block。</p>\n<p> 描述</p>\n<p>这个方法被调用时就会触发 block 的回调。之后会一直处于监听状态，并且 block 会被 WDGAuth 持有，直到移除这个监听。需要防止引用循环。</p>\n<h2 id=\"removeAuthStateDidChangeListener\"><a href=\"#removeAuthStateDidChangeListener\" class=\"headerlink\" title=\"- removeAuthStateDidChangeListener:\"></a>- removeAuthStateDidChangeListener:</h2><p> 定义</p>\n<p><code>- (void)removeAuthStateDidChangeListener:(WDGAuthStateDidChangeListenerHandle)listenerHandle</code></p>\n<p> 说明</p>\n<p>移除 auth 状态变更监听。</p>\n<p> 参数</p>\n<p>listenerHandle WDGAuth.addAuthStateDidChangeListener: 返回的句柄。</p>\n<h1 id=\"WDGAuthCredential-Methods\"><a href=\"#WDGAuthCredential-Methods\" class=\"headerlink\" title=\"WDGAuthCredential (Methods)\"></a>WDGAuthCredential (<em>Methods</em>)</h1><h2 id=\"provider\"><a href=\"#provider\" class=\"headerlink\" title=\"provider\"></a>provider</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *provider</code></p>\n<p> 说明</p>\n<p>获取凭证的 id 名。</p>\n<h1 id=\"WDGEmailPasswordAuthProvider-Methods\"><a href=\"#WDGEmailPasswordAuthProvider-Methods\" class=\"headerlink\" title=\"WDGEmailPasswordAuthProvider (Methods)\"></a>WDGEmailPasswordAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithEmail-password\"><a href=\"#credentialWithEmail-password\" class=\"headerlink\" title=\"+ credentialWithEmail: password:\"></a>+ credentialWithEmail: password:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password</code></p>\n<p> 说明</p>\n<p>创建一个 email &amp; password 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>email 用户的 email 地址。<br>password 用户的登录密码。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 email &amp; password 登录方式凭证。</p>\n<h1 id=\"WDGQQAuthProvider-Methods\"><a href=\"#WDGQQAuthProvider-Methods\" class=\"headerlink\" title=\"WDGQQAuthProvider (Methods)\"></a>WDGQQAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken\"><a href=\"#credentialWithAccessToken\" class=\"headerlink\" title=\"+ credentialWithAccessToken:\"></a>+ credentialWithAccessToken:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken</code></p>\n<p> 说明</p>\n<p>创建一个 qq 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken QQ OAuth access token.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 qq 登录凭证。</p>\n<h1 id=\"WDGSinaAuthProvider-Methods\"><a href=\"#WDGSinaAuthProvider-Methods\" class=\"headerlink\" title=\"WDGSinaAuthProvider (Methods)\"></a>WDGSinaAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithAccessToken-userID\"><a href=\"#credentialWithAccessToken-userID\" class=\"headerlink\" title=\"+ credentialWithAccessToken: userID:\"></a>+ credentialWithAccessToken: userID:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithAccessToken:(NSString *)accessToken userID:(NSString *)userID</code></p>\n<p> 说明</p>\n<p>创建一个 Sina 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>accessToken Sina OAuth access token.<br>userID Sina OAuth 的 userID。</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 Sina 登录凭证。</p>\n<h1 id=\"WDGWeiXinAuthProvider-Methods\"><a href=\"#WDGWeiXinAuthProvider-Methods\" class=\"headerlink\" title=\"WDGWeiXinAuthProvider (Methods)\"></a>WDGWeiXinAuthProvider (<em>Methods</em>)</h1><h2 id=\"credentialWithCode\"><a href=\"#credentialWithCode\" class=\"headerlink\" title=\"+ credentialWithCode:\"></a>+ credentialWithCode:</h2><p> 定义</p>\n<p><code>+ (WDGAuthCredential *)credentialWithCode:(NSString *)code</code></p>\n<p> 说明</p>\n<p>创建一个 Weixin 登录方式的 WDGAuthCredential 凭证。</p>\n<p> 参数</p>\n<p>code Weixin OAuth code.</p>\n<p> 返回值</p>\n<p>WDGAuthCredential 对象，里面包含 WeiXin 登录凭证。</p>\n<h1 id=\"WDGUser-Methods\"><a href=\"#WDGUser-Methods\" class=\"headerlink\" title=\"WDGUser (Methods)\"></a>WDGUser (<em>Methods</em>)</h1><h2 id=\"anonymous\"><a href=\"#anonymous\" class=\"headerlink\" title=\"anonymous\"></a>anonymous</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isAnonymous) BOOL anonymous</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表明为匿名用户。</p>\n<h2 id=\"emailVerified\"><a href=\"#emailVerified\" class=\"headerlink\" title=\"emailVerified\"></a>emailVerified</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, getter=isEmailVerified) BOOL emailVerified</code></p>\n<p> 说明</p>\n<p>如果为 YES 则表示和这个帐号关联的邮箱已经验证过。</p>\n<h2 id=\"providerData\"><a href=\"#providerData\" class=\"headerlink\" title=\"providerData\"></a>providerData</h2><p> 定义</p>\n<p><code>@property(nonatomic, readonly, nonnull) NSArray&lt;id&lt;WDGUserInfo&gt;&gt; *providerData</code></p>\n<p> 说明</p>\n<p>所有登录方式的用户信息。</p>\n<p> 描述</p>\n<p>不同登录方式之间可以相互绑定，绑定之后可以以任意一种登录方式登录主帐号</p>\n<h2 id=\"updateEmail-completion\"><a href=\"#updateEmail-completion\" class=\"headerlink\" title=\"- updateEmail:completion:\"></a>- updateEmail:completion:</h2><p> 定义</p>\n<p><code>- (void)updateEmail:(NSString *)email completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>更新帐号邮箱。如果更新成功，本地缓存也会刷新。</p>\n<p> 参数</p>\n<p>email 用户的邮箱地址。<br>completion 可以为空；返回用户的登录方式列表或者错误信息。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果这个邮箱已经创建过用户，则会更新失败。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 邮箱已被另一个用户使用。</li>\n<li>WDGAuthErrorCodeInvalidEmail 邮箱格式错误。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改邮箱为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"updatePassword-completion\"><a href=\"#updatePassword-completion\" class=\"headerlink\" title=\"- updatePassword:completion:\"></a>- updatePassword:completion:</h2><p> 定义</p>\n<p><code>- (void)updatePassword:(NSString *)password\n            completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>修改用户密码。如果成功，本地缓存也会被刷新。</p>\n<p> 参数</p>\n<p>password 用户设置的新密码。<br>completion 可以为空；当用户登录成功或者发生错误时触发。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 表明管理员关闭了这种登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 发生这个错误表明用户在短期内没有登录过，而修改密码为敏感操作，必须重新登录才能继续操作。可以调用 WDGUser.reauthenticateWithCredential:completion: 方法。</li>\n<li>WDGAuthErrorCodeWeakPassword 密码设置不符合规定。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"profileChangeRequest\"><a href=\"#profileChangeRequest\" class=\"headerlink\" title=\"profileChangeRequest\"></a>profileChangeRequest</h2><p> 定义</p>\n<p><code>- (WDGUserProfileChangeRequest *)profileChangeRequest</code></p>\n<p> 说明</p>\n<p>创建一个可以改变用户信息的对象。</p>\n<p> 描述</p>\n<p>修改完这个返回对象的属性，然后调用 WDGUserProfileChangeRequest.commitChangesWithCallback: 来完成用户信息的修改。</p>\n<p> 返回值</p>\n<p>返回一个可以用来原子性的修改用户信息的对象。也就是说不会单独某个属性修改成功，而其它的修改失败。</p>\n<h2 id=\"reloadWithCompletion\"><a href=\"#reloadWithCompletion\" class=\"headerlink\" title=\"- reloadWithCompletion:\"></a>- reloadWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)reloadWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>从服务器上获取最新的用户信息。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能返回 WDGAuthErrorCodeCredentialTooOld 错误。这种情况下，需要调用 WDGUser.reauthenticateWithCredential:completion: 重新登录。</p>\n<p>可能发生的错误：  </p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"reauthenticateWithCredential-completion\"><a href=\"#reauthenticateWithCredential-completion\" class=\"headerlink\" title=\"- reauthenticateWithCredential:completion:\"></a>- reauthenticateWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)reauthenticateWithCredential:(WDGAuthCredential *)credential\n                          completion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>重新登录，刷新本地 idToken。</p>\n<p> 参数</p>\n<p>credential 用户提供的登录凭证，服务将会认证他的正确性。这个凭证可以是第三方登录，或者密码登录方式。<br>completion 可以为空；重新登录成功时会被调用这个 block，block 为异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>如果用户提供的凭证和之前的不一样或者提供的凭证是错误的。则返回错误信息。当前用户继续保持登录状态。<br>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeInvalidCredential 无效的凭证。<ul>\n<li>WDGAuthErrorCodeOperationNotAllowed 这种登录方式被禁止，可以在野狗应用控制面板打开这个选项。</li>\n<li>WDGAuthErrorCodeEmailAlreadyInUse 提供的 Email 地址已经被使用。</li>\n<li>WDGAuthErrorCodeUserDisabled 用户帐号被禁用。</li>\n<li>WDGAuthErrorCodeWrongPassword 邮箱或者密码错误。</li>\n<li>WDGAuthErrorCodeUserMismatch 重现登录提供的凭证与当前用户不一致。</li>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"getTokenWithCompletion\"><a href=\"#getTokenWithCompletion\" class=\"headerlink\" title=\"- getTokenWithCompletion:\"></a>- getTokenWithCompletion:</h2><p> 定义<br><code>- (void)getTokenWithCompletion:(nullable WDGAuthTokenCallback)completion</code></p>\n<p> 说明</p>\n<p>获取用户 token。</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>See WDGAuthErrors API 调用可能发生的所有错误。</li>\n</ul>\n<h2 id=\"linkWithCredential-completion\"><a href=\"#linkWithCredential-completion\" class=\"headerlink\" title=\"- linkWithCredential:completion:\"></a>- linkWithCredential:completion:</h2><p> 定义</p>\n<p><code>- (void)linkWithCredential:(WDGAuthCredential *)credential\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>将第三方帐号绑定到当前用户上。以实现通过不同的登录方式登录。</p>\n<p> 参数</p>\n<p>credential 一种登录方式的凭证。<br>completion 可以为空；请求成功会触发的 block。异步等待，会在主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeProviderAlreadyLinked 提供的登录方式已经绑定在这个帐号中。</li>\n<li>WDGAuthErrorCodeCredentialAlreadyInUse 提供的登录方式凭证已经是一个用户。</li>\n<li>WDGAuthErrorCodeOperationNotAllowed 提供的登录方式被禁用。可以在野狗控制面板中打开。</li>\n<li>这个方法也有可能返回 updateEmail:completion: 和 updatePassword:completion: 的错误。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h2 id=\"unlinkFromProvider-completion\"><a href=\"#unlinkFromProvider-completion\" class=\"headerlink\" title=\"- unlinkFromProvider:completion:\"></a>- unlinkFromProvider:completion:</h2><p> 定义</p>\n<p><code>- (void)unlinkFromProvider:(NSString *)provider\n                completion:(nullable WDGAuthResultCallback)completion</code></p>\n<p> 说明</p>\n<p>解绑第三方帐号。</p>\n<p> 参数</p>\n<p>provider 需要解绑的登录方式，可能为 qq、weixin、weibo。<br>completion 可以为空；请求成功后会被调用的 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeNoSuchProvider 此帐号没有绑定需要解绑的登录方式。</li>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录帐号来保证安全性。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h2 id=\"sendEmailVerificationWithCompletion\"><a href=\"#sendEmailVerificationWithCompletion\" class=\"headerlink\" title=\"- sendEmailVerificationWithCompletion:\"></a>- sendEmailVerificationWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)sendEmailVerificationWithCompletion:(nullable WDGSendEmailVerificationCallback)completion</code></p>\n<p> 说明</p>\n<p>发送邮箱验证。</p>\n<p> 参数</p>\n<p>completion 可以为空；当请求成功或失败时会调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeUserNotFound 没有这个帐号。</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h2 id=\"deleteWithCompletion\"><a href=\"#deleteWithCompletion\" class=\"headerlink\" title=\"- deleteWithCompletion:\"></a>- deleteWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)deleteWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>删除这个帐号（如果是当前用户，则退出登录）。</p>\n<p> 参数</p>\n<p>completion 可以为空；删除帐号成功或失败时调用这个 block，异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>可能发生的错误：</p>\n<ul>\n<li>WDGAuthErrorCodeRequiresRecentLogin 敏感操作，需要重新登录来确保安全性。可以调用 WDGUser.reauthenticateWithCredential:completion:</li>\n<li>See 更多错误请参考 WDGAuthErrors。</li>\n</ul>\n<h1 id=\"WDGUserProfileChangeRequest-Methods\"><a href=\"#WDGUserProfileChangeRequest-Methods\" class=\"headerlink\" title=\"WDGUserProfileChangeRequest (Methods)\"></a>WDGUserProfileChangeRequest (<em>Methods</em>)</h1><h2 id=\"displayName\"><a href=\"#displayName\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<h2 id=\"photoURL\"><a href=\"#photoURL\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像</p>\n<p> 描述</p>\n<p>必须在使用  WDGUserProfileChangeRequest.commitChangesWithCallback: 方法前设置这个参数。</p>\n<h2 id=\"commitChangesWithCompletion\"><a href=\"#commitChangesWithCompletion\" class=\"headerlink\" title=\"- commitChangesWithCompletion:\"></a>- commitChangesWithCompletion:</h2><p> 定义</p>\n<p><code>- (void)commitChangesWithCompletion:(nullable WDGUserProfileChangeCallback)completion</code></p>\n<p> 说明</p>\n<p>提交更改</p>\n<p> 参数</p>\n<p>completion 可以为空；请求成功或失败时调用这个 block。异步等待，主线程中回调。</p>\n<p> 描述</p>\n<p>修改属性必须在这个方法调用之前。</p>\n<h1 id=\"WDGUserInfo-protocol\"><a href=\"#WDGUserInfo-protocol\" class=\"headerlink\" title=\"WDGUserInfo (protocol)\"></a>WDGUserInfo (<em>protocol</em>)</h1><h2 id=\"providerID\"><a href=\"#providerID\" class=\"headerlink\" title=\"providerID\"></a>providerID</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *providerID</code></p>\n<p> 说明</p>\n<p>用户登录方式。</p>\n<h2 id=\"uid\"><a href=\"#uid\" class=\"headerlink\" title=\"uid\"></a>uid</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly) NSString *uid</code></p>\n<p> 说明</p>\n<p>用户 id。</p>\n<h2 id=\"displayName-1\"><a href=\"#displayName-1\" class=\"headerlink\" title=\"displayName\"></a>displayName</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *displayName</code></p>\n<p> 说明</p>\n<p>用户名。</p>\n<h2 id=\"photoURL-1\"><a href=\"#photoURL-1\" class=\"headerlink\" title=\"photoURL\"></a>photoURL</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSURL *photoURL</code></p>\n<p> 说明</p>\n<p>用户头像。</p>\n<h2 id=\"email\"><a href=\"#email\" class=\"headerlink\" title=\"email\"></a>email</h2><p> 定义</p>\n<p><code>@property(nonatomic, copy, readonly, nullable) NSString *email</code></p>\n<p> 说明</p>\n<p>用户邮箱地址。</p>\n<h1 id=\"WDGAuthErrors-Methods\"><a href=\"#WDGAuthErrors-Methods\" class=\"headerlink\" title=\"WDGAuthErrors (Methods)\"></a>WDGAuthErrors (<em>Methods</em>)</h1><h2 id=\"WDGAuthErrorCode\"><a href=\"#WDGAuthErrorCode\" class=\"headerlink\" title=\"WDGAuthErrorCode\"></a>WDGAuthErrorCode</h2><p> 定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, WDGAuthErrorCode) &#123;</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCustomToken = 17000,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCustomTokenMismatch = 17002,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidCredential = 17004,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserDisabled = 17005,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeOperationNotAllowed = 17006,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeEmailAlreadyInUse = 17007,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidEmail = 17008,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWrongPassword = 17009,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeTooManyRequests = 17010,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserNotFound = 17011,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrrorCodeAccountExistsWithDifferentCredential = 17012,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeRequiresRecentLogin = 17014,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeProviderAlreadyLinked = 17015,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNoSuchProvider = 17016,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidUserToken = 17017,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeNetworkError = 17020,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserTokenExpired = 17021,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInvalidAPIKey = 17023,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeUserMismatch = 17024,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeCredentialAlreadyInUse = 17025,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeWeakPassword = 17026,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeAppNotAuthorized = 17028,</div><div class=\"line\">    </div><div class=\"line\">    WDGAuthErrorCodeKeychainError = 17995,</div><div class=\"line\"></div><div class=\"line\">    WDGAuthErrorCodeInternalError = 17999,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p> 说明</p>\n<p>Wilddog iOS 身份认证错误。</p>\n<p> 参数</p>\n<p>WDGAuthErrorCodeInvalidCustomToken 表示自定义令牌认证错误</p>\n<p>WDGAuthErrorCodeCustomTokenMismatch 表明服务账号和 API key 属于不同的工程</p>\n<p>WDGAuthErrorCodeInvalidCredential 如果凭据到期或格式不正确，则可能发生此错误</p>\n<p>WDGAuthErrorCodeUserDisabled 表示用户的帐户已停用</p>\n<p>WDGAuthErrorCodeOperationNotAllowed 表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用</p>\n<p>WDGAuthErrorCodeEmailAlreadyInUse 表示用户的邮箱已经被占用</p>\n<p>WDGAuthErrorCodeInvalidEmail 表示该电子邮件地址格式不正确</p>\n<p>WDGAuthErrorCodeWrongPassword 表示用户用了错误密码登录</p>\n<p>WDGAuthErrorCodeTooManyRequests 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止，请在稍后重试</p>\n<p>WDGAuthErrorCodeUserNotFound 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误</p>\n<p>WDGAuthErrorCodeAccountExistsWithDifferentCredential 表示需要帐户链接</p>\n<p>WDGAuthErrrorCodeAccountExistsWithDifferentCredential 类似于<code>WDGAuthErrorCodeAccountExistsWithDifferentCredential</code>，只是拼写错误，只存在向后兼容性</p>\n<p>WDGAuthErrorCodeRequiresRecentLogin 此错误表示该用户近期长时间没有登录过</p>\n<p>WDGAuthErrorCodeProviderAlreadyLinked 表示尝试关联的登录方式的类型已经关联到此帐户</p>\n<p>WDGAuthErrorCodeNoSuchProvider 表示尝试取消关联的提供程序没有关联到该帐户</p>\n<p>WDGAuthErrorCodeInvalidUserToken 表示 token 失效，你必须提示该用户在此设备重新登录</p>\n<p>WDGAuthErrorCodeNetworkError 表示在操作过程中出现网络错误</p>\n<p>WDGAuthErrorCodeUserTokenExpired 表示当前用户的令牌已到期</p>\n<p>WDGAuthErrorCodeInvalidAPIKey 表示在请求中需要提供 API key 的无效</p>\n<p>WDGAuthErrorCodeUserMismatch 表示重新认证的这个用户不是现有用户</p>\n<p>WDGAuthErrorCodeCredentialAlreadyInUse 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联</p>\n<p>WDGAuthErrorCodeWeakPassword 表示尝试设置的密码被认为太弱</p>\n<p>WDGAuthErrorCodeAppNotAuthorized 表示应用程序用提供的 API 密钥去认证时</p>\n<p>WDGAuthErrorCodeKeychainError 表示在访问钥匙串时出错</p>\n<p>WDGAuthErrorCodeInternalError 表示出现内部错误。 请用整个 NSError 对象报告错误</p>\n"},{"title":"自定义身份认证","_content":"\n你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。\n\n## 开始前的准备工作\n1. [创建野狗应用](https://www.wilddog.com/dashboard/)。\n2. 将下面 pod 加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n3. 使用野狗超级密钥生成 Custom Token (在“控制面板 - 身份认证 - 登录方式 - 登录方式设置”生成)。\n\n## Wilddog 身份认证\n\n1、 引入 WilddogAuth 模块：\n \nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 初始化 WDGAuth 对象：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。\n4、 从服务器收到 Custom Token 后，传到 `signInWithCustomToken:` 方法中进行登录：\n\nObjective-C\n```objectivec\n[auth signInWithCustomToken:customToken\n                 completion:^(WDGUser *_Nullable user, NSError *_Nullable error) {\n                        // ...\n                 }];\n```\nSwift\n```swift\nauth?.signInWithCustomToken(customToken) { (user, error) in\n  // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","source":"guide/auth/ios/custom.md","raw":"title: 自定义身份认证\n---\n\n你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。\n\n## 开始前的准备工作\n1. [创建野狗应用](https://www.wilddog.com/dashboard/)。\n2. 将下面 pod 加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n3. 使用野狗超级密钥生成 Custom Token (在“控制面板 - 身份认证 - 登录方式 - 登录方式设置”生成)。\n\n## Wilddog 身份认证\n\n1、 引入 WilddogAuth 模块：\n \nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 初始化 WDGAuth 对象：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。\n4、 从服务器收到 Custom Token 后，传到 `signInWithCustomToken:` 方法中进行登录：\n\nObjective-C\n```objectivec\n[auth signInWithCustomToken:customToken\n                 completion:^(WDGUser *_Nullable user, NSError *_Nullable error) {\n                        // ...\n                 }];\n```\nSwift\n```swift\nauth?.signInWithCustomToken(customToken) { (user, error) in\n  // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","date":"2016-09-06T03:38:22.524Z","updated":"2016-09-06T03:38:22.524Z","path":"guide/auth/ios/custom.html","comments":1,"layout":"page","_id":"cisswi9kl000yz4fwzla45d6e","content":"<p>你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><a href=\"https://www.wilddog.com/dashboard/\" target=\"_blank\" rel=\"external\">创建野狗应用</a>。</li>\n<li><p>将下面 pod 加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用野狗超级密钥生成 Custom Token (在“控制面板 - 身份认证 - 登录方式 - 登录方式设置”生成)。</p>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 引入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 初始化 WDGAuth 对象：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。<br>4、 从服务器收到 Custom Token 后，传到 <code>signInWithCustomToken:</code> 方法中进行登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCustomToken:customToken</div><div class=\"line\">                 completion:^(WDGUser *_Nullable user, <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">                        <span class=\"comment\">// ...</span></div><div class=\"line\">                 &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCustomToken(customToken) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n","excerpt":"","more":"<p>你可以通过自定义身份认证系统来集成你的已有帐号系统，当用户登录到你的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><a href=\"https://www.wilddog.com/dashboard/\">创建野狗应用</a>。</li>\n<li><p>将下面 pod 加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用野狗超级密钥生成 Custom Token (在“控制面板 - 身份认证 - 登录方式 - 登录方式设置”生成)。</p>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 引入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 初始化 WDGAuth 对象：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 当用户登录你的应用时，发送他们的凭据（比如邮箱密码的方式）到你的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。<br>4、 从服务器收到 Custom Token 后，传到 <code>signInWithCustomToken:</code> 方法中进行登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCustomToken:customToken</div><div class=\"line\">                 completion:^(WDGUser *_Nullable user, <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">                        <span class=\"comment\">// ...</span></div><div class=\"line\">                 &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCustomToken(customToken) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n"},{"title":"微信登录","_content":"\n通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1.将 `WilddogAuth` 添加至你的 Android 项目。\n\n2.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n4.在[微信开放平台](https://open.weixin.qq.com/)管理中心，获取应用的 App ID 和 App Secret。\n\n5.在野狗应用控制面板中打开微信登录方式:\n\n  *  在野狗控制面板中选择 ”身份认证“->登录方式。\n  *  点击微信登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。\n\n## Wilddog 身份认证\n\n1.参考 [微信 `Android` 接入指南](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=1417751808&token=&lang=zh_CN) 将微信登录集成到你的应用中。\n\n2.在微信的`WXEntryActivity`的 `onResp` 方法中获取微信和accessToken和openId\n\n```java\npublic void onResp(BaseResp baseResp) {\n   \n    switch (baseResp.errCode){\n        case BaseResp.ErrCode.ERR_OK:\n            //成功\n            if(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()){\n                //成功分享到微信\n                AlertMessageUtil.showShortToast(\"分享成功\");\n                AlertMessageUtil.dismissprogressbar();\n            }else {\n                //授权成功，获取token值\n           \n                String code = ((SendAuth.Resp) baseResp).code;\n                // 进行WilddogAuth操作\n               }\n            break;\n        case BaseResp.ErrCode.ERR_AUTH_DENIED:\n            //拒绝\n            if(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()){\n                //取消分享到微信\n                AlertMessageUtil.showShortToast(\"用户拒绝分享到微信\");\n                AlertMessageUtil.dismissprogressbar();\n            }else {\n                //用户拒绝授权\n                AlertMessageUtil.showShortToast(\"用户拒绝授权\");\n            }\n\n            break;\n        case BaseResp.ErrCode.ERR_USER_CANCEL:\n            if (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) {\n              AlertMessageUtil.showShortToast(\"取消分享到微信\");\n                AlertMessageUtil.dismissprogressbar();\n            }else {\n                AlertMessageUtil.showShortToast(\"取消授权\");\n            }\n\n            break;\n        default:\n            if (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) {\n              AlertMessageUtil.showShortToast(\"分享到微信出现未知错误\");\n       \n            }\n            break;\n    }\n}\n```\n\n3.微信授权登录成功后，获取微信 accessToken 和openId来生成 Wilddog 凭据：\n\n```java\nAuthCredential weixinAuthCredential= WeixinAuthProvider.getCredential(code);\n```\n\n4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\n```java\nmauth.signInWithCredential(weixinAuthCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n        processResult(var1);\n    }\n});\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","source":"guide/auth/android/weixin.md","raw":"title: 微信登录\n---\n\n通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1.将 `WilddogAuth` 添加至你的 Android 项目。\n\n2.将 `WilddogAuth` 的依赖项添加至你的应用级 build.gradle 文件：\n    \n    compile 'com.wilddog.client:wilddog-auth-android:2.0.0'\n3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。\n\n4.在[微信开放平台](https://open.weixin.qq.com/)管理中心，获取应用的 App ID 和 App Secret。\n\n5.在野狗应用控制面板中打开微信登录方式:\n\n  *  在野狗控制面板中选择 ”身份认证“->登录方式。\n  *  点击微信登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。\n\n## Wilddog 身份认证\n\n1.参考 [微信 `Android` 接入指南](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=1417751808&token=&lang=zh_CN) 将微信登录集成到你的应用中。\n\n2.在微信的`WXEntryActivity`的 `onResp` 方法中获取微信和accessToken和openId\n\n```java\npublic void onResp(BaseResp baseResp) {\n   \n    switch (baseResp.errCode){\n        case BaseResp.ErrCode.ERR_OK:\n            //成功\n            if(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()){\n                //成功分享到微信\n                AlertMessageUtil.showShortToast(\"分享成功\");\n                AlertMessageUtil.dismissprogressbar();\n            }else {\n                //授权成功，获取token值\n           \n                String code = ((SendAuth.Resp) baseResp).code;\n                // 进行WilddogAuth操作\n               }\n            break;\n        case BaseResp.ErrCode.ERR_AUTH_DENIED:\n            //拒绝\n            if(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()){\n                //取消分享到微信\n                AlertMessageUtil.showShortToast(\"用户拒绝分享到微信\");\n                AlertMessageUtil.dismissprogressbar();\n            }else {\n                //用户拒绝授权\n                AlertMessageUtil.showShortToast(\"用户拒绝授权\");\n            }\n\n            break;\n        case BaseResp.ErrCode.ERR_USER_CANCEL:\n            if (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) {\n              AlertMessageUtil.showShortToast(\"取消分享到微信\");\n                AlertMessageUtil.dismissprogressbar();\n            }else {\n                AlertMessageUtil.showShortToast(\"取消授权\");\n            }\n\n            break;\n        default:\n            if (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) {\n              AlertMessageUtil.showShortToast(\"分享到微信出现未知错误\");\n       \n            }\n            break;\n    }\n}\n```\n\n3.微信授权登录成功后，获取微信 accessToken 和openId来生成 Wilddog 凭据：\n\n```java\nAuthCredential weixinAuthCredential= WeixinAuthProvider.getCredential(code);\n```\n\n4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\n```java\nmauth.signInWithCredential(weixinAuthCredential).addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(Task<AuthResult> var1) {\n        processResult(var1);\n    }\n});\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n在您的应用中，您可以通过 `WilddogAuth.getCurrentUser()` 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n调用 signOut: 退出登录：\n\n```java\nmauth.SignOut();\n```\n\n可能发生的错误，请参考 处理错误。","date":"2016-09-06T03:38:22.522Z","updated":"2016-09-06T03:38:22.522Z","path":"guide/auth/android/weixin.html","comments":1,"layout":"page","_id":"cisswi9kl000zz4fwlrrnpmwp","content":"<p>通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 添加至你的 Android 项目。</p>\n<p>2.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>4.在<a href=\"https://open.weixin.qq.com/\" target=\"_blank\" rel=\"external\">微信开放平台</a>管理中心，获取应用的 App ID 和 App Secret。</p>\n<p>5.在野狗应用控制面板中打开微信登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微信登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。</li>\n</ul>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1.参考 <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417751808&amp;token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"external\">微信 <code>Android</code> 接入指南</a> 将微信登录集成到你的应用中。</p>\n<p>2.在微信的<code>WXEntryActivity</code>的 <code>onResp</code> 方法中获取微信和accessToken和openId</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResp</span><span class=\"params\">(BaseResp baseResp)</span> </span>&#123;</div><div class=\"line\">   </div><div class=\"line\">    <span class=\"keyword\">switch</span> (baseResp.errCode)&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseResp.ErrCode.ERR_OK:</div><div class=\"line\">            <span class=\"comment\">//成功</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType())&#123;</div><div class=\"line\">                <span class=\"comment\">//成功分享到微信</span></div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"分享成功\"</span>);</div><div class=\"line\">                AlertMessageUtil.dismissprogressbar();</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//授权成功，获取token值</span></div><div class=\"line\">           </div><div class=\"line\">                String code = ((SendAuth.Resp) baseResp).code;</div><div class=\"line\">                <span class=\"comment\">// 进行WilddogAuth操作</span></div><div class=\"line\">               &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseResp.ErrCode.ERR_AUTH_DENIED:</div><div class=\"line\">            <span class=\"comment\">//拒绝</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType())&#123;</div><div class=\"line\">                <span class=\"comment\">//取消分享到微信</span></div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"用户拒绝分享到微信\"</span>);</div><div class=\"line\">                AlertMessageUtil.dismissprogressbar();</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//用户拒绝授权</span></div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"用户拒绝授权\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseResp.ErrCode.ERR_USER_CANCEL:</div><div class=\"line\">            <span class=\"keyword\">if</span> (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) &#123;</div><div class=\"line\">              AlertMessageUtil.showShortToast(<span class=\"string\">\"取消分享到微信\"</span>);</div><div class=\"line\">                AlertMessageUtil.dismissprogressbar();</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"取消授权\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">if</span> (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) &#123;</div><div class=\"line\">              AlertMessageUtil.showShortToast(<span class=\"string\">\"分享到微信出现未知错误\"</span>);</div><div class=\"line\">       </div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3.微信授权登录成功后，获取微信 accessToken 和openId来生成 Wilddog 凭据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weixinAuthCredential= WeixinAuthProvider.getCredential(code);</div></pre></td></tr></table></figure>\n<p>4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCredential(weixinAuthCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">        processResult(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n","excerpt":"","more":"<p>通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>1.将 <code>WilddogAuth</code> 添加至你的 Android 项目。</p>\n<p>2.将 <code>WilddogAuth</code> 的依赖项添加至你的应用级 build.gradle 文件：</p>\n<pre><code>compile &apos;com.wilddog.client:wilddog-auth-android:2.0.0&apos;\n</code></pre><p>3.如果你还没有创建Wilddog应用，请到官网控制面板去创建应用。</p>\n<p>4.在<a href=\"https://open.weixin.qq.com/\">微信开放平台</a>管理中心，获取应用的 App ID 和 App Secret。</p>\n<p>5.在野狗应用控制面板中打开微信登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微信登录开关，点击配置，输入 微信帐号 APP ID 和 App Secret。</li>\n</ul>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1.参考 <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417751808&amp;token=&amp;lang=zh_CN\">微信 <code>Android</code> 接入指南</a> 将微信登录集成到你的应用中。</p>\n<p>2.在微信的<code>WXEntryActivity</code>的 <code>onResp</code> 方法中获取微信和accessToken和openId</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResp</span><span class=\"params\">(BaseResp baseResp)</span> </span>&#123;</div><div class=\"line\">   </div><div class=\"line\">    <span class=\"keyword\">switch</span> (baseResp.errCode)&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseResp.ErrCode.ERR_OK:</div><div class=\"line\">            <span class=\"comment\">//成功</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType())&#123;</div><div class=\"line\">                <span class=\"comment\">//成功分享到微信</span></div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"分享成功\"</span>);</div><div class=\"line\">                AlertMessageUtil.dismissprogressbar();</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//授权成功，获取token值</span></div><div class=\"line\">           </div><div class=\"line\">                String code = ((SendAuth.Resp) baseResp).code;</div><div class=\"line\">                <span class=\"comment\">// 进行WilddogAuth操作</span></div><div class=\"line\">               &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseResp.ErrCode.ERR_AUTH_DENIED:</div><div class=\"line\">            <span class=\"comment\">//拒绝</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType())&#123;</div><div class=\"line\">                <span class=\"comment\">//取消分享到微信</span></div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"用户拒绝分享到微信\"</span>);</div><div class=\"line\">                AlertMessageUtil.dismissprogressbar();</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//用户拒绝授权</span></div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"用户拒绝授权\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseResp.ErrCode.ERR_USER_CANCEL:</div><div class=\"line\">            <span class=\"keyword\">if</span> (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) &#123;</div><div class=\"line\">              AlertMessageUtil.showShortToast(<span class=\"string\">\"取消分享到微信\"</span>);</div><div class=\"line\">                AlertMessageUtil.dismissprogressbar();</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                AlertMessageUtil.showShortToast(<span class=\"string\">\"取消授权\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">if</span> (ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX == baseResp.getType()) &#123;</div><div class=\"line\">              AlertMessageUtil.showShortToast(<span class=\"string\">\"分享到微信出现未知错误\"</span>);</div><div class=\"line\">       </div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3.微信授权登录成功后，获取微信 accessToken 和openId来生成 Wilddog 凭据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">AuthCredential weixinAuthCredential= WeixinAuthProvider.getCredential(code);</div></pre></td></tr></table></figure>\n<p>4.最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.signInWithCredential(weixinAuthCredential).addOnCompleteListener(<span class=\"keyword\">new</span> OnCompleteListener&lt;AuthResult&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(Task&lt;AuthResult&gt; var1)</span> </span>&#123;</div><div class=\"line\">        processResult(var1);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<p>在您的应用中，您可以通过 <code>WilddogAuth.getCurrentUser()</code> 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n<p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。<br>调用 signOut: 退出登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mauth.SignOut();</div></pre></td></tr></table></figure>\n<p>可能发生的错误，请参考 处理错误。</p>\n"},{"title":"处理身份认证错误","_content":"如果在 WilddogAuth 的回调方法中收到一个非空 `NSError` 参数，则表示出现了错误。 要想实现正确的错误逻辑处理，请对照常见错误和下面所列的方法特定错误检查错误代码。\n\n有些错误可通过特定用户操作解决。例如，`WDGAuthErrorCodeUserTokenExpired` 可通过重新登录该用户解决，`WDGAuthErrorCodeWrongPassword` 可通过让用户提供正确密码解决。\n\n除 `WDGAuthErrorCodeNetworkError` 或 `WDGAuthErrorCodeTooManyRequests` 之外，用相同参数重试一个失败的操作决不会成功。切勿对操作在服务器端是否生效进行任何假设。\n\n调试或打印错误时，请查阅 userInfo 字典。WDGAuthErrorNameKey 包含可用于识别错误的跨平台错误名字符串。NSLocalizedDescriptionKey 包含错误说明。此说明只适合开发者使用，不适合用户使用。NSUnderlyingErrorKey 包含引起所述错误的基础错误（如果存在基础错误）。\n\n除了上面所列的主要字段外，userInfo 字典中可能还提供了一些你在诊断错误时可能觉得有用的其他字段。\n\n## 所有 API 方法通用的错误代码\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeNetworkError | 表示在操作过程中出现网络错误。\nWDGAuthErrorCodeUserNotFound | 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误。\nWDGAuthErrorCodeUserTokenExpired | 表示当前用户的令牌已到期。例如，该用户可能在另一台设备上更改了帐户密码。 你必须提示该用户在此设备上重新登录。\nWDGAuthErrorCodeTooManyRequests | 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止。 请在稍后重试。\nWDGAuthErrorCodeInternalError | 表示出现内部错误。 请用整个 NSError 对象报告错误。\n\n## 方法特定错误代码\n\n#### WDGAuth 操作常见错误\n\n##### fetchProvidersForEmail:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeInvalidEmail | 表示电子邮件地址格式不正确。    \n\n##### signInWithEmail:password:completion:\n\n代码 | 含义\t\n--- | ---\nWDGAuthErrorCodeOperationNotAllowed |表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\nWDGAuthErrorCodeUserDisabled\t| 表示用户的帐户已停用。\nWDGAuthErrorCodeWrongPassword | 表示用户尝试用错误密码登录。\n\n\n##### signInWithCredential:completion:\n\n代码 | 含义\t\n---|---\nWDGAuthErrorCodeInvalidCredential | 如果凭据到期或格式不正确，则可能发生此错误。\nWDGAuthErrorCodeOperationNotAllowed\t| 表示用凭据表示用户身份提供程序的帐户尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用该帐户。\nWDGAuthErrorCodeEmailAlreadyInUse |\t表示用该凭据声明的电子邮件已被一个现有帐户使用，无法用此登录方法进行身份认证。\t请为此用户电子邮件调用 fetchProvidersForEmail，然后提示其用返回的任何登录提供程序登录。只有在 Wilddog console 中的 Authentication 设置下启用 \"One account per email address\" 设置时才会引发此错误。\nWDGAuthErrorCodeUserDisabled | 表示该用户的帐户已停用。\nWDGAuthErrorCodeWrongPassword |\t表示该用户尝试用错误密码登录（如果凭据类型为 EmailAuthCredential）。\n\n##### signInAnonymouslyWithCompletion:\n\n代码 | 含义\t\n---|---\nWDGAuthErrorCodeOperationNotAllowed | 表示匿名登录方式未启用。请在 Wilddog 控制面板的“用户认证”部分启用。\t\n\t\n##### signInWithCustomToken:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeInvalidCustomToken | 表示自定义令牌认证错误。\n\n##### createUserWithEmail:password:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeInvalidEmail | 表示该电子邮件地址格式不正确。\nWDGAuthErrorCodeEmailAlreadyInUse | 表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。\nWDGAuthErrorCodeOperationNotAllowed | 表示该电子邮件和密码帐户尚未启用。 请在 Wilddog console 的“ Authentication ”部分启用。\nWDGAuthErrorCodeWeakPassword | 表示尝试设置的密码被认为太弱。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。\n\n#### WDGUser 操作常见错误\n\n代码 | 含义\t\n---|----\nWDGAuthErrorCodeInvalidUserToken | token 失效，你必须提示该用户在此设备重新登录。\nWDGAuthErrorCodeUserDisabled |\t表示该用户的帐户已停用，只有从 Wilddog console 的“Users”面板重新启用后方可继续使用。\t\n\n##### updateEmail:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeEmailAlreadyInUse | 表示该电子邮件已被另一个帐户使用。\nWDGAuthErrorCodeInvalidEmail | 表示该电子邮件地址格式不正确。\nWDGAuthErrorCodeRequiresRecentLogin | 更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\n\n##### updatePassword:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeOperationNotAllowed | 表示管理员已停用指定用户身份提供程序的登录。\nWDGAuthErrorCodeRequiresRecentLogin | 更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\nWDGAuthErrorCodeWeakPassword | 表示尝试设置一个被认为太弱的密码。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。\n\n##### linkWithCredential:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeProviderAlreadyLinked | 表示尝试关联的登录方式的类型已经关联到此帐户。\nWDGAuthErrorCodeCredentialAlreadyInUse | 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。\nWDGAuthErrorCodeOperationNotAllowed | 表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。此方法也可能返回与 WDGUser 上 updateEmail:completion: 和 updatePassword:completion: 相关的错误代码。\n\n##### unlinkFromProvider:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeNoSuchProvider | 表示尝试取消关联的提供程序没有关联到该帐户。\nWDGAuthErrorCodeRequiresRecentLogin | 更新电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\n\n##### sendEmailVerificationWithCompletion:\n\n代码 | 含义\n---- | -----------\nWDGAuthErrorCodeUserNotFound | 表示未找到该用户帐户。\n\n##### deleteWithCompletion:\n\n代码 |\t含义\n---|-----\nWDGAuthErrorCodeRequiresRecentLogin\t| 敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\n\n","source":"guide/auth/ios/errorcode.md","raw":"title: 处理身份认证错误\n---\n如果在 WilddogAuth 的回调方法中收到一个非空 `NSError` 参数，则表示出现了错误。 要想实现正确的错误逻辑处理，请对照常见错误和下面所列的方法特定错误检查错误代码。\n\n有些错误可通过特定用户操作解决。例如，`WDGAuthErrorCodeUserTokenExpired` 可通过重新登录该用户解决，`WDGAuthErrorCodeWrongPassword` 可通过让用户提供正确密码解决。\n\n除 `WDGAuthErrorCodeNetworkError` 或 `WDGAuthErrorCodeTooManyRequests` 之外，用相同参数重试一个失败的操作决不会成功。切勿对操作在服务器端是否生效进行任何假设。\n\n调试或打印错误时，请查阅 userInfo 字典。WDGAuthErrorNameKey 包含可用于识别错误的跨平台错误名字符串。NSLocalizedDescriptionKey 包含错误说明。此说明只适合开发者使用，不适合用户使用。NSUnderlyingErrorKey 包含引起所述错误的基础错误（如果存在基础错误）。\n\n除了上面所列的主要字段外，userInfo 字典中可能还提供了一些你在诊断错误时可能觉得有用的其他字段。\n\n## 所有 API 方法通用的错误代码\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeNetworkError | 表示在操作过程中出现网络错误。\nWDGAuthErrorCodeUserNotFound | 表示未找到用户帐户。如果用户帐户已删除则可能发生此错误。\nWDGAuthErrorCodeUserTokenExpired | 表示当前用户的令牌已到期。例如，该用户可能在另一台设备上更改了帐户密码。 你必须提示该用户在此设备上重新登录。\nWDGAuthErrorCodeTooManyRequests | 表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止。 请在稍后重试。\nWDGAuthErrorCodeInternalError | 表示出现内部错误。 请用整个 NSError 对象报告错误。\n\n## 方法特定错误代码\n\n#### WDGAuth 操作常见错误\n\n##### fetchProvidersForEmail:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeInvalidEmail | 表示电子邮件地址格式不正确。    \n\n##### signInWithEmail:password:completion:\n\n代码 | 含义\t\n--- | ---\nWDGAuthErrorCodeOperationNotAllowed |表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\nWDGAuthErrorCodeUserDisabled\t| 表示用户的帐户已停用。\nWDGAuthErrorCodeWrongPassword | 表示用户尝试用错误密码登录。\n\n\n##### signInWithCredential:completion:\n\n代码 | 含义\t\n---|---\nWDGAuthErrorCodeInvalidCredential | 如果凭据到期或格式不正确，则可能发生此错误。\nWDGAuthErrorCodeOperationNotAllowed\t| 表示用凭据表示用户身份提供程序的帐户尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用该帐户。\nWDGAuthErrorCodeEmailAlreadyInUse |\t表示用该凭据声明的电子邮件已被一个现有帐户使用，无法用此登录方法进行身份认证。\t请为此用户电子邮件调用 fetchProvidersForEmail，然后提示其用返回的任何登录提供程序登录。只有在 Wilddog console 中的 Authentication 设置下启用 \"One account per email address\" 设置时才会引发此错误。\nWDGAuthErrorCodeUserDisabled | 表示该用户的帐户已停用。\nWDGAuthErrorCodeWrongPassword |\t表示该用户尝试用错误密码登录（如果凭据类型为 EmailAuthCredential）。\n\n##### signInAnonymouslyWithCompletion:\n\n代码 | 含义\t\n---|---\nWDGAuthErrorCodeOperationNotAllowed | 表示匿名登录方式未启用。请在 Wilddog 控制面板的“用户认证”部分启用。\t\n\t\n##### signInWithCustomToken:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeInvalidCustomToken | 表示自定义令牌认证错误。\n\n##### createUserWithEmail:password:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeInvalidEmail | 表示该电子邮件地址格式不正确。\nWDGAuthErrorCodeEmailAlreadyInUse | 表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。\nWDGAuthErrorCodeOperationNotAllowed | 表示该电子邮件和密码帐户尚未启用。 请在 Wilddog console 的“ Authentication ”部分启用。\nWDGAuthErrorCodeWeakPassword | 表示尝试设置的密码被认为太弱。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。\n\n#### WDGUser 操作常见错误\n\n代码 | 含义\t\n---|----\nWDGAuthErrorCodeInvalidUserToken | token 失效，你必须提示该用户在此设备重新登录。\nWDGAuthErrorCodeUserDisabled |\t表示该用户的帐户已停用，只有从 Wilddog console 的“Users”面板重新启用后方可继续使用。\t\n\n##### updateEmail:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeEmailAlreadyInUse | 表示该电子邮件已被另一个帐户使用。\nWDGAuthErrorCodeInvalidEmail | 表示该电子邮件地址格式不正确。\nWDGAuthErrorCodeRequiresRecentLogin | 更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\n\n##### updatePassword:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeOperationNotAllowed | 表示管理员已停用指定用户身份提供程序的登录。\nWDGAuthErrorCodeRequiresRecentLogin | 更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\nWDGAuthErrorCodeWeakPassword | 表示尝试设置一个被认为太弱的密码。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。\n\n##### linkWithCredential:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeProviderAlreadyLinked | 表示尝试关联的登录方式的类型已经关联到此帐户。\nWDGAuthErrorCodeCredentialAlreadyInUse | 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。\nWDGAuthErrorCodeOperationNotAllowed | 表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。此方法也可能返回与 WDGUser 上 updateEmail:completion: 和 updatePassword:completion: 相关的错误代码。\n\n##### unlinkFromProvider:completion:\n\n代码 | 含义 \n---- | -----------\nWDGAuthErrorCodeNoSuchProvider | 表示尝试取消关联的提供程序没有关联到该帐户。\nWDGAuthErrorCodeRequiresRecentLogin | 更新电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\n\n##### sendEmailVerificationWithCompletion:\n\n代码 | 含义\n---- | -----------\nWDGAuthErrorCodeUserNotFound | 表示未找到该用户帐户。\n\n##### deleteWithCompletion:\n\n代码 |\t含义\n---|-----\nWDGAuthErrorCodeRequiresRecentLogin\t| 敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。\n\n","date":"2016-09-06T03:38:22.525Z","updated":"2016-09-06T03:38:22.525Z","path":"guide/auth/ios/errorcode.html","comments":1,"layout":"page","_id":"cisswi9kl0010z4fwjx8jdkhm","content":"<p>如果在 WilddogAuth 的回调方法中收到一个非空 <code>NSError</code> 参数，则表示出现了错误。 要想实现正确的错误逻辑处理，请对照常见错误和下面所列的方法特定错误检查错误代码。</p>\n<p>有些错误可通过特定用户操作解决。例如，<code>WDGAuthErrorCodeUserTokenExpired</code> 可通过重新登录该用户解决，<code>WDGAuthErrorCodeWrongPassword</code> 可通过让用户提供正确密码解决。</p>\n<p>除 <code>WDGAuthErrorCodeNetworkError</code> 或 <code>WDGAuthErrorCodeTooManyRequests</code> 之外，用相同参数重试一个失败的操作决不会成功。切勿对操作在服务器端是否生效进行任何假设。</p>\n<p>调试或打印错误时，请查阅 userInfo 字典。WDGAuthErrorNameKey 包含可用于识别错误的跨平台错误名字符串。NSLocalizedDescriptionKey 包含错误说明。此说明只适合开发者使用，不适合用户使用。NSUnderlyingErrorKey 包含引起所述错误的基础错误（如果存在基础错误）。</p>\n<p>除了上面所列的主要字段外，userInfo 字典中可能还提供了一些你在诊断错误时可能觉得有用的其他字段。</p>\n<h2 id=\"所有-API-方法通用的错误代码\"><a href=\"#所有-API-方法通用的错误代码\" class=\"headerlink\" title=\"所有 API 方法通用的错误代码\"></a>所有 API 方法通用的错误代码</h2><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeNetworkError</td>\n<td>表示在操作过程中出现网络错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserNotFound</td>\n<td>表示未找到用户帐户。如果用户帐户已删除则可能发生此错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserTokenExpired</td>\n<td>表示当前用户的令牌已到期。例如，该用户可能在另一台设备上更改了帐户密码。 你必须提示该用户在此设备上重新登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeTooManyRequests</td>\n<td>表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止。 请在稍后重试。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeInternalError</td>\n<td>表示出现内部错误。 请用整个 NSError 对象报告错误。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"方法特定错误代码\"><a href=\"#方法特定错误代码\" class=\"headerlink\" title=\"方法特定错误代码\"></a>方法特定错误代码</h2><h4 id=\"WDGAuth-操作常见错误\"><a href=\"#WDGAuth-操作常见错误\" class=\"headerlink\" title=\"WDGAuth 操作常见错误\"></a>WDGAuth 操作常见错误</h4><h5 id=\"fetchProvidersForEmail-completion\"><a href=\"#fetchProvidersForEmail-completion\" class=\"headerlink\" title=\"fetchProvidersForEmail:completion:\"></a>fetchProvidersForEmail:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidEmail</td>\n<td>表示电子邮件地址格式不正确。    </td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInWithEmail-password-completion\"><a href=\"#signInWithEmail-password-completion\" class=\"headerlink\" title=\"signInWithEmail:password:completion:\"></a>signInWithEmail:password:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserDisabled</td>\n<td>表示用户的帐户已停用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWrongPassword</td>\n<td>表示用户尝试用错误密码登录。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInWithCredential-completion\"><a href=\"#signInWithCredential-completion\" class=\"headerlink\" title=\"signInWithCredential:completion:\"></a>signInWithCredential:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidCredential</td>\n<td>如果凭据到期或格式不正确，则可能发生此错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示用凭据表示用户身份提供程序的帐户尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用该帐户。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeEmailAlreadyInUse</td>\n<td>表示用该凭据声明的电子邮件已被一个现有帐户使用，无法用此登录方法进行身份认证。    请为此用户电子邮件调用 fetchProvidersForEmail，然后提示其用返回的任何登录提供程序登录。只有在 Wilddog console 中的 Authentication 设置下启用 “One account per email address” 设置时才会引发此错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserDisabled</td>\n<td>表示该用户的帐户已停用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWrongPassword</td>\n<td>表示该用户尝试用错误密码登录（如果凭据类型为 EmailAuthCredential）。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInAnonymouslyWithCompletion\"><a href=\"#signInAnonymouslyWithCompletion\" class=\"headerlink\" title=\"signInAnonymouslyWithCompletion:\"></a>signInAnonymouslyWithCompletion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示匿名登录方式未启用。请在 Wilddog 控制面板的“用户认证”部分启用。    </td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInWithCustomToken-completion\"><a href=\"#signInWithCustomToken-completion\" class=\"headerlink\" title=\"signInWithCustomToken:completion:\"></a>signInWithCustomToken:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidCustomToken</td>\n<td>表示自定义令牌认证错误。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"createUserWithEmail-password-completion\"><a href=\"#createUserWithEmail-password-completion\" class=\"headerlink\" title=\"createUserWithEmail:password:completion:\"></a>createUserWithEmail:password:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidEmail</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeEmailAlreadyInUse</td>\n<td>表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示该电子邮件和密码帐户尚未启用。 请在 Wilddog console 的“ Authentication ”部分启用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWeakPassword</td>\n<td>表示尝试设置的密码被认为太弱。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"WDGUser-操作常见错误\"><a href=\"#WDGUser-操作常见错误\" class=\"headerlink\" title=\"WDGUser 操作常见错误\"></a>WDGUser 操作常见错误</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidUserToken</td>\n<td>token 失效，你必须提示该用户在此设备重新登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserDisabled</td>\n<td>表示该用户的帐户已停用，只有从 Wilddog console 的“Users”面板重新启用后方可继续使用。    </td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"updateEmail-completion\"><a href=\"#updateEmail-completion\" class=\"headerlink\" title=\"updateEmail:completion:\"></a>updateEmail:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeEmailAlreadyInUse</td>\n<td>表示该电子邮件已被另一个帐户使用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeInvalidEmail</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"updatePassword-completion\"><a href=\"#updatePassword-completion\" class=\"headerlink\" title=\"updatePassword:completion:\"></a>updatePassword:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示管理员已停用指定用户身份提供程序的登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWeakPassword</td>\n<td>表示尝试设置一个被认为太弱的密码。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"linkWithCredential-completion\"><a href=\"#linkWithCredential-completion\" class=\"headerlink\" title=\"linkWithCredential:completion:\"></a>linkWithCredential:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeProviderAlreadyLinked</td>\n<td>表示尝试关联的登录方式的类型已经关联到此帐户。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeCredentialAlreadyInUse</td>\n<td>表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。此方法也可能返回与 WDGUser 上 updateEmail:completion: 和 updatePassword:completion: 相关的错误代码。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"unlinkFromProvider-completion\"><a href=\"#unlinkFromProvider-completion\" class=\"headerlink\" title=\"unlinkFromProvider:completion:\"></a>unlinkFromProvider:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeNoSuchProvider</td>\n<td>表示尝试取消关联的提供程序没有关联到该帐户。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>更新电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"sendEmailVerificationWithCompletion\"><a href=\"#sendEmailVerificationWithCompletion\" class=\"headerlink\" title=\"sendEmailVerificationWithCompletion:\"></a>sendEmailVerificationWithCompletion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeUserNotFound</td>\n<td>表示未找到该用户帐户。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"deleteWithCompletion\"><a href=\"#deleteWithCompletion\" class=\"headerlink\" title=\"deleteWithCompletion:\"></a>deleteWithCompletion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<p>如果在 WilddogAuth 的回调方法中收到一个非空 <code>NSError</code> 参数，则表示出现了错误。 要想实现正确的错误逻辑处理，请对照常见错误和下面所列的方法特定错误检查错误代码。</p>\n<p>有些错误可通过特定用户操作解决。例如，<code>WDGAuthErrorCodeUserTokenExpired</code> 可通过重新登录该用户解决，<code>WDGAuthErrorCodeWrongPassword</code> 可通过让用户提供正确密码解决。</p>\n<p>除 <code>WDGAuthErrorCodeNetworkError</code> 或 <code>WDGAuthErrorCodeTooManyRequests</code> 之外，用相同参数重试一个失败的操作决不会成功。切勿对操作在服务器端是否生效进行任何假设。</p>\n<p>调试或打印错误时，请查阅 userInfo 字典。WDGAuthErrorNameKey 包含可用于识别错误的跨平台错误名字符串。NSLocalizedDescriptionKey 包含错误说明。此说明只适合开发者使用，不适合用户使用。NSUnderlyingErrorKey 包含引起所述错误的基础错误（如果存在基础错误）。</p>\n<p>除了上面所列的主要字段外，userInfo 字典中可能还提供了一些你在诊断错误时可能觉得有用的其他字段。</p>\n<h2 id=\"所有-API-方法通用的错误代码\"><a href=\"#所有-API-方法通用的错误代码\" class=\"headerlink\" title=\"所有 API 方法通用的错误代码\"></a>所有 API 方法通用的错误代码</h2><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeNetworkError</td>\n<td>表示在操作过程中出现网络错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserNotFound</td>\n<td>表示未找到用户帐户。如果用户帐户已删除则可能发生此错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserTokenExpired</td>\n<td>表示当前用户的令牌已到期。例如，该用户可能在另一台设备上更改了帐户密码。 你必须提示该用户在此设备上重新登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeTooManyRequests</td>\n<td>表示从调用方设备向 Wilddog Authentication 服务器的异常请求达到一定数量后，该请求被阻止。 请在稍后重试。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeInternalError</td>\n<td>表示出现内部错误。 请用整个 NSError 对象报告错误。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"方法特定错误代码\"><a href=\"#方法特定错误代码\" class=\"headerlink\" title=\"方法特定错误代码\"></a>方法特定错误代码</h2><h4 id=\"WDGAuth-操作常见错误\"><a href=\"#WDGAuth-操作常见错误\" class=\"headerlink\" title=\"WDGAuth 操作常见错误\"></a>WDGAuth 操作常见错误</h4><h5 id=\"fetchProvidersForEmail-completion\"><a href=\"#fetchProvidersForEmail-completion\" class=\"headerlink\" title=\"fetchProvidersForEmail:completion:\"></a>fetchProvidersForEmail:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidEmail</td>\n<td>表示电子邮件地址格式不正确。    </td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInWithEmail-password-completion\"><a href=\"#signInWithEmail-password-completion\" class=\"headerlink\" title=\"signInWithEmail:password:completion:\"></a>signInWithEmail:password:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserDisabled</td>\n<td>表示用户的帐户已停用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWrongPassword</td>\n<td>表示用户尝试用错误密码登录。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInWithCredential-completion\"><a href=\"#signInWithCredential-completion\" class=\"headerlink\" title=\"signInWithCredential:completion:\"></a>signInWithCredential:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidCredential</td>\n<td>如果凭据到期或格式不正确，则可能发生此错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示用凭据表示用户身份提供程序的帐户尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用该帐户。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeEmailAlreadyInUse</td>\n<td>表示用该凭据声明的电子邮件已被一个现有帐户使用，无法用此登录方法进行身份认证。    请为此用户电子邮件调用 fetchProvidersForEmail，然后提示其用返回的任何登录提供程序登录。只有在 Wilddog console 中的 Authentication 设置下启用 “One account per email address” 设置时才会引发此错误。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserDisabled</td>\n<td>表示该用户的帐户已停用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWrongPassword</td>\n<td>表示该用户尝试用错误密码登录（如果凭据类型为 EmailAuthCredential）。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInAnonymouslyWithCompletion\"><a href=\"#signInAnonymouslyWithCompletion\" class=\"headerlink\" title=\"signInAnonymouslyWithCompletion:\"></a>signInAnonymouslyWithCompletion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示匿名登录方式未启用。请在 Wilddog 控制面板的“用户认证”部分启用。    </td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"signInWithCustomToken-completion\"><a href=\"#signInWithCustomToken-completion\" class=\"headerlink\" title=\"signInWithCustomToken:completion:\"></a>signInWithCustomToken:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidCustomToken</td>\n<td>表示自定义令牌认证错误。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"createUserWithEmail-password-completion\"><a href=\"#createUserWithEmail-password-completion\" class=\"headerlink\" title=\"createUserWithEmail:password:completion:\"></a>createUserWithEmail:password:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidEmail</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeEmailAlreadyInUse</td>\n<td>表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示该电子邮件和密码帐户尚未启用。 请在 Wilddog console 的“ Authentication ”部分启用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWeakPassword</td>\n<td>表示尝试设置的密码被认为太弱。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"WDGUser-操作常见错误\"><a href=\"#WDGUser-操作常见错误\" class=\"headerlink\" title=\"WDGUser 操作常见错误\"></a>WDGUser 操作常见错误</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeInvalidUserToken</td>\n<td>token 失效，你必须提示该用户在此设备重新登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeUserDisabled</td>\n<td>表示该用户的帐户已停用，只有从 Wilddog console 的“Users”面板重新启用后方可继续使用。    </td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"updateEmail-completion\"><a href=\"#updateEmail-completion\" class=\"headerlink\" title=\"updateEmail:completion:\"></a>updateEmail:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeEmailAlreadyInUse</td>\n<td>表示该电子邮件已被另一个帐户使用。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeInvalidEmail</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"updatePassword-completion\"><a href=\"#updatePassword-completion\" class=\"headerlink\" title=\"updatePassword:completion:\"></a>updatePassword:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示管理员已停用指定用户身份提供程序的登录。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeWeakPassword</td>\n<td>表示尝试设置一个被认为太弱的密码。 NSError.userInfo 字典对象的 NSLocalizedFailureReasonErrorKey 字段含有可向该用户显示的更详细解释。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"linkWithCredential-completion\"><a href=\"#linkWithCredential-completion\" class=\"headerlink\" title=\"linkWithCredential:completion:\"></a>linkWithCredential:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeProviderAlreadyLinked</td>\n<td>表示尝试关联的登录方式的类型已经关联到此帐户。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeCredentialAlreadyInUse</td>\n<td>表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeOperationNotAllowed</td>\n<td>表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。此方法也可能返回与 WDGUser 上 updateEmail:completion: 和 updatePassword:completion: 相关的错误代码。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"unlinkFromProvider-completion\"><a href=\"#unlinkFromProvider-completion\" class=\"headerlink\" title=\"unlinkFromProvider:completion:\"></a>unlinkFromProvider:completion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeNoSuchProvider</td>\n<td>表示尝试取消关联的提供程序没有关联到该帐户。</td>\n</tr>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>更新电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"sendEmailVerificationWithCompletion\"><a href=\"#sendEmailVerificationWithCompletion\" class=\"headerlink\" title=\"sendEmailVerificationWithCompletion:\"></a>sendEmailVerificationWithCompletion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeUserNotFound</td>\n<td>表示未找到该用户帐户。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"deleteWithCompletion\"><a href=\"#deleteWithCompletion\" class=\"headerlink\" title=\"deleteWithCompletion:\"></a>deleteWithCompletion:</h5><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WDGAuthErrorCodeRequiresRecentLogin</td>\n<td>敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，请在 WDGUser 上调用 reauthenticateWithCredential:completion:，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"管理用户","_content":"\n## 创建用户\n通过调用 `createUserWithEmail:password:completion:` 方法或首次使用第三方登录方式（如 QQ Sign-In 或 WeiXin Login）登录一个用户，就可以在你的 Wilddog 项目中创建一个新用户。\n\n你也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。\n\n## 获取当前登录的用户\n获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：\n\nObjective-C\n```objectivec\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"]; addAuthStateDidChangeListener:^(WDGAuth *_Nonnull auth,\n                                                WDGUser *_Nullable user) {\n  if (user != nil) {\n    // User is signed in.\n  } else {\n    // No user is signed in.\n  }\n}];\n```\nSwift\n```swift\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.addAuthStateDidChangeListener{ auth, user in\n    if let user = user {\n        // User is signed in.\n    } else {\n        // No user is signed in.\n    }\n}\n\n```\n\n使用侦听器可保证在你获取当前用户时 Auth 对象不会处于中间状态如初始化。\n\n你也可以使用 `currentUser` 属性获取当前已登录的用户。 如果用户没有登录，`currentUser` 则为空：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\nif (user != nil) {\n  // User is signed in.\n} else {\n  // No user is signed in.\n}\n```\nSwift\n```swift\nif let user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser {\n    // User is signed in.\n} else {\n    // No user is signed in.\n}\n\n```\n\n注：`currentUser` 可能为空，这是因为 auth 对象尚未完成初始化。 如果你使用侦听器跟踪用户登录状态，你将无需处理该情况。\n\n## 获取用户个人资料\n要获取用户的个人资料信息，请使用 `WDGUser` 实例的属性。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\nif (user != nil) {\n  NSString *name = user.displayName;\n  NSString *email = user.email;\n  NSURL *photoUrl = user.photoURL;\n  NSString *uid = user.uid;    \n  //  The user's ID, unique to the Wilddog project.\n  //  Do NOT use this value to authenticate with\n  //  your backend server, if you have one. Use\n  //  getTokenWithCompletion:completion: instead.    \n} else {\n  // No user is signed in.\n}\n```\nSwift\n```swift\nif let user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser {\n    let name = user.displayName\n    let email = user.email\n    let photoUrl = user.photoURL\n    let uid = user.id;  \n    // The user's ID, unique to the Wilddog project.\n    // Do NOT use this value to authenticate with\n    // your backend server, if you have one.Use\n    // getTokenWithCompletion:completion: instead.\n} else {\n    // No user is signed in.\n}\n\n```\n\n## 获取用户的其它登录方式的个人资料信息\n要获取已链接至用户的其它登录方式的个人资料信息，请使用 providerData 属性。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\nif (user != nil) {\n  for (WDGUserInfo *profile in user.providerData) {\n    NSString *providerID = profile.providerID;\n    NSString *uid = profile.uid;  // Provider-specific UID\n    NSString *name = profile.displayName;\n    NSString *email = profile.email;\n    NSURL *photoURL = profile.photoURL;\n  }\n} else {\n  // No user is signed in.\n}\n```\nSwift\n```swift\nif let user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser {\n    for profile in user.providerData {\n        let providerID = profile.providerID\n        let uid = profile.uid;  // Provider-specific UID\n        let name = profile.displayName\n        let email = profile.email\n        let photoURL = profile.photoURL\n    }\n} else {\n    // No user is signed in.\n}\n\n```\n\n## 更新用户个人资料\n你可以使用`WDGUserProfileChangeRequest` 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\nWDGUserProfileChangeRequest *changeRequest = [user profileChangeRequest];\n\nchangeRequest.displayName = @\"JianDong. User\";\nchangeRequest.photoURL =\n    [NSURL URLWithString:@\"https://example.com/jane-q-user/profile.jpg\"];\n[changeRequest commitChangesWithCompletion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Profile updated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\nif let user = user {\n    let changeRequest = user.profileChangeRequest()\n    \n    changeRequest.displayName = \"Jane Q. User\"\n    changeRequest.photoURL =\n        NSURL(string: \"https://example.com/jane-q-user/profile.jpg\")\n    changeRequest.commitChangesWithCompletion { error in\n        if let error = error {\n            // An error happened.\n        } else {\n            // Profile updated.\n        }\n    }\n}\n\n```\n\n## 设置用户的电子邮件地址\n你可以用 `updateEmail:completion:` 方法设置用户的电子邮件地址。如果这个用户已经存在邮箱，则更新它，之后需要使用新的邮箱地址进行登录。例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\n[user updateEmail:@\"user@example.com\" completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Email updated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\n\nuser?.updateEmail(\"user@example.com\") { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Email updated.\n    }\n}\n\n```\n\n重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅 [对用户重新进行身份认证](/guide/auth/ios/manageuser.html#对用户重新进行身份认证)。\n\n## 设置用户密码\n你可以使用 `updatePassword:completion:` 方法设置用户密码。密码更新成功后，需要使用新的密码进行登录。例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\nNSString *newPassword = [yourApp getRandomSecurePassword];\n\n[user updatePassword:newPassword completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Password updated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\nlet newPassword = getRandomSecurePassword()\n\nuser?.updatePassword(newPassword) { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Password updated.\n    }\n}\n\n```\n\n重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 发送重设密码电子邮件\n你可以用 `sendPasswordResetWithEmail:completion:` 方法向用户发送一封重设密码电子邮件。 例如：\n\nObjective-C\n```objectivec\nNSString *email = @\"user@example.com\";\n\n[[WDGAuth auth] sendPasswordResetWithEmail:email\n                                completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Password reset email sent.\n  }\n}];\n```\nSwift\n```swift\nlet email = \"user@example.com\"\n\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.sendPasswordResetWithEmail(email) { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Password reset email sent.\n    }\n}\n\n```\n\n你可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。\n\n你也可以从 Wilddog 控制面板中发送重设密码电子邮件。\n\n## 删除用户\n\n你可以使用 `deleteWithCompletion` 方法删除用户帐户。例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\n[user deleteWithCompletion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Account deleted.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\n\nuser?.deleteWithCompletion { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Account deleted.\n    }\n}\n```\n\n你可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。\n\n重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 对用户重新进行身份认证\n有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。\n\n如果你执行这些操作之一，而该用户在很久以前登录过，该操作便会失败，显示 `WDGAuthErrorCodeCredentialTooOld` 错误。\n\n发生这种错误时，请从用户获取新登录凭据并将该凭据传递到 `reauthenticateWithCredential:`，对该用户重新进行身份认证。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\nWDGAuthCredential *credential; // 需要初始化\n\n// Prompt the user to re-provide their sign-in credentials\n\n[user reauthenticateWithCredential:credential completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // User re-authenticated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\nvar credential: WDGAuthCredential // 需要初始化\n\n// Prompt the user to re-provide their sign-in credentials\n\nuser?.reauthenticateWithCredential(credential) { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // User re-authenticated.\n    }\n})\n\n```","source":"guide/auth/ios/manageuser.md","raw":"title: 管理用户\n---\n\n## 创建用户\n通过调用 `createUserWithEmail:password:completion:` 方法或首次使用第三方登录方式（如 QQ Sign-In 或 WeiXin Login）登录一个用户，就可以在你的 Wilddog 项目中创建一个新用户。\n\n你也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。\n\n## 获取当前登录的用户\n获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：\n\nObjective-C\n```objectivec\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"]; addAuthStateDidChangeListener:^(WDGAuth *_Nonnull auth,\n                                                WDGUser *_Nullable user) {\n  if (user != nil) {\n    // User is signed in.\n  } else {\n    // No user is signed in.\n  }\n}];\n```\nSwift\n```swift\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.addAuthStateDidChangeListener{ auth, user in\n    if let user = user {\n        // User is signed in.\n    } else {\n        // No user is signed in.\n    }\n}\n\n```\n\n使用侦听器可保证在你获取当前用户时 Auth 对象不会处于中间状态如初始化。\n\n你也可以使用 `currentUser` 属性获取当前已登录的用户。 如果用户没有登录，`currentUser` 则为空：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\nif (user != nil) {\n  // User is signed in.\n} else {\n  // No user is signed in.\n}\n```\nSwift\n```swift\nif let user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser {\n    // User is signed in.\n} else {\n    // No user is signed in.\n}\n\n```\n\n注：`currentUser` 可能为空，这是因为 auth 对象尚未完成初始化。 如果你使用侦听器跟踪用户登录状态，你将无需处理该情况。\n\n## 获取用户个人资料\n要获取用户的个人资料信息，请使用 `WDGUser` 实例的属性。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\nif (user != nil) {\n  NSString *name = user.displayName;\n  NSString *email = user.email;\n  NSURL *photoUrl = user.photoURL;\n  NSString *uid = user.uid;    \n  //  The user's ID, unique to the Wilddog project.\n  //  Do NOT use this value to authenticate with\n  //  your backend server, if you have one. Use\n  //  getTokenWithCompletion:completion: instead.    \n} else {\n  // No user is signed in.\n}\n```\nSwift\n```swift\nif let user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser {\n    let name = user.displayName\n    let email = user.email\n    let photoUrl = user.photoURL\n    let uid = user.id;  \n    // The user's ID, unique to the Wilddog project.\n    // Do NOT use this value to authenticate with\n    // your backend server, if you have one.Use\n    // getTokenWithCompletion:completion: instead.\n} else {\n    // No user is signed in.\n}\n\n```\n\n## 获取用户的其它登录方式的个人资料信息\n要获取已链接至用户的其它登录方式的个人资料信息，请使用 providerData 属性。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\nif (user != nil) {\n  for (WDGUserInfo *profile in user.providerData) {\n    NSString *providerID = profile.providerID;\n    NSString *uid = profile.uid;  // Provider-specific UID\n    NSString *name = profile.displayName;\n    NSString *email = profile.email;\n    NSURL *photoURL = profile.photoURL;\n  }\n} else {\n  // No user is signed in.\n}\n```\nSwift\n```swift\nif let user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser {\n    for profile in user.providerData {\n        let providerID = profile.providerID\n        let uid = profile.uid;  // Provider-specific UID\n        let name = profile.displayName\n        let email = profile.email\n        let photoURL = profile.photoURL\n    }\n} else {\n    // No user is signed in.\n}\n\n```\n\n## 更新用户个人资料\n你可以使用`WDGUserProfileChangeRequest` 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\nWDGUserProfileChangeRequest *changeRequest = [user profileChangeRequest];\n\nchangeRequest.displayName = @\"JianDong. User\";\nchangeRequest.photoURL =\n    [NSURL URLWithString:@\"https://example.com/jane-q-user/profile.jpg\"];\n[changeRequest commitChangesWithCompletion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Profile updated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\nif let user = user {\n    let changeRequest = user.profileChangeRequest()\n    \n    changeRequest.displayName = \"Jane Q. User\"\n    changeRequest.photoURL =\n        NSURL(string: \"https://example.com/jane-q-user/profile.jpg\")\n    changeRequest.commitChangesWithCompletion { error in\n        if let error = error {\n            // An error happened.\n        } else {\n            // Profile updated.\n        }\n    }\n}\n\n```\n\n## 设置用户的电子邮件地址\n你可以用 `updateEmail:completion:` 方法设置用户的电子邮件地址。如果这个用户已经存在邮箱，则更新它，之后需要使用新的邮箱地址进行登录。例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\n[user updateEmail:@\"user@example.com\" completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Email updated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\n\nuser?.updateEmail(\"user@example.com\") { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Email updated.\n    }\n}\n\n```\n\n重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅 [对用户重新进行身份认证](/guide/auth/ios/manageuser.html#对用户重新进行身份认证)。\n\n## 设置用户密码\n你可以使用 `updatePassword:completion:` 方法设置用户密码。密码更新成功后，需要使用新的密码进行登录。例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\nNSString *newPassword = [yourApp getRandomSecurePassword];\n\n[user updatePassword:newPassword completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Password updated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\nlet newPassword = getRandomSecurePassword()\n\nuser?.updatePassword(newPassword) { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Password updated.\n    }\n}\n\n```\n\n重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 发送重设密码电子邮件\n你可以用 `sendPasswordResetWithEmail:completion:` 方法向用户发送一封重设密码电子邮件。 例如：\n\nObjective-C\n```objectivec\nNSString *email = @\"user@example.com\";\n\n[[WDGAuth auth] sendPasswordResetWithEmail:email\n                                completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Password reset email sent.\n  }\n}];\n```\nSwift\n```swift\nlet email = \"user@example.com\"\n\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.sendPasswordResetWithEmail(email) { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Password reset email sent.\n    }\n}\n\n```\n\n你可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。\n\n你也可以从 Wilddog 控制面板中发送重设密码电子邮件。\n\n## 删除用户\n\n你可以使用 `deleteWithCompletion` 方法删除用户帐户。例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\n\n[user deleteWithCompletion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // Account deleted.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\n\nuser?.deleteWithCompletion { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // Account deleted.\n    }\n}\n```\n\n你可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。\n\n重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n\n## 对用户重新进行身份认证\n有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。\n\n如果你执行这些操作之一，而该用户在很久以前登录过，该操作便会失败，显示 `WDGAuthErrorCodeCredentialTooOld` 错误。\n\n发生这种错误时，请从用户获取新登录凭据并将该凭据传递到 `reauthenticateWithCredential:`，对该用户重新进行身份认证。 例如：\n\nObjective-C\n```objectivec\nWDGUser *user = [WDGAuth auth].currentUser;\nWDGAuthCredential *credential; // 需要初始化\n\n// Prompt the user to re-provide their sign-in credentials\n\n[user reauthenticateWithCredential:credential completion:^(NSError *_Nullable error) {\n  if (error) {\n    // An error happened.\n  } else {\n    // User re-authenticated.\n  }\n}];\n```\nSwift\n```swift\nlet user = WDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser\nvar credential: WDGAuthCredential // 需要初始化\n\n// Prompt the user to re-provide their sign-in credentials\n\nuser?.reauthenticateWithCredential(credential) { error in\n    if let error = error {\n        // An error happened.\n    } else {\n        // User re-authenticated.\n    }\n})\n\n```","date":"2016-09-06T03:38:22.526Z","updated":"2016-09-06T03:38:22.526Z","path":"guide/auth/ios/manageuser.html","comments":1,"layout":"page","_id":"cisswi9kl0011z4fwsi3ubjzl","content":"<h2 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h2><p>通过调用 <code>createUserWithEmail:password:completion:</code> 方法或首次使用第三方登录方式（如 QQ Sign-In 或 WeiXin Login）登录一个用户，就可以在你的 Wilddog 项目中创建一个新用户。</p>\n<p>你也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。</p>\n<h2 id=\"获取当前登录的用户\"><a href=\"#获取当前登录的用户\" class=\"headerlink\" title=\"获取当前登录的用户\"></a>获取当前登录的用户</h2><p>获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>]; addAuthStateDidChangeListener:^(WDGAuth *_Nonnull auth,</div><div class=\"line\">                                                WDGUser *_Nullable user) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.addAuthStateDidChangeListener&#123; auth, user <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = user &#123;</div><div class=\"line\">        <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用侦听器可保证在你获取当前用户时 Auth 对象不会处于中间状态如初始化。</p>\n<p>你也可以使用 <code>currentUser</code> 属性获取当前已登录的用户。 如果用户没有登录，<code>currentUser</code> 则为空：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：<code>currentUser</code> 可能为空，这是因为 auth 对象尚未完成初始化。 如果你使用侦听器跟踪用户登录状态，你将无需处理该情况。</p>\n<h2 id=\"获取用户个人资料\"><a href=\"#获取用户个人资料\" class=\"headerlink\" title=\"获取用户个人资料\"></a>获取用户个人资料</h2><p>要获取用户的个人资料信息，请使用 <code>WDGUser</code> 实例的属性。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *name = user.displayName;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *email = user.email;</div><div class=\"line\">  <span class=\"built_in\">NSURL</span> *photoUrl = user.photoURL;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *uid = user.uid;    </div><div class=\"line\">  <span class=\"comment\">//  The user's ID, unique to the Wilddog project.</span></div><div class=\"line\">  <span class=\"comment\">//  Do NOT use this value to authenticate with</span></div><div class=\"line\">  <span class=\"comment\">//  your backend server, if you have one. Use</span></div><div class=\"line\">  <span class=\"comment\">//  getTokenWithCompletion:completion: instead.    </span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name = user.displayName</div><div class=\"line\">    <span class=\"keyword\">let</span> email = user.email</div><div class=\"line\">    <span class=\"keyword\">let</span> photoUrl = user.photoURL</div><div class=\"line\">    <span class=\"keyword\">let</span> uid = user.id;  </div><div class=\"line\">    <span class=\"comment\">// The user's ID, unique to the Wilddog project.</span></div><div class=\"line\">    <span class=\"comment\">// Do NOT use this value to authenticate with</span></div><div class=\"line\">    <span class=\"comment\">// your backend server, if you have one.Use</span></div><div class=\"line\">    <span class=\"comment\">// getTokenWithCompletion:completion: instead.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"获取用户的其它登录方式的个人资料信息\"><a href=\"#获取用户的其它登录方式的个人资料信息\" class=\"headerlink\" title=\"获取用户的其它登录方式的个人资料信息\"></a>获取用户的其它登录方式的个人资料信息</h2><p>要获取已链接至用户的其它登录方式的个人资料信息，请使用 providerData 属性。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (WDGUserInfo *profile <span class=\"keyword\">in</span> user.providerData) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *providerID = profile.providerID;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *uid = profile.uid;  <span class=\"comment\">// Provider-specific UID</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *name = profile.displayName;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *email = profile.email;</div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *photoURL = profile.photoURL;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> profile <span class=\"keyword\">in</span> user.providerData &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> providerID = profile.providerID</div><div class=\"line\">        <span class=\"keyword\">let</span> uid = profile.uid;  <span class=\"comment\">// Provider-specific UID</span></div><div class=\"line\">        <span class=\"keyword\">let</span> name = profile.displayName</div><div class=\"line\">        <span class=\"keyword\">let</span> email = profile.email</div><div class=\"line\">        <span class=\"keyword\">let</span> photoURL = profile.photoURL</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"更新用户个人资料\"><a href=\"#更新用户个人资料\" class=\"headerlink\" title=\"更新用户个人资料\"></a>更新用户个人资料</h2><p>你可以使用<code>WDGUserProfileChangeRequest</code> 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\">WDGUserProfileChangeRequest *changeRequest = [user profileChangeRequest];</div><div class=\"line\"></div><div class=\"line\">changeRequest.displayName = <span class=\"string\">@\"JianDong. User\"</span>;</div><div class=\"line\">changeRequest.photoURL =</div><div class=\"line\">    [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"https://example.com/jane-q-user/profile.jpg\"</span>];</div><div class=\"line\">[changeRequest commitChangesWithCompletion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Profile updated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = user &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> changeRequest = user.profileChangeRequest()</div><div class=\"line\">    </div><div class=\"line\">    changeRequest.displayName = <span class=\"string\">\"Jane Q. User\"</span></div><div class=\"line\">    changeRequest.photoURL =</div><div class=\"line\">        <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"https://example.com/jane-q-user/profile.jpg\"</span>)</div><div class=\"line\">    changeRequest.commitChangesWithCompletion &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">            <span class=\"comment\">// An error happened.</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Profile updated.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"设置用户的电子邮件地址\"><a href=\"#设置用户的电子邮件地址\" class=\"headerlink\" title=\"设置用户的电子邮件地址\"></a>设置用户的电子邮件地址</h2><p>你可以用 <code>updateEmail:completion:</code> 方法设置用户的电子邮件地址。如果这个用户已经存在邮箱，则更新它，之后需要使用新的邮箱地址进行登录。例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\">[user updateEmail:<span class=\"string\">@\"user@example.com\"</span> completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Email updated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"></div><div class=\"line\">user?.updateEmail(<span class=\"string\">\"user@example.com\"</span>) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Email updated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅 <a href=\"/guide/auth/ios/manageuser.html#对用户重新进行身份认证\">对用户重新进行身份认证</a>。</p>\n<h2 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h2><p>你可以使用 <code>updatePassword:completion:</code> 方法设置用户密码。密码更新成功后，需要使用新的密码进行登录。例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *newPassword = [yourApp getRandomSecurePassword];</div><div class=\"line\"></div><div class=\"line\">[user updatePassword:newPassword completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Password updated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"><span class=\"keyword\">let</span> newPassword = getRandomSecurePassword()</div><div class=\"line\"></div><div class=\"line\">user?.updatePassword(newPassword) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Password updated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"发送重设密码电子邮件\"><a href=\"#发送重设密码电子邮件\" class=\"headerlink\" title=\"发送重设密码电子邮件\"></a>发送重设密码电子邮件</h2><p>你可以用 <code>sendPasswordResetWithEmail:completion:</code> 方法向用户发送一封重设密码电子邮件。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *email = <span class=\"string\">@\"user@example.com\"</span>;</div><div class=\"line\"></div><div class=\"line\">[[WDGAuth auth] sendPasswordResetWithEmail:email</div><div class=\"line\">                                completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Password reset email sent.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> email = <span class=\"string\">\"user@example.com\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.sendPasswordResetWithEmail(email) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Password reset email sent.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>你可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。</p>\n<p>你也可以从 Wilddog 控制面板中发送重设密码电子邮件。</p>\n<h2 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h2><p>你可以使用 <code>deleteWithCompletion</code> 方法删除用户帐户。例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\">[user deleteWithCompletion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Account deleted.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"></div><div class=\"line\">user?.deleteWithCompletion &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Account deleted.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>你可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。</p>\n<p>重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"对用户重新进行身份认证\"><a href=\"#对用户重新进行身份认证\" class=\"headerlink\" title=\"对用户重新进行身份认证\"></a>对用户重新进行身份认证</h2><p>有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。</p>\n<p>如果你执行这些操作之一，而该用户在很久以前登录过，该操作便会失败，显示 <code>WDGAuthErrorCodeCredentialTooOld</code> 错误。</p>\n<p>发生这种错误时，请从用户获取新登录凭据并将该凭据传递到 <code>reauthenticateWithCredential:</code>，对该用户重新进行身份认证。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\">WDGAuthCredential *credential; <span class=\"comment\">// 需要初始化</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prompt the user to re-provide their sign-in credentials</span></div><div class=\"line\"></div><div class=\"line\">[user reauthenticateWithCredential:credential completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// User re-authenticated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"><span class=\"keyword\">var</span> credential: <span class=\"type\">WDGAuthCredential</span> <span class=\"comment\">// 需要初始化</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prompt the user to re-provide their sign-in credentials</span></div><div class=\"line\"></div><div class=\"line\">user?.reauthenticateWithCredential(credential) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// User re-authenticated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h2 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h2><p>通过调用 <code>createUserWithEmail:password:completion:</code> 方法或首次使用第三方登录方式（如 QQ Sign-In 或 WeiXin Login）登录一个用户，就可以在你的 Wilddog 项目中创建一个新用户。</p>\n<p>你也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。</p>\n<h2 id=\"获取当前登录的用户\"><a href=\"#获取当前登录的用户\" class=\"headerlink\" title=\"获取当前登录的用户\"></a>获取当前登录的用户</h2><p>获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>]; addAuthStateDidChangeListener:^(WDGAuth *_Nonnull auth,</div><div class=\"line\">                                                WDGUser *_Nullable user) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.addAuthStateDidChangeListener&#123; auth, user <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = user &#123;</div><div class=\"line\">        <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用侦听器可保证在你获取当前用户时 Auth 对象不会处于中间状态如初始化。</p>\n<p>你也可以使用 <code>currentUser</code> 属性获取当前已登录的用户。 如果用户没有登录，<code>currentUser</code> 则为空：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser &#123;</div><div class=\"line\">    <span class=\"comment\">// User is signed in.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：<code>currentUser</code> 可能为空，这是因为 auth 对象尚未完成初始化。 如果你使用侦听器跟踪用户登录状态，你将无需处理该情况。</p>\n<h2 id=\"获取用户个人资料\"><a href=\"#获取用户个人资料\" class=\"headerlink\" title=\"获取用户个人资料\"></a>获取用户个人资料</h2><p>要获取用户的个人资料信息，请使用 <code>WDGUser</code> 实例的属性。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *name = user.displayName;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *email = user.email;</div><div class=\"line\">  <span class=\"built_in\">NSURL</span> *photoUrl = user.photoURL;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *uid = user.uid;    </div><div class=\"line\">  <span class=\"comment\">//  The user's ID, unique to the Wilddog project.</span></div><div class=\"line\">  <span class=\"comment\">//  Do NOT use this value to authenticate with</span></div><div class=\"line\">  <span class=\"comment\">//  your backend server, if you have one. Use</span></div><div class=\"line\">  <span class=\"comment\">//  getTokenWithCompletion:completion: instead.    </span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name = user.displayName</div><div class=\"line\">    <span class=\"keyword\">let</span> email = user.email</div><div class=\"line\">    <span class=\"keyword\">let</span> photoUrl = user.photoURL</div><div class=\"line\">    <span class=\"keyword\">let</span> uid = user.id;  </div><div class=\"line\">    <span class=\"comment\">// The user's ID, unique to the Wilddog project.</span></div><div class=\"line\">    <span class=\"comment\">// Do NOT use this value to authenticate with</span></div><div class=\"line\">    <span class=\"comment\">// your backend server, if you have one.Use</span></div><div class=\"line\">    <span class=\"comment\">// getTokenWithCompletion:completion: instead.</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"获取用户的其它登录方式的个人资料信息\"><a href=\"#获取用户的其它登录方式的个人资料信息\" class=\"headerlink\" title=\"获取用户的其它登录方式的个人资料信息\"></a>获取用户的其它登录方式的个人资料信息</h2><p>要获取已链接至用户的其它登录方式的个人资料信息，请使用 providerData 属性。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (user != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">  <span class=\"keyword\">for</span> (WDGUserInfo *profile <span class=\"keyword\">in</span> user.providerData) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *providerID = profile.providerID;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *uid = profile.uid;  <span class=\"comment\">// Provider-specific UID</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *name = profile.displayName;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *email = profile.email;</div><div class=\"line\">    <span class=\"built_in\">NSURL</span> *photoURL = profile.photoURL;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> profile <span class=\"keyword\">in</span> user.providerData &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> providerID = profile.providerID</div><div class=\"line\">        <span class=\"keyword\">let</span> uid = profile.uid;  <span class=\"comment\">// Provider-specific UID</span></div><div class=\"line\">        <span class=\"keyword\">let</span> name = profile.displayName</div><div class=\"line\">        <span class=\"keyword\">let</span> email = profile.email</div><div class=\"line\">        <span class=\"keyword\">let</span> photoURL = profile.photoURL</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// No user is signed in.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"更新用户个人资料\"><a href=\"#更新用户个人资料\" class=\"headerlink\" title=\"更新用户个人资料\"></a>更新用户个人资料</h2><p>你可以使用<code>WDGUserProfileChangeRequest</code> 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\">WDGUserProfileChangeRequest *changeRequest = [user profileChangeRequest];</div><div class=\"line\"></div><div class=\"line\">changeRequest.displayName = <span class=\"string\">@\"JianDong. User\"</span>;</div><div class=\"line\">changeRequest.photoURL =</div><div class=\"line\">    [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"https://example.com/jane-q-user/profile.jpg\"</span>];</div><div class=\"line\">[changeRequest commitChangesWithCompletion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Profile updated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> user = user &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> changeRequest = user.profileChangeRequest()</div><div class=\"line\">    </div><div class=\"line\">    changeRequest.displayName = <span class=\"string\">\"Jane Q. User\"</span></div><div class=\"line\">    changeRequest.photoURL =</div><div class=\"line\">        <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"https://example.com/jane-q-user/profile.jpg\"</span>)</div><div class=\"line\">    changeRequest.commitChangesWithCompletion &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">            <span class=\"comment\">// An error happened.</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Profile updated.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"设置用户的电子邮件地址\"><a href=\"#设置用户的电子邮件地址\" class=\"headerlink\" title=\"设置用户的电子邮件地址\"></a>设置用户的电子邮件地址</h2><p>你可以用 <code>updateEmail:completion:</code> 方法设置用户的电子邮件地址。如果这个用户已经存在邮箱，则更新它，之后需要使用新的邮箱地址进行登录。例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\">[user updateEmail:<span class=\"string\">@\"user@example.com\"</span> completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Email updated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"></div><div class=\"line\">user?.updateEmail(<span class=\"string\">\"user@example.com\"</span>) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Email updated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅 <a href=\"/guide/auth/ios/manageuser.html#对用户重新进行身份认证\">对用户重新进行身份认证</a>。</p>\n<h2 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h2><p>你可以使用 <code>updatePassword:completion:</code> 方法设置用户密码。密码更新成功后，需要使用新的密码进行登录。例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *newPassword = [yourApp getRandomSecurePassword];</div><div class=\"line\"></div><div class=\"line\">[user updatePassword:newPassword completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Password updated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"><span class=\"keyword\">let</span> newPassword = getRandomSecurePassword()</div><div class=\"line\"></div><div class=\"line\">user?.updatePassword(newPassword) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Password updated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重要说明：要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"发送重设密码电子邮件\"><a href=\"#发送重设密码电子邮件\" class=\"headerlink\" title=\"发送重设密码电子邮件\"></a>发送重设密码电子邮件</h2><p>你可以用 <code>sendPasswordResetWithEmail:completion:</code> 方法向用户发送一封重设密码电子邮件。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *email = <span class=\"string\">@\"user@example.com\"</span>;</div><div class=\"line\"></div><div class=\"line\">[[WDGAuth auth] sendPasswordResetWithEmail:email</div><div class=\"line\">                                completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Password reset email sent.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> email = <span class=\"string\">\"user@example.com\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.sendPasswordResetWithEmail(email) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Password reset email sent.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>你可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。</p>\n<p>你也可以从 Wilddog 控制面板中发送重设密码电子邮件。</p>\n<h2 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h2><p>你可以使用 <code>deleteWithCompletion</code> 方法删除用户帐户。例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\"></div><div class=\"line\">[user deleteWithCompletion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Account deleted.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"></div><div class=\"line\">user?.deleteWithCompletion &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Account deleted.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>你可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。</p>\n<p>重要说明：要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。</p>\n<h2 id=\"对用户重新进行身份认证\"><a href=\"#对用户重新进行身份认证\" class=\"headerlink\" title=\"对用户重新进行身份认证\"></a>对用户重新进行身份认证</h2><p>有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。</p>\n<p>如果你执行这些操作之一，而该用户在很久以前登录过，该操作便会失败，显示 <code>WDGAuthErrorCodeCredentialTooOld</code> 错误。</p>\n<p>发生这种错误时，请从用户获取新登录凭据并将该凭据传递到 <code>reauthenticateWithCredential:</code>，对该用户重新进行身份认证。 例如：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *user = [WDGAuth auth].currentUser;</div><div class=\"line\">WDGAuthCredential *credential; <span class=\"comment\">// 需要初始化</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prompt the user to re-provide their sign-in credentials</span></div><div class=\"line\"></div><div class=\"line\">[user reauthenticateWithCredential:credential completion:^(<span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"comment\">// An error happened.</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// User re-authenticated.</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser</div><div class=\"line\"><span class=\"keyword\">var</span> credential: <span class=\"type\">WDGAuthCredential</span> <span class=\"comment\">// 需要初始化</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Prompt the user to re-provide their sign-in credentials</span></div><div class=\"line\"></div><div class=\"line\">user?.reauthenticateWithCredential(credential) &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</div><div class=\"line\">        <span class=\"comment\">// An error happened.</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// User re-authenticated.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n"},{"title":"绑定多种登录方式","_content":"\n通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。\n\n\n## 开始前的准备工作\n在野狗控制面板中打开多种登录方式（可以是匿名登录）。\n    \n## 给帐号链接多种登录方式\n完成以下步骤为已有帐号添加多种登录方式：  \n1. 以任意一种登录方式登录一个帐号。  \n2. 准备一个未在你的应用上登录过的邮箱或者第三方登录方式。  \n3. 通过一种登录方式获取 WDGAuthCredential：登录凭据。  \n\n##### QQ 登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];\n```\nSwift\n```swift\nlet credential = WDGQQAuthProvider.credentialWithAccessToken(qqOAuth.accessToken)\n\n```\n##### 微信登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];\n```\nSwift\n```swift\nlet credential = WDGWeiXinAuthProvider.credentialWithCode(weixinOAuth.code)\n\n```\n##### 微博登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken \n                   userID:sinaOAuth.userID];\n```\n\nSwift\n```swift\nlet credential = WDGSinaAuthProvider.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)\n\n```\n##### 邮箱登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential =\n    [WDGEmailPasswordAuthProvider credentialWithEmail:email\n                                             password:password];\n```\n\nSwift\n```swift\nlet credential = WDGEmailPasswordAuthProvider.credentialWithEmail(email, password: password)\n\n```\n\n4.使用 `linkWithCredential:completion:` 方法来完成完成链接，如果链接的凭据已经链接到其它帐号上，则会返回失败：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n[auth.currentUser linkWithCredential:credential\n                                      completion:^(WDGUser *_Nullable user,\n                                                   NSError *_Nullable error) {\n                                          // ...\n                                        }];\n```\n\nSwift\n```swift\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser?.linkWithCredential(credential, completion: { (user, error) in\n    // ...\n})\n\n```\n\n如果调用 `linkWithCredential:completion:` 方法成功，被链接的帐号就可以访问这个帐号的数据了。\n\n## 解除一种登录方式\n如果不想再使用某种登录方式，你可以解除链接。\n\n为帐号解除登录方式，通过传递参数 provider ID 给 `unlinkFromProvider:completion:` 方法，你可以从 `providerData` 属性中获取到 provider ID。\n\nObjective-C\n```objectivec\nWDGUser *currentUser = [WDGAuth authWithAppID:@\"your-appid\"].currentUser;\n[currentUser unlinkFromProvider:providerId\n                     completion:^(WDGUser *user, NSError *error) {\n                       if (error == nil) {\n                         // Provider unlinked from account\n                       }\n                     }];\n```\n\nSwift\n```swift\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser?.unlinkFromProvider(providerId, completion: { (user, error) in\n    // ...\n})\n\n```\n","source":"guide/auth/ios/link.md","raw":"title: 绑定多种登录方式\n---\n\n通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。\n\n\n## 开始前的准备工作\n在野狗控制面板中打开多种登录方式（可以是匿名登录）。\n    \n## 给帐号链接多种登录方式\n完成以下步骤为已有帐号添加多种登录方式：  \n1. 以任意一种登录方式登录一个帐号。  \n2. 准备一个未在你的应用上登录过的邮箱或者第三方登录方式。  \n3. 通过一种登录方式获取 WDGAuthCredential：登录凭据。  \n\n##### QQ 登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];\n```\nSwift\n```swift\nlet credential = WDGQQAuthProvider.credentialWithAccessToken(qqOAuth.accessToken)\n\n```\n##### 微信登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];\n```\nSwift\n```swift\nlet credential = WDGWeiXinAuthProvider.credentialWithCode(weixinOAuth.code)\n\n```\n##### 微博登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken \n                   userID:sinaOAuth.userID];\n```\n\nSwift\n```swift\nlet credential = WDGSinaAuthProvider.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)\n\n```\n##### 邮箱登录\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential =\n    [WDGEmailPasswordAuthProvider credentialWithEmail:email\n                                             password:password];\n```\n\nSwift\n```swift\nlet credential = WDGEmailPasswordAuthProvider.credentialWithEmail(email, password: password)\n\n```\n\n4.使用 `linkWithCredential:completion:` 方法来完成完成链接，如果链接的凭据已经链接到其它帐号上，则会返回失败：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n[auth.currentUser linkWithCredential:credential\n                                      completion:^(WDGUser *_Nullable user,\n                                                   NSError *_Nullable error) {\n                                          // ...\n                                        }];\n```\n\nSwift\n```swift\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser?.linkWithCredential(credential, completion: { (user, error) in\n    // ...\n})\n\n```\n\n如果调用 `linkWithCredential:completion:` 方法成功，被链接的帐号就可以访问这个帐号的数据了。\n\n## 解除一种登录方式\n如果不想再使用某种登录方式，你可以解除链接。\n\n为帐号解除登录方式，通过传递参数 provider ID 给 `unlinkFromProvider:completion:` 方法，你可以从 `providerData` 属性中获取到 provider ID。\n\nObjective-C\n```objectivec\nWDGUser *currentUser = [WDGAuth authWithAppID:@\"your-appid\"].currentUser;\n[currentUser unlinkFromProvider:providerId\n                     completion:^(WDGUser *user, NSError *error) {\n                       if (error == nil) {\n                         // Provider unlinked from account\n                       }\n                     }];\n```\n\nSwift\n```swift\nWDGAuth.auth(appID: \"your-wilddog-appid\")?.currentUser?.unlinkFromProvider(providerId, completion: { (user, error) in\n    // ...\n})\n\n```\n","date":"2016-09-06T03:38:22.525Z","updated":"2016-09-06T03:38:22.525Z","path":"guide/auth/ios/link.html","comments":1,"layout":"page","_id":"cisswi9l10012z4fwa5pmt30l","content":"<p>通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>在野狗控制面板中打开多种登录方式（可以是匿名登录）。</p>\n<h2 id=\"给帐号链接多种登录方式\"><a href=\"#给帐号链接多种登录方式\" class=\"headerlink\" title=\"给帐号链接多种登录方式\"></a>给帐号链接多种登录方式</h2><p>完成以下步骤为已有帐号添加多种登录方式：  </p>\n<ol>\n<li>以任意一种登录方式登录一个帐号。  </li>\n<li>准备一个未在你的应用上登录过的邮箱或者第三方登录方式。  </li>\n<li>通过一种登录方式获取 WDGAuthCredential：登录凭据。  </li>\n</ol>\n<h5 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGQQAuthProvider</span>.credentialWithAccessToken(qqOAuth.accessToken)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGWeiXinAuthProvider</span>.credentialWithCode(weixinOAuth.code)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken </div><div class=\"line\">                   userID:sinaOAuth.userID];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGSinaAuthProvider</span>.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)</div></pre></td></tr></table></figure></p>\n<h5 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential =</div><div class=\"line\">    [WDGEmailPasswordAuthProvider credentialWithEmail:email</div><div class=\"line\">                                             password:password];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGEmailPasswordAuthProvider</span>.credentialWithEmail(email, password: password)</div></pre></td></tr></table></figure></p>\n<p>4.使用 <code>linkWithCredential:completion:</code> 方法来完成完成链接，如果链接的凭据已经链接到其它帐号上，则会返回失败：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div><div class=\"line\">[auth.currentUser linkWithCredential:credential</div><div class=\"line\">                                      completion:^(WDGUser *_Nullable user,</div><div class=\"line\">                                                   <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">                                          <span class=\"comment\">// ...</span></div><div class=\"line\">                                        &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser?.linkWithCredential(credential, completion: &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>如果调用 <code>linkWithCredential:completion:</code> 方法成功，被链接的帐号就可以访问这个帐号的数据了。</p>\n<h2 id=\"解除一种登录方式\"><a href=\"#解除一种登录方式\" class=\"headerlink\" title=\"解除一种登录方式\"></a>解除一种登录方式</h2><p>如果不想再使用某种登录方式，你可以解除链接。</p>\n<p>为帐号解除登录方式，通过传递参数 provider ID 给 <code>unlinkFromProvider:completion:</code> 方法，你可以从 <code>providerData</code> 属性中获取到 provider ID。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *currentUser = [WDGAuth authWithAppID:<span class=\"string\">@\"your-appid\"</span>].currentUser;</div><div class=\"line\">[currentUser unlinkFromProvider:providerId</div><div class=\"line\">                     completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                       <span class=\"keyword\">if</span> (error == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">                         <span class=\"comment\">// Provider unlinked from account</span></div><div class=\"line\">                       &#125;</div><div class=\"line\">                     &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser?.unlinkFromProvider(providerId, completion: &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>通过链接功能，你可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>在野狗控制面板中打开多种登录方式（可以是匿名登录）。</p>\n<h2 id=\"给帐号链接多种登录方式\"><a href=\"#给帐号链接多种登录方式\" class=\"headerlink\" title=\"给帐号链接多种登录方式\"></a>给帐号链接多种登录方式</h2><p>完成以下步骤为已有帐号添加多种登录方式：  </p>\n<ol>\n<li>以任意一种登录方式登录一个帐号。  </li>\n<li>准备一个未在你的应用上登录过的邮箱或者第三方登录方式。  </li>\n<li>通过一种登录方式获取 WDGAuthCredential：登录凭据。  </li>\n</ol>\n<h5 id=\"QQ-登录\"><a href=\"#QQ-登录\" class=\"headerlink\" title=\"QQ 登录\"></a>QQ 登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGQQAuthProvider credentialWithAccessToken:qqOAuth.accessToken];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGQQAuthProvider</span>.credentialWithAccessToken(qqOAuth.accessToken)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微信登录\"><a href=\"#微信登录\" class=\"headerlink\" title=\"微信登录\"></a>微信登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGWeiXinAuthProvider credentialWithCode:weixinOAuth.code];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGWeiXinAuthProvider</span>.credentialWithCode(weixinOAuth.code)</div></pre></td></tr></table></figure></p>\n<h5 id=\"微博登录\"><a href=\"#微博登录\" class=\"headerlink\" title=\"微博登录\"></a>微博登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = [WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken </div><div class=\"line\">                   userID:sinaOAuth.userID];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGSinaAuthProvider</span>.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth.userID)</div></pre></td></tr></table></figure></p>\n<h5 id=\"邮箱登录\"><a href=\"#邮箱登录\" class=\"headerlink\" title=\"邮箱登录\"></a>邮箱登录</h5><p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential =</div><div class=\"line\">    [WDGEmailPasswordAuthProvider credentialWithEmail:email</div><div class=\"line\">                                             password:password];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGEmailPasswordAuthProvider</span>.credentialWithEmail(email, password: password)</div></pre></td></tr></table></figure></p>\n<p>4.使用 <code>linkWithCredential:completion:</code> 方法来完成完成链接，如果链接的凭据已经链接到其它帐号上，则会返回失败：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div><div class=\"line\">[auth.currentUser linkWithCredential:credential</div><div class=\"line\">                                      completion:^(WDGUser *_Nullable user,</div><div class=\"line\">                                                   <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">                                          <span class=\"comment\">// ...</span></div><div class=\"line\">                                        &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser?.linkWithCredential(credential, completion: &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>如果调用 <code>linkWithCredential:completion:</code> 方法成功，被链接的帐号就可以访问这个帐号的数据了。</p>\n<h2 id=\"解除一种登录方式\"><a href=\"#解除一种登录方式\" class=\"headerlink\" title=\"解除一种登录方式\"></a>解除一种登录方式</h2><p>如果不想再使用某种登录方式，你可以解除链接。</p>\n<p>为帐号解除登录方式，通过传递参数 provider ID 给 <code>unlinkFromProvider:completion:</code> 方法，你可以从 <code>providerData</code> 属性中获取到 provider ID。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGUser *currentUser = [WDGAuth authWithAppID:<span class=\"string\">@\"your-appid\"</span>].currentUser;</div><div class=\"line\">[currentUser unlinkFromProvider:providerId</div><div class=\"line\">                     completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                       <span class=\"keyword\">if</span> (error == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">                         <span class=\"comment\">// Provider unlinked from account</span></div><div class=\"line\">                       &#125;</div><div class=\"line\">                     &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)?.currentUser?.unlinkFromProvider(providerId, completion: &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n"},{"title":"邮箱密码登录","_content":"\n你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。\n\n## 开始前的准备工作\n\n1. 将 Wilddog 添加至你的 iOS 项目。将以下 pod 包含在你的 Podfile 中：\n\t\n\t```\n \t pod 'Wilddog/Auth'\n\t```\n2. 在 Wilddog 控制面板中创建一个应用.\n3. 在野狗应用控制面板中打开邮箱登录方式:\n\n    * 在野狗控制面板中选择身份认证选项。\n    * 在｀登录方式｀标签中打开邮箱登录方式。\n\n## 创建基于邮箱密码的帐户\n\n要用邮箱密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：\n\n1、 导入 Wilddog Auth 模块:\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 以 Wilddog AppId 初始化 WDGAuth。\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 通过将该新用户的电子邮件地址和密码传递到 createUserWithEmail:email:password:completion: 来创建新帐户。 \nObjective-C\n```objectivec\n[auth createUserWithEmail:email\n                 password:password\n               completion:^(WDGUser *_Nullable user,\n                          NSError *_Nullable error) {\n                    // ...\n                  }];\n             ```\nSwift\n```swift\nauth?.createUserWithEmail(email, password: password) { (user, error) in\n  // ...\n}\n```\n             \n如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。\n\n## 用电子邮件地址和密码登录一个用户\n\n用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：\n\n1、 导入 Wilddog Auth 模块:\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 以 Wilddog AppId 初始化 WDGAuth。\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 将该用户的电子邮件地址和密码传递到 `signInWithEmail:email:password:completion:`,即可在你应用中登录此用户。\n\nObjective-C\n```objectivec\n[auth signInWithEmail:_emailField.text\n                       password:_passwordField.text\n                     completion:^(WDGUser *user, NSError *error) {\n                       // ...\n                     }];\n```\nSwift\n```swift\nauth?.signInWithEmail(email, password: password) { (user, error) in\n  // ...\n}\n```\n\n如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","source":"guide/auth/ios/password.md","raw":"title: 邮箱密码登录\n---\n\n你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。\n\n## 开始前的准备工作\n\n1. 将 Wilddog 添加至你的 iOS 项目。将以下 pod 包含在你的 Podfile 中：\n\t\n\t```\n \t pod 'Wilddog/Auth'\n\t```\n2. 在 Wilddog 控制面板中创建一个应用.\n3. 在野狗应用控制面板中打开邮箱登录方式:\n\n    * 在野狗控制面板中选择身份认证选项。\n    * 在｀登录方式｀标签中打开邮箱登录方式。\n\n## 创建基于邮箱密码的帐户\n\n要用邮箱密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：\n\n1、 导入 Wilddog Auth 模块:\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 以 Wilddog AppId 初始化 WDGAuth。\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 通过将该新用户的电子邮件地址和密码传递到 createUserWithEmail:email:password:completion: 来创建新帐户。 \nObjective-C\n```objectivec\n[auth createUserWithEmail:email\n                 password:password\n               completion:^(WDGUser *_Nullable user,\n                          NSError *_Nullable error) {\n                    // ...\n                  }];\n             ```\nSwift\n```swift\nauth?.createUserWithEmail(email, password: password) { (user, error) in\n  // ...\n}\n```\n             \n如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。\n\n## 用电子邮件地址和密码登录一个用户\n\n用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：\n\n1、 导入 Wilddog Auth 模块:\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n2、 以 Wilddog AppId 初始化 WDGAuth。\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n3、 将该用户的电子邮件地址和密码传递到 `signInWithEmail:email:password:completion:`,即可在你应用中登录此用户。\n\nObjective-C\n```objectivec\n[auth signInWithEmail:_emailField.text\n                       password:_passwordField.text\n                     completion:^(WDGUser *user, NSError *error) {\n                       // ...\n                     }];\n```\nSwift\n```swift\nauth?.signInWithEmail(email, password: password) { (user, error) in\n  // ...\n}\n```\n\n如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","date":"2016-09-06T03:38:22.526Z","updated":"2016-09-06T03:38:22.526Z","path":"guide/auth/ios/password.html","comments":1,"layout":"page","_id":"cisswi9l10013z4fw3bv8p7dr","content":"<p>你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>将 Wilddog 添加至你的 iOS 项目。将以下 pod 包含在你的 Podfile 中：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 Wilddog 控制面板中创建一个应用.</p>\n</li>\n<li><p>在野狗应用控制面板中打开邮箱登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证选项。</li>\n<li>在｀登录方式｀标签中打开邮箱登录方式。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"创建基于邮箱密码的帐户\"><a href=\"#创建基于邮箱密码的帐户\" class=\"headerlink\" title=\"创建基于邮箱密码的帐户\"></a>创建基于邮箱密码的帐户</h2><p>要用邮箱密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：</p>\n<p>1、 导入 Wilddog Auth 模块:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 以 Wilddog AppId 初始化 WDGAuth。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 通过将该新用户的电子邮件地址和密码传递到 createUserWithEmail:email:password:completion: 来创建新帐户。<br>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth createUserWithEmail:email</div><div class=\"line\">                 password:password</div><div class=\"line\">               completion:^(WDGUser *_Nullable user,</div><div class=\"line\">                          <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">                    <span class=\"comment\">// ...</span></div><div class=\"line\">                  &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.createUserWithEmail(email, password: password) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。</p>\n<h2 id=\"用电子邮件地址和密码登录一个用户\"><a href=\"#用电子邮件地址和密码登录一个用户\" class=\"headerlink\" title=\"用电子邮件地址和密码登录一个用户\"></a>用电子邮件地址和密码登录一个用户</h2><p>用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：</p>\n<p>1、 导入 Wilddog Auth 模块:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 以 Wilddog AppId 初始化 WDGAuth。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 将该用户的电子邮件地址和密码传递到 <code>signInWithEmail:email:password:completion:</code>,即可在你应用中登录此用户。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithEmail:_emailField.text</div><div class=\"line\">                       password:_passwordField.text</div><div class=\"line\">                     completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                       <span class=\"comment\">// ...</span></div><div class=\"line\">                     &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithEmail(email, password: password) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。</p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n","excerpt":"","more":"<p>你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>将 Wilddog 添加至你的 iOS 项目。将以下 pod 包含在你的 Podfile 中：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 Wilddog 控制面板中创建一个应用.</p>\n</li>\n<li><p>在野狗应用控制面板中打开邮箱登录方式:</p>\n<ul>\n<li>在野狗控制面板中选择身份认证选项。</li>\n<li>在｀登录方式｀标签中打开邮箱登录方式。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"创建基于邮箱密码的帐户\"><a href=\"#创建基于邮箱密码的帐户\" class=\"headerlink\" title=\"创建基于邮箱密码的帐户\"></a>创建基于邮箱密码的帐户</h2><p>要用邮箱密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：</p>\n<p>1、 导入 Wilddog Auth 模块:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 以 Wilddog AppId 初始化 WDGAuth。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 通过将该新用户的电子邮件地址和密码传递到 createUserWithEmail:email:password:completion: 来创建新帐户。<br>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth createUserWithEmail:email</div><div class=\"line\">                 password:password</div><div class=\"line\">               completion:^(WDGUser *_Nullable user,</div><div class=\"line\">                          <span class=\"built_in\">NSError</span> *_Nullable error) &#123;</div><div class=\"line\">                    <span class=\"comment\">// ...</span></div><div class=\"line\">                  &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.createUserWithEmail(email, password: password) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。</p>\n<h2 id=\"用电子邮件地址和密码登录一个用户\"><a href=\"#用电子邮件地址和密码登录一个用户\" class=\"headerlink\" title=\"用电子邮件地址和密码登录一个用户\"></a>用电子邮件地址和密码登录一个用户</h2><p>用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：</p>\n<p>1、 导入 Wilddog Auth 模块:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>2、 以 Wilddog AppId 初始化 WDGAuth。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>3、 将该用户的电子邮件地址和密码传递到 <code>signInWithEmail:email:password:completion:</code>,即可在你应用中登录此用户。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithEmail:_emailField.text</div><div class=\"line\">                       password:_passwordField.text</div><div class=\"line\">                     completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                       <span class=\"comment\">// ...</span></div><div class=\"line\">                     &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithEmail(email, password: password) &#123; (user, error) <span class=\"keyword\">in</span></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。</p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n"},{"title":"QQ 登录","_content":"\n通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。\n\n\n## 开始前的准备工作\n1. 创建野狗应用。将下面 pod 添加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n2. 在 [QQ 开放平台管理中心](http://op.open.qq.com/ios_appinfov2/detail?appid=111)，获取应用的 **App ID** 和 **App Secret**。\n3. 在野狗控制面板中打开 QQ 登录方式:\n  * 在野狗控制面板中选择 ”身份认证“->登录方式。\n  * 点击 QQ 登录开关，点击配置，输入 QQ 帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n1、 参考 [QQ API 调用说明](http://wiki.open.qq.com/wiki/IOS_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E) 将 QQ 登录集成到认证的应用中。当初始化 `TencentOAuth` 对象时，设置 delegate 来接收登录和登出事件:\n\nObjective-C\n```objectivec\n_qqOAuth = [[TencentOAuth alloc] initWithAppId:@\"your QQ App ID\"\n                                   andDelegate:self];\nNSArray *_permissions =  [NSArray arrayWithObjects:@\"get_user_info\", @\"get_simple_userinfo\", @\"add_t\", nil];\n[qqOAuth authorize:_permissions inSafari:NO];\n```\nSwift\n```swift\nlet tencentOAuth = TencentOAuth(appId:\"tencent-appId\", andDelegate: self)\nlet permissions = [\"get_user_info\", \"get_simple_userinfo\", \"add_t\"]\ntencentOAuth.authorize(permissions, inSafari: false)\n```\n\n在你的 delegate 中，实现 `tencentDidLogin` 方法。\n\nObjective-C\n```objectivec\n- (void)tencentDidLogin {\n    // ...\n}\n```\nSwift\n```swift\nfunc tencentDidLogin() {\n   // ...     \n}\n```\n关于 swift 的配置，可在你应用的 project-Bridging-Header.h 文件中，添加以下内容：\n\n\t#import <TencentOpenAPI/TencentOAuth.h>\n如果你的项目没有 project-Bridging-Header.h 文件，则可通过 Objective-C 文件添加创建一个 .h 到你的应用。 最简单的方式是将一个 .m 文件拖放到你的项目中 — 此操作将创建桥接标头并将你的项目配置为使用该标头 — 然后删除该 .m 文件。 请参阅 [同一项目中的 Swift 和 Objective-C](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID156)。\n\n\n2、 导入 WilddogAuth 模块：\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n3、 初始化 `WDGAuth` 对象： \n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n4、 QQ 登录成功后，在 `tencentDidLogin` 方法中通过 _qqOAuth 对象获取 QQ access token 来生成 Wilddog 凭据：\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = \n[WDGQQAuthProvider credentialWithAccessToken:_qqOAuth.accessToken];\n```\nSwift\n```swift\nlet credential = WDGQQAuthProvider.credentialWithAccessToken(qqOAuth?.accessToken)\n```\n\n5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\nObjective-C\n```objectivec\n[auth signInWithCredential:credential\n                completion:^(WDGUser *user, NSError *error) {\n                            // ...\n                          }];\n```\nSwift\n```swift\nauth?.signInWithCredential(credential){(user, error) in\n    // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。\n","source":"guide/auth/ios/qq.md","raw":"title: QQ 登录\n---\n\n通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。\n\n\n## 开始前的准备工作\n1. 创建野狗应用。将下面 pod 添加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n2. 在 [QQ 开放平台管理中心](http://op.open.qq.com/ios_appinfov2/detail?appid=111)，获取应用的 **App ID** 和 **App Secret**。\n3. 在野狗控制面板中打开 QQ 登录方式:\n  * 在野狗控制面板中选择 ”身份认证“->登录方式。\n  * 点击 QQ 登录开关，点击配置，输入 QQ 帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n1、 参考 [QQ API 调用说明](http://wiki.open.qq.com/wiki/IOS_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E) 将 QQ 登录集成到认证的应用中。当初始化 `TencentOAuth` 对象时，设置 delegate 来接收登录和登出事件:\n\nObjective-C\n```objectivec\n_qqOAuth = [[TencentOAuth alloc] initWithAppId:@\"your QQ App ID\"\n                                   andDelegate:self];\nNSArray *_permissions =  [NSArray arrayWithObjects:@\"get_user_info\", @\"get_simple_userinfo\", @\"add_t\", nil];\n[qqOAuth authorize:_permissions inSafari:NO];\n```\nSwift\n```swift\nlet tencentOAuth = TencentOAuth(appId:\"tencent-appId\", andDelegate: self)\nlet permissions = [\"get_user_info\", \"get_simple_userinfo\", \"add_t\"]\ntencentOAuth.authorize(permissions, inSafari: false)\n```\n\n在你的 delegate 中，实现 `tencentDidLogin` 方法。\n\nObjective-C\n```objectivec\n- (void)tencentDidLogin {\n    // ...\n}\n```\nSwift\n```swift\nfunc tencentDidLogin() {\n   // ...     \n}\n```\n关于 swift 的配置，可在你应用的 project-Bridging-Header.h 文件中，添加以下内容：\n\n\t#import <TencentOpenAPI/TencentOAuth.h>\n如果你的项目没有 project-Bridging-Header.h 文件，则可通过 Objective-C 文件添加创建一个 .h 到你的应用。 最简单的方式是将一个 .m 文件拖放到你的项目中 — 此操作将创建桥接标头并将你的项目配置为使用该标头 — 然后删除该 .m 文件。 请参阅 [同一项目中的 Swift 和 Objective-C](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID156)。\n\n\n2、 导入 WilddogAuth 模块：\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n3、 初始化 `WDGAuth` 对象： \n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n4、 QQ 登录成功后，在 `tencentDidLogin` 方法中通过 _qqOAuth 对象获取 QQ access token 来生成 Wilddog 凭据：\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = \n[WDGQQAuthProvider credentialWithAccessToken:_qqOAuth.accessToken];\n```\nSwift\n```swift\nlet credential = WDGQQAuthProvider.credentialWithAccessToken(qqOAuth?.accessToken)\n```\n\n5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\nObjective-C\n```objectivec\n[auth signInWithCredential:credential\n                completion:^(WDGUser *user, NSError *error) {\n                            // ...\n                          }];\n```\nSwift\n```swift\nauth?.signInWithCredential(credential){(user, error) in\n    // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。\n","date":"2016-09-06T03:38:22.527Z","updated":"2016-09-06T03:38:22.527Z","path":"guide/auth/ios/qq.html","comments":1,"layout":"page","_id":"cisswi9l10014z4fwg2m6t6nz","content":"<p>通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>创建野狗应用。将下面 pod 添加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 <a href=\"http://op.open.qq.com/ios_appinfov2/detail?appid=111\" target=\"_blank\" rel=\"external\">QQ 开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li>在野狗控制面板中打开 QQ 登录方式:<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击 QQ 登录开关，点击配置，输入 QQ 帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 参考 <a href=\"http://wiki.open.qq.com/wiki/IOS_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E\" target=\"_blank\" rel=\"external\">QQ API 调用说明</a> 将 QQ 登录集成到认证的应用中。当初始化 <code>TencentOAuth</code> 对象时，设置 delegate 来接收登录和登出事件:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">_qqOAuth = [[TencentOAuth alloc] initWithAppId:<span class=\"string\">@\"your QQ App ID\"</span></div><div class=\"line\">                                   andDelegate:<span class=\"keyword\">self</span>];</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *_permissions =  [<span class=\"built_in\">NSArray</span> arrayWithObjects:<span class=\"string\">@\"get_user_info\"</span>, <span class=\"string\">@\"get_simple_userinfo\"</span>, <span class=\"string\">@\"add_t\"</span>, <span class=\"literal\">nil</span>];</div><div class=\"line\">[qqOAuth authorize:_permissions inSafari:<span class=\"literal\">NO</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tencentOAuth = <span class=\"type\">TencentOAuth</span>(appId:<span class=\"string\">\"tencent-appId\"</span>, andDelegate: <span class=\"keyword\">self</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> permissions = [<span class=\"string\">\"get_user_info\"</span>, <span class=\"string\">\"get_simple_userinfo\"</span>, <span class=\"string\">\"add_t\"</span>]</div><div class=\"line\">tencentOAuth.authorize(permissions, inSafari: <span class=\"literal\">false</span>)</div></pre></td></tr></table></figure></p>\n<p>在你的 delegate 中，实现 <code>tencentDidLogin</code> 方法。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tencentDidLogin &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tencentDidLogin</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">   <span class=\"comment\">// ...     </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>关于 swift 的配置，可在你应用的 project-Bridging-Header.h 文件中，添加以下内容：</p>\n<pre><code>#import &lt;TencentOpenAPI/TencentOAuth.h&gt;\n</code></pre><p>如果你的项目没有 project-Bridging-Header.h 文件，则可通过 Objective-C 文件添加创建一个 .h 到你的应用。 最简单的方式是将一个 .m 文件拖放到你的项目中 — 此操作将创建桥接标头并将你的项目配置为使用该标头 — 然后删除该 .m 文件。 请参阅 <a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID156\" target=\"_blank\" rel=\"external\">同一项目中的 Swift 和 Objective-C</a>。</p>\n<p>2、 导入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>3、 初始化 <code>WDGAuth</code> 对象： </p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>4、 QQ 登录成功后，在 <code>tencentDidLogin</code> 方法中通过 _qqOAuth 对象获取 QQ access token 来生成 Wilddog 凭据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = </div><div class=\"line\">[WDGQQAuthProvider credentialWithAccessToken:_qqOAuth.accessToken];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGQQAuthProvider</span>.credentialWithAccessToken(qqOAuth?.accessToken)</div></pre></td></tr></table></figure></p>\n<p>5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCredential:credential</div><div class=\"line\">                completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                            <span class=\"comment\">// ...</span></div><div class=\"line\">                          &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCredential(credential)&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n","excerpt":"","more":"<p>通过集成 QQ 登录，你可以让你的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>创建野狗应用。将下面 pod 添加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 <a href=\"http://op.open.qq.com/ios_appinfov2/detail?appid=111\">QQ 开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li>在野狗控制面板中打开 QQ 登录方式:<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击 QQ 登录开关，点击配置，输入 QQ 帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 参考 <a href=\"http://wiki.open.qq.com/wiki/IOS_API%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E\">QQ API 调用说明</a> 将 QQ 登录集成到认证的应用中。当初始化 <code>TencentOAuth</code> 对象时，设置 delegate 来接收登录和登出事件:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">_qqOAuth = [[TencentOAuth alloc] initWithAppId:<span class=\"string\">@\"your QQ App ID\"</span></div><div class=\"line\">                                   andDelegate:<span class=\"keyword\">self</span>];</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *_permissions =  [<span class=\"built_in\">NSArray</span> arrayWithObjects:<span class=\"string\">@\"get_user_info\"</span>, <span class=\"string\">@\"get_simple_userinfo\"</span>, <span class=\"string\">@\"add_t\"</span>, <span class=\"literal\">nil</span>];</div><div class=\"line\">[qqOAuth authorize:_permissions inSafari:<span class=\"literal\">NO</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tencentOAuth = <span class=\"type\">TencentOAuth</span>(appId:<span class=\"string\">\"tencent-appId\"</span>, andDelegate: <span class=\"keyword\">self</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> permissions = [<span class=\"string\">\"get_user_info\"</span>, <span class=\"string\">\"get_simple_userinfo\"</span>, <span class=\"string\">\"add_t\"</span>]</div><div class=\"line\">tencentOAuth.authorize(permissions, inSafari: <span class=\"literal\">false</span>)</div></pre></td></tr></table></figure></p>\n<p>在你的 delegate 中，实现 <code>tencentDidLogin</code> 方法。</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tencentDidLogin &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tencentDidLogin</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">   <span class=\"comment\">// ...     </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>关于 swift 的配置，可在你应用的 project-Bridging-Header.h 文件中，添加以下内容：</p>\n<pre><code>#import &lt;TencentOpenAPI/TencentOAuth.h&gt;\n</code></pre><p>如果你的项目没有 project-Bridging-Header.h 文件，则可通过 Objective-C 文件添加创建一个 .h 到你的应用。 最简单的方式是将一个 .m 文件拖放到你的项目中 — 此操作将创建桥接标头并将你的项目配置为使用该标头 — 然后删除该 .m 文件。 请参阅 <a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID156\">同一项目中的 Swift 和 Objective-C</a>。</p>\n<p>2、 导入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>3、 初始化 <code>WDGAuth</code> 对象： </p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>4、 QQ 登录成功后，在 <code>tencentDidLogin</code> 方法中通过 _qqOAuth 对象获取 QQ access token 来生成 Wilddog 凭据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = </div><div class=\"line\">[WDGQQAuthProvider credentialWithAccessToken:_qqOAuth.accessToken];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGQQAuthProvider</span>.credentialWithAccessToken(qqOAuth?.accessToken)</div></pre></td></tr></table></figure></p>\n<p>5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCredential:credential</div><div class=\"line\">                completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                            <span class=\"comment\">// ...</span></div><div class=\"line\">                          &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCredential(credential)&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n"},{"title":"新浪微博登录","_content":"\n通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n1. 创建野狗应用。将下面 pod 添加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n2. 在 [新浪微博开放平台管理中心](http://open.weibo.com/apps)，获取应用的 **App Key** 和 **App Secret**。\n3. 在野狗控制面板中打开新浪微博登录方式:\n  * 在野狗控制面板中选择 ”身份认证“->登录方式。\n  * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n1、 参考 [新浪微博 iOS 接入指南](https://github.com/sinaweibosdk/weibo_ios_sdk) 将新浪微博登录集成到你的应用中。在 AppDelegate 的 `application: openURL: options:` 方法中设置 delegate 来接收网络事件:\n\nObjective-C\n```objectivec\n - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n {\n     if([url.absoluteString hasPrefix:@\"wb\"]) {\n        return [WeiboSDK handleOpenURL:url delegate:self];\n     }\n     return NO;\n }\n```\n\nSwift\n```swift\nfunc application(app: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -> Bool {\n    if url.absoluteString.hasPrefix(\"wb\") {\n        return WeiboSDK.handleOpenURL(url, delegate: self)\n    }\n}\n```\n\n调用新浪微博的授权代码：\n\nObjective-C\n```objectivec\n WBAuthorizeRequest *request = [WBAuthorizeRequest request];\n request.redirectURI = @\"https://api.weibo.com/oauth2/default.html\";\n request.scope = @\"all\";\n request.userInfo = @{@\"SSO_From\": @\"SendMessageToWeiboViewController\",\n                      @\"Other_Info_1\": [NSNumber numberWithInt:123],\n                      @\"Other_Info_2\": @[@\"obj1\", @\"obj2\"],\n                      @\"Other_Info_3\": @{@\"key1\": @\"obj1\", @\"key2\": @\"obj2\"}};\n    \n [WeiboSDK sendRequest:request];\n```\nSwift\n```swift\nlet request = WBAuthorizeRequest.request() as! WBAuthorizeRequest\nrequest.redirectURI = \"https://api.weibo.com/oauth2/default.html\"\nrequest.scope = \"all\"\nrequest.userInfo = [\"SSO_From\": \"SendMessageToWeiboViewController\",\n                    \"Other_Info_1\": NSNumber(int: Int32(123)),\n                    \"Other_Info_2\": [\"obj1\", \"obj2\"],\n                    \"Other_Info_3\": [\"key1\": \"obj1\", \"key2\": \"obj2\"]]\nWeiboSDK.sendRequest(request)\n```\n\n在你的 delegate 中，实现 `didReceiveWeiboResponse:` 方法，并从中获取用户登录的 accessToken 和 userID：\n\nObjective-C\n```objectivec\n - (void)didReceiveWeiboResponse:(WBBaseResponse *)response\n{\n    if ([response isKindOfClass:WBAuthorizeResponse.class])\n    {\n        WBAuthorizeResponse *authResponse = (WBAuthorizeResponse *)response;\n        NSString *accessToken = authResponse.accessToken;\n        NSString *openId = authResponse.userID;\n    }\n}\n```\nSwift\n```swift\nfunc didReceiveWeiboResponse(response: WBBaseResponse!){\n    if response is WBAuthorizeResponse{\n        let authResponse = response as! WBAuthorizeResponse\n        let accessToken = authResponse.accessToken\n        let openId = authResponse.userID\n    }\n}\n```\n\n2、 导入 WilddogAuth 模块：\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n\n3、 初始化 `WDGAuth` 对象：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n\n4、 新浪微博登录成功后，在 `didReceiveWeiboResponse:` 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = \n[WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken userID:userID];\n```\nSwift\n```swift\nlet credential = WDGSinaAuthProvider.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth?.userID)\n```\n\n5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\nObjective-C\n```objectivec\n[auth signInWithCredential:credential\n                completion:^(WDGUser *user, NSError *error) {\n                            // ...\n                          }];\n```\nSwift\n```swift\nauth?.signInWithCredential(credential){(user, error) in\n    // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","source":"guide/auth/ios/weibo.md","raw":"title: 新浪微博登录\n---\n\n通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n1. 创建野狗应用。将下面 pod 添加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n2. 在 [新浪微博开放平台管理中心](http://open.weibo.com/apps)，获取应用的 **App Key** 和 **App Secret**。\n3. 在野狗控制面板中打开新浪微博登录方式:\n  * 在野狗控制面板中选择 ”身份认证“->登录方式。\n  * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n1、 参考 [新浪微博 iOS 接入指南](https://github.com/sinaweibosdk/weibo_ios_sdk) 将新浪微博登录集成到你的应用中。在 AppDelegate 的 `application: openURL: options:` 方法中设置 delegate 来接收网络事件:\n\nObjective-C\n```objectivec\n - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n {\n     if([url.absoluteString hasPrefix:@\"wb\"]) {\n        return [WeiboSDK handleOpenURL:url delegate:self];\n     }\n     return NO;\n }\n```\n\nSwift\n```swift\nfunc application(app: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -> Bool {\n    if url.absoluteString.hasPrefix(\"wb\") {\n        return WeiboSDK.handleOpenURL(url, delegate: self)\n    }\n}\n```\n\n调用新浪微博的授权代码：\n\nObjective-C\n```objectivec\n WBAuthorizeRequest *request = [WBAuthorizeRequest request];\n request.redirectURI = @\"https://api.weibo.com/oauth2/default.html\";\n request.scope = @\"all\";\n request.userInfo = @{@\"SSO_From\": @\"SendMessageToWeiboViewController\",\n                      @\"Other_Info_1\": [NSNumber numberWithInt:123],\n                      @\"Other_Info_2\": @[@\"obj1\", @\"obj2\"],\n                      @\"Other_Info_3\": @{@\"key1\": @\"obj1\", @\"key2\": @\"obj2\"}};\n    \n [WeiboSDK sendRequest:request];\n```\nSwift\n```swift\nlet request = WBAuthorizeRequest.request() as! WBAuthorizeRequest\nrequest.redirectURI = \"https://api.weibo.com/oauth2/default.html\"\nrequest.scope = \"all\"\nrequest.userInfo = [\"SSO_From\": \"SendMessageToWeiboViewController\",\n                    \"Other_Info_1\": NSNumber(int: Int32(123)),\n                    \"Other_Info_2\": [\"obj1\", \"obj2\"],\n                    \"Other_Info_3\": [\"key1\": \"obj1\", \"key2\": \"obj2\"]]\nWeiboSDK.sendRequest(request)\n```\n\n在你的 delegate 中，实现 `didReceiveWeiboResponse:` 方法，并从中获取用户登录的 accessToken 和 userID：\n\nObjective-C\n```objectivec\n - (void)didReceiveWeiboResponse:(WBBaseResponse *)response\n{\n    if ([response isKindOfClass:WBAuthorizeResponse.class])\n    {\n        WBAuthorizeResponse *authResponse = (WBAuthorizeResponse *)response;\n        NSString *accessToken = authResponse.accessToken;\n        NSString *openId = authResponse.userID;\n    }\n}\n```\nSwift\n```swift\nfunc didReceiveWeiboResponse(response: WBBaseResponse!){\n    if response is WBAuthorizeResponse{\n        let authResponse = response as! WBAuthorizeResponse\n        let accessToken = authResponse.accessToken\n        let openId = authResponse.userID\n    }\n}\n```\n\n2、 导入 WilddogAuth 模块：\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n\n3、 初始化 `WDGAuth` 对象：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n\n4、 新浪微博登录成功后，在 `didReceiveWeiboResponse:` 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = \n[WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken userID:userID];\n```\nSwift\n```swift\nlet credential = WDGSinaAuthProvider.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth?.userID)\n```\n\n5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\nObjective-C\n```objectivec\n[auth signInWithCredential:credential\n                completion:^(WDGUser *user, NSError *error) {\n                            // ...\n                          }];\n```\nSwift\n```swift\nauth?.signInWithCredential(credential){(user, error) in\n    // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","date":"2016-09-06T03:38:22.528Z","updated":"2016-09-06T03:38:22.528Z","path":"guide/auth/ios/weibo.html","comments":1,"layout":"page","_id":"cisswi9l10015z4fwrbpbbe9g","content":"<p>通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>创建野狗应用。将下面 pod 添加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 <a href=\"http://open.weibo.com/apps\" target=\"_blank\" rel=\"external\">新浪微博开放平台管理中心</a>，获取应用的 <strong>App Key</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li>在野狗控制面板中打开新浪微博登录方式:<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 参考 <a href=\"https://github.com/sinaweibosdk/weibo_ios_sdk\" target=\"_blank\" rel=\"external\">新浪微博 iOS 接入指南</a> 将新浪微博登录集成到你的应用中。在 AppDelegate 的 <code>application: openURL: options:</code> 方法中设置 delegate 来接收网络事件:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)app openURL:(<span class=\"built_in\">NSURL</span> *)url options:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)options</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>([url.absoluteString hasPrefix:<span class=\"string\">@\"wb\"</span>]) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> [WeiboSDK handleOpenURL:url delegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(app: UIApplication, openURL url: NSURL, options: [String : AnyObject])</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> url.absoluteString.hasPrefix(<span class=\"string\">\"wb\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">WeiboSDK</span>.handleOpenURL(url, delegate: <span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用新浪微博的授权代码：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WBAuthorizeRequest *request = [WBAuthorizeRequest request];</div><div class=\"line\">request.redirectURI = <span class=\"string\">@\"https://api.weibo.com/oauth2/default.html\"</span>;</div><div class=\"line\">request.scope = <span class=\"string\">@\"all\"</span>;</div><div class=\"line\">request.userInfo = @&#123;<span class=\"string\">@\"SSO_From\"</span>: <span class=\"string\">@\"SendMessageToWeiboViewController\"</span>,</div><div class=\"line\">                     <span class=\"string\">@\"Other_Info_1\"</span>: [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">123</span>],</div><div class=\"line\">                     <span class=\"string\">@\"Other_Info_2\"</span>: @[<span class=\"string\">@\"obj1\"</span>, <span class=\"string\">@\"obj2\"</span>],</div><div class=\"line\">                     <span class=\"string\">@\"Other_Info_3\"</span>: @&#123;<span class=\"string\">@\"key1\"</span>: <span class=\"string\">@\"obj1\"</span>, <span class=\"string\">@\"key2\"</span>: <span class=\"string\">@\"obj2\"</span>&#125;&#125;;</div><div class=\"line\">   </div><div class=\"line\">[WeiboSDK sendRequest:request];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">WBAuthorizeRequest</span>.request() <span class=\"keyword\">as</span>! <span class=\"type\">WBAuthorizeRequest</span></div><div class=\"line\">request.redirectURI = <span class=\"string\">\"https://api.weibo.com/oauth2/default.html\"</span></div><div class=\"line\">request.scope = <span class=\"string\">\"all\"</span></div><div class=\"line\">request.userInfo = [<span class=\"string\">\"SSO_From\"</span>: <span class=\"string\">\"SendMessageToWeiboViewController\"</span>,</div><div class=\"line\">                    <span class=\"string\">\"Other_Info_1\"</span>: <span class=\"type\">NSNumber</span>(int: <span class=\"type\">Int32</span>(<span class=\"number\">123</span>)),</div><div class=\"line\">                    <span class=\"string\">\"Other_Info_2\"</span>: [<span class=\"string\">\"obj1\"</span>, <span class=\"string\">\"obj2\"</span>],</div><div class=\"line\">                    <span class=\"string\">\"Other_Info_3\"</span>: [<span class=\"string\">\"key1\"</span>: <span class=\"string\">\"obj1\"</span>, <span class=\"string\">\"key2\"</span>: <span class=\"string\">\"obj2\"</span>]]</div><div class=\"line\"><span class=\"type\">WeiboSDK</span>.sendRequest(request)</div></pre></td></tr></table></figure></p>\n<p>在你的 delegate 中，实现 <code>didReceiveWeiboResponse:</code> 方法，并从中获取用户登录的 accessToken 和 userID：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"> - (<span class=\"keyword\">void</span>)didReceiveWeiboResponse:(WBBaseResponse *)response</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([response isKindOfClass:WBAuthorizeResponse.class])</div><div class=\"line\">    &#123;</div><div class=\"line\">        WBAuthorizeResponse *authResponse = (WBAuthorizeResponse *)response;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *accessToken = authResponse.accessToken;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *openId = authResponse.userID;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceiveWeiboResponse</span><span class=\"params\">(response: WBBaseResponse!)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"type\">WBAuthorizeResponse</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> authResponse = response <span class=\"keyword\">as</span>! <span class=\"type\">WBAuthorizeResponse</span></div><div class=\"line\">        <span class=\"keyword\">let</span> accessToken = authResponse.accessToken</div><div class=\"line\">        <span class=\"keyword\">let</span> openId = authResponse.userID</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2、 导入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>3、 初始化 <code>WDGAuth</code> 对象：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>4、 新浪微博登录成功后，在 <code>didReceiveWeiboResponse:</code> 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = </div><div class=\"line\">[WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken userID:userID];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGSinaAuthProvider</span>.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth?.userID)</div></pre></td></tr></table></figure></p>\n<p>5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCredential:credential</div><div class=\"line\">                completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                            <span class=\"comment\">// ...</span></div><div class=\"line\">                          &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCredential(credential)&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n","excerpt":"","more":"<p>通过集成新浪微博登录，你可以让你的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>创建野狗应用。将下面 pod 添加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 <a href=\"http://open.weibo.com/apps\">新浪微博开放平台管理中心</a>，获取应用的 <strong>App Key</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li>在野狗控制面板中打开新浪微博登录方式:<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 参考 <a href=\"https://github.com/sinaweibosdk/weibo_ios_sdk\">新浪微博 iOS 接入指南</a> 将新浪微博登录集成到你的应用中。在 AppDelegate 的 <code>application: openURL: options:</code> 方法中设置 delegate 来接收网络事件:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)app openURL:(<span class=\"built_in\">NSURL</span> *)url options:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)options</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>([url.absoluteString hasPrefix:<span class=\"string\">@\"wb\"</span>]) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> [WeiboSDK handleOpenURL:url delegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(app: UIApplication, openURL url: NSURL, options: [String : AnyObject])</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> url.absoluteString.hasPrefix(<span class=\"string\">\"wb\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">WeiboSDK</span>.handleOpenURL(url, delegate: <span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用新浪微博的授权代码：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WBAuthorizeRequest *request = [WBAuthorizeRequest request];</div><div class=\"line\">request.redirectURI = <span class=\"string\">@\"https://api.weibo.com/oauth2/default.html\"</span>;</div><div class=\"line\">request.scope = <span class=\"string\">@\"all\"</span>;</div><div class=\"line\">request.userInfo = @&#123;<span class=\"string\">@\"SSO_From\"</span>: <span class=\"string\">@\"SendMessageToWeiboViewController\"</span>,</div><div class=\"line\">                     <span class=\"string\">@\"Other_Info_1\"</span>: [<span class=\"built_in\">NSNumber</span> numberWithInt:<span class=\"number\">123</span>],</div><div class=\"line\">                     <span class=\"string\">@\"Other_Info_2\"</span>: @[<span class=\"string\">@\"obj1\"</span>, <span class=\"string\">@\"obj2\"</span>],</div><div class=\"line\">                     <span class=\"string\">@\"Other_Info_3\"</span>: @&#123;<span class=\"string\">@\"key1\"</span>: <span class=\"string\">@\"obj1\"</span>, <span class=\"string\">@\"key2\"</span>: <span class=\"string\">@\"obj2\"</span>&#125;&#125;;</div><div class=\"line\">   </div><div class=\"line\">[WeiboSDK sendRequest:request];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">WBAuthorizeRequest</span>.request() <span class=\"keyword\">as</span>! <span class=\"type\">WBAuthorizeRequest</span></div><div class=\"line\">request.redirectURI = <span class=\"string\">\"https://api.weibo.com/oauth2/default.html\"</span></div><div class=\"line\">request.scope = <span class=\"string\">\"all\"</span></div><div class=\"line\">request.userInfo = [<span class=\"string\">\"SSO_From\"</span>: <span class=\"string\">\"SendMessageToWeiboViewController\"</span>,</div><div class=\"line\">                    <span class=\"string\">\"Other_Info_1\"</span>: <span class=\"type\">NSNumber</span>(int: <span class=\"type\">Int32</span>(<span class=\"number\">123</span>)),</div><div class=\"line\">                    <span class=\"string\">\"Other_Info_2\"</span>: [<span class=\"string\">\"obj1\"</span>, <span class=\"string\">\"obj2\"</span>],</div><div class=\"line\">                    <span class=\"string\">\"Other_Info_3\"</span>: [<span class=\"string\">\"key1\"</span>: <span class=\"string\">\"obj1\"</span>, <span class=\"string\">\"key2\"</span>: <span class=\"string\">\"obj2\"</span>]]</div><div class=\"line\"><span class=\"type\">WeiboSDK</span>.sendRequest(request)</div></pre></td></tr></table></figure></p>\n<p>在你的 delegate 中，实现 <code>didReceiveWeiboResponse:</code> 方法，并从中获取用户登录的 accessToken 和 userID：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"> - (<span class=\"keyword\">void</span>)didReceiveWeiboResponse:(WBBaseResponse *)response</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([response isKindOfClass:WBAuthorizeResponse.class])</div><div class=\"line\">    &#123;</div><div class=\"line\">        WBAuthorizeResponse *authResponse = (WBAuthorizeResponse *)response;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *accessToken = authResponse.accessToken;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *openId = authResponse.userID;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceiveWeiboResponse</span><span class=\"params\">(response: WBBaseResponse!)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"type\">WBAuthorizeResponse</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> authResponse = response <span class=\"keyword\">as</span>! <span class=\"type\">WBAuthorizeResponse</span></div><div class=\"line\">        <span class=\"keyword\">let</span> accessToken = authResponse.accessToken</div><div class=\"line\">        <span class=\"keyword\">let</span> openId = authResponse.userID</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2、 导入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>3、 初始化 <code>WDGAuth</code> 对象：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>4、 新浪微博登录成功后，在 <code>didReceiveWeiboResponse:</code> 方法中得到的 accessToken 和 userID 来生成 Wilddog 凭据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = </div><div class=\"line\">[WDGSinaAuthProvider credentialWithAccessToken:sinaOAuth.accessToken userID:userID];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGSinaAuthProvider</span>.credentialWithAccessToken(sinaOAuth.accessToken, userID: sinaOAuth?.userID)</div></pre></td></tr></table></figure></p>\n<p>5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCredential:credential</div><div class=\"line\">                completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                            <span class=\"comment\">// ...</span></div><div class=\"line\">                          &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCredential(credential)&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n"},{"title":"参考资源","_content":"\n## 示例源码\n\n名称 | 描述\n----|------\n[Authentication](https://github.com/WildDogTeam/wilddog-ios-quickstart) | Authentication 是一个基于 WilddogAuth iOS SDK 开发登录 demo，其中实现的功能实例有邮箱登录、QQ登录、微信登录、微博登录、匿名登录。\n\n\n\n\n\n\n","source":"guide/auth/ios/resources.md","raw":"title:  参考资源\n---\n\n## 示例源码\n\n名称 | 描述\n----|------\n[Authentication](https://github.com/WildDogTeam/wilddog-ios-quickstart) | Authentication 是一个基于 WilddogAuth iOS SDK 开发登录 demo，其中实现的功能实例有邮箱登录、QQ登录、微信登录、微博登录、匿名登录。\n\n\n\n\n\n\n","date":"2016-09-06T03:38:22.527Z","updated":"2016-09-06T03:38:22.527Z","path":"guide/auth/ios/resources.html","comments":1,"layout":"page","_id":"cisswi9l10016z4fwrj07z1pd","content":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/wilddog-ios-quickstart\" target=\"_blank\" rel=\"external\">Authentication</a></td>\n<td>Authentication 是一个基于 WilddogAuth iOS SDK 开发登录 demo，其中实现的功能实例有邮箱登录、QQ登录、微信登录、微博登录、匿名登录。</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/wilddog-ios-quickstart\">Authentication</a></td>\n<td>Authentication 是一个基于 WilddogAuth iOS SDK 开发登录 demo，其中实现的功能实例有邮箱登录、QQ登录、微信登录、微博登录、匿名登录。</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"微信登录","_content":"通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n1. 创建野狗应用。将下面 pod 添加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n2. 在 [微信开放平台管理中心](https://open.weixin.qq.com/)，获取应用的 **App ID** 和 **App Secret**。\n3. 在野狗控制面板中打开微信登录方式:\n  * 在野狗控制面板中选择 ”身份认证“->登录方式。\n  * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n\n1、 参考 [微信 iOS 接入指南](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=1417694084&token=202bb3157581f30a1fd92c713f9f9fc2356fc860&lang=zh_CN) 将微信登录集成到你的应用中。在 AppDelegate 的 `application: openURL: options:` 方法中设置 delegate 来接收网络事件:\n\nObjective-C\n```objectivec\n - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n {\n     if ([url.absoluteString hasPrefix:@\"wx\"]) {\n         return [WXApi handleOpenURL:url delegate:self];\n     }\n     return NO;\n }\n```\n\nSwift\n```swift\nfunc application(app: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -> Bool {\n    if url.absoluteString.hasPrefix(\"wx\") {\n        return WXApi.handleOpenURL(url, delegate: self)\n    }\n}\n```\n调用微信的授权代码：\n\nObjective-C\n```objectivec\nSendAuthReq *req = [SendAuthReq new];\nreq.scope = @\"snsapi_userinfo\" ;\nreq.state = @\"osc_wechat_login\" ;\n// 第三方向微信终端发送一个 SendAuthReq 消息结构\n[WXApi sendReq:req];\n```\n\nSwift\n```swift\nlet req = SendAuthReq()\nreq.scope = \"snsapi_userinfo\"\nreq.state = \"osc_wechat_login\"\n// 第三方向微信终端发送一个 SendAuthReq 消息结构\nWXApi.sendReq(req)\n```\n在你的 delegate 中，实现 `onResp:` 方法，并从中获取用户登录的 accessToken 和 openId：\n\nObjective-C\n```objectivec\n -(void)onResp:(BaseResp*)resp\n {\n     SendAuthResp *response = (SendAuthResp*)resp;\n     NSString *code = response.code;\n }\n```\n\nSwift\n```swift\nfunc onResp(resp: BaseResp!) {\n    let response = resp as? SendAuthResp\n    let code = response?.code\n}\n```\n\n2、 导入 WilddogAuth 模块：\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n\n3、 初始化 `WDGAuth` 对象：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n\n4、 微信登录成功后，在 `onResp:` 方法中得到的 code 来生成 Wilddog 凭据：\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = \n[WDGWeiXinAuthProvider credentialWithCode:code];\n```\nSwift\n```swift\nlet credential = WDGWeiXinAuthProvider.credentialWithCode(weixinOAuth.code)\n```\n\n5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\nObjective-C\n```objectivec\n[auth signInWithCredential:credential\n                completion:^(WDGUser *user, NSError *error) {\n                            // ...\n                          }];\n```\nSwift\n```swift\nauth?.signInWithCredential(credential){(user, error) in\n    // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","source":"guide/auth/ios/weixin.md","raw":"title: 微信登录\n---\n通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n1. 创建野狗应用。将下面 pod 添加到 `Podfile` 文件中：\n```\npod 'Wilddog/Auth'\n```\n2. 在 [微信开放平台管理中心](https://open.weixin.qq.com/)，获取应用的 **App ID** 和 **App Secret**。\n3. 在野狗控制面板中打开微信登录方式:\n  * 在野狗控制面板中选择 ”身份认证“->登录方式。\n  * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n\n1、 参考 [微信 iOS 接入指南](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=1417694084&token=202bb3157581f30a1fd92c713f9f9fc2356fc860&lang=zh_CN) 将微信登录集成到你的应用中。在 AppDelegate 的 `application: openURL: options:` 方法中设置 delegate 来接收网络事件:\n\nObjective-C\n```objectivec\n - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n {\n     if ([url.absoluteString hasPrefix:@\"wx\"]) {\n         return [WXApi handleOpenURL:url delegate:self];\n     }\n     return NO;\n }\n```\n\nSwift\n```swift\nfunc application(app: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -> Bool {\n    if url.absoluteString.hasPrefix(\"wx\") {\n        return WXApi.handleOpenURL(url, delegate: self)\n    }\n}\n```\n调用微信的授权代码：\n\nObjective-C\n```objectivec\nSendAuthReq *req = [SendAuthReq new];\nreq.scope = @\"snsapi_userinfo\" ;\nreq.state = @\"osc_wechat_login\" ;\n// 第三方向微信终端发送一个 SendAuthReq 消息结构\n[WXApi sendReq:req];\n```\n\nSwift\n```swift\nlet req = SendAuthReq()\nreq.scope = \"snsapi_userinfo\"\nreq.state = \"osc_wechat_login\"\n// 第三方向微信终端发送一个 SendAuthReq 消息结构\nWXApi.sendReq(req)\n```\n在你的 delegate 中，实现 `onResp:` 方法，并从中获取用户登录的 accessToken 和 openId：\n\nObjective-C\n```objectivec\n -(void)onResp:(BaseResp*)resp\n {\n     SendAuthResp *response = (SendAuthResp*)resp;\n     NSString *code = response.code;\n }\n```\n\nSwift\n```swift\nfunc onResp(resp: BaseResp!) {\n    let response = resp as? SendAuthResp\n    let code = response?.code\n}\n```\n\n2、 导入 WilddogAuth 模块：\n\nObjective-C\n```objectivec\n@import WilddogAuth;\n```\nSwift\n```swift\nimport WilddogAuth\n```\n\n3、 初始化 `WDGAuth` 对象：\n\nObjective-C\n```objectivec\nWDGAuth *auth = [WDGAuth authWithAppID:@\"your-wilddog-appid\"];\n```\nSwift\n```swift\nlet auth = WDGAuth.auth(appID: \"your-wilddog-appid\")\n```\n\n4、 微信登录成功后，在 `onResp:` 方法中得到的 code 来生成 Wilddog 凭据：\n\nObjective-C\n```objectivec\nWDGAuthCredential *credential = \n[WDGWeiXinAuthProvider credentialWithCode:code];\n```\nSwift\n```swift\nlet credential = WDGWeiXinAuthProvider.credentialWithCode(weixinOAuth.code)\n```\n\n5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：\n\nObjective-C\n```objectivec\n[auth signInWithCredential:credential\n                completion:^(WDGUser *user, NSError *error) {\n                            // ...\n                          }];\n```\nSwift\n```swift\nauth?.signInWithCredential(credential){(user, error) in\n    // ...\n}\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/ios/manageuser.html)。\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/ios/link.html) 来实现不同的登录方式登录同一个帐号。\n\n调用 [signOut:](/api/auth/ios.html#WDGAuth-Methods#-signOut:) 退出登录：\n\nObjective-C\n```objectivec\nNSError *error;\n[[WDGAuth authWithAppID:@\"your-wilddog-appid\"] signOut:&error];\nif (!error) {\n    // 退出登录成功\n}\n\n```\nSwift\n```swift\ntry! WDGAuth.auth(appID: \"your-wilddog-appid\")!.signOut()\n\n```\n可能发生的错误，请参考 [处理错误](/guide/auth/ios/errorcode.html)。","date":"2016-09-06T03:38:22.528Z","updated":"2016-09-06T03:38:22.528Z","path":"guide/auth/ios/weixin.html","comments":1,"layout":"page","_id":"cisswi9l10017z4fwvtvql5a6","content":"<p>通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>创建野狗应用。将下面 pod 添加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 <a href=\"https://open.weixin.qq.com/\" target=\"_blank\" rel=\"external\">微信开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li>在野狗控制面板中打开微信登录方式:<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 参考 <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417694084&amp;token=202bb3157581f30a1fd92c713f9f9fc2356fc860&amp;lang=zh_CN\" target=\"_blank\" rel=\"external\">微信 iOS 接入指南</a> 将微信登录集成到你的应用中。在 AppDelegate 的 <code>application: openURL: options:</code> 方法中设置 delegate 来接收网络事件:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)app openURL:(<span class=\"built_in\">NSURL</span> *)url options:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)options</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([url.absoluteString hasPrefix:<span class=\"string\">@\"wx\"</span>]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> [WXApi handleOpenURL:url delegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(app: UIApplication, openURL url: NSURL, options: [String : AnyObject])</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> url.absoluteString.hasPrefix(<span class=\"string\">\"wx\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">WXApi</span>.handleOpenURL(url, delegate: <span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用微信的授权代码：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">SendAuthReq *req = [SendAuthReq new];</div><div class=\"line\">req.scope = <span class=\"string\">@\"snsapi_userinfo\"</span> ;</div><div class=\"line\">req.state = <span class=\"string\">@\"osc_wechat_login\"</span> ;</div><div class=\"line\"><span class=\"comment\">// 第三方向微信终端发送一个 SendAuthReq 消息结构</span></div><div class=\"line\">[WXApi sendReq:req];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> req = <span class=\"type\">SendAuthReq</span>()</div><div class=\"line\">req.scope = <span class=\"string\">\"snsapi_userinfo\"</span></div><div class=\"line\">req.state = <span class=\"string\">\"osc_wechat_login\"</span></div><div class=\"line\"><span class=\"comment\">// 第三方向微信终端发送一个 SendAuthReq 消息结构</span></div><div class=\"line\"><span class=\"type\">WXApi</span>.sendReq(req)</div></pre></td></tr></table></figure></p>\n<p>在你的 delegate 中，实现 <code>onResp:</code> 方法，并从中获取用户登录的 accessToken 和 openId：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)onResp:(BaseResp*)resp</div><div class=\"line\">&#123;</div><div class=\"line\">    SendAuthResp *response = (SendAuthResp*)resp;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *code = response.code;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onResp</span><span class=\"params\">(resp: BaseResp!)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> response = resp <span class=\"keyword\">as</span>? <span class=\"type\">SendAuthResp</span></div><div class=\"line\">    <span class=\"keyword\">let</span> code = response?.code</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2、 导入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>3、 初始化 <code>WDGAuth</code> 对象：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>4、 微信登录成功后，在 <code>onResp:</code> 方法中得到的 code 来生成 Wilddog 凭据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = </div><div class=\"line\">[WDGWeiXinAuthProvider credentialWithCode:code];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGWeiXinAuthProvider</span>.credentialWithCode(weixinOAuth.code)</div></pre></td></tr></table></figure></p>\n<p>5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCredential:credential</div><div class=\"line\">                completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                            <span class=\"comment\">// ...</span></div><div class=\"line\">                          &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCredential(credential)&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n","excerpt":"","more":"<p>通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>创建野狗应用。将下面 pod 添加到 <code>Podfile</code> 文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pod &apos;Wilddog/Auth&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 <a href=\"https://open.weixin.qq.com/\">微信开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li>在野狗控制面板中打开微信登录方式:<ul>\n<li>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</li>\n<li>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><p>1、 参考 <a href=\"https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417694084&amp;token=202bb3157581f30a1fd92c713f9f9fc2356fc860&amp;lang=zh_CN\">微信 iOS 接入指南</a> 将微信登录集成到你的应用中。在 AppDelegate 的 <code>application: openURL: options:</code> 方法中设置 delegate 来接收网络事件:</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)app openURL:(<span class=\"built_in\">NSURL</span> *)url options:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *,<span class=\"keyword\">id</span>&gt; *)options</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([url.absoluteString hasPrefix:<span class=\"string\">@\"wx\"</span>]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> [WXApi handleOpenURL:url delegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(app: UIApplication, openURL url: NSURL, options: [String : AnyObject])</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> url.absoluteString.hasPrefix(<span class=\"string\">\"wx\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">WXApi</span>.handleOpenURL(url, delegate: <span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>调用微信的授权代码：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">SendAuthReq *req = [SendAuthReq new];</div><div class=\"line\">req.scope = <span class=\"string\">@\"snsapi_userinfo\"</span> ;</div><div class=\"line\">req.state = <span class=\"string\">@\"osc_wechat_login\"</span> ;</div><div class=\"line\"><span class=\"comment\">// 第三方向微信终端发送一个 SendAuthReq 消息结构</span></div><div class=\"line\">[WXApi sendReq:req];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> req = <span class=\"type\">SendAuthReq</span>()</div><div class=\"line\">req.scope = <span class=\"string\">\"snsapi_userinfo\"</span></div><div class=\"line\">req.state = <span class=\"string\">\"osc_wechat_login\"</span></div><div class=\"line\"><span class=\"comment\">// 第三方向微信终端发送一个 SendAuthReq 消息结构</span></div><div class=\"line\"><span class=\"type\">WXApi</span>.sendReq(req)</div></pre></td></tr></table></figure></p>\n<p>在你的 delegate 中，实现 <code>onResp:</code> 方法，并从中获取用户登录的 accessToken 和 openId：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)onResp:(BaseResp*)resp</div><div class=\"line\">&#123;</div><div class=\"line\">    SendAuthResp *response = (SendAuthResp*)resp;</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *code = response.code;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onResp</span><span class=\"params\">(resp: BaseResp!)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> response = resp <span class=\"keyword\">as</span>? <span class=\"type\">SendAuthResp</span></div><div class=\"line\">    <span class=\"keyword\">let</span> code = response?.code</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>2、 导入 WilddogAuth 模块：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@import</span> WilddogAuth;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> WilddogAuth</div></pre></td></tr></table></figure></p>\n<p>3、 初始化 <code>WDGAuth</code> 对象：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuth *auth = [WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)</div></pre></td></tr></table></figure></p>\n<p>4、 微信登录成功后，在 <code>onResp:</code> 方法中得到的 code 来生成 Wilddog 凭据：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WDGAuthCredential *credential = </div><div class=\"line\">[WDGWeiXinAuthProvider credentialWithCode:code];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> credential = <span class=\"type\">WDGWeiXinAuthProvider</span>.credentialWithCode(weixinOAuth.code)</div></pre></td></tr></table></figure></p>\n<p>5、 最后，使用 Wilddog 凭据来进行 Wilddog 用户认证：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[auth signInWithCredential:credential</div><div class=\"line\">                completion:^(WDGUser *user, <span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">                            <span class=\"comment\">// ...</span></div><div class=\"line\">                          &#125;];</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">auth?.signInWithCredential(credential)&#123;(user, error) <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li>在你的应用中，你可以通过 WDGUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/ios/manageuser.html\">管理用户</a>。</li>\n<li>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/ios/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<p>调用 <a href=\"/api/auth/ios.html#WDGAuth-Methods#-signOut:\">signOut:</a> 退出登录：</p>\n<p>Objective-C<br><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSError</span> *error;</div><div class=\"line\">[[WDGAuth authWithAppID:<span class=\"string\">@\"your-wilddog-appid\"</span>] signOut:&amp;error];</div><div class=\"line\"><span class=\"keyword\">if</span> (!error) &#123;</div><div class=\"line\">    <span class=\"comment\">// 退出登录成功</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Swift<br><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>! <span class=\"type\">WDGAuth</span>.auth(appID: <span class=\"string\">\"your-wilddog-appid\"</span>)!.signOut()</div></pre></td></tr></table></figure></p>\n<p>可能发生的错误，请参考 <a href=\"/guide/auth/ios/errorcode.html\">处理错误</a>。</p>\n"},{"title":"身份认证","_content":"\n你可以使用 Wilddog Server SDK 创建并认证用于在客户端应用与服务器之间对身份认证信息进行安全通信的令牌（Token）。\n\n* 创建适用于集成自定义身份认证系统与 Wilddog 应用的自定义令牌。\n\n* 认证 ID 令牌（用于从客户端应用向后端服务器传递已登录用户）。\n\n\n注：Wilddog Server SDK 中包含的 ID 令牌认证方法不能认证你用 Wilddog Server SDK 创建的自定义令牌。\n\n资源下载地址:\nhttps://www.wilddog.com/download/\n\n## 创建Custom Token\n\n用户可以通过 Wilddog 的 Server SDK 对个人系统的用户生成 Custom Token。\n我们将提供 java 和 Nodejs 两种语言的 Server SDK:\n\njava:\n\n```java\n //生成自定义token\n //自定义字段\n String secret = \"<your-secret>\"; \n Map<String, Object> developerClaims = new HashMap<String, Object>();\n developerClaims.put(\"claims1\", 112);\n developerClaims.put(\"claims2\", true);\n Map<String, Object> developerClaims2 = new HashMap<String, Object>();\n developerClaims2.put(\"aaa\", 212);\n developerClaims2.put(\"bbb\", \"bbb\");\n developerClaims.put(\"claims3\", developerClaims2);\n TokenOptions options = new TokenOptions();\n options.setExpires(new Date(System.currentTimeMillis() + 2 * 24 * 3600 * 1000L));\n String token = CustomTokenGenerator.createCustomToken(\"some-uid:\", developerClaims, secret, options);\n\n //生成admin token\n String secret = \"<your-secret>\";\n TokenOptions options = new TokenOptions();\n options.setExpires(new Date(System.currentTimeMillis() + 2 * 24 * 3600 * 1000L));\n String token = CustomTokenGenerator.createAdminToken(secret, options);\n```\n\nnodejs:\n\n```javascript\n 后续推出\n```\n\n在创建 Custom Token 后, 可以将该 token 发送给客户端应用, 进行 Wilddog 身份认证\n\n```javascript\nwilddog.auth.signInWithCustomToken(customToken).catch(function(error)){\n    var errorCode = error.code;\n    var errorMessage = error.message;\n}\n```\n\n## 校验ID Token\n\n如果你的 Wilddog 客户端 APP 与自己的后端服务器有业务关联，你也许需要在后端服务中校验当前登录用户的合法性。当客户端用户成功登陆后，将Wilddog服务返回的ID Token 使用 HTTPS 发送给自有后端服务器，在服务中，调用 Wilddog 提供的校验接口校验用户的合法性。\n\n**在客户端获取用户ID Token**\n\n```javascript\nwilddog.auth().currentUser.getToken(\n    /* forceRefresh */\n    true).then(function(idToken) {\n    // Send token to your backend via HTTPS \n    // ...\n}).catch(function(error) {\n    // Handle error\n});\n```\n\n**使用 Wilddog SDK 校验 ID Token**\n\n我们将提供 java 和 Nodejs 两种语言的 Server SDK:\n\njava\n\n```java\n VerifyResult result = IdTokenVerifier.verifyIdToken(idToken, appId);\n boolean isValid = result.isValid();\n Token token = result.getIdToken();\n\n```\n\nnodejs:\n\n```javascript\n后续推出\n\n```\n\n","source":"guide/auth/server/server.md","raw":"title: 身份认证\n---\n\n你可以使用 Wilddog Server SDK 创建并认证用于在客户端应用与服务器之间对身份认证信息进行安全通信的令牌（Token）。\n\n* 创建适用于集成自定义身份认证系统与 Wilddog 应用的自定义令牌。\n\n* 认证 ID 令牌（用于从客户端应用向后端服务器传递已登录用户）。\n\n\n注：Wilddog Server SDK 中包含的 ID 令牌认证方法不能认证你用 Wilddog Server SDK 创建的自定义令牌。\n\n资源下载地址:\nhttps://www.wilddog.com/download/\n\n## 创建Custom Token\n\n用户可以通过 Wilddog 的 Server SDK 对个人系统的用户生成 Custom Token。\n我们将提供 java 和 Nodejs 两种语言的 Server SDK:\n\njava:\n\n```java\n //生成自定义token\n //自定义字段\n String secret = \"<your-secret>\"; \n Map<String, Object> developerClaims = new HashMap<String, Object>();\n developerClaims.put(\"claims1\", 112);\n developerClaims.put(\"claims2\", true);\n Map<String, Object> developerClaims2 = new HashMap<String, Object>();\n developerClaims2.put(\"aaa\", 212);\n developerClaims2.put(\"bbb\", \"bbb\");\n developerClaims.put(\"claims3\", developerClaims2);\n TokenOptions options = new TokenOptions();\n options.setExpires(new Date(System.currentTimeMillis() + 2 * 24 * 3600 * 1000L));\n String token = CustomTokenGenerator.createCustomToken(\"some-uid:\", developerClaims, secret, options);\n\n //生成admin token\n String secret = \"<your-secret>\";\n TokenOptions options = new TokenOptions();\n options.setExpires(new Date(System.currentTimeMillis() + 2 * 24 * 3600 * 1000L));\n String token = CustomTokenGenerator.createAdminToken(secret, options);\n```\n\nnodejs:\n\n```javascript\n 后续推出\n```\n\n在创建 Custom Token 后, 可以将该 token 发送给客户端应用, 进行 Wilddog 身份认证\n\n```javascript\nwilddog.auth.signInWithCustomToken(customToken).catch(function(error)){\n    var errorCode = error.code;\n    var errorMessage = error.message;\n}\n```\n\n## 校验ID Token\n\n如果你的 Wilddog 客户端 APP 与自己的后端服务器有业务关联，你也许需要在后端服务中校验当前登录用户的合法性。当客户端用户成功登陆后，将Wilddog服务返回的ID Token 使用 HTTPS 发送给自有后端服务器，在服务中，调用 Wilddog 提供的校验接口校验用户的合法性。\n\n**在客户端获取用户ID Token**\n\n```javascript\nwilddog.auth().currentUser.getToken(\n    /* forceRefresh */\n    true).then(function(idToken) {\n    // Send token to your backend via HTTPS \n    // ...\n}).catch(function(error) {\n    // Handle error\n});\n```\n\n**使用 Wilddog SDK 校验 ID Token**\n\n我们将提供 java 和 Nodejs 两种语言的 Server SDK:\n\njava\n\n```java\n VerifyResult result = IdTokenVerifier.verifyIdToken(idToken, appId);\n boolean isValid = result.isValid();\n Token token = result.getIdToken();\n\n```\n\nnodejs:\n\n```javascript\n后续推出\n\n```\n\n","date":"2016-09-07T13:24:23.101Z","updated":"2016-09-07T13:24:23.101Z","path":"guide/auth/server/server.html","_id":"cisswi9l10018z4fw3vbmcq9n","comments":1,"layout":"page","content":"<p>你可以使用 Wilddog Server SDK 创建并认证用于在客户端应用与服务器之间对身份认证信息进行安全通信的令牌（Token）。</p>\n<ul>\n<li><p>创建适用于集成自定义身份认证系统与 Wilddog 应用的自定义令牌。</p>\n</li>\n<li><p>认证 ID 令牌（用于从客户端应用向后端服务器传递已登录用户）。</p>\n</li>\n</ul>\n<p>注：Wilddog Server SDK 中包含的 ID 令牌认证方法不能认证你用 Wilddog Server SDK 创建的自定义令牌。</p>\n<p>资源下载地址:<br><a href=\"https://www.wilddog.com/download/\" target=\"_blank\" rel=\"external\">https://www.wilddog.com/download/</a></p>\n<h2 id=\"创建Custom-Token\"><a href=\"#创建Custom-Token\" class=\"headerlink\" title=\"创建Custom Token\"></a>创建Custom Token</h2><p>用户可以通过 Wilddog 的 Server SDK 对个人系统的用户生成 Custom Token。<br>我们将提供 java 和 Nodejs 两种语言的 Server SDK:</p>\n<p>java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//生成自定义token</span></div><div class=\"line\"><span class=\"comment\">//自定义字段</span></div><div class=\"line\">String secret = <span class=\"string\">\"&lt;your-secret&gt;\"</span>; </div><div class=\"line\">Map&lt;String, Object&gt; developerClaims = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">developerClaims.put(<span class=\"string\">\"claims1\"</span>, <span class=\"number\">112</span>);</div><div class=\"line\">developerClaims.put(<span class=\"string\">\"claims2\"</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">Map&lt;String, Object&gt; developerClaims2 = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">developerClaims2.put(<span class=\"string\">\"aaa\"</span>, <span class=\"number\">212</span>);</div><div class=\"line\">developerClaims2.put(<span class=\"string\">\"bbb\"</span>, <span class=\"string\">\"bbb\"</span>);</div><div class=\"line\">developerClaims.put(<span class=\"string\">\"claims3\"</span>, developerClaims2);</div><div class=\"line\">TokenOptions options = <span class=\"keyword\">new</span> TokenOptions();</div><div class=\"line\">options.setExpires(<span class=\"keyword\">new</span> Date(System.currentTimeMillis() + <span class=\"number\">2</span> * <span class=\"number\">24</span> * <span class=\"number\">3600</span> * <span class=\"number\">1000L</span>));</div><div class=\"line\">String token = CustomTokenGenerator.createCustomToken(<span class=\"string\">\"some-uid:\"</span>, developerClaims, secret, options);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//生成admin token</span></div><div class=\"line\">String secret = <span class=\"string\">\"&lt;your-secret&gt;\"</span>;</div><div class=\"line\">TokenOptions options = <span class=\"keyword\">new</span> TokenOptions();</div><div class=\"line\">options.setExpires(<span class=\"keyword\">new</span> Date(System.currentTimeMillis() + <span class=\"number\">2</span> * <span class=\"number\">24</span> * <span class=\"number\">3600</span> * <span class=\"number\">1000L</span>));</div><div class=\"line\">String token = CustomTokenGenerator.createAdminToken(secret, options);</div></pre></td></tr></table></figure>\n<p>nodejs:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">后续推出</div></pre></td></tr></table></figure>\n<p>在创建 Custom Token 后, 可以将该 token 发送给客户端应用, 进行 Wilddog 身份认证</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth.signInWithCustomToken(customToken).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>))</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> errorCode = error.code;</div><div class=\"line\">    <span class=\"keyword\">var</span> errorMessage = error.message;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"校验ID-Token\"><a href=\"#校验ID-Token\" class=\"headerlink\" title=\"校验ID Token\"></a>校验ID Token</h2><p>如果你的 Wilddog 客户端 APP 与自己的后端服务器有业务关联，你也许需要在后端服务中校验当前登录用户的合法性。当客户端用户成功登陆后，将Wilddog服务返回的ID Token 使用 HTTPS 发送给自有后端服务器，在服务中，调用 Wilddog 提供的校验接口校验用户的合法性。</p>\n<p><strong>在客户端获取用户ID Token</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.getToken(</div><div class=\"line\">    <span class=\"comment\">/* forceRefresh */</span></div><div class=\"line\">    <span class=\"literal\">true</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">idToken</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Send token to your backend via HTTPS </span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Handle error</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong>使用 Wilddog SDK 校验 ID Token</strong></p>\n<p>我们将提供 java 和 Nodejs 两种语言的 Server SDK:</p>\n<p>java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">VerifyResult result = IdTokenVerifier.verifyIdToken(idToken, appId);</div><div class=\"line\"><span class=\"keyword\">boolean</span> isValid = result.isValid();</div><div class=\"line\">Token token = result.getIdToken();</div></pre></td></tr></table></figure>\n<p>nodejs:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">后续推出</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>你可以使用 Wilddog Server SDK 创建并认证用于在客户端应用与服务器之间对身份认证信息进行安全通信的令牌（Token）。</p>\n<ul>\n<li><p>创建适用于集成自定义身份认证系统与 Wilddog 应用的自定义令牌。</p>\n</li>\n<li><p>认证 ID 令牌（用于从客户端应用向后端服务器传递已登录用户）。</p>\n</li>\n</ul>\n<p>注：Wilddog Server SDK 中包含的 ID 令牌认证方法不能认证你用 Wilddog Server SDK 创建的自定义令牌。</p>\n<p>资源下载地址:<br><a href=\"https://www.wilddog.com/download/\">https://www.wilddog.com/download/</a></p>\n<h2 id=\"创建Custom-Token\"><a href=\"#创建Custom-Token\" class=\"headerlink\" title=\"创建Custom Token\"></a>创建Custom Token</h2><p>用户可以通过 Wilddog 的 Server SDK 对个人系统的用户生成 Custom Token。<br>我们将提供 java 和 Nodejs 两种语言的 Server SDK:</p>\n<p>java:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//生成自定义token</span></div><div class=\"line\"><span class=\"comment\">//自定义字段</span></div><div class=\"line\">String secret = <span class=\"string\">\"&lt;your-secret&gt;\"</span>; </div><div class=\"line\">Map&lt;String, Object&gt; developerClaims = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">developerClaims.put(<span class=\"string\">\"claims1\"</span>, <span class=\"number\">112</span>);</div><div class=\"line\">developerClaims.put(<span class=\"string\">\"claims2\"</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">Map&lt;String, Object&gt; developerClaims2 = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">developerClaims2.put(<span class=\"string\">\"aaa\"</span>, <span class=\"number\">212</span>);</div><div class=\"line\">developerClaims2.put(<span class=\"string\">\"bbb\"</span>, <span class=\"string\">\"bbb\"</span>);</div><div class=\"line\">developerClaims.put(<span class=\"string\">\"claims3\"</span>, developerClaims2);</div><div class=\"line\">TokenOptions options = <span class=\"keyword\">new</span> TokenOptions();</div><div class=\"line\">options.setExpires(<span class=\"keyword\">new</span> Date(System.currentTimeMillis() + <span class=\"number\">2</span> * <span class=\"number\">24</span> * <span class=\"number\">3600</span> * <span class=\"number\">1000L</span>));</div><div class=\"line\">String token = CustomTokenGenerator.createCustomToken(<span class=\"string\">\"some-uid:\"</span>, developerClaims, secret, options);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//生成admin token</span></div><div class=\"line\">String secret = <span class=\"string\">\"&lt;your-secret&gt;\"</span>;</div><div class=\"line\">TokenOptions options = <span class=\"keyword\">new</span> TokenOptions();</div><div class=\"line\">options.setExpires(<span class=\"keyword\">new</span> Date(System.currentTimeMillis() + <span class=\"number\">2</span> * <span class=\"number\">24</span> * <span class=\"number\">3600</span> * <span class=\"number\">1000L</span>));</div><div class=\"line\">String token = CustomTokenGenerator.createAdminToken(secret, options);</div></pre></td></tr></table></figure>\n<p>nodejs:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">后续推出</div></pre></td></tr></table></figure>\n<p>在创建 Custom Token 后, 可以将该 token 发送给客户端应用, 进行 Wilddog 身份认证</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth.signInWithCustomToken(customToken).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>))</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> errorCode = error.code;</div><div class=\"line\">    <span class=\"keyword\">var</span> errorMessage = error.message;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"校验ID-Token\"><a href=\"#校验ID-Token\" class=\"headerlink\" title=\"校验ID Token\"></a>校验ID Token</h2><p>如果你的 Wilddog 客户端 APP 与自己的后端服务器有业务关联，你也许需要在后端服务中校验当前登录用户的合法性。当客户端用户成功登陆后，将Wilddog服务返回的ID Token 使用 HTTPS 发送给自有后端服务器，在服务中，调用 Wilddog 提供的校验接口校验用户的合法性。</p>\n<p><strong>在客户端获取用户ID Token</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.getToken(</div><div class=\"line\">    <span class=\"comment\">/* forceRefresh */</span></div><div class=\"line\">    <span class=\"literal\">true</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">idToken</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Send token to your backend via HTTPS </span></div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Handle error</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong>使用 Wilddog SDK 校验 ID Token</strong></p>\n<p>我们将提供 java 和 Nodejs 两种语言的 Server SDK:</p>\n<p>java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">VerifyResult result = IdTokenVerifier.verifyIdToken(idToken, appId);</div><div class=\"line\"><span class=\"keyword\">boolean</span> isValid = result.isValid();</div><div class=\"line\">Token token = result.getIdToken();</div></pre></td></tr></table></figure>\n<p>nodejs:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">后续推出</div></pre></td></tr></table></figure>\n"},{"title":"服务端身份认证","_content":"\n使用 Wilddog，你可以将你自己的已有服务与 Wilddog Auth 集成起来。\n你可以使用 Wilddog 官方提供的 Server SDK 来操作用户认证 token, 或者你可以用第三方的 JWT（JSON Web Token）库自己实现。\n\nWilddog 服务端身份认证 SDK 主要帮助用户实现以下两个功能：\n\n* **生成 Custom Token**\n\n  **\n  **你可以将已有用户系统与Wilddog集成，比如，你可能已经拥有一个用户数据库，或者你想要集成一个Wilddog不原生支持的第三方认证提供方（如Facebook）。\n  你可以生成自定义 Token，并且你可以添加任意标识用户的信息。然后，这个custom token就可以被用来作为Wilddog API 中自定义登录的参数来登录 Wilddog, 完成操作实时数据同步等。\n\n* **认证 ID Token**\n\n  **\n  **Wilddog Auth 主要用来认证你的 APP 用户，来限制用户对于 Wilddog 服务的权限。但是，你也可以在你自己的服务中认证用户。\n  要做到这样，你需要在客户端获取登录 Wilddog 的用户的ID Token，然后作为参数调用 Wilddog 提供的接口获得用户是否合法。\n\n\n","source":"guide/auth/server/introduction.md","raw":"title: 服务端身份认证\n---\n\n使用 Wilddog，你可以将你自己的已有服务与 Wilddog Auth 集成起来。\n你可以使用 Wilddog 官方提供的 Server SDK 来操作用户认证 token, 或者你可以用第三方的 JWT（JSON Web Token）库自己实现。\n\nWilddog 服务端身份认证 SDK 主要帮助用户实现以下两个功能：\n\n* **生成 Custom Token**\n\n  **\n  **你可以将已有用户系统与Wilddog集成，比如，你可能已经拥有一个用户数据库，或者你想要集成一个Wilddog不原生支持的第三方认证提供方（如Facebook）。\n  你可以生成自定义 Token，并且你可以添加任意标识用户的信息。然后，这个custom token就可以被用来作为Wilddog API 中自定义登录的参数来登录 Wilddog, 完成操作实时数据同步等。\n\n* **认证 ID Token**\n\n  **\n  **Wilddog Auth 主要用来认证你的 APP 用户，来限制用户对于 Wilddog 服务的权限。但是，你也可以在你自己的服务中认证用户。\n  要做到这样，你需要在客户端获取登录 Wilddog 的用户的ID Token，然后作为参数调用 Wilddog 提供的接口获得用户是否合法。\n\n\n","date":"2016-09-07T13:24:23.099Z","updated":"2016-09-07T13:24:23.099Z","path":"guide/auth/server/introduction.html","_id":"cisswi9l10019z4fwai9uik30","comments":1,"layout":"page","content":"<p>使用 Wilddog，你可以将你自己的已有服务与 Wilddog Auth 集成起来。<br>你可以使用 Wilddog 官方提供的 Server SDK 来操作用户认证 token, 或者你可以用第三方的 JWT（JSON Web Token）库自己实现。</p>\n<p>Wilddog 服务端身份认证 SDK 主要帮助用户实现以下两个功能：</p>\n<ul>\n<li><p><strong>生成 Custom Token</strong></p>\n<p><strong>\n</strong>你可以将已有用户系统与Wilddog集成，比如，你可能已经拥有一个用户数据库，或者你想要集成一个Wilddog不原生支持的第三方认证提供方（如Facebook）。<br>你可以生成自定义 Token，并且你可以添加任意标识用户的信息。然后，这个custom token就可以被用来作为Wilddog API 中自定义登录的参数来登录 Wilddog, 完成操作实时数据同步等。</p>\n</li>\n<li><p><strong>认证 ID Token</strong></p>\n<p><strong>\n</strong>Wilddog Auth 主要用来认证你的 APP 用户，来限制用户对于 Wilddog 服务的权限。但是，你也可以在你自己的服务中认证用户。<br>要做到这样，你需要在客户端获取登录 Wilddog 的用户的ID Token，然后作为参数调用 Wilddog 提供的接口获得用户是否合法。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>使用 Wilddog，你可以将你自己的已有服务与 Wilddog Auth 集成起来。<br>你可以使用 Wilddog 官方提供的 Server SDK 来操作用户认证 token, 或者你可以用第三方的 JWT（JSON Web Token）库自己实现。</p>\n<p>Wilddog 服务端身份认证 SDK 主要帮助用户实现以下两个功能：</p>\n<ul>\n<li><p><strong>生成 Custom Token</strong></p>\n<p><strong>\n</strong>你可以将已有用户系统与Wilddog集成，比如，你可能已经拥有一个用户数据库，或者你想要集成一个Wilddog不原生支持的第三方认证提供方（如Facebook）。<br>你可以生成自定义 Token，并且你可以添加任意标识用户的信息。然后，这个custom token就可以被用来作为Wilddog API 中自定义登录的参数来登录 Wilddog, 完成操作实时数据同步等。</p>\n</li>\n<li><p><strong>认证 ID Token</strong></p>\n<p><strong>\n</strong>Wilddog Auth 主要用来认证你的 APP 用户，来限制用户对于 Wilddog 服务的权限。但是，你也可以在你自己的服务中认证用户。<br>要做到这样，你需要在客户端获取登录 Wilddog 的用户的ID Token，然后作为参数调用 Wilddog 提供的接口获得用户是否合法。</p>\n</li>\n</ul>\n"},{"title":"匿名登录","_content":"\n你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，[可以绑定其它登录方式](/guide/auth/web/link.html)。\n\n## 开始前的准备工作\n\n1. 在 Wilddog 控制面板中创建一个应用.\n\n2. 打开匿名登录方式:\n\n * 在野狗控制面板中选择身份认证选项。\n\n * 在｀登录方式｀标签中打开匿名登录方式。\n\n## 使用 Wilddog 匿名登录认证\n\n当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：\n\n1. 导入 Wilddog Auth 模块:\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 以 Wilddog AppId 初始化 Wilddog 应用。\n    ```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n\n    ```\n\n3. 调用 `signInAnonymously()`方法：\n    ```\n   wilddog.auth().signInAnonymously().then(function(res){\n         console.log(res);\n   }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n   });\n    ```\n\n4. 如果signInAnonymously方法调用成功并且没有返回错误信息，你可以在 当前用户 对象中获取用户数据：\n```\nvar isAnonymous = user.anonymous; \nvar uid = user.uid;\n```\n\n## 将匿名帐号转变成永久帐号\n\n当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：\n\n准备一个未在你的应用上登录过的邮箱或者第三方登录方式。\n\n#### 关联QQ登录\n\n```\nvar provider = new wilddog.auth.QQAuthProvider();\n\npopup关联\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n    console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.\n    console.log(errorCode);\n     // ...\n});\n\nredirect关联\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.  \n     console.log(errorCode);     \n     // ...\n});\n```\n\n#### 关联微信登录\n\n```\nvar provider = new wilddog.auth.WeixinAuthProvider();\n\npopup\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.     \n    console.log(errorCode);    \n     // ...\n});\n\nredirect\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.     \n    console.log(errorCode);  \n    // ...\n});\n\n```\n\n#### 关联微博登录\n\n```\n\nvar provider = new wilddog.auth.WeiboAuthProvider();\n\npopup\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n      console.log(result);\n}).catch(function (error) {\n      // Handle Errors here.   \n      console.log(errorCode);     \n     // ...\n});\n\nredirect\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {     \n     // Handle Errors here.   \n     console.log(errorCode);  \n    // ...\n});\n\n```\n\n#### 关联微信公众账号登录\n\n```\nvar provider = new wilddog.auth.WeixinmpAuthProvider();\n\npopup\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {、\n     // Handle Errors here.\n     console.log(errorCode);\n     // ...\n});\n\nredirect\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {  \n     // Handle Errors here.  \n     console.log(errorCode); \n     // ...\n});\n```\n\n#### 关联邮箱登录\n\n```\n var credentialEmail = wilddog.auth.EmailAuthProvider.credential(\"22443311@qq.com\", \"12345678\");\n var user = wilddog.auth().currentUser;\n user.link(credentialEmail).then(function (user) {\n     console.log(\"Account linking1 success\", user);\n }, function (error) {\n     console.log(\"Account linking1 error\", error);\n });\n\n```\n\n\n## 后续步骤\n\n现在我们已经学会了使用野狗进行用户认证，你可以配置 [规则表达式](/guide/sync/rules/introduce.html) 来控制野狗实时数据的访问权限。\n","source":"guide/auth/web/anonymous.md","raw":"title:  匿名登录\n---\n\n你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，[可以绑定其它登录方式](/guide/auth/web/link.html)。\n\n## 开始前的准备工作\n\n1. 在 Wilddog 控制面板中创建一个应用.\n\n2. 打开匿名登录方式:\n\n * 在野狗控制面板中选择身份认证选项。\n\n * 在｀登录方式｀标签中打开匿名登录方式。\n\n## 使用 Wilddog 匿名登录认证\n\n当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：\n\n1. 导入 Wilddog Auth 模块:\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 以 Wilddog AppId 初始化 Wilddog 应用。\n    ```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n\n    ```\n\n3. 调用 `signInAnonymously()`方法：\n    ```\n   wilddog.auth().signInAnonymously().then(function(res){\n         console.log(res);\n   }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n   });\n    ```\n\n4. 如果signInAnonymously方法调用成功并且没有返回错误信息，你可以在 当前用户 对象中获取用户数据：\n```\nvar isAnonymous = user.anonymous; \nvar uid = user.uid;\n```\n\n## 将匿名帐号转变成永久帐号\n\n当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：\n\n准备一个未在你的应用上登录过的邮箱或者第三方登录方式。\n\n#### 关联QQ登录\n\n```\nvar provider = new wilddog.auth.QQAuthProvider();\n\npopup关联\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n    console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.\n    console.log(errorCode);\n     // ...\n});\n\nredirect关联\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.  \n     console.log(errorCode);     \n     // ...\n});\n```\n\n#### 关联微信登录\n\n```\nvar provider = new wilddog.auth.WeixinAuthProvider();\n\npopup\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.     \n    console.log(errorCode);    \n     // ...\n});\n\nredirect\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {\n     // Handle Errors here.     \n    console.log(errorCode);  \n    // ...\n});\n\n```\n\n#### 关联微博登录\n\n```\n\nvar provider = new wilddog.auth.WeiboAuthProvider();\n\npopup\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n      console.log(result);\n}).catch(function (error) {\n      // Handle Errors here.   \n      console.log(errorCode);     \n     // ...\n});\n\nredirect\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {     \n     // Handle Errors here.   \n     console.log(errorCode);  \n    // ...\n});\n\n```\n\n#### 关联微信公众账号登录\n\n```\nvar provider = new wilddog.auth.WeixinmpAuthProvider();\n\npopup\nwilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {、\n     // Handle Errors here.\n     console.log(errorCode);\n     // ...\n});\n\nredirect\nwilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n     console.log(result);\n}).catch(function (error) {  \n     // Handle Errors here.  \n     console.log(errorCode); \n     // ...\n});\n```\n\n#### 关联邮箱登录\n\n```\n var credentialEmail = wilddog.auth.EmailAuthProvider.credential(\"22443311@qq.com\", \"12345678\");\n var user = wilddog.auth().currentUser;\n user.link(credentialEmail).then(function (user) {\n     console.log(\"Account linking1 success\", user);\n }, function (error) {\n     console.log(\"Account linking1 error\", error);\n });\n\n```\n\n\n## 后续步骤\n\n现在我们已经学会了使用野狗进行用户认证，你可以配置 [规则表达式](/guide/sync/rules/introduce.html) 来控制野狗实时数据的访问权限。\n","date":"2016-09-06T03:38:22.530Z","updated":"2016-09-06T03:38:22.530Z","path":"guide/auth/web/anonymous.html","comments":1,"layout":"page","_id":"cisswi9l1001az4fwbmmbsoeo","content":"<p>你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，<a href=\"/guide/auth/web/link.html\">可以绑定其它登录方式</a>。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 Wilddog 控制面板中创建一个应用.</p>\n</li>\n<li><p>打开匿名登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择身份认证选项。</p>\n</li>\n<li><p>在｀登录方式｀标签中打开匿名登录方式。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用-Wilddog-匿名登录认证\"><a href=\"#使用-Wilddog-匿名登录认证\" class=\"headerlink\" title=\"使用 Wilddog 匿名登录认证\"></a>使用 Wilddog 匿名登录认证</h2><p>当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：</p>\n<ol>\n<li><p>导入 Wilddog Auth 模块:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>以 Wilddog AppId 初始化 Wilddog 应用。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用 <code>signInAnonymously()</code>方法：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInAnonymously().then(function(res)&#123;</div><div class=\"line\">      console.log(res);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">      // Handle Errors here.</div><div class=\"line\">      console.log(error);</div><div class=\"line\">      // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果signInAnonymously方法调用成功并且没有返回错误信息，你可以在 当前用户 对象中获取用户数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var isAnonymous = user.anonymous; </div><div class=\"line\">var uid = user.uid;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"将匿名帐号转变成永久帐号\"><a href=\"#将匿名帐号转变成永久帐号\" class=\"headerlink\" title=\"将匿名帐号转变成永久帐号\"></a>将匿名帐号转变成永久帐号</h2><p>当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：</p>\n<p>准备一个未在你的应用上登录过的邮箱或者第三方登录方式。</p>\n<h4 id=\"关联QQ登录\"><a href=\"#关联QQ登录\" class=\"headerlink\" title=\"关联QQ登录\"></a>关联QQ登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.QQAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup关联</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">    console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">    console.log(errorCode);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect关联</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.  </div><div class=\"line\">     console.log(errorCode);     </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联微信登录\"><a href=\"#关联微信登录\" class=\"headerlink\" title=\"关联微信登录\"></a>关联微信登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.     </div><div class=\"line\">    console.log(errorCode);    </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.     </div><div class=\"line\">    console.log(errorCode);  </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联微博登录\"><a href=\"#关联微博登录\" class=\"headerlink\" title=\"关联微博登录\"></a>关联微博登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var provider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">      console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">      // Handle Errors here.   </div><div class=\"line\">      console.log(errorCode);     </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;     </div><div class=\"line\">     // Handle Errors here.   </div><div class=\"line\">     console.log(errorCode);  </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联微信公众账号登录\"><a href=\"#关联微信公众账号登录\" class=\"headerlink\" title=\"关联微信公众账号登录\"></a>关联微信公众账号登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinmpAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;、</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(errorCode);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;  </div><div class=\"line\">     // Handle Errors here.  </div><div class=\"line\">     console.log(errorCode); </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联邮箱登录\"><a href=\"#关联邮箱登录\" class=\"headerlink\" title=\"关联邮箱登录\"></a>关联邮箱登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var credentialEmail = wilddog.auth.EmailAuthProvider.credential(&quot;22443311@qq.com&quot;, &quot;12345678&quot;);</div><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">user.link(credentialEmail).then(function (user) &#123;</div><div class=\"line\">    console.log(&quot;Account linking1 success&quot;, user);</div><div class=\"line\">&#125;, function (error) &#123;</div><div class=\"line\">    console.log(&quot;Account linking1 error&quot;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>现在我们已经学会了使用野狗进行用户认证，你可以配置 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 来控制野狗实时数据的访问权限。</p>\n","excerpt":"","more":"<p>你可以在 Wilddog 身份认证中创建和使用临时匿名帐号来进行身份认证。如果你在应用中使用了规则表达式来保护数据的访问权限，即使用户未登录，使用临时匿名帐号也能正常访问数据。如果想长期保留临时匿名帐号，<a href=\"/guide/auth/web/link.html\">可以绑定其它登录方式</a>。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 Wilddog 控制面板中创建一个应用.</p>\n</li>\n<li><p>打开匿名登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择身份认证选项。</p>\n</li>\n<li><p>在｀登录方式｀标签中打开匿名登录方式。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用-Wilddog-匿名登录认证\"><a href=\"#使用-Wilddog-匿名登录认证\" class=\"headerlink\" title=\"使用 Wilddog 匿名登录认证\"></a>使用 Wilddog 匿名登录认证</h2><p>当一个未登录的用户想想使用一个 Wilddog 必须登录才能使用的特性，可以利用匿名登录，完成下面步骤：</p>\n<ol>\n<li><p>导入 Wilddog Auth 模块:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>以 Wilddog AppId 初始化 Wilddog 应用。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>调用 <code>signInAnonymously()</code>方法：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInAnonymously().then(function(res)&#123;</div><div class=\"line\">      console.log(res);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">      // Handle Errors here.</div><div class=\"line\">      console.log(error);</div><div class=\"line\">      // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果signInAnonymously方法调用成功并且没有返回错误信息，你可以在 当前用户 对象中获取用户数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var isAnonymous = user.anonymous; </div><div class=\"line\">var uid = user.uid;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"将匿名帐号转变成永久帐号\"><a href=\"#将匿名帐号转变成永久帐号\" class=\"headerlink\" title=\"将匿名帐号转变成永久帐号\"></a>将匿名帐号转变成永久帐号</h2><p>当使用匿名登录时，你可能想下次在其它设备上还能登录这个帐号。比如你有一个新闻类的应用，用户在使用应用时，收藏了很多新闻，但是当换一个设备时，却访问不到这些数据。完成下面步骤可以将其转换为永久帐号：</p>\n<p>准备一个未在你的应用上登录过的邮箱或者第三方登录方式。</p>\n<h4 id=\"关联QQ登录\"><a href=\"#关联QQ登录\" class=\"headerlink\" title=\"关联QQ登录\"></a>关联QQ登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.QQAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup关联</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">    console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">    console.log(errorCode);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect关联</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.  </div><div class=\"line\">     console.log(errorCode);     </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联微信登录\"><a href=\"#关联微信登录\" class=\"headerlink\" title=\"关联微信登录\"></a>关联微信登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.     </div><div class=\"line\">    console.log(errorCode);    </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.     </div><div class=\"line\">    console.log(errorCode);  </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联微博登录\"><a href=\"#关联微博登录\" class=\"headerlink\" title=\"关联微博登录\"></a>关联微博登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var provider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">      console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">      // Handle Errors here.   </div><div class=\"line\">      console.log(errorCode);     </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;     </div><div class=\"line\">     // Handle Errors here.   </div><div class=\"line\">     console.log(errorCode);  </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联微信公众账号登录\"><a href=\"#关联微信公众账号登录\" class=\"headerlink\" title=\"关联微信公众账号登录\"></a>关联微信公众账号登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinmpAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;、</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(errorCode);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;  </div><div class=\"line\">     // Handle Errors here.  </div><div class=\"line\">     console.log(errorCode); </div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"关联邮箱登录\"><a href=\"#关联邮箱登录\" class=\"headerlink\" title=\"关联邮箱登录\"></a>关联邮箱登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var credentialEmail = wilddog.auth.EmailAuthProvider.credential(&quot;22443311@qq.com&quot;, &quot;12345678&quot;);</div><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">user.link(credentialEmail).then(function (user) &#123;</div><div class=\"line\">    console.log(&quot;Account linking1 success&quot;, user);</div><div class=\"line\">&#125;, function (error) &#123;</div><div class=\"line\">    console.log(&quot;Account linking1 error&quot;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>现在我们已经学会了使用野狗进行用户认证，你可以配置 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 来控制野狗实时数据的访问权限。</p>\n"},{"title":"自定义身份认证","_content":"\n您可以通过自定义身份认证系统来集成您的已有帐号系统，当用户登录到您的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。\n\n\n\n## 开始前的准备工作\n\n1. [创建野狗应用](/console/creat.html)\n\n2. [使用野狗超级密钥生成 Custom Token](/guide/auth/server/server.html)\n\n\n\n## Wilddog 身份认证\n\n1. 引入 WilddogAuth 模块：\n\n```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n```\n\n2. 初始化 Wilddog 应用实例：\n\n```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n```\n\n3. 当用户登录您的应用时，发送他们的凭据（比如邮箱密码的方式）到您的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。\n\n4. 从服务器收到 Custom Token 后，传到 `signInWithCustomToken:` 方法中进行登录：\n\n```\nwilddog.auth().signInWithCustomToken(customToken).then(function (res){\n     console.log(res);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n\n* 在您的应用中，您可以通过 wilddog.auth().currentUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\n\n wilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n","source":"guide/auth/web/custom.md","raw":"title:  自定义身份认证\n---\n\n您可以通过自定义身份认证系统来集成您的已有帐号系统，当用户登录到您的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。\n\n\n\n## 开始前的准备工作\n\n1. [创建野狗应用](/console/creat.html)\n\n2. [使用野狗超级密钥生成 Custom Token](/guide/auth/server/server.html)\n\n\n\n## Wilddog 身份认证\n\n1. 引入 WilddogAuth 模块：\n\n```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n```\n\n2. 初始化 Wilddog 应用实例：\n\n```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n```\n\n3. 当用户登录您的应用时，发送他们的凭据（比如邮箱密码的方式）到您的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。\n\n4. 从服务器收到 Custom Token 后，传到 `signInWithCustomToken:` 方法中进行登录：\n\n```\nwilddog.auth().signInWithCustomToken(customToken).then(function (res){\n     console.log(res);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n\n* 在您的应用中，您可以通过 wilddog.auth().currentUser 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\n\n wilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n","date":"2016-09-06T03:38:22.531Z","updated":"2016-09-06T03:38:22.531Z","path":"guide/auth/web/custom.html","comments":1,"layout":"page","_id":"cisswi9l1001bz4fwsjrd9rah","content":"<p>您可以通过自定义身份认证系统来集成您的已有帐号系统，当用户登录到您的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p><a href=\"/console/creat.html\">创建野狗应用</a></p>\n</li>\n<li><p><a href=\"/guide/auth/server/server.html\">使用野狗超级密钥生成 Custom Token</a></p>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li>引入 WilddogAuth 模块：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<ol>\n<li>初始化 Wilddog 应用实例：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n<ol>\n<li><p>当用户登录您的应用时，发送他们的凭据（比如邮箱密码的方式）到您的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。</p>\n</li>\n<li><p>从服务器收到 Custom Token 后，传到 <code>signInWithCustomToken:</code> 方法中进行登录：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInWithCustomToken(customToken).then(function (res)&#123;</div><div class=\"line\">     console.log(res);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在您的应用中，您可以通过 wilddog.auth().currentUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">    // Sign-out successful.</div><div class=\"line\">    console.log(&quot;sign-out&quot;)</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">    // An error happened.</div><div class=\"line\">    console.log(&quot;sign-out-error&quot;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>您可以通过自定义身份认证系统来集成您的已有帐号系统，当用户登录到您的服务器时，生成 Custom Token 返回给客户端，Wilddog 身份认证系统利用它来进行身份认证。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p><a href=\"/console/creat.html\">创建野狗应用</a></p>\n</li>\n<li><p><a href=\"/guide/auth/server/server.html\">使用野狗超级密钥生成 Custom Token</a></p>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li>引入 WilddogAuth 模块：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<ol>\n<li>初始化 Wilddog 应用实例：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n<ol>\n<li><p>当用户登录您的应用时，发送他们的凭据（比如邮箱密码的方式）到您的服务器上。然后服务器检查凭据的正确性并返回 Custom Token。</p>\n</li>\n<li><p>从服务器收到 Custom Token 后，传到 <code>signInWithCustomToken:</code> 方法中进行登录：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInWithCustomToken(customToken).then(function (res)&#123;</div><div class=\"line\">     console.log(res);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在您的应用中，您可以通过 wilddog.auth().currentUser 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">    // Sign-out successful.</div><div class=\"line\">    console.log(&quot;sign-out&quot;)</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">    // An error happened.</div><div class=\"line\">    console.log(&quot;sign-out-error&quot;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"完整 API 文档","_content":"\n## Auth相关\n\n* 创建邮箱密码登录\n\n`wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example:\nwilddog.auth().createUserWithEmailAndPassword(email, pwd).then(function (user) {\n     console.info(\"user created.\", user);\n }).catch(function (err, more) { \n     console.info(\"create user failed.\", err, more);\n });\n```\n\n* 匿名用户登录\n\n`wilddog.auth().signInAnonymously() returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example:\n    wilddog.auth().signInAnoymously().then(function (result){\n            console.info(\"signInAnouymously success\", result)\n        }).catch(function(err){\n            console.info(\"signInAnouymously failed\",err)\n        })\n    }\n```\n\n* 邮箱密码登录\n\n`wilddog.auth().signInWithEmailAndPassword(email, pwd) returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise) \n\n```\nfor example:\nwilddog.auth().signInWithEmailAndPassword(email,pwd).then(function (a, b) { \n    console.info(\"login success->\", a, b);    \n    console.info(\"currentUser->\",wilddog.auth().currentUser);\n}).catch(function (a, b) {\n    console.info('login failed ->', a, b);\n});\n```\n\n* OAuth登录\\(popup\\)\n\n`wilddog.auth().signInWithPopup(provider) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example: weibo OAuth\n\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithPopup(weiboProvider).then(function () {\n\n });\n```\n\n* OAuth登录\\(redirect\\)\n\n`wilddog.auth().signInWithRedirect(provider) return `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example : weibo OAuth\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithRedirect(weiboProvider).then(function () {\n console.info(\"signInWithRedirect success.\")\n });\n\n```\n\n* 通过customToken登录\n\n`wilddog.auth().signInWithCustomToken(token) return` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n* 监听用户状态\n\n`wilddog.auth().onAuthStateChanged`\n\n```\nfor example: \n\nwilddog.auth().onAuthStateChanged(function (user) {\n console.info(\"onAuthStateChanged\",user);\n });\n\n```\n\n* 重置密码\n\n`wilddog.auth().sendPasswordResetEmail(email) returns ` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n* 通过[credential](/api/auth/web.html#Credential)登录\n\n`wilddog.auth().signInWithCredential(credential) returns`\n[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\ncredential为用户凭证,是使用的凭证\n目前有两种凭证:\n    1:账号密码登录方式中的账号和密码\n    2:OAuth登录中的accessToken\nfor example : \nvar credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);\nwilddog.auth().signInWithCredential(credential)\n\n```\n\n* 登出 <a id=\"signout\"></a>\n\n```javascript\nwilddog.auth().signOut();\n```\nfor example:\n```javascript\nif (wilddog.auth().currentUser) {\n     wilddog.auth().signOut();\n}\n```\n\n## User相关\n\n- 通过credential关联登录方式\n\n`wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)`\n\n```\nwilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(function (user) { \n    console.info(\"link email.\", user);\n}).catch(function (err, more) {\n    console.info(\"link email failed.\", err.code, err, user);\n});\n\n```\n- 通过Oauth的popup关联登录方式\n\n`wilddog.auth().currentUser.linkWithPopup(provider)`\n\n```\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n\n```\n\n- 通过Oauth的redirect关联登录方式\n\n`wilddog.auth().currentUser.linkWithRedirect(provider)`\n```\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n\n- 取消账户的登录方式\n\n`wilddog.auth().currentUser.unlink(providerId)`\n```\nproviderId目前一共有5种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp\nwilddog.auth().currentUser.unlink('weibo').then(function (res) {\n console.info(\"unlink weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n\n- 删除用户\n\n`wilddog.auth().currentUser.delete()`\n\n- 更新账户信息\n\n`wilddog.auth().currentUser.updateProfile();`\n```\n修改用户的属性,目前包括displayName和photoUrl\nfor example :\nwilddog.auth().currentUser.updateProfile({\n 'photoURL': photoUrl,\n 'displayName': displayName,\n}).then(function (res) {\n console.info('update user ->', res);\n}).catch(function (err) {\n console.info(\"update user info failed.\", err);\n});\n\n```\n\n- 更新邮箱\n\n`wilddog.auth().currentUser.updateEmail(email);`\n\n- 更新密码\n\n`wilddog.auth().currentUser.updatePassword(password)`\n\n- reauthenticate\n\n`wilddog.auth().currentUser.reauthenticate(credential)`\n\n- 发送邮箱确认邮件\n\n`wilddog.auth().currentUser.sendEmailVerification()`\n\n## wilddog.Promise\n\n*class static*\n  ```A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.```\n\nConstructor    \n- new Promise(resolver)\n\nMain Methods\n- catch\n    Assign a callback when the Promise rejects.\n- then\n    Assign callback functions called where the Promise eather resolves, or is reject.\n\n## Credential\n\n本次Auth增加Credential的概念\n\ncredential有两种形式\n- 账号密码\n- OAuth\n\n例如email登录方式\n\n`var credential = wilddog.auth.EmailAuthProvider.credential(email,password)`\n\n例如微博登录方式\n\n`var credentail = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token)` ","source":"guide/auth/web/api.md","raw":"title:  完整 API 文档\n---\n\n## Auth相关\n\n* 创建邮箱密码登录\n\n`wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example:\nwilddog.auth().createUserWithEmailAndPassword(email, pwd).then(function (user) {\n     console.info(\"user created.\", user);\n }).catch(function (err, more) { \n     console.info(\"create user failed.\", err, more);\n });\n```\n\n* 匿名用户登录\n\n`wilddog.auth().signInAnonymously() returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example:\n    wilddog.auth().signInAnoymously().then(function (result){\n            console.info(\"signInAnouymously success\", result)\n        }).catch(function(err){\n            console.info(\"signInAnouymously failed\",err)\n        })\n    }\n```\n\n* 邮箱密码登录\n\n`wilddog.auth().signInWithEmailAndPassword(email, pwd) returns` [wilddog.Promise](/api/auth/web.html#wilddog-Promise) \n\n```\nfor example:\nwilddog.auth().signInWithEmailAndPassword(email,pwd).then(function (a, b) { \n    console.info(\"login success->\", a, b);    \n    console.info(\"currentUser->\",wilddog.auth().currentUser);\n}).catch(function (a, b) {\n    console.info('login failed ->', a, b);\n});\n```\n\n* OAuth登录\\(popup\\)\n\n`wilddog.auth().signInWithPopup(provider) returns `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example: weibo OAuth\n\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithPopup(weiboProvider).then(function () {\n\n });\n```\n\n* OAuth登录\\(redirect\\)\n\n`wilddog.auth().signInWithRedirect(provider) return `[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\nfor example : weibo OAuth\nvar weiboProvider = new wilddog.auth.WeiboAuthProvider();\nwilddog.auth().signInWithRedirect(weiboProvider).then(function () {\n console.info(\"signInWithRedirect success.\")\n });\n\n```\n\n* 通过customToken登录\n\n`wilddog.auth().signInWithCustomToken(token) return` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n* 监听用户状态\n\n`wilddog.auth().onAuthStateChanged`\n\n```\nfor example: \n\nwilddog.auth().onAuthStateChanged(function (user) {\n console.info(\"onAuthStateChanged\",user);\n });\n\n```\n\n* 重置密码\n\n`wilddog.auth().sendPasswordResetEmail(email) returns ` [wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n* 通过[credential](/api/auth/web.html#Credential)登录\n\n`wilddog.auth().signInWithCredential(credential) returns`\n[wilddog.Promise](/api/auth/web.html#wilddog-Promise)\n\n```\ncredential为用户凭证,是使用的凭证\n目前有两种凭证:\n    1:账号密码登录方式中的账号和密码\n    2:OAuth登录中的accessToken\nfor example : \nvar credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);\nwilddog.auth().signInWithCredential(credential)\n\n```\n\n* 登出 <a id=\"signout\"></a>\n\n```javascript\nwilddog.auth().signOut();\n```\nfor example:\n```javascript\nif (wilddog.auth().currentUser) {\n     wilddog.auth().signOut();\n}\n```\n\n## User相关\n\n- 通过credential关联登录方式\n\n`wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)`\n\n```\nwilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(function (user) { \n    console.info(\"link email.\", user);\n}).catch(function (err, more) {\n    console.info(\"link email failed.\", err.code, err, user);\n});\n\n```\n- 通过Oauth的popup关联登录方式\n\n`wilddog.auth().currentUser.linkWithPopup(provider)`\n\n```\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n\n```\n\n- 通过Oauth的redirect关联登录方式\n\n`wilddog.auth().currentUser.linkWithRedirect(provider)`\n```\nfor example : Weibo OAuth\nwilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) {\n console.info(\"link weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n\n- 取消账户的登录方式\n\n`wilddog.auth().currentUser.unlink(providerId)`\n```\nproviderId目前一共有5种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp\nwilddog.auth().currentUser.unlink('weibo').then(function (res) {\n console.info(\"unlink weibo->\", res);\n}).catch(function (err) {\n console.info(err);\n});\n\n```\n\n- 删除用户\n\n`wilddog.auth().currentUser.delete()`\n\n- 更新账户信息\n\n`wilddog.auth().currentUser.updateProfile();`\n```\n修改用户的属性,目前包括displayName和photoUrl\nfor example :\nwilddog.auth().currentUser.updateProfile({\n 'photoURL': photoUrl,\n 'displayName': displayName,\n}).then(function (res) {\n console.info('update user ->', res);\n}).catch(function (err) {\n console.info(\"update user info failed.\", err);\n});\n\n```\n\n- 更新邮箱\n\n`wilddog.auth().currentUser.updateEmail(email);`\n\n- 更新密码\n\n`wilddog.auth().currentUser.updatePassword(password)`\n\n- reauthenticate\n\n`wilddog.auth().currentUser.reauthenticate(credential)`\n\n- 发送邮箱确认邮件\n\n`wilddog.auth().currentUser.sendEmailVerification()`\n\n## wilddog.Promise\n\n*class static*\n  ```A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.```\n\nConstructor    \n- new Promise(resolver)\n\nMain Methods\n- catch\n    Assign a callback when the Promise rejects.\n- then\n    Assign callback functions called where the Promise eather resolves, or is reject.\n\n## Credential\n\n本次Auth增加Credential的概念\n\ncredential有两种形式\n- 账号密码\n- OAuth\n\n例如email登录方式\n\n`var credential = wilddog.auth.EmailAuthProvider.credential(email,password)`\n\n例如微博登录方式\n\n`var credentail = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token)` ","date":"2016-09-06T03:38:22.530Z","updated":"2016-09-06T03:38:22.530Z","path":"guide/auth/web/api.html","comments":1,"layout":"page","_id":"cisswi9l1001cz4fwdm5j3k7e","content":"<h2 id=\"Auth相关\"><a href=\"#Auth相关\" class=\"headerlink\" title=\"Auth相关\"></a>Auth相关</h2><ul>\n<li>创建邮箱密码登录</li>\n</ul>\n<p><code>wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example:</div><div class=\"line\">wilddog.auth().createUserWithEmailAndPassword(email, pwd).then(function (user) &#123;</div><div class=\"line\">     console.info(&quot;user created.&quot;, user);</div><div class=\"line\"> &#125;).catch(function (err, more) &#123; </div><div class=\"line\">     console.info(&quot;create user failed.&quot;, err, more);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>匿名用户登录</li>\n</ul>\n<p><code>wilddog.auth().signInAnonymously() returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example:</div><div class=\"line\">    wilddog.auth().signInAnoymously().then(function (result)&#123;</div><div class=\"line\">            console.info(&quot;signInAnouymously success&quot;, result)</div><div class=\"line\">        &#125;).catch(function(err)&#123;</div><div class=\"line\">            console.info(&quot;signInAnouymously failed&quot;,err)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>邮箱密码登录</li>\n</ul>\n<p><code>wilddog.auth().signInWithEmailAndPassword(email, pwd) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example:</div><div class=\"line\">wilddog.auth().signInWithEmailAndPassword(email,pwd).then(function (a, b) &#123; </div><div class=\"line\">    console.info(&quot;login success-&gt;&quot;, a, b);    </div><div class=\"line\">    console.info(&quot;currentUser-&gt;&quot;,wilddog.auth().currentUser);</div><div class=\"line\">&#125;).catch(function (a, b) &#123;</div><div class=\"line\">    console.info(&apos;login failed -&gt;&apos;, a, b);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>OAuth登录(popup)</li>\n</ul>\n<p><code>wilddog.auth().signInWithPopup(provider) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example: weibo OAuth</div><div class=\"line\"></div><div class=\"line\">var weiboProvider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithPopup(weiboProvider).then(function () &#123;</div><div class=\"line\"></div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>OAuth登录(redirect)</li>\n</ul>\n<p><code>wilddog.auth().signInWithRedirect(provider) return</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : weibo OAuth</div><div class=\"line\">var weiboProvider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithRedirect(weiboProvider).then(function () &#123;</div><div class=\"line\"> console.info(&quot;signInWithRedirect success.&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过customToken登录</li>\n</ul>\n<p><code>wilddog.auth().signInWithCustomToken(token) return</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<ul>\n<li>监听用户状态</li>\n</ul>\n<p><code>wilddog.auth().onAuthStateChanged</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example: </div><div class=\"line\"></div><div class=\"line\">wilddog.auth().onAuthStateChanged(function (user) &#123;</div><div class=\"line\"> console.info(&quot;onAuthStateChanged&quot;,user);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>重置密码</li>\n</ul>\n<p><code>wilddog.auth().sendPasswordResetEmail(email) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<ul>\n<li>通过<a href=\"/api/auth/web.html#Credential\">credential</a>登录</li>\n</ul>\n<p><code>wilddog.auth().signInWithCredential(credential) returns</code><br><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">credential为用户凭证,是使用的凭证</div><div class=\"line\">目前有两种凭证:</div><div class=\"line\">    1:账号密码登录方式中的账号和密码</div><div class=\"line\">    2:OAuth登录中的accessToken</div><div class=\"line\">for example : </div><div class=\"line\">var credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);</div><div class=\"line\">wilddog.auth().signInWithCredential(credential)</div></pre></td></tr></table></figure>\n<ul>\n<li>登出 <a id=\"signout\"></a></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut();</div></pre></td></tr></table></figure>\n<p>for example:<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (wilddog.auth().currentUser) &#123;</div><div class=\"line\">     wilddog.auth().signOut();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"User相关\"><a href=\"#User相关\" class=\"headerlink\" title=\"User相关\"></a>User相关</h2><ul>\n<li>通过credential关联登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(function (user) &#123; </div><div class=\"line\">    console.info(&quot;link email.&quot;, user);</div><div class=\"line\">&#125;).catch(function (err, more) &#123;</div><div class=\"line\">    console.info(&quot;link email failed.&quot;, err.code, err, user);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Oauth的popup关联登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.linkWithPopup(provider)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) &#123;</div><div class=\"line\"> console.info(&quot;link weibo-&gt;&quot;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Oauth的redirect关联登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.linkWithRedirect(provider)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) &#123;</div><div class=\"line\"> console.info(&quot;link weibo-&gt;&quot;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>取消账户的登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.unlink(providerId)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">providerId目前一共有5种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp</div><div class=\"line\">wilddog.auth().currentUser.unlink(&apos;weibo&apos;).then(function (res) &#123;</div><div class=\"line\"> console.info(&quot;unlink weibo-&gt;&quot;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>删除用户</li>\n</ul>\n<p><code>wilddog.auth().currentUser.delete()</code></p>\n<ul>\n<li>更新账户信息</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updateProfile();</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">修改用户的属性,目前包括displayName和photoUrl</div><div class=\"line\">for example :</div><div class=\"line\">wilddog.auth().currentUser.updateProfile(&#123;</div><div class=\"line\"> &apos;photoURL&apos;: photoUrl,</div><div class=\"line\"> &apos;displayName&apos;: displayName,</div><div class=\"line\">&#125;).then(function (res) &#123;</div><div class=\"line\"> console.info(&apos;update user -&gt;&apos;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(&quot;update user info failed.&quot;, err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>更新邮箱</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updateEmail(email);</code></p>\n<ul>\n<li>更新密码</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updatePassword(password)</code></p>\n<ul>\n<li>reauthenticate</li>\n</ul>\n<p><code>wilddog.auth().currentUser.reauthenticate(credential)</code></p>\n<ul>\n<li>发送邮箱确认邮件</li>\n</ul>\n<p><code>wilddog.auth().currentUser.sendEmailVerification()</code></p>\n<h2 id=\"wilddog-Promise\"><a href=\"#wilddog-Promise\" class=\"headerlink\" title=\"wilddog.Promise\"></a>wilddog.Promise</h2><p><em>class static</em><br>  <code>A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.</code></p>\n<p>Constructor    </p>\n<ul>\n<li>new Promise(resolver)</li>\n</ul>\n<p>Main Methods</p>\n<ul>\n<li>catch<br>  Assign a callback when the Promise rejects.</li>\n<li>then<br>  Assign callback functions called where the Promise eather resolves, or is reject.</li>\n</ul>\n<h2 id=\"Credential\"><a href=\"#Credential\" class=\"headerlink\" title=\"Credential\"></a>Credential</h2><p>本次Auth增加Credential的概念</p>\n<p>credential有两种形式</p>\n<ul>\n<li>账号密码</li>\n<li>OAuth</li>\n</ul>\n<p>例如email登录方式</p>\n<p><code>var credential = wilddog.auth.EmailAuthProvider.credential(email,password)</code></p>\n<p>例如微博登录方式</p>\n<p><code>var credentail = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token)</code> </p>\n","excerpt":"","more":"<h2 id=\"Auth相关\"><a href=\"#Auth相关\" class=\"headerlink\" title=\"Auth相关\"></a>Auth相关</h2><ul>\n<li>创建邮箱密码登录</li>\n</ul>\n<p><code>wilddog.auth().createUserWithEmailAndPassword(email, pwd) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example:</div><div class=\"line\">wilddog.auth().createUserWithEmailAndPassword(email, pwd).then(function (user) &#123;</div><div class=\"line\">     console.info(&quot;user created.&quot;, user);</div><div class=\"line\"> &#125;).catch(function (err, more) &#123; </div><div class=\"line\">     console.info(&quot;create user failed.&quot;, err, more);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>匿名用户登录</li>\n</ul>\n<p><code>wilddog.auth().signInAnonymously() returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example:</div><div class=\"line\">    wilddog.auth().signInAnoymously().then(function (result)&#123;</div><div class=\"line\">            console.info(&quot;signInAnouymously success&quot;, result)</div><div class=\"line\">        &#125;).catch(function(err)&#123;</div><div class=\"line\">            console.info(&quot;signInAnouymously failed&quot;,err)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>邮箱密码登录</li>\n</ul>\n<p><code>wilddog.auth().signInWithEmailAndPassword(email, pwd) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example:</div><div class=\"line\">wilddog.auth().signInWithEmailAndPassword(email,pwd).then(function (a, b) &#123; </div><div class=\"line\">    console.info(&quot;login success-&gt;&quot;, a, b);    </div><div class=\"line\">    console.info(&quot;currentUser-&gt;&quot;,wilddog.auth().currentUser);</div><div class=\"line\">&#125;).catch(function (a, b) &#123;</div><div class=\"line\">    console.info(&apos;login failed -&gt;&apos;, a, b);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>OAuth登录(popup)</li>\n</ul>\n<p><code>wilddog.auth().signInWithPopup(provider) returns</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example: weibo OAuth</div><div class=\"line\"></div><div class=\"line\">var weiboProvider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithPopup(weiboProvider).then(function () &#123;</div><div class=\"line\"></div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>OAuth登录(redirect)</li>\n</ul>\n<p><code>wilddog.auth().signInWithRedirect(provider) return</code><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : weibo OAuth</div><div class=\"line\">var weiboProvider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\">wilddog.auth().signInWithRedirect(weiboProvider).then(function () &#123;</div><div class=\"line\"> console.info(&quot;signInWithRedirect success.&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过customToken登录</li>\n</ul>\n<p><code>wilddog.auth().signInWithCustomToken(token) return</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<ul>\n<li>监听用户状态</li>\n</ul>\n<p><code>wilddog.auth().onAuthStateChanged</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example: </div><div class=\"line\"></div><div class=\"line\">wilddog.auth().onAuthStateChanged(function (user) &#123;</div><div class=\"line\"> console.info(&quot;onAuthStateChanged&quot;,user);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>重置密码</li>\n</ul>\n<p><code>wilddog.auth().sendPasswordResetEmail(email) returns</code> <a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<ul>\n<li>通过<a href=\"/api/auth/web.html#Credential\">credential</a>登录</li>\n</ul>\n<p><code>wilddog.auth().signInWithCredential(credential) returns</code><br><a href=\"/api/auth/web.html#wilddog-Promise\">wilddog.Promise</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">credential为用户凭证,是使用的凭证</div><div class=\"line\">目前有两种凭证:</div><div class=\"line\">    1:账号密码登录方式中的账号和密码</div><div class=\"line\">    2:OAuth登录中的accessToken</div><div class=\"line\">for example : </div><div class=\"line\">var credential = wilddog.auth.WeiboAuthProvider.credential(accessToken);</div><div class=\"line\">wilddog.auth().signInWithCredential(credential)</div></pre></td></tr></table></figure>\n<ul>\n<li>登出 <a id=\"signout\"></a></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut();</div></pre></td></tr></table></figure>\n<p>for example:<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (wilddog.auth().currentUser) &#123;</div><div class=\"line\">     wilddog.auth().signOut();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"User相关\"><a href=\"#User相关\" class=\"headerlink\" title=\"User相关\"></a>User相关</h2><ul>\n<li>通过credential关联登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.link(wilddog.auth.EmailAuthProvider.credential(email, pwd)).then(function (user) &#123; </div><div class=\"line\">    console.info(&quot;link email.&quot;, user);</div><div class=\"line\">&#125;).catch(function (err, more) &#123;</div><div class=\"line\">    console.info(&quot;link email failed.&quot;, err.code, err, user);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Oauth的popup关联登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.linkWithPopup(provider)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) &#123;</div><div class=\"line\"> console.info(&quot;link weibo-&gt;&quot;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>通过Oauth的redirect关联登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.linkWithRedirect(provider)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : Weibo OAuth</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(weiboProvider).then(function (res) &#123;</div><div class=\"line\"> console.info(&quot;link weibo-&gt;&quot;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>取消账户的登录方式</li>\n</ul>\n<p><code>wilddog.auth().currentUser.unlink(providerId)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">providerId目前一共有5种,包括password(账号密码登录),weibo(微博OAuth),weixin(微信),qq,weixinmp</div><div class=\"line\">wilddog.auth().currentUser.unlink(&apos;weibo&apos;).then(function (res) &#123;</div><div class=\"line\"> console.info(&quot;unlink weibo-&gt;&quot;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>删除用户</li>\n</ul>\n<p><code>wilddog.auth().currentUser.delete()</code></p>\n<ul>\n<li>更新账户信息</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updateProfile();</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">修改用户的属性,目前包括displayName和photoUrl</div><div class=\"line\">for example :</div><div class=\"line\">wilddog.auth().currentUser.updateProfile(&#123;</div><div class=\"line\"> &apos;photoURL&apos;: photoUrl,</div><div class=\"line\"> &apos;displayName&apos;: displayName,</div><div class=\"line\">&#125;).then(function (res) &#123;</div><div class=\"line\"> console.info(&apos;update user -&gt;&apos;, res);</div><div class=\"line\">&#125;).catch(function (err) &#123;</div><div class=\"line\"> console.info(&quot;update user info failed.&quot;, err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>更新邮箱</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updateEmail(email);</code></p>\n<ul>\n<li>更新密码</li>\n</ul>\n<p><code>wilddog.auth().currentUser.updatePassword(password)</code></p>\n<ul>\n<li>reauthenticate</li>\n</ul>\n<p><code>wilddog.auth().currentUser.reauthenticate(credential)</code></p>\n<ul>\n<li>发送邮箱确认邮件</li>\n</ul>\n<p><code>wilddog.auth().currentUser.sendEmailVerification()</code></p>\n<h2 id=\"wilddog-Promise\"><a href=\"#wilddog-Promise\" class=\"headerlink\" title=\"wilddog.Promise\"></a>wilddog.Promise</h2><p><em>class static</em><br>  <code>A Promise represents an eventual (asynchronous) value. A Promise should (eventually) either resolve or reject. When it does, it will call all the callback functions that have been assigned via the .then() or .catch() methods.</code></p>\n<p>Constructor    </p>\n<ul>\n<li>new Promise(resolver)</li>\n</ul>\n<p>Main Methods</p>\n<ul>\n<li>catch<br>  Assign a callback when the Promise rejects.</li>\n<li>then<br>  Assign callback functions called where the Promise eather resolves, or is reject.</li>\n</ul>\n<h2 id=\"Credential\"><a href=\"#Credential\" class=\"headerlink\" title=\"Credential\"></a>Credential</h2><p>本次Auth增加Credential的概念</p>\n<p>credential有两种形式</p>\n<ul>\n<li>账号密码</li>\n<li>OAuth</li>\n</ul>\n<p>例如email登录方式</p>\n<p><code>var credential = wilddog.auth.EmailAuthProvider.credential(email,password)</code></p>\n<p>例如微博登录方式</p>\n<p><code>var credentail = wilddog.auth.WeiboAuthProvider.credential(Weibo.access_token)</code> </p>\n"},{"title":"处理身份认证错误","_content":"\n本次Auth API中,关于 Auth 和 User 相关操作,回调中能够catch Error信息,下面简单列举了核心接口中错误信息。\n\n## 所有 API 方法通用的错误代码\n\n代码信息 | 含义\n---- | ----\nemail_already_in_use | 邮箱已经被其他用户使用。\nuser_not_found | 用户没有找到。\ninvalid_email | 表示电子邮箱地址格式不正确。\n\n## 方法特定错误代码\n\n### Auth\n\n#### fetchProvidersForEmail(email)\n\n代码 | 含义\n---- | ----------\ninvalid_email | 表示电子邮件地址格式不正确。\n\n### signInWithEmailAndPassword(emai,password)\n\n代码 | 含义\n--- | ----------\nauthentication_disabled |表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\ninvalid_email | 表示电子邮件地址格式不正确。\ninvalid_password | 表示用户尝试用错误密码登录。\n\n#### signInWithCredential(credential)\n\n\n代码 | 含义\n---|---\nauthentication_disabled |表示登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\ninvalid_email | 表示电子邮件地址格式不正确。\ninvalid_password | 表示用户尝试用错误密码登录。\n\n#### signInAnonymously()\n\n代码 | 含义\n---|---\nauthentication_disabled |表示匿名登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\n\n#### signInWithCustomToken(token)\n\n代码 | 含义\n---- | -----------\ninvalid_token | 表示自定义令牌认证错误。\n\n#### createUserWithEmailAndPassword(email,password)\n代码 | 含义\n---- | -----------\ninvalid_user | 表示该电子邮件地址格式不正确。\nemail_already_in_use | 表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。\nauthentication_disabled | 表示邮箱登录方式未打开, 请在Wilddog 的控制面板的'用户认证'部分开启\n\n### User\n\n#### User 操作常见错误\n\n代码 | 含义\n---|----\ncredential_too_old_login_again | token 失效，您必须提示该用户在此设备重新登录。\n\n#### updateEmail(email)\n\n代码 | 含义\n---- | -----------\nemail_already_in_use | 表示该电子邮件已被另一个帐户使用。\ninvalid_email | 表示该电子邮件地址格式不正确。\ncredential_too_old_login_again | 更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential),来对该用户重新进行身份认证。\n\n#### updateProfile()\n\n代码 | 含义\n---- | -----------\ndisplay-name-length-error | 更新名称时,名称过长,目前支持名称在20位之内\nphoto-url-length-error | 更新头像时,头像链接过长,目前头像链接最多支持1024个字符\n\n#### updatePassword(password)\n代码 | 含义\n---- | -----------\ncredential_too_old_login_again | 更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential)，对该用户重新进行身份认证。\n\n#### linkWithCredential(credential)\n\n代码 | 含义\n---- | -----------\nprovider_already_linked | 表示尝试关联的登录方式的类型已经关联到此帐户。\nemail_already_in_use | 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。\nauthentication_disabled | 表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。\n\n#### sendEmailVerification()\n\n代码 | 含义\n---- | -----------\nuser_not_found | 表示未找到该用户帐户。\n\n#### delete()\n\n代码 | 含义\n---|-----\ncredential_too_old_login_again | 敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，需要调用reauthenticate(credential)，对该用户重新进行身份认证。\n\n\n\n\n","source":"guide/auth/web/errorcode.md","raw":"title:  处理身份认证错误\n---\n\n本次Auth API中,关于 Auth 和 User 相关操作,回调中能够catch Error信息,下面简单列举了核心接口中错误信息。\n\n## 所有 API 方法通用的错误代码\n\n代码信息 | 含义\n---- | ----\nemail_already_in_use | 邮箱已经被其他用户使用。\nuser_not_found | 用户没有找到。\ninvalid_email | 表示电子邮箱地址格式不正确。\n\n## 方法特定错误代码\n\n### Auth\n\n#### fetchProvidersForEmail(email)\n\n代码 | 含义\n---- | ----------\ninvalid_email | 表示电子邮件地址格式不正确。\n\n### signInWithEmailAndPassword(emai,password)\n\n代码 | 含义\n--- | ----------\nauthentication_disabled |表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\ninvalid_email | 表示电子邮件地址格式不正确。\ninvalid_password | 表示用户尝试用错误密码登录。\n\n#### signInWithCredential(credential)\n\n\n代码 | 含义\n---|---\nauthentication_disabled |表示登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\ninvalid_email | 表示电子邮件地址格式不正确。\ninvalid_password | 表示用户尝试用错误密码登录。\n\n#### signInAnonymously()\n\n代码 | 含义\n---|---\nauthentication_disabled |表示匿名登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。\n\n#### signInWithCustomToken(token)\n\n代码 | 含义\n---- | -----------\ninvalid_token | 表示自定义令牌认证错误。\n\n#### createUserWithEmailAndPassword(email,password)\n代码 | 含义\n---- | -----------\ninvalid_user | 表示该电子邮件地址格式不正确。\nemail_already_in_use | 表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。\nauthentication_disabled | 表示邮箱登录方式未打开, 请在Wilddog 的控制面板的'用户认证'部分开启\n\n### User\n\n#### User 操作常见错误\n\n代码 | 含义\n---|----\ncredential_too_old_login_again | token 失效，您必须提示该用户在此设备重新登录。\n\n#### updateEmail(email)\n\n代码 | 含义\n---- | -----------\nemail_already_in_use | 表示该电子邮件已被另一个帐户使用。\ninvalid_email | 表示该电子邮件地址格式不正确。\ncredential_too_old_login_again | 更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential),来对该用户重新进行身份认证。\n\n#### updateProfile()\n\n代码 | 含义\n---- | -----------\ndisplay-name-length-error | 更新名称时,名称过长,目前支持名称在20位之内\nphoto-url-length-error | 更新头像时,头像链接过长,目前头像链接最多支持1024个字符\n\n#### updatePassword(password)\n代码 | 含义\n---- | -----------\ncredential_too_old_login_again | 更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential)，对该用户重新进行身份认证。\n\n#### linkWithCredential(credential)\n\n代码 | 含义\n---- | -----------\nprovider_already_linked | 表示尝试关联的登录方式的类型已经关联到此帐户。\nemail_already_in_use | 表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。\nauthentication_disabled | 表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。\n\n#### sendEmailVerification()\n\n代码 | 含义\n---- | -----------\nuser_not_found | 表示未找到该用户帐户。\n\n#### delete()\n\n代码 | 含义\n---|-----\ncredential_too_old_login_again | 敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，需要调用reauthenticate(credential)，对该用户重新进行身份认证。\n\n\n\n\n","date":"2016-09-06T03:38:22.531Z","updated":"2016-09-06T03:38:22.531Z","path":"guide/auth/web/errorcode.html","comments":1,"layout":"page","_id":"cisswi9l1001dz4fwoiemz5w2","content":"<p>本次Auth API中,关于 Auth 和 User 相关操作,回调中能够catch Error信息,下面简单列举了核心接口中错误信息。</p>\n<h2 id=\"所有-API-方法通用的错误代码\"><a href=\"#所有-API-方法通用的错误代码\" class=\"headerlink\" title=\"所有 API 方法通用的错误代码\"></a>所有 API 方法通用的错误代码</h2><table>\n<thead>\n<tr>\n<th>代码信息</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>email_already_in_use</td>\n<td>邮箱已经被其他用户使用。</td>\n</tr>\n<tr>\n<td>user_not_found</td>\n<td>用户没有找到。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮箱地址格式不正确。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"方法特定错误代码\"><a href=\"#方法特定错误代码\" class=\"headerlink\" title=\"方法特定错误代码\"></a>方法特定错误代码</h2><h3 id=\"Auth\"><a href=\"#Auth\" class=\"headerlink\" title=\"Auth\"></a>Auth</h3><h4 id=\"fetchProvidersForEmail-email\"><a href=\"#fetchProvidersForEmail-email\" class=\"headerlink\" title=\"fetchProvidersForEmail(email)\"></a>fetchProvidersForEmail(email)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮件地址格式不正确。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"signInWithEmailAndPassword-emai-password\"><a href=\"#signInWithEmailAndPassword-emai-password\" class=\"headerlink\" title=\"signInWithEmailAndPassword(emai,password)\"></a>signInWithEmailAndPassword(emai,password)</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>authentication_disabled</td>\n<td>表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>invalid_password</td>\n<td>表示用户尝试用错误密码登录。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"signInWithCredential-credential\"><a href=\"#signInWithCredential-credential\" class=\"headerlink\" title=\"signInWithCredential(credential)\"></a>signInWithCredential(credential)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>authentication_disabled</td>\n<td>表示登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>invalid_password</td>\n<td>表示用户尝试用错误密码登录。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"signInAnonymously\"><a href=\"#signInAnonymously\" class=\"headerlink\" title=\"signInAnonymously()\"></a>signInAnonymously()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>authentication_disabled</td>\n<td>表示匿名登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"signInWithCustomToken-token\"><a href=\"#signInWithCustomToken-token\" class=\"headerlink\" title=\"signInWithCustomToken(token)\"></a>signInWithCustomToken(token)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invalid_token</td>\n<td>表示自定义令牌认证错误。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"createUserWithEmailAndPassword-email-password\"><a href=\"#createUserWithEmailAndPassword-email-password\" class=\"headerlink\" title=\"createUserWithEmailAndPassword(email,password)\"></a>createUserWithEmailAndPassword(email,password)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invalid_user</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>email_already_in_use</td>\n<td>表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。</td>\n</tr>\n<tr>\n<td>authentication_disabled</td>\n<td>表示邮箱登录方式未打开, 请在Wilddog 的控制面板的’用户认证’部分开启</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h3><h4 id=\"User-操作常见错误\"><a href=\"#User-操作常见错误\" class=\"headerlink\" title=\"User 操作常见错误\"></a>User 操作常见错误</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>token 失效，您必须提示该用户在此设备重新登录。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"updateEmail-email\"><a href=\"#updateEmail-email\" class=\"headerlink\" title=\"updateEmail(email)\"></a>updateEmail(email)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>email_already_in_use</td>\n<td>表示该电子邮件已被另一个帐户使用。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential),来对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"updateProfile\"><a href=\"#updateProfile\" class=\"headerlink\" title=\"updateProfile()\"></a>updateProfile()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>display-name-length-error</td>\n<td>更新名称时,名称过长,目前支持名称在20位之内</td>\n</tr>\n<tr>\n<td>photo-url-length-error</td>\n<td>更新头像时,头像链接过长,目前头像链接最多支持1024个字符</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"updatePassword-password\"><a href=\"#updatePassword-password\" class=\"headerlink\" title=\"updatePassword(password)\"></a>updatePassword(password)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential)，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"linkWithCredential-credential\"><a href=\"#linkWithCredential-credential\" class=\"headerlink\" title=\"linkWithCredential(credential)\"></a>linkWithCredential(credential)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>provider_already_linked</td>\n<td>表示尝试关联的登录方式的类型已经关联到此帐户。</td>\n</tr>\n<tr>\n<td>email_already_in_use</td>\n<td>表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。</td>\n</tr>\n<tr>\n<td>authentication_disabled</td>\n<td>表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"sendEmailVerification\"><a href=\"#sendEmailVerification\" class=\"headerlink\" title=\"sendEmailVerification()\"></a>sendEmailVerification()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user_not_found</td>\n<td>表示未找到该用户帐户。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete()\"></a>delete()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，需要调用reauthenticate(credential)，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<p>本次Auth API中,关于 Auth 和 User 相关操作,回调中能够catch Error信息,下面简单列举了核心接口中错误信息。</p>\n<h2 id=\"所有-API-方法通用的错误代码\"><a href=\"#所有-API-方法通用的错误代码\" class=\"headerlink\" title=\"所有 API 方法通用的错误代码\"></a>所有 API 方法通用的错误代码</h2><table>\n<thead>\n<tr>\n<th>代码信息</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>email_already_in_use</td>\n<td>邮箱已经被其他用户使用。</td>\n</tr>\n<tr>\n<td>user_not_found</td>\n<td>用户没有找到。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮箱地址格式不正确。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"方法特定错误代码\"><a href=\"#方法特定错误代码\" class=\"headerlink\" title=\"方法特定错误代码\"></a>方法特定错误代码</h2><h3 id=\"Auth\"><a href=\"#Auth\" class=\"headerlink\" title=\"Auth\"></a>Auth</h3><h4 id=\"fetchProvidersForEmail-email\"><a href=\"#fetchProvidersForEmail-email\" class=\"headerlink\" title=\"fetchProvidersForEmail(email)\"></a>fetchProvidersForEmail(email)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮件地址格式不正确。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"signInWithEmailAndPassword-emai-password\"><a href=\"#signInWithEmailAndPassword-emai-password\" class=\"headerlink\" title=\"signInWithEmailAndPassword(emai,password)\"></a>signInWithEmailAndPassword(emai,password)</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>authentication_disabled</td>\n<td>表示邮箱登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>invalid_password</td>\n<td>表示用户尝试用错误密码登录。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"signInWithCredential-credential\"><a href=\"#signInWithCredential-credential\" class=\"headerlink\" title=\"signInWithCredential(credential)\"></a>signInWithCredential(credential)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>authentication_disabled</td>\n<td>表示登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>invalid_password</td>\n<td>表示用户尝试用错误密码登录。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"signInAnonymously\"><a href=\"#signInAnonymously\" class=\"headerlink\" title=\"signInAnonymously()\"></a>signInAnonymously()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>authentication_disabled</td>\n<td>表示匿名登录方式未打开，请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"signInWithCustomToken-token\"><a href=\"#signInWithCustomToken-token\" class=\"headerlink\" title=\"signInWithCustomToken(token)\"></a>signInWithCustomToken(token)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invalid_token</td>\n<td>表示自定义令牌认证错误。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"createUserWithEmailAndPassword-email-password\"><a href=\"#createUserWithEmailAndPassword-email-password\" class=\"headerlink\" title=\"createUserWithEmailAndPassword(email,password)\"></a>createUserWithEmailAndPassword(email,password)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>invalid_user</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>email_already_in_use</td>\n<td>表示用于尝试注册的电子邮件已经存在。请调用 fetchProvidersForEmail 检查该用户使用哪些登录机制并提示该用户以这些机制之一登录。</td>\n</tr>\n<tr>\n<td>authentication_disabled</td>\n<td>表示邮箱登录方式未打开, 请在Wilddog 的控制面板的’用户认证’部分开启</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h3><h4 id=\"User-操作常见错误\"><a href=\"#User-操作常见错误\" class=\"headerlink\" title=\"User 操作常见错误\"></a>User 操作常见错误</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>token 失效，您必须提示该用户在此设备重新登录。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"updateEmail-email\"><a href=\"#updateEmail-email\" class=\"headerlink\" title=\"updateEmail(email)\"></a>updateEmail(email)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>email_already_in_use</td>\n<td>表示该电子邮件已被另一个帐户使用。</td>\n</tr>\n<tr>\n<td>invalid_email</td>\n<td>表示该电子邮件地址格式不正确。</td>\n</tr>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>更新用户电子邮件是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential),来对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"updateProfile\"><a href=\"#updateProfile\" class=\"headerlink\" title=\"updateProfile()\"></a>updateProfile()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>display-name-length-error</td>\n<td>更新名称时,名称过长,目前支持名称在20位之内</td>\n</tr>\n<tr>\n<td>photo-url-length-error</td>\n<td>更新头像时,头像链接过长,目前头像链接最多支持1024个字符</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"updatePassword-password\"><a href=\"#updatePassword-password\" class=\"headerlink\" title=\"updatePassword(password)\"></a>updatePassword(password)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>更新用户密码是一项安全相关操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误,调用reauthenticate(credential)，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"linkWithCredential-credential\"><a href=\"#linkWithCredential-credential\" class=\"headerlink\" title=\"linkWithCredential(credential)\"></a>linkWithCredential(credential)</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>provider_already_linked</td>\n<td>表示尝试关联的登录方式的类型已经关联到此帐户。</td>\n</tr>\n<tr>\n<td>email_already_in_use</td>\n<td>表示尝试关联的凭据已与另一个不同 Wilddog 帐户关联。</td>\n</tr>\n<tr>\n<td>authentication_disabled</td>\n<td>表示用该凭据表示的用户身份提供程序尚未启用。请在 Wilddog 控制面板的“用户认证”部分启用。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"sendEmailVerification\"><a href=\"#sendEmailVerification\" class=\"headerlink\" title=\"sendEmailVerification()\"></a>sendEmailVerification()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user_not_found</td>\n<td>表示未找到该用户帐户。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete()\"></a>delete()</h4><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>credential_too_old_login_again</td>\n<td>敏感操作，需要该用户的最近一次登录。此错误表示该用户近期长时间没有登录过。要解决此错误，需要调用reauthenticate(credential)，对该用户重新进行身份认证。</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"绑定多种登录方式","_content":"\n通过链接功能，您可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。\n\n\n## 开始前的准备工作\n\n在野狗控制面板中打开多种登录方式。\n\n\n\n## 给帐号链接多种登录方式\n\n完成以下步骤为已有帐号添加多种登录方式：\n\n1. 以任意一种登录方式登录一个帐号。\n\n2. 准备一个未在您的应用上登录过的邮箱或者第三方登录方式。\n\n3. 进行登录关联。\n\n### 关联QQ登录\n```\n    var provider = new wilddog.auth.QQAuthProvider();\n\n    popup关联\n\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) {\n\n         // Handle Errors here.\n\n         console.log(errorCode);\n\n         // ...\n\n    });\n\n\n\n    redirect关联\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n        console.log(result);\n\n    }).catch(function (error) { \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n\n```\n\n### 关联微信登录\n\n\n```\n    var provider = new wilddog.auth.WeixinAuthProvider();\n    popup\n\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) {、\n         // Handle Errors here. \n        console.log(errorCode);\n         // ...\n    });\n\n    redirect\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) { \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n\n\n\n```\n\n### 关联微博登录\n\n```\n\n\n\n    var provider = new wilddog.auth.WeiboAuthProvider();\n\n\n\n    popup\n\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) {、 \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n\n\n\n    redirect\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) { \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n```\n### 关联微信公众账号登录\n\n```\n\n    var provider = new wilddog.auth.WeixinmpAuthProvider();\n    \n    popup\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n         console.log(result);\n     }).catch(function (error) {、\n          // Handle Errors here.\n           console.log(errorCode);\n           // ...\n\n    });\n\n\n\n    redirect\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) { // Handle Errors here. console.log(errorCode); // ...});\n\n```\n\n### 关联邮箱登录\n\n\n```\n\n     var credentialEmail = wilddog.auth.EmailAuthProvider.credential(email, password);\n\n     var user = wilddog.auth().currentUser;\n\n     user.link(credentialEmail).then(function (user) {\n\n         console.log(\"Account linking1 success\", user);\n\n     }, function (error) {\n\n         console.log(\"Account linking1 error\", error);\n\n     });\n\n\n\n```\n重要说明:若使用customToken登录时,若customToken中admin属性为true,则不能进行关联操作.\n\n## 解除一种登录方式\n\n如果不想再使用某种登录方式，您可以解除链接。\n\n为帐号解除登录方式，通过传递参数 provider ID 给 `unlinkFromProvider:completion:` 方法，您可以从 `providerData` 属性中获取到 provider ID。\n\n```\nfor example : unlink 微信登录方式\nvar user = wilddog.auth().currentUser;\n     user.unlink(\"weixin\").then(function () {\n     console.log(\"unlink\")\n     console.log(provider);\n }, function (error) {\n     console.log(error);\n });\n```\n","source":"guide/auth/web/link.md","raw":"title:  绑定多种登录方式\n---\n\n通过链接功能，您可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。\n\n\n## 开始前的准备工作\n\n在野狗控制面板中打开多种登录方式。\n\n\n\n## 给帐号链接多种登录方式\n\n完成以下步骤为已有帐号添加多种登录方式：\n\n1. 以任意一种登录方式登录一个帐号。\n\n2. 准备一个未在您的应用上登录过的邮箱或者第三方登录方式。\n\n3. 进行登录关联。\n\n### 关联QQ登录\n```\n    var provider = new wilddog.auth.QQAuthProvider();\n\n    popup关联\n\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) {\n\n         // Handle Errors here.\n\n         console.log(errorCode);\n\n         // ...\n\n    });\n\n\n\n    redirect关联\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n        console.log(result);\n\n    }).catch(function (error) { \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n\n```\n\n### 关联微信登录\n\n\n```\n    var provider = new wilddog.auth.WeixinAuthProvider();\n    popup\n\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) {、\n         // Handle Errors here. \n        console.log(errorCode);\n         // ...\n    });\n\n    redirect\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) { \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n\n\n\n```\n\n### 关联微博登录\n\n```\n\n\n\n    var provider = new wilddog.auth.WeiboAuthProvider();\n\n\n\n    popup\n\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) {、 \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n\n\n\n    redirect\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) { \n        // Handle Errors here. \n        console.log(errorCode); \n        // ...\n    });\n```\n### 关联微信公众账号登录\n\n```\n\n    var provider = new wilddog.auth.WeixinmpAuthProvider();\n    \n    popup\n    wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) {\n         console.log(result);\n     }).catch(function (error) {、\n          // Handle Errors here.\n           console.log(errorCode);\n           // ...\n\n    });\n\n\n\n    redirect\n\n    wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) {\n\n         console.log(result);\n\n    }).catch(function (error) { // Handle Errors here. console.log(errorCode); // ...});\n\n```\n\n### 关联邮箱登录\n\n\n```\n\n     var credentialEmail = wilddog.auth.EmailAuthProvider.credential(email, password);\n\n     var user = wilddog.auth().currentUser;\n\n     user.link(credentialEmail).then(function (user) {\n\n         console.log(\"Account linking1 success\", user);\n\n     }, function (error) {\n\n         console.log(\"Account linking1 error\", error);\n\n     });\n\n\n\n```\n重要说明:若使用customToken登录时,若customToken中admin属性为true,则不能进行关联操作.\n\n## 解除一种登录方式\n\n如果不想再使用某种登录方式，您可以解除链接。\n\n为帐号解除登录方式，通过传递参数 provider ID 给 `unlinkFromProvider:completion:` 方法，您可以从 `providerData` 属性中获取到 provider ID。\n\n```\nfor example : unlink 微信登录方式\nvar user = wilddog.auth().currentUser;\n     user.unlink(\"weixin\").then(function () {\n     console.log(\"unlink\")\n     console.log(provider);\n }, function (error) {\n     console.log(error);\n });\n```\n","date":"2016-09-07T13:24:23.104Z","updated":"2016-09-07T13:24:23.104Z","path":"guide/auth/web/link.html","_id":"cisswi9l1001ez4fw6one5ksc","comments":1,"layout":"page","content":"<p>通过链接功能，您可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>在野狗控制面板中打开多种登录方式。</p>\n<h2 id=\"给帐号链接多种登录方式\"><a href=\"#给帐号链接多种登录方式\" class=\"headerlink\" title=\"给帐号链接多种登录方式\"></a>给帐号链接多种登录方式</h2><p>完成以下步骤为已有帐号添加多种登录方式：</p>\n<ol>\n<li><p>以任意一种登录方式登录一个帐号。</p>\n</li>\n<li><p>准备一个未在您的应用上登录过的邮箱或者第三方登录方式。</p>\n</li>\n<li><p>进行登录关联。</p>\n</li>\n</ol>\n<h3 id=\"关联QQ登录\"><a href=\"#关联QQ登录\" class=\"headerlink\" title=\"关联QQ登录\"></a>关联QQ登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.QQAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup关联</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\"></div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\"></div><div class=\"line\">     console.log(errorCode);</div><div class=\"line\"></div><div class=\"line\">     // ...</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect关联</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">    console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联微信登录\"><a href=\"#关联微信登录\" class=\"headerlink\" title=\"关联微信登录\"></a>关联微信登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinAuthProvider();</div><div class=\"line\">popup</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123;、</div><div class=\"line\">     // Handle Errors here. </div><div class=\"line\">    console.log(errorCode);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联微博登录\"><a href=\"#关联微博登录\" class=\"headerlink\" title=\"关联微博登录\"></a>关联微博登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var provider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123;、 </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联微信公众账号登录\"><a href=\"#关联微信公众账号登录\" class=\"headerlink\" title=\"关联微信公众账号登录\"></a>关联微信公众账号登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var provider = new wilddog.auth.WeixinmpAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;、</div><div class=\"line\">      // Handle Errors here.</div><div class=\"line\">       console.log(errorCode);</div><div class=\"line\">       // ...</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; // Handle Errors here. console.log(errorCode); // ...&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联邮箱登录\"><a href=\"#关联邮箱登录\" class=\"headerlink\" title=\"关联邮箱登录\"></a>关联邮箱登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var credentialEmail = wilddog.auth.EmailAuthProvider.credential(email, password);</div><div class=\"line\"></div><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\"></div><div class=\"line\">user.link(credentialEmail).then(function (user) &#123;</div><div class=\"line\"></div><div class=\"line\">    console.log(&quot;Account linking1 success&quot;, user);</div><div class=\"line\"></div><div class=\"line\">&#125;, function (error) &#123;</div><div class=\"line\"></div><div class=\"line\">    console.log(&quot;Account linking1 error&quot;, error);</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>重要说明:若使用customToken登录时,若customToken中admin属性为true,则不能进行关联操作.</p>\n<h2 id=\"解除一种登录方式\"><a href=\"#解除一种登录方式\" class=\"headerlink\" title=\"解除一种登录方式\"></a>解除一种登录方式</h2><p>如果不想再使用某种登录方式，您可以解除链接。</p>\n<p>为帐号解除登录方式，通过传递参数 provider ID 给 <code>unlinkFromProvider:completion:</code> 方法，您可以从 <code>providerData</code> 属性中获取到 provider ID。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : unlink 微信登录方式</div><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">     user.unlink(&quot;weixin&quot;).then(function () &#123;</div><div class=\"line\">     console.log(&quot;unlink&quot;)</div><div class=\"line\">     console.log(provider);</div><div class=\"line\"> &#125;, function (error) &#123;</div><div class=\"line\">     console.log(error);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>通过链接功能，您可以使用不同的登录方式来登录同一个帐号。不管采用哪种登录方式，用户都可以通过相同的 Wilddog ID 来标识身份。打个比方，一个用户使用邮箱登录然后链接 QQ 登录，那么他能使用这两种方式来登录这个帐号。或者一个匿名帐号链接微信登录方式，则可以使用微信登录方式来登录这个匿名帐号。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><p>在野狗控制面板中打开多种登录方式。</p>\n<h2 id=\"给帐号链接多种登录方式\"><a href=\"#给帐号链接多种登录方式\" class=\"headerlink\" title=\"给帐号链接多种登录方式\"></a>给帐号链接多种登录方式</h2><p>完成以下步骤为已有帐号添加多种登录方式：</p>\n<ol>\n<li><p>以任意一种登录方式登录一个帐号。</p>\n</li>\n<li><p>准备一个未在您的应用上登录过的邮箱或者第三方登录方式。</p>\n</li>\n<li><p>进行登录关联。</p>\n</li>\n</ol>\n<h3 id=\"关联QQ登录\"><a href=\"#关联QQ登录\" class=\"headerlink\" title=\"关联QQ登录\"></a>关联QQ登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.QQAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup关联</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\"></div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\"></div><div class=\"line\">     console.log(errorCode);</div><div class=\"line\"></div><div class=\"line\">     // ...</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect关联</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">    console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联微信登录\"><a href=\"#关联微信登录\" class=\"headerlink\" title=\"关联微信登录\"></a>关联微信登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinAuthProvider();</div><div class=\"line\">popup</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123;、</div><div class=\"line\">     // Handle Errors here. </div><div class=\"line\">    console.log(errorCode);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联微博登录\"><a href=\"#关联微博登录\" class=\"headerlink\" title=\"关联微博登录\"></a>关联微博登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var provider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123;、 </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; </div><div class=\"line\">    // Handle Errors here. </div><div class=\"line\">    console.log(errorCode); </div><div class=\"line\">    // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联微信公众账号登录\"><a href=\"#关联微信公众账号登录\" class=\"headerlink\" title=\"关联微信公众账号登录\"></a>关联微信公众账号登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var provider = new wilddog.auth.WeixinmpAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup</div><div class=\"line\">wilddog.auth().currentUser.linkWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;、</div><div class=\"line\">      // Handle Errors here.</div><div class=\"line\">       console.log(errorCode);</div><div class=\"line\">       // ...</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().currentUser.linkWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\"></div><div class=\"line\">     console.log(result);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(function (error) &#123; // Handle Errors here. console.log(errorCode); // ...&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"关联邮箱登录\"><a href=\"#关联邮箱登录\" class=\"headerlink\" title=\"关联邮箱登录\"></a>关联邮箱登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var credentialEmail = wilddog.auth.EmailAuthProvider.credential(email, password);</div><div class=\"line\"></div><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\"></div><div class=\"line\">user.link(credentialEmail).then(function (user) &#123;</div><div class=\"line\"></div><div class=\"line\">    console.log(&quot;Account linking1 success&quot;, user);</div><div class=\"line\"></div><div class=\"line\">&#125;, function (error) &#123;</div><div class=\"line\"></div><div class=\"line\">    console.log(&quot;Account linking1 error&quot;, error);</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>重要说明:若使用customToken登录时,若customToken中admin属性为true,则不能进行关联操作.</p>\n<h2 id=\"解除一种登录方式\"><a href=\"#解除一种登录方式\" class=\"headerlink\" title=\"解除一种登录方式\"></a>解除一种登录方式</h2><p>如果不想再使用某种登录方式，您可以解除链接。</p>\n<p>为帐号解除登录方式，通过传递参数 provider ID 给 <code>unlinkFromProvider:completion:</code> 方法，您可以从 <code>providerData</code> 属性中获取到 provider ID。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">for example : unlink 微信登录方式</div><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">     user.unlink(&quot;weixin&quot;).then(function () &#123;</div><div class=\"line\">     console.log(&quot;unlink&quot;)</div><div class=\"line\">     console.log(provider);</div><div class=\"line\"> &#125;, function (error) &#123;</div><div class=\"line\">     console.log(error);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"管理用户","_content":"\n## 创建用户\n\n通过调用`createUserWithEmailAndPassword`(email,password) 方法或首次使用第三方登录方式（如 QQ 或 Weixin）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。\n\n您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。\n\n## 获取当前登录的用户\n\n\n获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：\n\n```\nwilddog.auth().onAuthStateChanged(function(user) {\n  if (user) {\n     console.log(\"wxl\");\n  } else {\n     console.log(\"no user\");\n  }\n});\n```\n\n使用侦听器可保证在您获取当前用户时 Auth 对象不会处于中间状态如初始化。\n\n\n您也可以使用 `currentUser` 属性获取当前已登录的用户。 如果用户没有登录，`currentUser` 则为空：\n\n\n```\nvar user = wilddog.auth().currentUser;\nif (user != nil) {\n     // User is signed in.\n} else {\n     // No user is signed in.\n}\n```\n\n注：`currentUser` 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。\n\n## 获取用户个人资料\n\n要获取用户的个人资料信息，请使用 `User` 实例的属性。 例如：\n\n\n```\nvar user = wilddog.auth().currentUser;\nif (user != null) {\n    var name = user.displayName;\n    var email = user.email;\n    var photoUrl = user.photoURL;\n    var uid = user.uid; \n} else {\n // No user is signed in.\n}\n\n```\n## 获取用户的第三方登录的个人资料信息\n\n要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：\n\n```\nvar user = wilddog.auth().currentUser;\n console.log(user);\n user.providerData.forEach(function (profile) {\n console.log(\"Sign-in provider: \" + profile.providerId);\n console.log(\" Provider-specific UID: \" + profile.uid);\n console.log(\" Name: \" + profile.displayName);\n console.log(\" Email: \" + profile.email);\n console.log(\" Photo URL: \" + profile.photoURL);\n });\n\n\n```\n\n## 更新用户个人资料\n\n您可以使用`WDGUserProfileChangeRequest` 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：\n\n```\nwilddog.auth().currentUser.updateProfile({\n     displayName: \"name\",\n     photoURL: \"https://example.com/path/photo.jpg\"\n }).then(function() {\n     // Update successful.\n }, function(error) {\n     // An error happened.\n });\n```\n重要说明:使用customToken登录时,若customToken中admin属性为true,则不能进行信息修改。\n## 设置用户的电子邮件地址\n\n您可以用 `updateEmail:completion:` 方法设置用户的电子邮件地址。例如：\n\n```\nwilddog.auth().currentUser.updateEmail(email).then(function() {\n     // Update successful.\n }, function(error) {\n     // An error happened.\n     console.log(error);\n });\n```\n\n重要说明：\n\n - 要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n - 使用customToken登录时,若customToken中admin属性为true,则不能进行邮箱修改。\n\n\n## 设置用户密码\n\n您可以使用 `updatePassword:completion:` 方法设置用户密码。例如：\n\n```\nwilddog.auth().currentUser.updatePassword(\"12345678\").then(function() {\n     // Update successful.\n     console.log(\"\");\n }, function(error) {\n     console.log(error);\n     // An error happened. \n});\n注意:使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改\n```\n\n重要说明：\n\n - 要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n - 使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改。\n\n\n## 发送重设密码电子邮件\n\n\n您可以用 `sendPasswordResetWithEmail:completion:` 方法向用户发送一封重设密码电子邮件。 例如：\n\n\n\n```\nwilddog.auth().sendPasswordResetEmail(email);\n```\n\n您可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。\n\n\n您也可以从 Wilddog 控制面板中发送重设密码电子邮件。\n\n\n## 删除用户\n\n您可以使用 `delete` 方法删除用户帐户。例如：\n\n\n\n```\nwilddog.auth().currentUser.delete();\n注意:若使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除\n```\n您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。\n\n重要说明：\n\n- 要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n- 使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除。\n\n\n\n## 对用户重新进行身份认证\n\n有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。\n\n如果您执行这些操作之一，而该用户在很久以前登录过，该操作便会失败。\n\n发生这种错误时，请通过从用户获取新登录凭据并将该凭据传递到 `reauthenticate`，对该用户重新进行身份认证。 例如：\n\n\n\n```\n wilddog.auth().currentUser.reauthenticate(credential).then(function(res) {\n     // Update successful.\n     console.log(res);\n }, function(error) {\n     // An error happened.\n     console.log(error);\n });\n```\n","source":"guide/auth/web/manageuser.md","raw":"title: 管理用户\n---\n\n## 创建用户\n\n通过调用`createUserWithEmailAndPassword`(email,password) 方法或首次使用第三方登录方式（如 QQ 或 Weixin）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。\n\n您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。\n\n## 获取当前登录的用户\n\n\n获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：\n\n```\nwilddog.auth().onAuthStateChanged(function(user) {\n  if (user) {\n     console.log(\"wxl\");\n  } else {\n     console.log(\"no user\");\n  }\n});\n```\n\n使用侦听器可保证在您获取当前用户时 Auth 对象不会处于中间状态如初始化。\n\n\n您也可以使用 `currentUser` 属性获取当前已登录的用户。 如果用户没有登录，`currentUser` 则为空：\n\n\n```\nvar user = wilddog.auth().currentUser;\nif (user != nil) {\n     // User is signed in.\n} else {\n     // No user is signed in.\n}\n```\n\n注：`currentUser` 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。\n\n## 获取用户个人资料\n\n要获取用户的个人资料信息，请使用 `User` 实例的属性。 例如：\n\n\n```\nvar user = wilddog.auth().currentUser;\nif (user != null) {\n    var name = user.displayName;\n    var email = user.email;\n    var photoUrl = user.photoURL;\n    var uid = user.uid; \n} else {\n // No user is signed in.\n}\n\n```\n## 获取用户的第三方登录的个人资料信息\n\n要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：\n\n```\nvar user = wilddog.auth().currentUser;\n console.log(user);\n user.providerData.forEach(function (profile) {\n console.log(\"Sign-in provider: \" + profile.providerId);\n console.log(\" Provider-specific UID: \" + profile.uid);\n console.log(\" Name: \" + profile.displayName);\n console.log(\" Email: \" + profile.email);\n console.log(\" Photo URL: \" + profile.photoURL);\n });\n\n\n```\n\n## 更新用户个人资料\n\n您可以使用`WDGUserProfileChangeRequest` 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：\n\n```\nwilddog.auth().currentUser.updateProfile({\n     displayName: \"name\",\n     photoURL: \"https://example.com/path/photo.jpg\"\n }).then(function() {\n     // Update successful.\n }, function(error) {\n     // An error happened.\n });\n```\n重要说明:使用customToken登录时,若customToken中admin属性为true,则不能进行信息修改。\n## 设置用户的电子邮件地址\n\n您可以用 `updateEmail:completion:` 方法设置用户的电子邮件地址。例如：\n\n```\nwilddog.auth().currentUser.updateEmail(email).then(function() {\n     // Update successful.\n }, function(error) {\n     // An error happened.\n     console.log(error);\n });\n```\n\n重要说明：\n\n - 要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n - 使用customToken登录时,若customToken中admin属性为true,则不能进行邮箱修改。\n\n\n## 设置用户密码\n\n您可以使用 `updatePassword:completion:` 方法设置用户密码。例如：\n\n```\nwilddog.auth().currentUser.updatePassword(\"12345678\").then(function() {\n     // Update successful.\n     console.log(\"\");\n }, function(error) {\n     console.log(error);\n     // An error happened. \n});\n注意:使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改\n```\n\n重要说明：\n\n - 要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n - 使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改。\n\n\n## 发送重设密码电子邮件\n\n\n您可以用 `sendPasswordResetWithEmail:completion:` 方法向用户发送一封重设密码电子邮件。 例如：\n\n\n\n```\nwilddog.auth().sendPasswordResetEmail(email);\n```\n\n您可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。\n\n\n您也可以从 Wilddog 控制面板中发送重设密码电子邮件。\n\n\n## 删除用户\n\n您可以使用 `delete` 方法删除用户帐户。例如：\n\n\n\n```\nwilddog.auth().currentUser.delete();\n注意:若使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除\n```\n您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。\n\n重要说明：\n\n- 要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。\n- 使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除。\n\n\n\n## 对用户重新进行身份认证\n\n有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。\n\n如果您执行这些操作之一，而该用户在很久以前登录过，该操作便会失败。\n\n发生这种错误时，请通过从用户获取新登录凭据并将该凭据传递到 `reauthenticate`，对该用户重新进行身份认证。 例如：\n\n\n\n```\n wilddog.auth().currentUser.reauthenticate(credential).then(function(res) {\n     // Update successful.\n     console.log(res);\n }, function(error) {\n     // An error happened.\n     console.log(error);\n });\n```\n","date":"2016-09-07T13:24:23.106Z","updated":"2016-09-07T13:24:23.106Z","path":"guide/auth/web/manageuser.html","_id":"cisswi9l1001fz4fwaxcj3kka","comments":1,"layout":"page","content":"<h2 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h2><p>通过调用<code>createUserWithEmailAndPassword</code>(email,password) 方法或首次使用第三方登录方式（如 QQ 或 Weixin）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。</p>\n<p>您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。</p>\n<h2 id=\"获取当前登录的用户\"><a href=\"#获取当前登录的用户\" class=\"headerlink\" title=\"获取当前登录的用户\"></a>获取当前登录的用户</h2><p>获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().onAuthStateChanged(function(user) &#123;</div><div class=\"line\">  if (user) &#123;</div><div class=\"line\">     console.log(&quot;wxl&quot;);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">     console.log(&quot;no user&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用侦听器可保证在您获取当前用户时 Auth 对象不会处于中间状态如初始化。</p>\n<p>您也可以使用 <code>currentUser</code> 属性获取当前已登录的用户。 如果用户没有登录，<code>currentUser</code> 则为空：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">if (user != nil) &#123;</div><div class=\"line\">     // User is signed in.</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">     // No user is signed in.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：<code>currentUser</code> 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。</p>\n<h2 id=\"获取用户个人资料\"><a href=\"#获取用户个人资料\" class=\"headerlink\" title=\"获取用户个人资料\"></a>获取用户个人资料</h2><p>要获取用户的个人资料信息，请使用 <code>User</code> 实例的属性。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">if (user != null) &#123;</div><div class=\"line\">    var name = user.displayName;</div><div class=\"line\">    var email = user.email;</div><div class=\"line\">    var photoUrl = user.photoURL;</div><div class=\"line\">    var uid = user.uid; </div><div class=\"line\">&#125; else &#123;</div><div class=\"line\"> // No user is signed in.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"获取用户的第三方登录的个人资料信息\"><a href=\"#获取用户的第三方登录的个人资料信息\" class=\"headerlink\" title=\"获取用户的第三方登录的个人资料信息\"></a>获取用户的第三方登录的个人资料信息</h2><p>要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\"> console.log(user);</div><div class=\"line\"> user.providerData.forEach(function (profile) &#123;</div><div class=\"line\"> console.log(&quot;Sign-in provider: &quot; + profile.providerId);</div><div class=\"line\"> console.log(&quot; Provider-specific UID: &quot; + profile.uid);</div><div class=\"line\"> console.log(&quot; Name: &quot; + profile.displayName);</div><div class=\"line\"> console.log(&quot; Email: &quot; + profile.email);</div><div class=\"line\"> console.log(&quot; Photo URL: &quot; + profile.photoURL);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"更新用户个人资料\"><a href=\"#更新用户个人资料\" class=\"headerlink\" title=\"更新用户个人资料\"></a>更新用户个人资料</h2><p>您可以使用<code>WDGUserProfileChangeRequest</code> 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.updateProfile(&#123;</div><div class=\"line\">     displayName: &quot;name&quot;,</div><div class=\"line\">     photoURL: &quot;https://example.com/path/photo.jpg&quot;</div><div class=\"line\"> &#125;).then(function() &#123;</div><div class=\"line\">     // Update successful.</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明:使用customToken登录时,若customToken中admin属性为true,则不能进行信息修改。</p>\n<h2 id=\"设置用户的电子邮件地址\"><a href=\"#设置用户的电子邮件地址\" class=\"headerlink\" title=\"设置用户的电子邮件地址\"></a>设置用户的电子邮件地址</h2><p>您可以用 <code>updateEmail:completion:</code> 方法设置用户的电子邮件地址。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.updateEmail(email).then(function() &#123;</div><div class=\"line\">     // Update successful.</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(error);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：</p>\n<ul>\n<li>要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</li>\n<li>使用customToken登录时,若customToken中admin属性为true,则不能进行邮箱修改。</li>\n</ul>\n<h2 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h2><p>您可以使用 <code>updatePassword:completion:</code> 方法设置用户密码。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.updatePassword(&quot;12345678&quot;).then(function() &#123;</div><div class=\"line\">     // Update successful.</div><div class=\"line\">     console.log(&quot;&quot;);</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // An error happened. </div><div class=\"line\">&#125;);</div><div class=\"line\">注意:使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改</div></pre></td></tr></table></figure>\n<p>重要说明：</p>\n<ul>\n<li>要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</li>\n<li>使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改。</li>\n</ul>\n<h2 id=\"发送重设密码电子邮件\"><a href=\"#发送重设密码电子邮件\" class=\"headerlink\" title=\"发送重设密码电子邮件\"></a>发送重设密码电子邮件</h2><p>您可以用 <code>sendPasswordResetWithEmail:completion:</code> 方法向用户发送一封重设密码电子邮件。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().sendPasswordResetEmail(email);</div></pre></td></tr></table></figure>\n<p>您可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。</p>\n<p>您也可以从 Wilddog 控制面板中发送重设密码电子邮件。</p>\n<h2 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h2><p>您可以使用 <code>delete</code> 方法删除用户帐户。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.delete();</div><div class=\"line\">注意:若使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除</div></pre></td></tr></table></figure>\n<p>您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。</p>\n<p>重要说明：</p>\n<ul>\n<li>要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。</li>\n<li>使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除。</li>\n</ul>\n<h2 id=\"对用户重新进行身份认证\"><a href=\"#对用户重新进行身份认证\" class=\"headerlink\" title=\"对用户重新进行身份认证\"></a>对用户重新进行身份认证</h2><p>有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。</p>\n<p>如果您执行这些操作之一，而该用户在很久以前登录过，该操作便会失败。</p>\n<p>发生这种错误时，请通过从用户获取新登录凭据并将该凭据传递到 <code>reauthenticate</code>，对该用户重新进行身份认证。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.reauthenticate(credential).then(function(res) &#123;</div><div class=\"line\">    // Update successful.</div><div class=\"line\">    console.log(res);</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">    // An error happened.</div><div class=\"line\">    console.log(error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h2><p>通过调用<code>createUserWithEmailAndPassword</code>(email,password) 方法或首次使用第三方登录方式（如 QQ 或 Weixin）登录一个用户，就可以在您的 Wilddog 项目中创建一个新用户。</p>\n<p>您也可以从 Wilddog 控制面板的身份“认证部分”的“用户”页面中创建新的密码认证用户。</p>\n<h2 id=\"获取当前登录的用户\"><a href=\"#获取当前登录的用户\" class=\"headerlink\" title=\"获取当前登录的用户\"></a>获取当前登录的用户</h2><p>获取当前用户的推荐方法是在 Auth 对象上设置一个侦听器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().onAuthStateChanged(function(user) &#123;</div><div class=\"line\">  if (user) &#123;</div><div class=\"line\">     console.log(&quot;wxl&quot;);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">     console.log(&quot;no user&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用侦听器可保证在您获取当前用户时 Auth 对象不会处于中间状态如初始化。</p>\n<p>您也可以使用 <code>currentUser</code> 属性获取当前已登录的用户。 如果用户没有登录，<code>currentUser</code> 则为空：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">if (user != nil) &#123;</div><div class=\"line\">     // User is signed in.</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">     // No user is signed in.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：<code>currentUser</code> 可能为空，这是因为 auth 对象尚未完成初始化。 如果您使用侦听器跟踪用户登录状态，您将无需处理该情况。</p>\n<h2 id=\"获取用户个人资料\"><a href=\"#获取用户个人资料\" class=\"headerlink\" title=\"获取用户个人资料\"></a>获取用户个人资料</h2><p>要获取用户的个人资料信息，请使用 <code>User</code> 实例的属性。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\">if (user != null) &#123;</div><div class=\"line\">    var name = user.displayName;</div><div class=\"line\">    var email = user.email;</div><div class=\"line\">    var photoUrl = user.photoURL;</div><div class=\"line\">    var uid = user.uid; </div><div class=\"line\">&#125; else &#123;</div><div class=\"line\"> // No user is signed in.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"获取用户的第三方登录的个人资料信息\"><a href=\"#获取用户的第三方登录的个人资料信息\" class=\"headerlink\" title=\"获取用户的第三方登录的个人资料信息\"></a>获取用户的第三方登录的个人资料信息</h2><p>要从已链接至用户的第三方登录中获取检索到的个人资料信息，请使用 providerData 属性。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var user = wilddog.auth().currentUser;</div><div class=\"line\"> console.log(user);</div><div class=\"line\"> user.providerData.forEach(function (profile) &#123;</div><div class=\"line\"> console.log(&quot;Sign-in provider: &quot; + profile.providerId);</div><div class=\"line\"> console.log(&quot; Provider-specific UID: &quot; + profile.uid);</div><div class=\"line\"> console.log(&quot; Name: &quot; + profile.displayName);</div><div class=\"line\"> console.log(&quot; Email: &quot; + profile.email);</div><div class=\"line\"> console.log(&quot; Photo URL: &quot; + profile.photoURL);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"更新用户个人资料\"><a href=\"#更新用户个人资料\" class=\"headerlink\" title=\"更新用户个人资料\"></a>更新用户个人资料</h2><p>您可以使用<code>WDGUserProfileChangeRequest</code> 类来更新一个用户的基本个人资料信息 — 用户的显示名称和个人资料照片网址。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.updateProfile(&#123;</div><div class=\"line\">     displayName: &quot;name&quot;,</div><div class=\"line\">     photoURL: &quot;https://example.com/path/photo.jpg&quot;</div><div class=\"line\"> &#125;).then(function() &#123;</div><div class=\"line\">     // Update successful.</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明:使用customToken登录时,若customToken中admin属性为true,则不能进行信息修改。</p>\n<h2 id=\"设置用户的电子邮件地址\"><a href=\"#设置用户的电子邮件地址\" class=\"headerlink\" title=\"设置用户的电子邮件地址\"></a>设置用户的电子邮件地址</h2><p>您可以用 <code>updateEmail:completion:</code> 方法设置用户的电子邮件地址。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.updateEmail(email).then(function() &#123;</div><div class=\"line\">     // Update successful.</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(error);</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<p>重要说明：</p>\n<ul>\n<li>要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</li>\n<li>使用customToken登录时,若customToken中admin属性为true,则不能进行邮箱修改。</li>\n</ul>\n<h2 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h2><p>您可以使用 <code>updatePassword:completion:</code> 方法设置用户密码。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.updatePassword(&quot;12345678&quot;).then(function() &#123;</div><div class=\"line\">     // Update successful.</div><div class=\"line\">     console.log(&quot;&quot;);</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // An error happened. </div><div class=\"line\">&#125;);</div><div class=\"line\">注意:使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改</div></pre></td></tr></table></figure>\n<p>重要说明：</p>\n<ul>\n<li>要设置用户的电子邮件地址，该用户必须最近登录过。请参阅对用户重新进行身份认证。</li>\n<li>使用customToken登录时,若customToken中admin属性为true,则不能进行密码修改。</li>\n</ul>\n<h2 id=\"发送重设密码电子邮件\"><a href=\"#发送重设密码电子邮件\" class=\"headerlink\" title=\"发送重设密码电子邮件\"></a>发送重设密码电子邮件</h2><p>您可以用 <code>sendPasswordResetWithEmail:completion:</code> 方法向用户发送一封重设密码电子邮件。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().sendPasswordResetEmail(email);</div></pre></td></tr></table></figure>\n<p>您可以在 Wilddog 控制面板的“用户认证”部分的“邮件模版”页面中自定义使用的电子邮件模板。</p>\n<p>您也可以从 Wilddog 控制面板中发送重设密码电子邮件。</p>\n<h2 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h2><p>您可以使用 <code>delete</code> 方法删除用户帐户。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.delete();</div><div class=\"line\">注意:若使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除</div></pre></td></tr></table></figure>\n<p>您可以从 Wilddog 控制面板的“用户认证”部分的“用户”页面中删除用户。</p>\n<p>重要说明：</p>\n<ul>\n<li>要删除用户，该用户必须最近登录过。请参阅对用户重新进行身份认证。</li>\n<li>使用customToken登录时,若customToken中admin属性为true,则不能进行用户删除。</li>\n</ul>\n<h2 id=\"对用户重新进行身份认证\"><a href=\"#对用户重新进行身份认证\" class=\"headerlink\" title=\"对用户重新进行身份认证\"></a>对用户重新进行身份认证</h2><p>有些安全敏感性操作—如删除帐户、设置主电子邮件地址和更改密码—需要用户最近登录过方可执行。</p>\n<p>如果您执行这些操作之一，而该用户在很久以前登录过，该操作便会失败。</p>\n<p>发生这种错误时，请通过从用户获取新登录凭据并将该凭据传递到 <code>reauthenticate</code>，对该用户重新进行身份认证。 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().currentUser.reauthenticate(credential).then(function(res) &#123;</div><div class=\"line\">    // Update successful.</div><div class=\"line\">    console.log(res);</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">    // An error happened.</div><div class=\"line\">    console.log(error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"密码登录","_content":"\n你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。\n\n\n## 开始前的准备工作\n\n\n1. 在 Wilddog 控制面板中创建一个应用.\n\n2. 在野狗应用控制面板中打开邮箱登录方式:\n\n\n\n * 在野狗控制面板中选择身份认证选项。\n\n * 在`登录方式`标签中打开邮箱登录方式。\n\n\n\n## 创建基于密码的帐户\n\n要用密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：\n\n\n1. 导入 Wilddog Auth 模块:\n \n ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n```\n\n2. 以 Wilddog AppId 初始化 Wilddog应用。\n\n```\nvar config = {\n\n authDomain: \"<appId>.wilddog.com\",\n\n syncURL: \"https://<appId>.wilddogio.com\"\n\n };\n\n wilddog.initializeApp(config, \"DEFAULT\");\n```\n\n3. 通过将该新用户的电子邮件地址和密码传递到 createUserWithEmailAndPassword(email,password) 来创建新帐户。\n\n```\nwilddog.auth().createUserWithEmailAndPassword(\"wangxiaoliang@wilddog.com\", \"12345678\").catch(function (error) {\n     // Handle Errors here.\n     console.log(error)\n });\n```\n\n如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。\n\n\n\n## 用电子邮件和密码登录一个用户\n\n用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：\n\n\n\n1. 导入 Wilddog Auth 模块:\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 初始化 `Wilddog` 应用实例。\n    ```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n```\n\n3. 将该用户的电子邮件地址和密码传递到 `signInWithEmailAndPassword(email:password)`,即可在你应用中登录此用户。\n    ```\nwilddog.auth().signInWithEmailAndPassword(\"550690505@qq.com\", \"1234567\").then(function(res){\n     console.log(res);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error)\n });\n    ```\n\n如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。\n\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n\n* 在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\n wilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n","source":"guide/auth/web/password.md","raw":"title:  密码登录\n---\n\n你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。\n\n\n## 开始前的准备工作\n\n\n1. 在 Wilddog 控制面板中创建一个应用.\n\n2. 在野狗应用控制面板中打开邮箱登录方式:\n\n\n\n * 在野狗控制面板中选择身份认证选项。\n\n * 在`登录方式`标签中打开邮箱登录方式。\n\n\n\n## 创建基于密码的帐户\n\n要用密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：\n\n\n1. 导入 Wilddog Auth 模块:\n \n ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n```\n\n2. 以 Wilddog AppId 初始化 Wilddog应用。\n\n```\nvar config = {\n\n authDomain: \"<appId>.wilddog.com\",\n\n syncURL: \"https://<appId>.wilddogio.com\"\n\n };\n\n wilddog.initializeApp(config, \"DEFAULT\");\n```\n\n3. 通过将该新用户的电子邮件地址和密码传递到 createUserWithEmailAndPassword(email,password) 来创建新帐户。\n\n```\nwilddog.auth().createUserWithEmailAndPassword(\"wangxiaoliang@wilddog.com\", \"12345678\").catch(function (error) {\n     // Handle Errors here.\n     console.log(error)\n });\n```\n\n如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。\n\n\n\n## 用电子邮件和密码登录一个用户\n\n用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：\n\n\n\n1. 导入 Wilddog Auth 模块:\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 初始化 `Wilddog` 应用实例。\n    ```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n```\n\n3. 将该用户的电子邮件地址和密码传递到 `signInWithEmailAndPassword(email:password)`,即可在你应用中登录此用户。\n    ```\nwilddog.auth().signInWithEmailAndPassword(\"550690505@qq.com\", \"1234567\").then(function(res){\n     console.log(res);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error)\n });\n    ```\n\n如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。\n\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n\n* 在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\n wilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n","date":"2016-09-06T03:38:22.533Z","updated":"2016-09-06T03:38:22.533Z","path":"guide/auth/web/password.html","comments":1,"layout":"page","_id":"cisswi9l1001gz4fwm1o9j4u1","content":"<p>你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 Wilddog 控制面板中创建一个应用.</p>\n</li>\n<li><p>在野狗应用控制面板中打开邮箱登录方式:</p>\n</li>\n</ol>\n<ul>\n<li><p>在野狗控制面板中选择身份认证选项。</p>\n</li>\n<li><p>在<code>登录方式</code>标签中打开邮箱登录方式。</p>\n</li>\n</ul>\n<h2 id=\"创建基于密码的帐户\"><a href=\"#创建基于密码的帐户\" class=\"headerlink\" title=\"创建基于密码的帐户\"></a>创建基于密码的帐户</h2><p>要用密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：</p>\n<ol>\n<li><p>导入 Wilddog Auth 模块:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>以 Wilddog AppId 初始化 Wilddog应用。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\"></div><div class=\"line\"> authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\"></div><div class=\"line\"> syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\"></div><div class=\"line\"> &#125;;</div><div class=\"line\"></div><div class=\"line\"> wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n<ol>\n<li>通过将该新用户的电子邮件地址和密码传递到 createUserWithEmailAndPassword(email,password) 来创建新帐户。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().createUserWithEmailAndPassword(&quot;wangxiaoliang@wilddog.com&quot;, &quot;12345678&quot;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<p>如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。</p>\n<h2 id=\"用电子邮件和密码登录一个用户\"><a href=\"#用电子邮件和密码登录一个用户\" class=\"headerlink\" title=\"用电子邮件和密码登录一个用户\"></a>用电子邮件和密码登录一个用户</h2><p>用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：</p>\n<ol>\n<li><p>导入 Wilddog Auth 模块:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>将该用户的电子邮件地址和密码传递到 <code>signInWithEmailAndPassword(email:password)</code>,即可在你应用中登录此用户。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInWithEmailAndPassword(&quot;550690505@qq.com&quot;, &quot;1234567&quot;).then(function(res)&#123;</div><div class=\"line\">     console.log(res);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。</p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">    // Sign-out successful.</div><div class=\"line\">    console.log(&quot;sign-out&quot;)</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">    // An error happened.</div><div class=\"line\">    console.log(&quot;sign-out-error&quot;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>你可以使用 Wilddog Auth 让你的用户用电子邮件地址和密码进行 Wilddog 身份认证，而且可以通过他来管理你的应用帐户。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 Wilddog 控制面板中创建一个应用.</p>\n</li>\n<li><p>在野狗应用控制面板中打开邮箱登录方式:</p>\n</li>\n</ol>\n<ul>\n<li><p>在野狗控制面板中选择身份认证选项。</p>\n</li>\n<li><p>在<code>登录方式</code>标签中打开邮箱登录方式。</p>\n</li>\n</ul>\n<h2 id=\"创建基于密码的帐户\"><a href=\"#创建基于密码的帐户\" class=\"headerlink\" title=\"创建基于密码的帐户\"></a>创建基于密码的帐户</h2><p>要用密码创建一个新用户帐户，请在你的应用登录模块中完成以下步骤：</p>\n<ol>\n<li><p>导入 Wilddog Auth 模块:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>以 Wilddog AppId 初始化 Wilddog应用。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\"></div><div class=\"line\"> authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\"></div><div class=\"line\"> syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\"></div><div class=\"line\"> &#125;;</div><div class=\"line\"></div><div class=\"line\"> wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n<ol>\n<li>通过将该新用户的电子邮件地址和密码传递到 createUserWithEmailAndPassword(email,password) 来创建新帐户。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().createUserWithEmailAndPassword(&quot;wangxiaoliang@wilddog.com&quot;, &quot;12345678&quot;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<p>如果新帐户创建成功，默认会处于登录状态，并且你可以在回调方法中获取登录用户的数据。</p>\n<h2 id=\"用电子邮件和密码登录一个用户\"><a href=\"#用电子邮件和密码登录一个用户\" class=\"headerlink\" title=\"用电子邮件和密码登录一个用户\"></a>用电子邮件和密码登录一个用户</h2><p>用密码登录一个用户的步骤与创建新帐户的步骤相似。 在你应用的登录模块中，执行以下操作：</p>\n<ol>\n<li><p>导入 Wilddog Auth 模块:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>将该用户的电子邮件地址和密码传递到 <code>signInWithEmailAndPassword(email:password)</code>,即可在你应用中登录此用户。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signInWithEmailAndPassword(&quot;550690505@qq.com&quot;, &quot;1234567&quot;).then(function(res)&#123;</div><div class=\"line\">     console.log(res);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如果该用户成功登录，你就可以从回调方法的用户对象中获得该用户的帐户数据。</p>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">    // Sign-out successful.</div><div class=\"line\">    console.log(&quot;sign-out&quot;)</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">    // An error happened.</div><div class=\"line\">    console.log(&quot;sign-out-error&quot;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"QQ 登录","_content":"\n通过集成 QQ 登录，您可以让您的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n\n## 开始前的准备工作\n\n1. 在 [QQ 开放平台管理中心](http://op.open.qq.com/)，获取应用的 **App ID** 和 **App Secret**。\n\n2. 在野狗控制面板中打开 QQ 登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击 QQ 登录开关，点击配置，输入 QQ 帐号 **APP ID** 和 **App Secret**。\n\n\n## Wilddog 身份认证\n1. 导入 WilddogAuth 模块：\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 初始化 `Wilddog` 应用实例：\n ```\nvar config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n    ```\n\n3.QQ登录(popup or redirect)\n\n```\nvar provider = new wilddog.auth.QQAuthProvider();\n\npopup登录\nwilddog.auth().signInWithPopup(provider).then(function (result) {\n    console.log(result);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n\nredirect登录\nwilddog.auth().signInWithRedirect(provider).then(function (result) {\n     console.log(result);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n* 在您的应用中，您可以通过 wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n\n\n\n","source":"guide/auth/web/qq.md","raw":"title:  QQ 登录\n---\n\n通过集成 QQ 登录，您可以让您的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n\n## 开始前的准备工作\n\n1. 在 [QQ 开放平台管理中心](http://op.open.qq.com/)，获取应用的 **App ID** 和 **App Secret**。\n\n2. 在野狗控制面板中打开 QQ 登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击 QQ 登录开关，点击配置，输入 QQ 帐号 **APP ID** 和 **App Secret**。\n\n\n## Wilddog 身份认证\n1. 导入 WilddogAuth 模块：\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 初始化 `Wilddog` 应用实例：\n ```\nvar config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n    ```\n\n3.QQ登录(popup or redirect)\n\n```\nvar provider = new wilddog.auth.QQAuthProvider();\n\npopup登录\nwilddog.auth().signInWithPopup(provider).then(function (result) {\n    console.log(result);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n\nredirect登录\nwilddog.auth().signInWithRedirect(provider).then(function (result) {\n     console.log(result);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n```\n\n## 后续步骤\n\n无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n* 在您的应用中，您可以通过 wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n您还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n\n\n\n","date":"2016-09-07T13:24:23.109Z","updated":"2016-09-07T13:24:23.109Z","path":"guide/auth/web/qq.html","_id":"cisswi9l1001hz4fw0a5ma3th","comments":1,"layout":"page","content":"<p>通过集成 QQ 登录，您可以让您的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"http://op.open.qq.com/\" target=\"_blank\" rel=\"external\">QQ 开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开 QQ 登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击 QQ 登录开关，点击配置，输入 QQ 帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">     authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">     syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.QQ登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.QQAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup登录</div><div class=\"line\">wilddog.auth().signInWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">    console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div><div class=\"line\"></div><div class=\"line\">redirect登录</div><div class=\"line\">wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在您的应用中，您可以通过 wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>通过集成 QQ 登录，您可以让您的用户使用他们的 QQ 帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"http://op.open.qq.com/\">QQ 开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开 QQ 登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击 QQ 登录开关，点击配置，输入 QQ 帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">     authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">     syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.QQ登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.QQAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup登录</div><div class=\"line\">wilddog.auth().signInWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">    console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div><div class=\"line\"></div><div class=\"line\">redirect登录</div><div class=\"line\">wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论您采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在您的应用中，您可以通过 wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>您还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"新浪微博登录","_content":"\n通过集成新浪微博登录，您可以让您的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。\n\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n1. 在 [新浪微博开放平台管理中心](http://open.weibo.com/apps)，获取应用的 **App Key** 和 **App Secret**。\n\n2. 在野狗控制面板中打开新浪微博登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击微博登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n\n1. 导入 WilddogAuth 模块：\n\n ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n\n ```\n2. 初始化 `Wilddog` 应用实例：\n ```\nvar config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n ```\n3.新浪微博登录(popup or redirect)\n\n```\nvar provider = new wilddog.auth.WeiboAuthProvider();\n\npopup登录\nwilddog.auth().signInWithPopup(provider).then(function (result) {\n     console.log(result);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n\nredirect登录\nwilddog.auth().signInWithRedirect(provider).then(function (result) {\n     console.log(result);    \n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在您的应用中，您可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n\n\n","source":"guide/auth/web/weibo.md","raw":"title:  新浪微博登录\n---\n\n通过集成新浪微博登录，您可以让您的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。\n\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n1. 在 [新浪微博开放平台管理中心](http://open.weibo.com/apps)，获取应用的 **App Key** 和 **App Secret**。\n\n2. 在野狗控制面板中打开新浪微博登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击微博登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n\n1. 导入 WilddogAuth 模块：\n\n ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n\n ```\n2. 初始化 `Wilddog` 应用实例：\n ```\nvar config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n ```\n3.新浪微博登录(popup or redirect)\n\n```\nvar provider = new wilddog.auth.WeiboAuthProvider();\n\npopup登录\nwilddog.auth().signInWithPopup(provider).then(function (result) {\n     console.log(result);\n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n\nredirect登录\nwilddog.auth().signInWithRedirect(provider).then(function (result) {\n     console.log(result);    \n }).catch(function (error) {\n     // Handle Errors here.\n     console.log(error);\n     // ...\n });\n```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在您的应用中，您可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在您的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n\n\n","date":"2016-09-07T13:24:23.111Z","updated":"2016-09-07T13:24:23.111Z","path":"guide/auth/web/weibo.html","_id":"cisswi9l1001iz4fwb6jd29b2","comments":1,"layout":"page","content":"<p>通过集成新浪微博登录，您可以让您的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"http://open.weibo.com/apps\" target=\"_blank\" rel=\"external\">新浪微博开放平台管理中心</a>，获取应用的 <strong>App Key</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开新浪微博登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击微博登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">     authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">     syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.新浪微博登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup登录</div><div class=\"line\">wilddog.auth().signInWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div><div class=\"line\"></div><div class=\"line\">redirect登录</div><div class=\"line\">wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);    </div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在您的应用中，您可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>通过集成新浪微博登录，您可以让您的用户使用他们的新浪微博帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"http://open.weibo.com/apps\">新浪微博开放平台管理中心</a>，获取应用的 <strong>App Key</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开新浪微博登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击微博登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">     authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">     syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.新浪微博登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeiboAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup登录</div><div class=\"line\">wilddog.auth().signInWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div><div class=\"line\"></div><div class=\"line\">redirect登录</div><div class=\"line\">wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);    </div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在您 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在您的应用中，您可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在您的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，您可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h3 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"微信登录","_content":"\n通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1. 在 [微信开放平台管理中心](https://open.weixin.qq.com/)，获取应用的 **App ID** 和 **App Secret**。\n\n2. 在野狗控制面板中打开微信登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n\n## Wilddog 身份认证\n\n1. 导入 WilddogAuth 模块：\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 初始化 `Wilddog` 应用实例：\n \n ```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n\n    ```\n\n3.微信登录(popup or redirect)\n\n```\n    var provider = new wilddog.auth.WeixinAuthProvider();\n    \npopup登录\n\n    wilddog.auth().signInWithPopup(provider).then(function (result) {\n         console.log(result);    \n    }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n    });\n  \nredirect登录\n    wilddog.auth().signInWithRedirect(provider).then(function (result) {\n         console.log(result);\n    }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n    });\n```\n\n\n## 后续步骤\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n* 在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n\n#### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n","source":"guide/auth/web/weixin.md","raw":"title:  微信登录\n---\n\n通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。\n\n登录的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1. 在 [微信开放平台管理中心](https://open.weixin.qq.com/)，获取应用的 **App ID** 和 **App Secret**。\n\n2. 在野狗控制面板中打开微信登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n\n## Wilddog 身份认证\n\n1. 导入 WilddogAuth 模块：\n    ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n    ```\n\n2. 初始化 `Wilddog` 应用实例：\n \n ```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n\n    ```\n\n3.微信登录(popup or redirect)\n\n```\n    var provider = new wilddog.auth.WeixinAuthProvider();\n    \npopup登录\n\n    wilddog.auth().signInWithPopup(provider).then(function (result) {\n         console.log(result);    \n    }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n    });\n  \nredirect登录\n    wilddog.auth().signInWithRedirect(provider).then(function (result) {\n         console.log(result);\n    }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n    });\n```\n\n\n## 后续步骤\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n\n* 在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n\n\n#### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n","date":"2016-09-06T12:15:41.041Z","updated":"2016-09-06T12:15:41.041Z","path":"guide/auth/web/weixin.html","comments":1,"layout":"page","_id":"cisswi9lg001jz4fw350g12r9","content":"<p>通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"https://open.weixin.qq.com/\" target=\"_blank\" rel=\"external\">微信开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开微信登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.微信登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">    var provider = new wilddog.auth.WeixinAuthProvider();</div><div class=\"line\">    </div><div class=\"line\">popup登录</div><div class=\"line\"></div><div class=\"line\">    wilddog.auth().signInWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">         console.log(result);    </div><div class=\"line\">    &#125;).catch(function (error) &#123;</div><div class=\"line\">         // Handle Errors here.</div><div class=\"line\">         console.log(error);</div><div class=\"line\">         // ...</div><div class=\"line\">    &#125;);</div><div class=\"line\">  </div><div class=\"line\">redirect登录</div><div class=\"line\">    wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">         console.log(result);</div><div class=\"line\">    &#125;).catch(function (error) &#123;</div><div class=\"line\">         // Handle Errors here.</div><div class=\"line\">         console.log(error);</div><div class=\"line\">         // ...</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h4 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>通过集成微信登录，你可以让你的用户使用他们的微信帐号来进行 Wilddog 身份认证。</p>\n<p>登录的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"https://open.weixin.qq.com/\">微信开放平台管理中心</a>，获取应用的 <strong>App ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开微信登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.微信登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">    var provider = new wilddog.auth.WeixinAuthProvider();</div><div class=\"line\">    </div><div class=\"line\">popup登录</div><div class=\"line\"></div><div class=\"line\">    wilddog.auth().signInWithPopup(provider).then(function (result) &#123;</div><div class=\"line\">         console.log(result);    </div><div class=\"line\">    &#125;).catch(function (error) &#123;</div><div class=\"line\">         // Handle Errors here.</div><div class=\"line\">         console.log(error);</div><div class=\"line\">         // ...</div><div class=\"line\">    &#125;);</div><div class=\"line\">  </div><div class=\"line\">redirect登录</div><div class=\"line\">    wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">         console.log(result);</div><div class=\"line\">    &#125;).catch(function (error) &#123;</div><div class=\"line\">         // Handle Errors here.</div><div class=\"line\">         console.log(error);</div><div class=\"line\">         // ...</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h4 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"微信公众账号登录","_content":"\n通过集成微信公众账号登录，你可以让你的用户使用他们的微信公众帐号来进行 Wilddog 身份认证。\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1. 在 [微信公众开放平台管理中心](http://mp.weixin.qq.com/)，获取应用的 **App Key** 和 **App Secret**。\n\n2. 在野狗控制面板中打开微信公众者账号登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n\n1. 导入 WilddogAuth 模块：\n ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n ```\n\n2. 初始化 `Wilddog` 应用实例：\n \n```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n\n ```\n\n3.微信公众者账号登录(popup or redirect)\n\n```\n    var provider = new wilddog.auth.WeixinmpAuthProvider();\n    \n    popup登录\n\n    wilddog.auth().signInWithPopup(provider).then(function         (result) {\n         console.log(result);\n     }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n     });\n\n\n\n    redirect登录\n\n    wilddog.auth().signInWithRedirect(provider).then(function (result) {\n         console.log(result);\n    }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n    });```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n#### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n\n\n\n\n\n\n\n","source":"guide/auth/web/weixinpublic.md","raw":"title: 微信公众账号登录\n---\n\n通过集成微信公众账号登录，你可以让你的用户使用他们的微信公众帐号来进行 Wilddog 身份认证。\n\n认证的用户可以访问野狗实时数据同步中用户登录受限的数据。\n\n## 开始前的准备工作\n\n1. 在 [微信公众开放平台管理中心](http://mp.weixin.qq.com/)，获取应用的 **App Key** 和 **App Secret**。\n\n2. 在野狗控制面板中打开微信公众者账号登录方式:\n\n * 在野狗控制面板中选择 ”身份认证“->登录方式。\n\n * 点击微信登录开关，点击配置，输入微信帐号 **APP ID** 和 **App Secret**。\n\n## Wilddog 身份认证\n\n1. 导入 WilddogAuth 模块：\n ```\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js\"></script>\n ```\n\n2. 初始化 `Wilddog` 应用实例：\n \n```\n var config = {\n     authDomain: \"<appId>.wilddog.com\",\n     syncURL: \"https://<appId>.wilddogio.com\"\n };\n wilddog.initializeApp(config, \"DEFAULT\");\n\n ```\n\n3.微信公众者账号登录(popup or redirect)\n\n```\n    var provider = new wilddog.auth.WeixinmpAuthProvider();\n    \n    popup登录\n\n    wilddog.auth().signInWithPopup(provider).then(function         (result) {\n         console.log(result);\n     }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n     });\n\n\n\n    redirect登录\n\n    wilddog.auth().signInWithRedirect(provider).then(function (result) {\n         console.log(result);\n    }).catch(function (error) {\n         // Handle Errors here.\n         console.log(error);\n         // ...\n    });```\n\n## 后续步骤\n\n无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 [规则表达式](/guide/sync/rules/introduce.html)，`auth` 还可以控制野狗实时数据同步的用户访问权限。\n\n* 在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 [管理用户](/guide/auth/web/manageuser.html)。\n\n* 在你的野狗实时数据同步 [规则表达式](/guide/sync/rules/introduce.html) 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。\n\n你还可以通过 [链接多种登录方式](/guide/auth/web/link.html) 来实现不同的登录方式登录同一个帐号。\n\n#### 调用 [signOut](/guide/auth/web/api.html#signout) 退出登录：\n\n```\nwilddog.auth().signOut().then(function() {\n     // Sign-out successful.\n     console.log(\"sign-out\")\n }, function(error) {\n     // An error happened.\n     console.log(\"sign-out-error\")\n });\n\n```\n\n\n\n\n\n\n\n\n","date":"2016-09-07T13:24:23.114Z","updated":"2016-09-07T13:24:23.114Z","path":"guide/auth/web/weixinpublic.html","_id":"cisswi9lg001kz4fwz5489z3n","comments":1,"layout":"page","content":"<p>通过集成微信公众账号登录，你可以让你的用户使用他们的微信公众帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"http://mp.weixin.qq.com/\" target=\"_blank\" rel=\"external\">微信公众开放平台管理中心</a>，获取应用的 <strong>App Key</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开微信公众者账号登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n<p>3.微信公众者账号登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinmpAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup登录</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().signInWithPopup(provider).then(function         (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect登录</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h4 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>通过集成微信公众账号登录，你可以让你的用户使用他们的微信公众帐号来进行 Wilddog 身份认证。</p>\n<p>认证的用户可以访问野狗实时数据同步中用户登录受限的数据。</p>\n<h2 id=\"开始前的准备工作\"><a href=\"#开始前的准备工作\" class=\"headerlink\" title=\"开始前的准备工作\"></a>开始前的准备工作</h2><ol>\n<li><p>在 <a href=\"http://mp.weixin.qq.com/\">微信公众开放平台管理中心</a>，获取应用的 <strong>App Key</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n<li><p>在野狗控制面板中打开微信公众者账号登录方式:</p>\n<ul>\n<li><p>在野狗控制面板中选择 ”身份认证“-&gt;登录方式。</p>\n</li>\n<li><p>点击微信登录开关，点击配置，输入微信帐号 <strong>APP ID</strong> 和 <strong>App Secret</strong>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Wilddog-身份认证\"><a href=\"#Wilddog-身份认证\" class=\"headerlink\" title=\"Wilddog 身份认证\"></a>Wilddog 身份认证</h2><ol>\n<li><p>导入 WilddogAuth 模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-auth.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>初始化 <code>Wilddog</code> 应用实例：</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var config = &#123;</div><div class=\"line\">    authDomain: &quot;&lt;appId&gt;.wilddog.com&quot;,</div><div class=\"line\">    syncURL: &quot;https://&lt;appId&gt;.wilddogio.com&quot;</div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config, &quot;DEFAULT&quot;);</div></pre></td></tr></table></figure>\n<p>3.微信公众者账号登录(popup or redirect)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var provider = new wilddog.auth.WeixinmpAuthProvider();</div><div class=\"line\"></div><div class=\"line\">popup登录</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().signInWithPopup(provider).then(function         (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\"> &#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\"> &#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">redirect登录</div><div class=\"line\"></div><div class=\"line\">wilddog.auth().signInWithRedirect(provider).then(function (result) &#123;</div><div class=\"line\">     console.log(result);</div><div class=\"line\">&#125;).catch(function (error) &#123;</div><div class=\"line\">     // Handle Errors here.</div><div class=\"line\">     console.log(error);</div><div class=\"line\">     // ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"后续步骤\"><a href=\"#后续步骤\" class=\"headerlink\" title=\"后续步骤\"></a>后续步骤</h2><p>无论你采用哪种登录方式，用户第一次登录后，野狗服务器都会生成一个唯一的 Wilddog ID 来标识这个帐户，使用这个 Wilddog ID，可以在你 APP 中确认每个用户的身份。配合 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a>，<code>auth</code> 还可以控制野狗实时数据同步的用户访问权限。</p>\n<ul>\n<li><p>在你的应用中，你可以通过 Wilddog.auth().currentUser() 来获取用户的基本属性。参考 <a href=\"/guide/auth/web/manageuser.html\">管理用户</a>。</p>\n</li>\n<li><p>在你的野狗实时数据同步 <a href=\"/guide/sync/rules/introduce.html\">规则表达式</a> 中，你可以获取到这个登录后生成的唯一用户 Wilddog ID， 通过他可以实现控制用户对数据的访问权限。</p>\n</li>\n</ul>\n<p>你还可以通过 <a href=\"/guide/auth/web/link.html\">链接多种登录方式</a> 来实现不同的登录方式登录同一个帐号。</p>\n<h4 id=\"调用-signOut-退出登录：\"><a href=\"#调用-signOut-退出登录：\" class=\"headerlink\" title=\"调用 signOut 退出登录：\"></a>调用 <a href=\"/guide/auth/web/api.html#signout\">signOut</a> 退出登录：</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog.auth().signOut().then(function() &#123;</div><div class=\"line\">     // Sign-out successful.</div><div class=\"line\">     console.log(&quot;sign-out&quot;)</div><div class=\"line\"> &#125;, function(error) &#123;</div><div class=\"line\">     // An error happened.</div><div class=\"line\">     console.log(&quot;sign-out-error&quot;)</div><div class=\"line\"> &#125;);</div></pre></td></tr></table></figure>\n"},{"title":"读取和查询数据","_content":"本部分将介绍如何读取数据以及如何对数据进行排序和查询。\n需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。\n\n## 监听的事件类型\n\n监听在数据初始化时会触发一次，并在满足特定特定条件时会再次触发。一共有以下几种事件类型：\n\n监听器 | 事件     | 描述\n---- | ---- | ---\nValueEventListener | onDataChange() | 当程序初始化时或有任何数据发生变化时触发\nChildEventListener | onChildAdded()   | 当程序初始化时或有新增子节点时触发\n                   | onChildChanged()  | 当程序初始化时或有新增子节点时触发\n                   | onChildRemoved()\t| 当有子节点被删除时触发\n                   | onChildMoved() | 当有子节排序发生变化时触发\n\n如果是监听当前路径下的所有数据，请使用 `addValueEventListener()` 或 `addListenerForSingleValueEvent()` 方法。若是要监听当前路径下的子节点数据，请使用 `addChildEventListener()` 方法。\n\n#### onDataChange() 事件 \n\n使用 `onDataChange()` 事件来读取当前节点下的所有数据的静态快照。\n此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。\n数据（包括子节点）的快照会以事件回调形式返回。\n\n**注意**：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。\n例如，如果不是必要，尽量不要在根路径设置 onDataChange() 监听。\n\n下面的例子演示了获取[示例应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop)中 gracehop 的个人信息。\n\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\");\n\nref.addValueEventListener(new ValueEventListener(){\n\n     public void onDataChange(DataSnapshot snapshot) {\n         // 获取数据\n         System.out.println(snapshot.getValue());\n     }\n\n     // 当listener在服务端失败，或者被删除的时候调用该方法。\n     public void onCancelled(WilddogError error) {\n         if(error != null){\n             System.out.println(error.getCode());\n         }\n     }\n});\n\n// 控制台输出：\n// {full_name=Grace Hopper, date_of_birth=December 9, 1906, nickname=Amazing Grace}\n```\n回调的数据快照 `snapshot` 对象会包含指定路径下的数据。使用 `getValue()` 方法来获取 `snapshot` 中的数据。\n`snapshot` 里封装了一些常用的方法，帮助你更方便的处理数据，将常用的列举如下：\n\n方法     | 说明\n-------- | ---\ngetValue() | 返回当前快照的数据。\ngetChildren()    | 返回当前快照中，所有子节点的迭代器。可做遍历用。\ngetChildrenCount()    | 返回当前节点中子节点的个数。\nexists()     | 如果 snapshot 对象包含数据返回 true，否则返回false。\nhasChild()     | 检查是否存在特定子节点。\n\n更多更详细的用法说明参见 [API 文档](/api/sync/android.html)。\n\n#### child 事件\n当某个节点的子节点发生改变时（如通过 `push()` 方法添加子节点，或通过 `updateChildren()` 更新子节点），就会触发 `child 事件`。\n对于监听对数据库中某个特定节点的子节点所做的各种变动，结合使用上述每一种方法就显得非常有用。\n\n`onChildAdded()` 事件常用来获取当前路径下的子节点列表。初始化时会针对每个子节点触发一次以获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。\n\n对子节点修改时会触发 `onChildChanged()` 事件，这个修改包括对子节点里更深层的节点所做的修改。\n\n删除直接子节点时，将会触发 `onChildRemoved()` 事件。\n\n每当因更新（导致子节点重新排序）而触发 `onChildChanged()` 事件时，系统就会触发 `onChildMoved()` 事件。该事件用于通过 `orderByChild`、`orderByValue` 或 `orderByPriority` 中的任何一种进行排序的数据。\n\n我们来举个组合使用的例子。在[博客应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts)中，我们可以这样监听博客的变化状态：\n\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\");\nref.addChildEventListener(new ChildEventListener(){    \n    public void onChildAdded(DataSnapshot snapshot, String ref) {  \n        String author = (String) snapshot.child(\"author\").getValue();\n        String title = (String) snapshot.child(\"title\").getValue();\n        System.out.println(author + \" 发布了一篇名为《\" + title + \"》的博客\");\n    }\n\n    public void onChildChanged(DataSnapshot snapshot, String ref) {\n        String author = (String) snapshot.child(\"author\").getValue();\n        String title = (String) snapshot.child(\"title\").getValue();\n        System.out.println(author + \" 更新博客标题为《\" + title + \"》\");\n    }\n\n    public void onChildMoved(DataSnapshot snapshot, String ref) {\n        String author = (String) snapshot.child(\"author\").getValue();\n        String title = (String) snapshot.child(\"title\").getValue();\n        System.out.println(\"博客《\" + title + \"》被删除\");\n    }\n\n    public void onChildRemoved(DataSnapshot snapshot) {\n    }\n  \n    public void onCancelled(WilddogError error) {\n    }\n\n});\n```\n\n## 移除监听\n\n通过`removeEventListener()`方法可以移除一个监听事件。\n\n在父节点上调用 `removeEventListener()` 时不会自动移除在其子节点上注册的监听。\n\n## 监听事件的保证\n\n野狗数据实时同步的事件监听有以下几个重要的保证：\n\n监听事件的保证 |\n---- |\n本地数据状态发生了改变，事件就会触发。 |\n事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。 |\n写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。 |\nValue 事件总是最后触发，并且能保证包含快照（`snapshot`）生成之前的所有改变。 |\n\n## 一次性读取数据\n\n在某些场景下，也许只需要事件的回调被触发一次即可，然后立即取消监听。可以使用`addListenerForSingleValueEvent()`方法：\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\");\nref.addListenerForSingleValueEvent(new ValueEventListener(){\n\n  public void onDataChange(DataSnapshot snapshot) {\n  // 执行业务处理，此回调方法只会被调用一次,之后就取消\n  }\n\n  public void onCancelled(WilddogError error) {\n    if(error != null){\n      System.out.println(error.getCode());\n    }\n  }\n});\n```\n## 排序和查询数据\n\n你可以使用 [Query](/api/sync/android.html#Query-Methods) 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。\n只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。\n\n**注意**：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 [.indexOn](/api/sync/rule.html#indexOn) 规则，以便在服务器上添加索引以提高查询性能。详细操作参见[添加索引](/guide/sync/rules/guide.html#数据索引)。\n\n#### 数据排序\n\n对数据排序前，要先指定按照`键`、`值`、`子节点的值`或按`优先级`这四种的哪一种排序。对应的方法如下：\n\n方法 | 用法\n----  | ----\norderByChild() | 按指定子节点的值对结果排序。\norderByKey() | 按键(key)对结果排序。\norderByValue() | 按值对结果排序。\norderByPriority() | 按优先级对结果排序。\n\n**注意**：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。\n\n下面这个示例演示了在[恐龙面板应用](https://dinosaur-facts.wilddogio.com)中如何按照每个恐龙的身高（\"height\"节点的值）进行排序。\n```java\nWilddog ref = new Wilddog(\"https://dinosaur-facts.wilddogio.com/dinosaurs\");\n\nQuery queryRef = ref.orderByChild(\"height\");\n\nqueryRef.addChildEventListener(new ChildEventListener() {\n\n    public void onChildAdded(DataSnapshot snapshot, String ref) {\n        String height = snapshot.child(\"height\").getValue().toString();\n        System.out.println(snapshot.getKey() + \" was \" + height + \" meters tall\");\n    }\n\n    public void onCancelled(WilddogError arg0) {\n    }\n\n    public void onChildChanged(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildMoved(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildRemoved(DataSnapshot arg0) {\n    }\n\n});\n```\n调用 `orderByChild()` 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 \"height\"，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见[排序规则](/guide/sync/android/retrieve-data.html#排序规则)。\n\n#### 查询数据\n\n只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。\n\n方法 | 用法\n---- | ----\nlimitToFirst() | 设置从第一条开始，一共返回多少条数据（节点）。\nlimitToLast() | 设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。\nstartAt() | 返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nendAt() | 返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nequalTo() | 返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。\n\n与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 `startAt()` 与 `endAt()` 方法将结果限制在指定的范围内。\n\n**限制结果数**\n\n你可以使用 `limitToFirst()` 和 `limitToLast()` 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 `limitToFirst(100)` 将限制个数设置为 100，那么一开始最多只能收到 100 个 `child_added` 事件，即只返回前 100 条数据的快照。\n当数据发生更改时，对于进入到前100的数据，你会接收到 `child_added` 事件，对于从前 100 中消失的数据，你才会接收到 `child_removed` 事件，也就是说只有这 100 条里的数据变化才会触发事件。\n\n继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：\n\n```java\nWilddog ref = new Wilddog(\"https://dinosaur-facts.wilddogio.com/dinosaurs\");\n\nQuery queryRef = ref.orderByChild(\"height\");\n\nqueryRef.limitToLast(3).addChildEventListener(new ChildEventListener() {\n\n    public void onChildAdded(DataSnapshot snapshot, String ref) {\n        String height = snapshot.child(\"height\").getValue().toString();\n        System.out.println(snapshot.getKey() + \" was \" + height + \" meters tall\");\n    }\n\n    public void onCancelled(WilddogError arg0) {\n    }\n\n    public void onChildChanged(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildMoved(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildRemoved(DataSnapshot arg0) {\n    }\n\n});\n```\n或者你只关心哪些[恐龙](https://dinosaur-facts.wilddogio.com/scores)的得分超过 60 了：\n\n```java\nWilddog ref = new Wilddog(\"https://dinosaur-facts.wilddogio.com/scores\");\n\nQuery queryRef = ref.orderByValue();\n\nqueryRef.startAt(60).addChildEventListener(new ChildEventListener() {\n\n    public void onChildAdded(DataSnapshot snapshot, String ref) {\n        String score = snapshot.getValue().toString();\n        System.out.println(snapshot.getKey() + \" is \" + score);\n    }\n    \n    public void onCancelled(WilddogError arg0) {\n    }\n\n    public void onChildChanged(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildMoved(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildRemoved(DataSnapshot arg0) {\n    }\n\n});\n```\n如上例所示，使用 `startAt()`、`endAt()` 和 `equalTo()` 为查询选择任意起点、终点或等量点。这可以用于`数据分页`和`精确查询`。\n\n#### 排序规则\n\n本小节介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**orderByChild**\n\n当使用`orderByChild(key)`时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用`\norderByChild(key)`获取全量数据，例如，\n```json\n   {\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    }, \n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }, \n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    }, \n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    }, \n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n```\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`number`类型，此时使用`orderByChild(key)`获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 `orderByChild('score').startAt(60).limitToFirst(4)` 将得到下面的结果：\n```json\n  {\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }\n  }\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用 `orderByChild(key)`将搜索不到该数据。</em></p>\n\n\n\n**orderByKey**\n\n当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。\n\n**orderByValue**\n\n当使用`orderByValue()`时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用`orderByValue()`获取全量数据，例如，\n```json\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n```\n霸王龙的分数是 `string`类型，雷龙的分数是 `boolean` 类型，而其他恐龙的分数是 `numberic` 类型，此时使用 `orderByValue()` 获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的value值为null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用```orderByValue().startAt(60).limitToFirst(4)```将得到下面的结果：\n```json\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用`orderByValue()`将搜索不到该数据。</em></p>\n\n**orderByPriority**\n当使用`orderByPriority()`对数据进行排序时，子节点数据将按照优先级和字段名进行排序。\n**注意**：优先级的值只能是数值型或字符串。\n优先级的设置可参考 [setPriority()](/api/sync/android.html#setPriority)\n\n- １. 没有设置优先级的数据（默认优先级为 null）优先。\n\n- ２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。\n\n- ３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。\n\n- ４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。\n\n\n\n","source":"guide/sync/android/retrieve-data.md","raw":"title:  读取和查询数据\n---\n本部分将介绍如何读取数据以及如何对数据进行排序和查询。\n需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。\n\n## 监听的事件类型\n\n监听在数据初始化时会触发一次，并在满足特定特定条件时会再次触发。一共有以下几种事件类型：\n\n监听器 | 事件     | 描述\n---- | ---- | ---\nValueEventListener | onDataChange() | 当程序初始化时或有任何数据发生变化时触发\nChildEventListener | onChildAdded()   | 当程序初始化时或有新增子节点时触发\n                   | onChildChanged()  | 当程序初始化时或有新增子节点时触发\n                   | onChildRemoved()\t| 当有子节点被删除时触发\n                   | onChildMoved() | 当有子节排序发生变化时触发\n\n如果是监听当前路径下的所有数据，请使用 `addValueEventListener()` 或 `addListenerForSingleValueEvent()` 方法。若是要监听当前路径下的子节点数据，请使用 `addChildEventListener()` 方法。\n\n#### onDataChange() 事件 \n\n使用 `onDataChange()` 事件来读取当前节点下的所有数据的静态快照。\n此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。\n数据（包括子节点）的快照会以事件回调形式返回。\n\n**注意**：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。\n例如，如果不是必要，尽量不要在根路径设置 onDataChange() 监听。\n\n下面的例子演示了获取[示例应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop)中 gracehop 的个人信息。\n\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\");\n\nref.addValueEventListener(new ValueEventListener(){\n\n     public void onDataChange(DataSnapshot snapshot) {\n         // 获取数据\n         System.out.println(snapshot.getValue());\n     }\n\n     // 当listener在服务端失败，或者被删除的时候调用该方法。\n     public void onCancelled(WilddogError error) {\n         if(error != null){\n             System.out.println(error.getCode());\n         }\n     }\n});\n\n// 控制台输出：\n// {full_name=Grace Hopper, date_of_birth=December 9, 1906, nickname=Amazing Grace}\n```\n回调的数据快照 `snapshot` 对象会包含指定路径下的数据。使用 `getValue()` 方法来获取 `snapshot` 中的数据。\n`snapshot` 里封装了一些常用的方法，帮助你更方便的处理数据，将常用的列举如下：\n\n方法     | 说明\n-------- | ---\ngetValue() | 返回当前快照的数据。\ngetChildren()    | 返回当前快照中，所有子节点的迭代器。可做遍历用。\ngetChildrenCount()    | 返回当前节点中子节点的个数。\nexists()     | 如果 snapshot 对象包含数据返回 true，否则返回false。\nhasChild()     | 检查是否存在特定子节点。\n\n更多更详细的用法说明参见 [API 文档](/api/sync/android.html)。\n\n#### child 事件\n当某个节点的子节点发生改变时（如通过 `push()` 方法添加子节点，或通过 `updateChildren()` 更新子节点），就会触发 `child 事件`。\n对于监听对数据库中某个特定节点的子节点所做的各种变动，结合使用上述每一种方法就显得非常有用。\n\n`onChildAdded()` 事件常用来获取当前路径下的子节点列表。初始化时会针对每个子节点触发一次以获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。\n\n对子节点修改时会触发 `onChildChanged()` 事件，这个修改包括对子节点里更深层的节点所做的修改。\n\n删除直接子节点时，将会触发 `onChildRemoved()` 事件。\n\n每当因更新（导致子节点重新排序）而触发 `onChildChanged()` 事件时，系统就会触发 `onChildMoved()` 事件。该事件用于通过 `orderByChild`、`orderByValue` 或 `orderByPriority` 中的任何一种进行排序的数据。\n\n我们来举个组合使用的例子。在[博客应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts)中，我们可以这样监听博客的变化状态：\n\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\");\nref.addChildEventListener(new ChildEventListener(){    \n    public void onChildAdded(DataSnapshot snapshot, String ref) {  \n        String author = (String) snapshot.child(\"author\").getValue();\n        String title = (String) snapshot.child(\"title\").getValue();\n        System.out.println(author + \" 发布了一篇名为《\" + title + \"》的博客\");\n    }\n\n    public void onChildChanged(DataSnapshot snapshot, String ref) {\n        String author = (String) snapshot.child(\"author\").getValue();\n        String title = (String) snapshot.child(\"title\").getValue();\n        System.out.println(author + \" 更新博客标题为《\" + title + \"》\");\n    }\n\n    public void onChildMoved(DataSnapshot snapshot, String ref) {\n        String author = (String) snapshot.child(\"author\").getValue();\n        String title = (String) snapshot.child(\"title\").getValue();\n        System.out.println(\"博客《\" + title + \"》被删除\");\n    }\n\n    public void onChildRemoved(DataSnapshot snapshot) {\n    }\n  \n    public void onCancelled(WilddogError error) {\n    }\n\n});\n```\n\n## 移除监听\n\n通过`removeEventListener()`方法可以移除一个监听事件。\n\n在父节点上调用 `removeEventListener()` 时不会自动移除在其子节点上注册的监听。\n\n## 监听事件的保证\n\n野狗数据实时同步的事件监听有以下几个重要的保证：\n\n监听事件的保证 |\n---- |\n本地数据状态发生了改变，事件就会触发。 |\n事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。 |\n写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。 |\nValue 事件总是最后触发，并且能保证包含快照（`snapshot`）生成之前的所有改变。 |\n\n## 一次性读取数据\n\n在某些场景下，也许只需要事件的回调被触发一次即可，然后立即取消监听。可以使用`addListenerForSingleValueEvent()`方法：\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\");\nref.addListenerForSingleValueEvent(new ValueEventListener(){\n\n  public void onDataChange(DataSnapshot snapshot) {\n  // 执行业务处理，此回调方法只会被调用一次,之后就取消\n  }\n\n  public void onCancelled(WilddogError error) {\n    if(error != null){\n      System.out.println(error.getCode());\n    }\n  }\n});\n```\n## 排序和查询数据\n\n你可以使用 [Query](/api/sync/android.html#Query-Methods) 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。\n只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。\n\n**注意**：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 [.indexOn](/api/sync/rule.html#indexOn) 规则，以便在服务器上添加索引以提高查询性能。详细操作参见[添加索引](/guide/sync/rules/guide.html#数据索引)。\n\n#### 数据排序\n\n对数据排序前，要先指定按照`键`、`值`、`子节点的值`或按`优先级`这四种的哪一种排序。对应的方法如下：\n\n方法 | 用法\n----  | ----\norderByChild() | 按指定子节点的值对结果排序。\norderByKey() | 按键(key)对结果排序。\norderByValue() | 按值对结果排序。\norderByPriority() | 按优先级对结果排序。\n\n**注意**：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。\n\n下面这个示例演示了在[恐龙面板应用](https://dinosaur-facts.wilddogio.com)中如何按照每个恐龙的身高（\"height\"节点的值）进行排序。\n```java\nWilddog ref = new Wilddog(\"https://dinosaur-facts.wilddogio.com/dinosaurs\");\n\nQuery queryRef = ref.orderByChild(\"height\");\n\nqueryRef.addChildEventListener(new ChildEventListener() {\n\n    public void onChildAdded(DataSnapshot snapshot, String ref) {\n        String height = snapshot.child(\"height\").getValue().toString();\n        System.out.println(snapshot.getKey() + \" was \" + height + \" meters tall\");\n    }\n\n    public void onCancelled(WilddogError arg0) {\n    }\n\n    public void onChildChanged(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildMoved(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildRemoved(DataSnapshot arg0) {\n    }\n\n});\n```\n调用 `orderByChild()` 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 \"height\"，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见[排序规则](/guide/sync/android/retrieve-data.html#排序规则)。\n\n#### 查询数据\n\n只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。\n\n方法 | 用法\n---- | ----\nlimitToFirst() | 设置从第一条开始，一共返回多少条数据（节点）。\nlimitToLast() | 设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。\nstartAt() | 返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nendAt() | 返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nequalTo() | 返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。\n\n与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 `startAt()` 与 `endAt()` 方法将结果限制在指定的范围内。\n\n**限制结果数**\n\n你可以使用 `limitToFirst()` 和 `limitToLast()` 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 `limitToFirst(100)` 将限制个数设置为 100，那么一开始最多只能收到 100 个 `child_added` 事件，即只返回前 100 条数据的快照。\n当数据发生更改时，对于进入到前100的数据，你会接收到 `child_added` 事件，对于从前 100 中消失的数据，你才会接收到 `child_removed` 事件，也就是说只有这 100 条里的数据变化才会触发事件。\n\n继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：\n\n```java\nWilddog ref = new Wilddog(\"https://dinosaur-facts.wilddogio.com/dinosaurs\");\n\nQuery queryRef = ref.orderByChild(\"height\");\n\nqueryRef.limitToLast(3).addChildEventListener(new ChildEventListener() {\n\n    public void onChildAdded(DataSnapshot snapshot, String ref) {\n        String height = snapshot.child(\"height\").getValue().toString();\n        System.out.println(snapshot.getKey() + \" was \" + height + \" meters tall\");\n    }\n\n    public void onCancelled(WilddogError arg0) {\n    }\n\n    public void onChildChanged(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildMoved(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildRemoved(DataSnapshot arg0) {\n    }\n\n});\n```\n或者你只关心哪些[恐龙](https://dinosaur-facts.wilddogio.com/scores)的得分超过 60 了：\n\n```java\nWilddog ref = new Wilddog(\"https://dinosaur-facts.wilddogio.com/scores\");\n\nQuery queryRef = ref.orderByValue();\n\nqueryRef.startAt(60).addChildEventListener(new ChildEventListener() {\n\n    public void onChildAdded(DataSnapshot snapshot, String ref) {\n        String score = snapshot.getValue().toString();\n        System.out.println(snapshot.getKey() + \" is \" + score);\n    }\n    \n    public void onCancelled(WilddogError arg0) {\n    }\n\n    public void onChildChanged(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildMoved(DataSnapshot arg0, String arg1) {\n    }\n\n    public void onChildRemoved(DataSnapshot arg0) {\n    }\n\n});\n```\n如上例所示，使用 `startAt()`、`endAt()` 和 `equalTo()` 为查询选择任意起点、终点或等量点。这可以用于`数据分页`和`精确查询`。\n\n#### 排序规则\n\n本小节介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**orderByChild**\n\n当使用`orderByChild(key)`时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用`\norderByChild(key)`获取全量数据，例如，\n```json\n   {\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    }, \n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }, \n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    }, \n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    }, \n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n```\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`number`类型，此时使用`orderByChild(key)`获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 `orderByChild('score').startAt(60).limitToFirst(4)` 将得到下面的结果：\n```json\n  {\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }\n  }\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用 `orderByChild(key)`将搜索不到该数据。</em></p>\n\n\n\n**orderByKey**\n\n当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。\n\n**orderByValue**\n\n当使用`orderByValue()`时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用`orderByValue()`获取全量数据，例如，\n```json\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n```\n霸王龙的分数是 `string`类型，雷龙的分数是 `boolean` 类型，而其他恐龙的分数是 `numberic` 类型，此时使用 `orderByValue()` 获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的value值为null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用```orderByValue().startAt(60).limitToFirst(4)```将得到下面的结果：\n```json\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用`orderByValue()`将搜索不到该数据。</em></p>\n\n**orderByPriority**\n当使用`orderByPriority()`对数据进行排序时，子节点数据将按照优先级和字段名进行排序。\n**注意**：优先级的值只能是数值型或字符串。\n优先级的设置可参考 [setPriority()](/api/sync/android.html#setPriority)\n\n- １. 没有设置优先级的数据（默认优先级为 null）优先。\n\n- ２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。\n\n- ３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。\n\n- ４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。\n\n\n\n","date":"2016-09-06T03:38:22.536Z","updated":"2016-09-06T03:38:22.536Z","path":"guide/sync/android/retrieve-data.html","comments":1,"layout":"page","_id":"cisswi9lg001lz4fwto9zu9m5","content":"<p>本部分将介绍如何读取数据以及如何对数据进行排序和查询。<br>需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。</p>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>监听在数据初始化时会触发一次，并在满足特定特定条件时会再次触发。一共有以下几种事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>监听器</th>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ValueEventListener</td>\n<td>onDataChange()</td>\n<td>当程序初始化时或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>ChildEventListener</td>\n<td>onChildAdded()</td>\n<td>当程序初始化时或有新增子节点时触发</td>\n</tr>\n<tr>\n<td></td>\n<td>onChildChanged()</td>\n<td>当程序初始化时或有新增子节点时触发</td>\n</tr>\n<tr>\n<td></td>\n<td>onChildRemoved()</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td></td>\n<td>onChildMoved()</td>\n<td>当有子节排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n<p>如果是监听当前路径下的所有数据，请使用 <code>addValueEventListener()</code> 或 <code>addListenerForSingleValueEvent()</code> 方法。若是要监听当前路径下的子节点数据，请使用 <code>addChildEventListener()</code> 方法。</p>\n<h4 id=\"onDataChange-事件\"><a href=\"#onDataChange-事件\" class=\"headerlink\" title=\"onDataChange() 事件\"></a>onDataChange() 事件</h4><p>使用 <code>onDataChange()</code> 事件来读取当前节点下的所有数据的静态快照。<br>此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。<br>数据（包括子节点）的快照会以事件回调形式返回。</p>\n<p><strong>注意</strong>：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。<br>例如，如果不是必要，尽量不要在根路径设置 onDataChange() 监听。</p>\n<p>下面的例子演示了获取<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\" target=\"_blank\" rel=\"external\">示例应用</a>中 gracehop 的个人信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener()&#123;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">// 获取数据</span></div><div class=\"line\">         System.out.println(snapshot.getValue());</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 当listener在服务端失败，或者被删除的时候调用该方法。</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">             System.out.println(error.getCode());</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 控制台输出：</span></div><div class=\"line\"><span class=\"comment\">// &#123;full_name=Grace Hopper, date_of_birth=December 9, 1906, nickname=Amazing Grace&#125;</span></div></pre></td></tr></table></figure>\n<p>回调的数据快照 <code>snapshot</code> 对象会包含指定路径下的数据。使用 <code>getValue()</code> 方法来获取 <code>snapshot</code> 中的数据。<br><code>snapshot</code> 里封装了一些常用的方法，帮助你更方便的处理数据，将常用的列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getValue()</td>\n<td>返回当前快照的数据。</td>\n</tr>\n<tr>\n<td>getChildren()</td>\n<td>返回当前快照中，所有子节点的迭代器。可做遍历用。</td>\n</tr>\n<tr>\n<td>getChildrenCount()</td>\n<td>返回当前节点中子节点的个数。</td>\n</tr>\n<tr>\n<td>exists()</td>\n<td>如果 snapshot 对象包含数据返回 true，否则返回false。</td>\n</tr>\n<tr>\n<td>hasChild()</td>\n<td>检查是否存在特定子节点。</td>\n</tr>\n</tbody>\n</table>\n<p>更多更详细的用法说明参见 <a href=\"/api/sync/android.html\">API 文档</a>。</p>\n<h4 id=\"child-事件\"><a href=\"#child-事件\" class=\"headerlink\" title=\"child 事件\"></a>child 事件</h4><p>当某个节点的子节点发生改变时（如通过 <code>push()</code> 方法添加子节点，或通过 <code>updateChildren()</code> 更新子节点），就会触发 <code>child 事件</code>。<br>对于监听对数据库中某个特定节点的子节点所做的各种变动，结合使用上述每一种方法就显得非常有用。</p>\n<p><code>onChildAdded()</code> 事件常用来获取当前路径下的子节点列表。初始化时会针对每个子节点触发一次以获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。</p>\n<p>对子节点修改时会触发 <code>onChildChanged()</code> 事件，这个修改包括对子节点里更深层的节点所做的修改。</p>\n<p>删除直接子节点时，将会触发 <code>onChildRemoved()</code> 事件。</p>\n<p>每当因更新（导致子节点重新排序）而触发 <code>onChildChanged()</code> 事件时，系统就会触发 <code>onChildMoved()</code> 事件。该事件用于通过 <code>orderByChild</code>、<code>orderByValue</code> 或 <code>orderByPriority</code> 中的任何一种进行排序的数据。</p>\n<p>我们来举个组合使用的例子。在<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\" target=\"_blank\" rel=\"external\">博客应用</a>中，我们可以这样监听博客的变化状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>);</div><div class=\"line\">ref.addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener()&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;  </div><div class=\"line\">        String author = (String) snapshot.child(<span class=\"string\">\"author\"</span>).getValue();</div><div class=\"line\">        String title = (String) snapshot.child(<span class=\"string\">\"title\"</span>).getValue();</div><div class=\"line\">        System.out.println(author + <span class=\"string\">\" 发布了一篇名为《\"</span> + title + <span class=\"string\">\"》的博客\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String author = (String) snapshot.child(<span class=\"string\">\"author\"</span>).getValue();</div><div class=\"line\">        String title = (String) snapshot.child(<span class=\"string\">\"title\"</span>).getValue();</div><div class=\"line\">        System.out.println(author + <span class=\"string\">\" 更新博客标题为《\"</span> + title + <span class=\"string\">\"》\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String author = (String) snapshot.child(<span class=\"string\">\"author\"</span>).getValue();</div><div class=\"line\">        String title = (String) snapshot.child(<span class=\"string\">\"title\"</span>).getValue();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"博客《\"</span> + title + <span class=\"string\">\"》被删除\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"移除监听\"><a href=\"#移除监听\" class=\"headerlink\" title=\"移除监听\"></a>移除监听</h2><p>通过<code>removeEventListener()</code>方法可以移除一个监听事件。</p>\n<p>在父节点上调用 <code>removeEventListener()</code> 时不会自动移除在其子节点上注册的监听。</p>\n<h2 id=\"监听事件的保证\"><a href=\"#监听事件的保证\" class=\"headerlink\" title=\"监听事件的保证\"></a>监听事件的保证</h2><p>野狗数据实时同步的事件监听有以下几个重要的保证：</p>\n<table>\n<thead>\n<tr>\n<th>监听事件的保证</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地数据状态发生了改变，事件就会触发。</td>\n<td></td>\n</tr>\n<tr>\n<td>事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。</td>\n<td></td>\n</tr>\n<tr>\n<td>写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。</td>\n<td></td>\n</tr>\n<tr>\n<td>Value 事件总是最后触发，并且能保证包含快照（<code>snapshot</code>）生成之前的所有改变。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一次性读取数据\"><a href=\"#一次性读取数据\" class=\"headerlink\" title=\"一次性读取数据\"></a>一次性读取数据</h2><p>在某些场景下，也许只需要事件的回调被触发一次即可，然后立即取消监听。可以使用<code>addListenerForSingleValueEvent()</code>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\"</span>);</div><div class=\"line\">ref.addListenerForSingleValueEvent(<span class=\"keyword\">new</span> ValueEventListener()&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 执行业务处理，此回调方法只会被调用一次,之后就取消</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"排序和查询数据\"><a href=\"#排序和查询数据\" class=\"headerlink\" title=\"排序和查询数据\"></a>排序和查询数据</h2><p>你可以使用 <a href=\"/api/sync/android.html#Query-Methods\">Query</a> 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。<br>只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。</p>\n<p><strong>注意</strong>：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 规则，以便在服务器上添加索引以提高查询性能。详细操作参见<a href=\"/guide/sync/rules/guide.html#数据索引\">添加索引</a>。</p>\n<h4 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>对数据排序前，要先指定按照<code>键</code>、<code>值</code>、<code>子节点的值</code>或按<code>优先级</code>这四种的哪一种排序。对应的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>orderByChild()</td>\n<td>按指定子节点的值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByKey()</td>\n<td>按键(key)对结果排序。</td>\n</tr>\n<tr>\n<td>orderByValue()</td>\n<td>按值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByPriority()</td>\n<td>按优先级对结果排序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。</p>\n<p>下面这个示例演示了在<a href=\"https://dinosaur-facts.wilddogio.com\" target=\"_blank\" rel=\"external\">恐龙面板应用</a>中如何按照每个恐龙的身高（”height”节点的值）进行排序。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>);</div><div class=\"line\"></div><div class=\"line\">Query queryRef = ref.orderByChild(<span class=\"string\">\"height\"</span>);</div><div class=\"line\"></div><div class=\"line\">queryRef.addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String height = snapshot.child(<span class=\"string\">\"height\"</span>).getValue().toString();</div><div class=\"line\">        System.out.println(snapshot.getKey() + <span class=\"string\">\" was \"</span> + height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用 <code>orderByChild()</code> 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 “height”，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见<a href=\"/guide/sync/android/retrieve-data.html#排序规则\">排序规则</a>。</p>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>limitToFirst()</td>\n<td>设置从第一条开始，一共返回多少条数据（节点）。</td>\n</tr>\n<tr>\n<td>limitToLast()</td>\n<td>设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。</td>\n</tr>\n<tr>\n<td>startAt()</td>\n<td>返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>endAt()</td>\n<td>返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>equalTo()</td>\n<td>返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。</td>\n</tr>\n</tbody>\n</table>\n<p>与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 <code>startAt()</code> 与 <code>endAt()</code> 方法将结果限制在指定的范围内。</p>\n<p><strong>限制结果数</strong></p>\n<p>你可以使用 <code>limitToFirst()</code> 和 <code>limitToLast()</code> 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 <code>limitToFirst(100)</code> 将限制个数设置为 100，那么一开始最多只能收到 100 个 <code>child_added</code> 事件，即只返回前 100 条数据的快照。<br>当数据发生更改时，对于进入到前100的数据，你会接收到 <code>child_added</code> 事件，对于从前 100 中消失的数据，你才会接收到 <code>child_removed</code> 事件，也就是说只有这 100 条里的数据变化才会触发事件。</p>\n<p>继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>);</div><div class=\"line\"></div><div class=\"line\">Query queryRef = ref.orderByChild(<span class=\"string\">\"height\"</span>);</div><div class=\"line\"></div><div class=\"line\">queryRef.limitToLast(<span class=\"number\">3</span>).addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String height = snapshot.child(<span class=\"string\">\"height\"</span>).getValue().toString();</div><div class=\"line\">        System.out.println(snapshot.getKey() + <span class=\"string\">\" was \"</span> + height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>或者你只关心哪些<a href=\"https://dinosaur-facts.wilddogio.com/scores\" target=\"_blank\" rel=\"external\">恐龙</a>的得分超过 60 了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/scores\"</span>);</div><div class=\"line\"></div><div class=\"line\">Query queryRef = ref.orderByValue();</div><div class=\"line\"></div><div class=\"line\">queryRef.startAt(<span class=\"number\">60</span>).addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String score = snapshot.getValue().toString();</div><div class=\"line\">        System.out.println(snapshot.getKey() + <span class=\"string\">\" is \"</span> + score);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如上例所示，使用 <code>startAt()</code>、<code>endAt()</code> 和 <code>equalTo()</code> 为查询选择任意起点、终点或等量点。这可以用于<code>数据分页</code>和<code>精确查询</code>。</p>\n<h4 id=\"排序规则\"><a href=\"#排序规则\" class=\"headerlink\" title=\"排序规则\"></a>排序规则</h4><p>本小节介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>orderByChild</strong></p>\n<p>当使用<code>orderByChild(key)</code>时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用<code>orderByChild(key)</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">   &#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"no1\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"tyrannosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"string\">\"120\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no2\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"bruhathkayosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">55</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no3\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"lambeosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">21</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no6\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"stegosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">5</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no7\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"triceratops\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">22</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no8\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"brontosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>number</code>类型，此时使用<code>orderByChild(key)</code>获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 <code>orderByChild(&#39;score&#39;).startAt(60).limitToFirst(4)</code> 将得到下面的结果：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style=\"color:red\"><em>注意：如果path与value的总长度超过1000字节时，使用 <code>orderByChild(key)</code>将搜索不到该数据。</em></p>\n\n\n\n<p><strong>orderByKey</strong></p>\n<p>当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。</p>\n<p><strong>orderByValue</strong></p>\n<p>当使用<code>orderByValue()</code>时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用<code>orderByValue()</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"tyrannosaurus\"</span> : <span class=\"string\">\"120\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"attr\">\"brontosaurus\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是 <code>string</code>类型，雷龙的分数是 <code>boolean</code> 类型，而其他恐龙的分数是 <code>numberic</code> 类型，此时使用 <code>orderByValue()</code> 获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的value值为null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">```json</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style=\"color:red\"><em>注意：如果path与value的总长度超过1000字节时，使用<code>orderByValue()</code>将搜索不到该数据。</em></p>\n\n<p><strong>orderByPriority</strong><br>当使用<code>orderByPriority()</code>对数据进行排序时，子节点数据将按照优先级和字段名进行排序。<br><strong>注意</strong>：优先级的值只能是数值型或字符串。<br>优先级的设置可参考 <a href=\"/api/sync/android.html#setPriority\">setPriority()</a></p>\n<ul>\n<li><p>１. 没有设置优先级的数据（默认优先级为 null）优先。</p>\n</li>\n<li><p>２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。</p>\n</li>\n<li><p>３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。</p>\n</li>\n<li><p>４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>本部分将介绍如何读取数据以及如何对数据进行排序和查询。<br>需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。</p>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>监听在数据初始化时会触发一次，并在满足特定特定条件时会再次触发。一共有以下几种事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>监听器</th>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ValueEventListener</td>\n<td>onDataChange()</td>\n<td>当程序初始化时或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>ChildEventListener</td>\n<td>onChildAdded()</td>\n<td>当程序初始化时或有新增子节点时触发</td>\n</tr>\n<tr>\n<td></td>\n<td>onChildChanged()</td>\n<td>当程序初始化时或有新增子节点时触发</td>\n</tr>\n<tr>\n<td></td>\n<td>onChildRemoved()</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td></td>\n<td>onChildMoved()</td>\n<td>当有子节排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n<p>如果是监听当前路径下的所有数据，请使用 <code>addValueEventListener()</code> 或 <code>addListenerForSingleValueEvent()</code> 方法。若是要监听当前路径下的子节点数据，请使用 <code>addChildEventListener()</code> 方法。</p>\n<h4 id=\"onDataChange-事件\"><a href=\"#onDataChange-事件\" class=\"headerlink\" title=\"onDataChange() 事件\"></a>onDataChange() 事件</h4><p>使用 <code>onDataChange()</code> 事件来读取当前节点下的所有数据的静态快照。<br>此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。<br>数据（包括子节点）的快照会以事件回调形式返回。</p>\n<p><strong>注意</strong>：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。<br>例如，如果不是必要，尽量不要在根路径设置 onDataChange() 监听。</p>\n<p>下面的例子演示了获取<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\">示例应用</a>中 gracehop 的个人信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener()&#123;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">         <span class=\"comment\">// 获取数据</span></div><div class=\"line\">         System.out.println(snapshot.getValue());</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 当listener在服务端失败，或者被删除的时候调用该方法。</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">         <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">             System.out.println(error.getCode());</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 控制台输出：</span></div><div class=\"line\"><span class=\"comment\">// &#123;full_name=Grace Hopper, date_of_birth=December 9, 1906, nickname=Amazing Grace&#125;</span></div></pre></td></tr></table></figure>\n<p>回调的数据快照 <code>snapshot</code> 对象会包含指定路径下的数据。使用 <code>getValue()</code> 方法来获取 <code>snapshot</code> 中的数据。<br><code>snapshot</code> 里封装了一些常用的方法，帮助你更方便的处理数据，将常用的列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getValue()</td>\n<td>返回当前快照的数据。</td>\n</tr>\n<tr>\n<td>getChildren()</td>\n<td>返回当前快照中，所有子节点的迭代器。可做遍历用。</td>\n</tr>\n<tr>\n<td>getChildrenCount()</td>\n<td>返回当前节点中子节点的个数。</td>\n</tr>\n<tr>\n<td>exists()</td>\n<td>如果 snapshot 对象包含数据返回 true，否则返回false。</td>\n</tr>\n<tr>\n<td>hasChild()</td>\n<td>检查是否存在特定子节点。</td>\n</tr>\n</tbody>\n</table>\n<p>更多更详细的用法说明参见 <a href=\"/api/sync/android.html\">API 文档</a>。</p>\n<h4 id=\"child-事件\"><a href=\"#child-事件\" class=\"headerlink\" title=\"child 事件\"></a>child 事件</h4><p>当某个节点的子节点发生改变时（如通过 <code>push()</code> 方法添加子节点，或通过 <code>updateChildren()</code> 更新子节点），就会触发 <code>child 事件</code>。<br>对于监听对数据库中某个特定节点的子节点所做的各种变动，结合使用上述每一种方法就显得非常有用。</p>\n<p><code>onChildAdded()</code> 事件常用来获取当前路径下的子节点列表。初始化时会针对每个子节点触发一次以获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。</p>\n<p>对子节点修改时会触发 <code>onChildChanged()</code> 事件，这个修改包括对子节点里更深层的节点所做的修改。</p>\n<p>删除直接子节点时，将会触发 <code>onChildRemoved()</code> 事件。</p>\n<p>每当因更新（导致子节点重新排序）而触发 <code>onChildChanged()</code> 事件时，系统就会触发 <code>onChildMoved()</code> 事件。该事件用于通过 <code>orderByChild</code>、<code>orderByValue</code> 或 <code>orderByPriority</code> 中的任何一种进行排序的数据。</p>\n<p>我们来举个组合使用的例子。在<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\">博客应用</a>中，我们可以这样监听博客的变化状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>);</div><div class=\"line\">ref.addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener()&#123;    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;  </div><div class=\"line\">        String author = (String) snapshot.child(<span class=\"string\">\"author\"</span>).getValue();</div><div class=\"line\">        String title = (String) snapshot.child(<span class=\"string\">\"title\"</span>).getValue();</div><div class=\"line\">        System.out.println(author + <span class=\"string\">\" 发布了一篇名为《\"</span> + title + <span class=\"string\">\"》的博客\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String author = (String) snapshot.child(<span class=\"string\">\"author\"</span>).getValue();</div><div class=\"line\">        String title = (String) snapshot.child(<span class=\"string\">\"title\"</span>).getValue();</div><div class=\"line\">        System.out.println(author + <span class=\"string\">\" 更新博客标题为《\"</span> + title + <span class=\"string\">\"》\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String author = (String) snapshot.child(<span class=\"string\">\"author\"</span>).getValue();</div><div class=\"line\">        String title = (String) snapshot.child(<span class=\"string\">\"title\"</span>).getValue();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"博客《\"</span> + title + <span class=\"string\">\"》被删除\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"移除监听\"><a href=\"#移除监听\" class=\"headerlink\" title=\"移除监听\"></a>移除监听</h2><p>通过<code>removeEventListener()</code>方法可以移除一个监听事件。</p>\n<p>在父节点上调用 <code>removeEventListener()</code> 时不会自动移除在其子节点上注册的监听。</p>\n<h2 id=\"监听事件的保证\"><a href=\"#监听事件的保证\" class=\"headerlink\" title=\"监听事件的保证\"></a>监听事件的保证</h2><p>野狗数据实时同步的事件监听有以下几个重要的保证：</p>\n<table>\n<thead>\n<tr>\n<th>监听事件的保证</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地数据状态发生了改变，事件就会触发。</td>\n<td></td>\n</tr>\n<tr>\n<td>事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。</td>\n<td></td>\n</tr>\n<tr>\n<td>写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。</td>\n<td></td>\n</tr>\n<tr>\n<td>Value 事件总是最后触发，并且能保证包含快照（<code>snapshot</code>）生成之前的所有改变。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一次性读取数据\"><a href=\"#一次性读取数据\" class=\"headerlink\" title=\"一次性读取数据\"></a>一次性读取数据</h2><p>在某些场景下，也许只需要事件的回调被触发一次即可，然后立即取消监听。可以使用<code>addListenerForSingleValueEvent()</code>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\"</span>);</div><div class=\"line\">ref.addListenerForSingleValueEvent(<span class=\"keyword\">new</span> ValueEventListener()&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 执行业务处理，此回调方法只会被调用一次,之后就取消</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">      System.out.println(error.getCode());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"排序和查询数据\"><a href=\"#排序和查询数据\" class=\"headerlink\" title=\"排序和查询数据\"></a>排序和查询数据</h2><p>你可以使用 <a href=\"/api/sync/android.html#Query-Methods\">Query</a> 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。<br>只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。</p>\n<p><strong>注意</strong>：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 规则，以便在服务器上添加索引以提高查询性能。详细操作参见<a href=\"/guide/sync/rules/guide.html#数据索引\">添加索引</a>。</p>\n<h4 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>对数据排序前，要先指定按照<code>键</code>、<code>值</code>、<code>子节点的值</code>或按<code>优先级</code>这四种的哪一种排序。对应的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>orderByChild()</td>\n<td>按指定子节点的值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByKey()</td>\n<td>按键(key)对结果排序。</td>\n</tr>\n<tr>\n<td>orderByValue()</td>\n<td>按值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByPriority()</td>\n<td>按优先级对结果排序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。</p>\n<p>下面这个示例演示了在<a href=\"https://dinosaur-facts.wilddogio.com\">恐龙面板应用</a>中如何按照每个恐龙的身高（”height”节点的值）进行排序。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>);</div><div class=\"line\"></div><div class=\"line\">Query queryRef = ref.orderByChild(<span class=\"string\">\"height\"</span>);</div><div class=\"line\"></div><div class=\"line\">queryRef.addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String height = snapshot.child(<span class=\"string\">\"height\"</span>).getValue().toString();</div><div class=\"line\">        System.out.println(snapshot.getKey() + <span class=\"string\">\" was \"</span> + height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用 <code>orderByChild()</code> 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 “height”，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见<a href=\"/guide/sync/android/retrieve-data.html#排序规则\">排序规则</a>。</p>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>limitToFirst()</td>\n<td>设置从第一条开始，一共返回多少条数据（节点）。</td>\n</tr>\n<tr>\n<td>limitToLast()</td>\n<td>设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。</td>\n</tr>\n<tr>\n<td>startAt()</td>\n<td>返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>endAt()</td>\n<td>返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>equalTo()</td>\n<td>返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。</td>\n</tr>\n</tbody>\n</table>\n<p>与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 <code>startAt()</code> 与 <code>endAt()</code> 方法将结果限制在指定的范围内。</p>\n<p><strong>限制结果数</strong></p>\n<p>你可以使用 <code>limitToFirst()</code> 和 <code>limitToLast()</code> 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 <code>limitToFirst(100)</code> 将限制个数设置为 100，那么一开始最多只能收到 100 个 <code>child_added</code> 事件，即只返回前 100 条数据的快照。<br>当数据发生更改时，对于进入到前100的数据，你会接收到 <code>child_added</code> 事件，对于从前 100 中消失的数据，你才会接收到 <code>child_removed</code> 事件，也就是说只有这 100 条里的数据变化才会触发事件。</p>\n<p>继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>);</div><div class=\"line\"></div><div class=\"line\">Query queryRef = ref.orderByChild(<span class=\"string\">\"height\"</span>);</div><div class=\"line\"></div><div class=\"line\">queryRef.limitToLast(<span class=\"number\">3</span>).addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String height = snapshot.child(<span class=\"string\">\"height\"</span>).getValue().toString();</div><div class=\"line\">        System.out.println(snapshot.getKey() + <span class=\"string\">\" was \"</span> + height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>或者你只关心哪些<a href=\"https://dinosaur-facts.wilddogio.com/scores\">恐龙</a>的得分超过 60 了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/scores\"</span>);</div><div class=\"line\"></div><div class=\"line\">Query queryRef = ref.orderByValue();</div><div class=\"line\"></div><div class=\"line\">queryRef.startAt(<span class=\"number\">60</span>).addChildEventListener(<span class=\"keyword\">new</span> ChildEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildAdded</span><span class=\"params\">(DataSnapshot snapshot, String ref)</span> </span>&#123;</div><div class=\"line\">        String score = snapshot.getValue().toString();</div><div class=\"line\">        System.out.println(snapshot.getKey() + <span class=\"string\">\" is \"</span> + score);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildChanged</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildMoved</span><span class=\"params\">(DataSnapshot arg0, String arg1)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChildRemoved</span><span class=\"params\">(DataSnapshot arg0)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如上例所示，使用 <code>startAt()</code>、<code>endAt()</code> 和 <code>equalTo()</code> 为查询选择任意起点、终点或等量点。这可以用于<code>数据分页</code>和<code>精确查询</code>。</p>\n<h4 id=\"排序规则\"><a href=\"#排序规则\" class=\"headerlink\" title=\"排序规则\"></a>排序规则</h4><p>本小节介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>orderByChild</strong></p>\n<p>当使用<code>orderByChild(key)</code>时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用<code>orderByChild(key)</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">   &#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"no1\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"tyrannosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"string\">\"120\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no2\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"bruhathkayosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">55</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no3\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"lambeosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">21</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no6\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"stegosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">5</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no7\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"triceratops\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">22</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no8\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"brontosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>number</code>类型，此时使用<code>orderByChild(key)</code>获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 <code>orderByChild(&#39;score&#39;).startAt(60).limitToFirst(4)</code> 将得到下面的结果：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用 <code>orderByChild(key)</code>将搜索不到该数据。</em></p>\n\n\n\n<p><strong>orderByKey</strong></p>\n<p>当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。</p>\n<p><strong>orderByValue</strong></p>\n<p>当使用<code>orderByValue()</code>时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用<code>orderByValue()</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"tyrannosaurus\"</span> : <span class=\"string\">\"120\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"attr\">\"brontosaurus\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是 <code>string</code>类型，雷龙的分数是 <code>boolean</code> 类型，而其他恐龙的分数是 <code>numberic</code> 类型，此时使用 <code>orderByValue()</code> 获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的value值为null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">```json</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用<code>orderByValue()</code>将搜索不到该数据。</em></p>\n\n<p><strong>orderByPriority</strong><br>当使用<code>orderByPriority()</code>对数据进行排序时，子节点数据将按照优先级和字段名进行排序。<br><strong>注意</strong>：优先级的值只能是数值型或字符串。<br>优先级的设置可参考 <a href=\"/api/sync/android.html#setPriority\">setPriority()</a></p>\n<ul>\n<li><p>１. 没有设置优先级的数据（默认优先级为 null）优先。</p>\n</li>\n<li><p>２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。</p>\n</li>\n<li><p>３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。</p>\n</li>\n<li><p>４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。</p>\n</li>\n</ul>\n"},{"title":"离线功能","_content":"Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。\n\n## 监控连接状态\n\n在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。\n``` java\nWilddog connectedRef = new Wilddog(\"https://samplechat.wilddogio.com/.info/connected\");\nconnectedRef.addValueEventListener(new ValueEventListener() {\n\n    public void onDataChange(DataSnapshot snapshot) {\n        boolean isOnline = (Boolean) snapshot.getValue();\n        if (isOnline == true) {\n            System.out.println(\"客户端上线了。\");\n        } else {\n            System.out.println(\"客户端掉线了。\");\n        }\n    }\n\n    public void onCancelled(WilddogError error) {\n        System.err.println(\"监听失败或被取消。\");\n    }\n});\n\n```\n/.info/connected的值是boolean类型的，它不会和云端进行同步。\n\n## 离线事件\n\n如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。\n\n离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 setValue(), updateChildren()，removeValue()，都可以设置在离线事件中执行。\n\n下面是一个例子，使用`onDisconnect()`方法，在客户端连接断开的时候写入数据：\n\n```java\npresenceRef.onDisconnect().setValue(\"I disconnected!\");\n```\n\n**离线事件是如何工作的**\n\n当进行了一个`onDisconnect()`调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。\n\n客户端可以通过回调方法，确保离线事件被云端成功记录了：\n\n```java\nWilddog ref = new Wilddog(\"https://samplechat.wilddogio.com/android/onDisconnect\");\n\nref.onDisconnect().setValue(\"I disconnected!\", new Wilddog.CompletionListener() {\n    public void onComplete(WilddogError error, Wilddog ref) {\n        if (error == null) {\n            System.out.println(\"设置离线事件成功。\");\n        }\n    }\n});\n```\n\n要取消一个离线事件，可以使用`cancel()`方法：\n\n```java\nWilddog onDisconnectRef = presenceRef.onDisconnect();\nonDisconnectRef.set('I disconnected');\n// 取消离线事件\nonDisconnectRef.onDisconnect().cancel();\n```\n## 云端时间戳\nWilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和`onDisconnect()`方法组合起来，很容易实现记录客户端断线时间的功能：\n\n```java\nWilddog userLastOnlineRef = new Wilddog(\"https://samplechat.wilddogio.com/users/joe/lastOnline\");\nuserLastOnlineRef.onDisconnect().setValue(ServerValue.TIMESTAMP);\n```\n\n另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 `/.info/serverTimeOffset` 中,你可以通过`addValueEventListener()` 或者`addListenerForSingleValueEvent()` 监听 `onDataChange` 事件来获取这个数据:\n\n```java\nWilddog userLastOnlineRef = new Wilddog(\"https://samplechat.wilddogio.com/.info/serverTimeOffset\");\nuserLastOnlineRef.addValueEventListener(new ValueEventListener() {\n    public void onDataChange(DataSnapshot snapshot) {\n\n        long timeDiff = (Long) snapshot.getValue();\n        long serverTime = System.currentTimeMillis() + timeDiff;\n\n        System.out.println(\"服务器和本地的时间差值为：\" + timeDiff);\n        System.out.println(\"当前服务器时间戳为：\" + serverTime);\n\n    }\n\n    public void onCancelled(WilddogError error) {\n    }\n});\n```\n如果你只是想简单的获取服务端时间，可以用 rest API [Server Values](/api/sync/rest.html#Server-Values)。即向 `<appId>.wilddogio.com/.json?sv=timestamp` 发一个 `GET` 请求即可。\n\n## 手动建立或断开连接\nWilddog 也提供了手动建立（Wilddog.goOnline()）或者断开 （Wilddog.goOffline()）连接的方法。示例如下：\n\n另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 `goOffline` 和 `goOnline` 会控制`全局`的在线和离线。 \n\n## 离线功能的实现机制\n\nWilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有，这也是离线事件执行可能有延迟的原因），重试连接等。\n另外，重试连接连上之后，之前设置的监听仍然有效。\n\n\n\n\n\n\n\n","source":"guide/sync/android/offline-capabilities.md","raw":"title:  离线功能\n---\nWilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。\n\n## 监控连接状态\n\n在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。\n``` java\nWilddog connectedRef = new Wilddog(\"https://samplechat.wilddogio.com/.info/connected\");\nconnectedRef.addValueEventListener(new ValueEventListener() {\n\n    public void onDataChange(DataSnapshot snapshot) {\n        boolean isOnline = (Boolean) snapshot.getValue();\n        if (isOnline == true) {\n            System.out.println(\"客户端上线了。\");\n        } else {\n            System.out.println(\"客户端掉线了。\");\n        }\n    }\n\n    public void onCancelled(WilddogError error) {\n        System.err.println(\"监听失败或被取消。\");\n    }\n});\n\n```\n/.info/connected的值是boolean类型的，它不会和云端进行同步。\n\n## 离线事件\n\n如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。\n\n离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 setValue(), updateChildren()，removeValue()，都可以设置在离线事件中执行。\n\n下面是一个例子，使用`onDisconnect()`方法，在客户端连接断开的时候写入数据：\n\n```java\npresenceRef.onDisconnect().setValue(\"I disconnected!\");\n```\n\n**离线事件是如何工作的**\n\n当进行了一个`onDisconnect()`调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。\n\n客户端可以通过回调方法，确保离线事件被云端成功记录了：\n\n```java\nWilddog ref = new Wilddog(\"https://samplechat.wilddogio.com/android/onDisconnect\");\n\nref.onDisconnect().setValue(\"I disconnected!\", new Wilddog.CompletionListener() {\n    public void onComplete(WilddogError error, Wilddog ref) {\n        if (error == null) {\n            System.out.println(\"设置离线事件成功。\");\n        }\n    }\n});\n```\n\n要取消一个离线事件，可以使用`cancel()`方法：\n\n```java\nWilddog onDisconnectRef = presenceRef.onDisconnect();\nonDisconnectRef.set('I disconnected');\n// 取消离线事件\nonDisconnectRef.onDisconnect().cancel();\n```\n## 云端时间戳\nWilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和`onDisconnect()`方法组合起来，很容易实现记录客户端断线时间的功能：\n\n```java\nWilddog userLastOnlineRef = new Wilddog(\"https://samplechat.wilddogio.com/users/joe/lastOnline\");\nuserLastOnlineRef.onDisconnect().setValue(ServerValue.TIMESTAMP);\n```\n\n另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 `/.info/serverTimeOffset` 中,你可以通过`addValueEventListener()` 或者`addListenerForSingleValueEvent()` 监听 `onDataChange` 事件来获取这个数据:\n\n```java\nWilddog userLastOnlineRef = new Wilddog(\"https://samplechat.wilddogio.com/.info/serverTimeOffset\");\nuserLastOnlineRef.addValueEventListener(new ValueEventListener() {\n    public void onDataChange(DataSnapshot snapshot) {\n\n        long timeDiff = (Long) snapshot.getValue();\n        long serverTime = System.currentTimeMillis() + timeDiff;\n\n        System.out.println(\"服务器和本地的时间差值为：\" + timeDiff);\n        System.out.println(\"当前服务器时间戳为：\" + serverTime);\n\n    }\n\n    public void onCancelled(WilddogError error) {\n    }\n});\n```\n如果你只是想简单的获取服务端时间，可以用 rest API [Server Values](/api/sync/rest.html#Server-Values)。即向 `<appId>.wilddogio.com/.json?sv=timestamp` 发一个 `GET` 请求即可。\n\n## 手动建立或断开连接\nWilddog 也提供了手动建立（Wilddog.goOnline()）或者断开 （Wilddog.goOffline()）连接的方法。示例如下：\n\n另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 `goOffline` 和 `goOnline` 会控制`全局`的在线和离线。 \n\n## 离线功能的实现机制\n\nWilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有，这也是离线事件执行可能有延迟的原因），重试连接等。\n另外，重试连接连上之后，之前设置的监听仍然有效。\n\n\n\n\n\n\n\n","date":"2016-09-06T03:38:22.536Z","updated":"2016-09-06T03:38:22.536Z","path":"guide/sync/android/offline-capabilities.html","comments":1,"layout":"page","_id":"cisswi9lg001mz4fwuahly8kf","content":"<p>Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。</p>\n<h2 id=\"监控连接状态\"><a href=\"#监控连接状态\" class=\"headerlink\" title=\"监控连接状态\"></a>监控连接状态</h2><p>在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog connectedRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/.info/connected\"</span>);</div><div class=\"line\">connectedRef.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> isOnline = (Boolean) snapshot.getValue();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isOnline == <span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"客户端上线了。\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"客户端掉线了。\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">        System.err.println(<span class=\"string\">\"监听失败或被取消。\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>/.info/connected的值是boolean类型的，它不会和云端进行同步。</p>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。</p>\n<p>离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 setValue(), updateChildren()，removeValue()，都可以设置在离线事件中执行。</p>\n<p>下面是一个例子，使用<code>onDisconnect()</code>方法，在客户端连接断开的时候写入数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnect().setValue(<span class=\"string\">\"I disconnected!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>离线事件是如何工作的</strong></p>\n<p>当进行了一个<code>onDisconnect()</code>调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。</p>\n<p>客户端可以通过回调方法，确保离线事件被云端成功记录了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/onDisconnect\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.onDisconnect().setValue(<span class=\"string\">\"I disconnected!\"</span>, <span class=\"keyword\">new</span> Wilddog.CompletionListener() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (error == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"设置离线事件成功。\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>要取消一个离线事件，可以使用<code>cancel()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog onDisconnectRef = presenceRef.onDisconnect();</div><div class=\"line\">onDisconnectRef.set(<span class=\"string\">'I disconnected'</span>);</div><div class=\"line\"><span class=\"comment\">// 取消离线事件</span></div><div class=\"line\">onDisconnectRef.onDisconnect().cancel();</div></pre></td></tr></table></figure>\n<h2 id=\"云端时间戳\"><a href=\"#云端时间戳\" class=\"headerlink\" title=\"云端时间戳\"></a>云端时间戳</h2><p>Wilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和<code>onDisconnect()</code>方法组合起来，很容易实现记录客户端断线时间的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog userLastOnlineRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/users/joe/lastOnline\"</span>);</div><div class=\"line\">userLastOnlineRef.onDisconnect().setValue(ServerValue.TIMESTAMP);</div></pre></td></tr></table></figure>\n<p>另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 <code>/.info/serverTimeOffset</code> 中,你可以通过<code>addValueEventListener()</code> 或者<code>addListenerForSingleValueEvent()</code> 监听 <code>onDataChange</code> 事件来获取这个数据:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog userLastOnlineRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/.info/serverTimeOffset\"</span>);</div><div class=\"line\">userLastOnlineRef.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">long</span> timeDiff = (Long) snapshot.getValue();</div><div class=\"line\">        <span class=\"keyword\">long</span> serverTime = System.currentTimeMillis() + timeDiff;</div><div class=\"line\"></div><div class=\"line\">        System.out.println(<span class=\"string\">\"服务器和本地的时间差值为：\"</span> + timeDiff);</div><div class=\"line\">        System.out.println(<span class=\"string\">\"当前服务器时间戳为：\"</span> + serverTime);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果你只是想简单的获取服务端时间，可以用 rest API <a href=\"/api/sync/rest.html#Server-Values\">Server Values</a>。即向 <code>&lt;appId&gt;.wilddogio.com/.json?sv=timestamp</code> 发一个 <code>GET</code> 请求即可。</p>\n<h2 id=\"手动建立或断开连接\"><a href=\"#手动建立或断开连接\" class=\"headerlink\" title=\"手动建立或断开连接\"></a>手动建立或断开连接</h2><p>Wilddog 也提供了手动建立（Wilddog.goOnline()）或者断开 （Wilddog.goOffline()）连接的方法。示例如下：</p>\n<p>另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 <code>goOffline</code> 和 <code>goOnline</code> 会控制<code>全局</code>的在线和离线。 </p>\n<h2 id=\"离线功能的实现机制\"><a href=\"#离线功能的实现机制\" class=\"headerlink\" title=\"离线功能的实现机制\"></a>离线功能的实现机制</h2><p>Wilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有，这也是离线事件执行可能有延迟的原因），重试连接等。<br>另外，重试连接连上之后，之前设置的监听仍然有效。</p>\n","excerpt":"","more":"<p>Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。</p>\n<h2 id=\"监控连接状态\"><a href=\"#监控连接状态\" class=\"headerlink\" title=\"监控连接状态\"></a>监控连接状态</h2><p>在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog connectedRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/.info/connected\"</span>);</div><div class=\"line\">connectedRef.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> isOnline = (Boolean) snapshot.getValue();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isOnline == <span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"客户端上线了。\"</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"客户端掉线了。\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">        System.err.println(<span class=\"string\">\"监听失败或被取消。\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>/.info/connected的值是boolean类型的，它不会和云端进行同步。</p>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。</p>\n<p>离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 setValue(), updateChildren()，removeValue()，都可以设置在离线事件中执行。</p>\n<p>下面是一个例子，使用<code>onDisconnect()</code>方法，在客户端连接断开的时候写入数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnect().setValue(<span class=\"string\">\"I disconnected!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>离线事件是如何工作的</strong></p>\n<p>当进行了一个<code>onDisconnect()</code>调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。</p>\n<p>客户端可以通过回调方法，确保离线事件被云端成功记录了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/onDisconnect\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.onDisconnect().setValue(<span class=\"string\">\"I disconnected!\"</span>, <span class=\"keyword\">new</span> Wilddog.CompletionListener() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (error == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"设置离线事件成功。\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>要取消一个离线事件，可以使用<code>cancel()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog onDisconnectRef = presenceRef.onDisconnect();</div><div class=\"line\">onDisconnectRef.set(<span class=\"string\">'I disconnected'</span>);</div><div class=\"line\"><span class=\"comment\">// 取消离线事件</span></div><div class=\"line\">onDisconnectRef.onDisconnect().cancel();</div></pre></td></tr></table></figure>\n<h2 id=\"云端时间戳\"><a href=\"#云端时间戳\" class=\"headerlink\" title=\"云端时间戳\"></a>云端时间戳</h2><p>Wilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和<code>onDisconnect()</code>方法组合起来，很容易实现记录客户端断线时间的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog userLastOnlineRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/users/joe/lastOnline\"</span>);</div><div class=\"line\">userLastOnlineRef.onDisconnect().setValue(ServerValue.TIMESTAMP);</div></pre></td></tr></table></figure>\n<p>另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 <code>/.info/serverTimeOffset</code> 中,你可以通过<code>addValueEventListener()</code> 或者<code>addListenerForSingleValueEvent()</code> 监听 <code>onDataChange</code> 事件来获取这个数据:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog userLastOnlineRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/.info/serverTimeOffset\"</span>);</div><div class=\"line\">userLastOnlineRef.addValueEventListener(<span class=\"keyword\">new</span> ValueEventListener() &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDataChange</span><span class=\"params\">(DataSnapshot snapshot)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">long</span> timeDiff = (Long) snapshot.getValue();</div><div class=\"line\">        <span class=\"keyword\">long</span> serverTime = System.currentTimeMillis() + timeDiff;</div><div class=\"line\"></div><div class=\"line\">        System.out.println(<span class=\"string\">\"服务器和本地的时间差值为：\"</span> + timeDiff);</div><div class=\"line\">        System.out.println(<span class=\"string\">\"当前服务器时间戳为：\"</span> + serverTime);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCancelled</span><span class=\"params\">(WilddogError error)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果你只是想简单的获取服务端时间，可以用 rest API <a href=\"/api/sync/rest.html#Server-Values\">Server Values</a>。即向 <code>&lt;appId&gt;.wilddogio.com/.json?sv=timestamp</code> 发一个 <code>GET</code> 请求即可。</p>\n<h2 id=\"手动建立或断开连接\"><a href=\"#手动建立或断开连接\" class=\"headerlink\" title=\"手动建立或断开连接\"></a>手动建立或断开连接</h2><p>Wilddog 也提供了手动建立（Wilddog.goOnline()）或者断开 （Wilddog.goOffline()）连接的方法。示例如下：</p>\n<p>另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 <code>goOffline</code> 和 <code>goOnline</code> 会控制<code>全局</code>的在线和离线。 </p>\n<h2 id=\"离线功能的实现机制\"><a href=\"#离线功能的实现机制\" class=\"headerlink\" title=\"离线功能的实现机制\"></a>离线功能的实现机制</h2><p>Wilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有，这也是离线事件执行可能有延迟的原因），重试连接等。<br>另外，重试连接连上之后，之前设置的监听仍然有效。</p>\n"},{"title":"数组处理","_content":"\n野狗没有原生对数组的支持，这是因为数组中的元素无法映射为一个对应的数据 URL 。但是野狗支持对数组进行存储和读取操作。当存储一个数组时，数据实际上将会被当作 key 为整数和 value 为 对象 的键值对来存储。如下：\n\n```json\n// 要存储的数组数据\n['hello', 'world']\n// Wilddog实际存储\n{0: 'hello', 1: 'world'}\n```  \n\n当数据在回调事件中被处理时，数据被转换回各平台语言中的原生数组。数据被还原为数组，需要符合条件：当 0 到最大的 key 之间，超过一半以上有值。在符合条件时，野狗会自动将这些数据转换回数组：\n\n```json\n// 要存储的数据\n['a', 'b', 'c', 'd', 'e']\n// Wilddog 实际存储\n{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e'}\n\n// 由于key是数值，并且是连续有序的,\n// 因此当查询数据时，将会得到：\n['a', 'b', 'c', 'd', 'e']\n\n// 然而，当我们删除掉a，b和d之后，\n// 就不满足“大部分key是连续的数值”这一条件了，因此\n// 当查询时，我们得到的是：\n{2: 'c', 4: 'e'}\n``` ","source":"guide/sync/bestpractice/array.md","raw":"title: 数组处理\n---\n\n野狗没有原生对数组的支持，这是因为数组中的元素无法映射为一个对应的数据 URL 。但是野狗支持对数组进行存储和读取操作。当存储一个数组时，数据实际上将会被当作 key 为整数和 value 为 对象 的键值对来存储。如下：\n\n```json\n// 要存储的数组数据\n['hello', 'world']\n// Wilddog实际存储\n{0: 'hello', 1: 'world'}\n```  \n\n当数据在回调事件中被处理时，数据被转换回各平台语言中的原生数组。数据被还原为数组，需要符合条件：当 0 到最大的 key 之间，超过一半以上有值。在符合条件时，野狗会自动将这些数据转换回数组：\n\n```json\n// 要存储的数据\n['a', 'b', 'c', 'd', 'e']\n// Wilddog 实际存储\n{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e'}\n\n// 由于key是数值，并且是连续有序的,\n// 因此当查询数据时，将会得到：\n['a', 'b', 'c', 'd', 'e']\n\n// 然而，当我们删除掉a，b和d之后，\n// 就不满足“大部分key是连续的数值”这一条件了，因此\n// 当查询时，我们得到的是：\n{2: 'c', 4: 'e'}\n``` ","date":"2016-09-06T12:24:55.012Z","updated":"2016-09-06T12:24:55.005Z","path":"guide/sync/bestpractice/array.html","comments":1,"layout":"page","_id":"cisswi9lg001nz4fwnqo381nz","content":"<p>野狗没有原生对数组的支持，这是因为数组中的元素无法映射为一个对应的数据 URL 。但是野狗支持对数组进行存储和读取操作。当存储一个数组时，数据实际上将会被当作 key 为整数和 value 为 对象 的键值对来存储。如下：</p>\n<pre><code class=\"json\">// 要存储的数组数据\n[&#39;hello&#39;, &#39;world&#39;]\n// Wilddog实际存储\n{0: &#39;hello&#39;, 1: &#39;world&#39;}\n</code></pre>\n<p>当数据在回调事件中被处理时，数据被转换回各平台语言中的原生数组。数据被还原为数组，需要符合条件：当 0 到最大的 key 之间，超过一半以上有值。在符合条件时，野狗会自动将这些数据转换回数组：</p>\n<pre><code class=\"json\">// 要存储的数据\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\n// Wilddog 实际存储\n{0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, 3: &#39;d&#39;, 4: &#39;e&#39;}\n\n// 由于key是数值，并且是连续有序的,\n// 因此当查询数据时，将会得到：\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\n\n// 然而，当我们删除掉a，b和d之后，\n// 就不满足“大部分key是连续的数值”这一条件了，因此\n// 当查询时，我们得到的是：\n{2: &#39;c&#39;, 4: &#39;e&#39;}\n</code></pre>\n","excerpt":"","more":"<p>野狗没有原生对数组的支持，这是因为数组中的元素无法映射为一个对应的数据 URL 。但是野狗支持对数组进行存储和读取操作。当存储一个数组时，数据实际上将会被当作 key 为整数和 value 为 对象 的键值对来存储。如下：</p>\n<pre><code class=\"json\">// 要存储的数组数据\n[&#39;hello&#39;, &#39;world&#39;]\n// Wilddog实际存储\n{0: &#39;hello&#39;, 1: &#39;world&#39;}\n</code></pre>\n<p>当数据在回调事件中被处理时，数据被转换回各平台语言中的原生数组。数据被还原为数组，需要符合条件：当 0 到最大的 key 之间，超过一半以上有值。在符合条件时，野狗会自动将这些数据转换回数组：</p>\n<pre><code class=\"json\">// 要存储的数据\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\n// Wilddog 实际存储\n{0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, 3: &#39;d&#39;, 4: &#39;e&#39;}\n\n// 由于key是数值，并且是连续有序的,\n// 因此当查询数据时，将会得到：\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\n\n// 然而，当我们删除掉a，b和d之后，\n// 就不满足“大部分key是连续的数值”这一条件了，因此\n// 当查询时，我们得到的是：\n{2: &#39;c&#39;, 4: &#39;e&#39;}\n</code></pre>\n"},{"title":"保存数据","_content":"\n如果你刚接触 Wilddog，**强烈建议**先去阅读[快速入门](/quickstart/sync/android.html)，以对 Wilddog 的相关概念有个基本的了解。\n\n以下四种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nsetValue() | 将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 \npush() | 在当前路径下新增一个子节点, 并返回子节点的引用。这个子节点的 key 是利用服务端的当前时间生成的随机字符串, 与 setValue() 配合使用，用于将数据新增到此路径下。\nupdateChildren() | 对子节点进行合并操作。不存在的子节点将会被新增，存在的子节点将会被替换。\nrunTransaction() | 提供事务性更新，用于并发更新操作的场景。\n\n## 写入数据\n\n`setValue()` 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。\n`setValue()` 可以传入几种数据类型 `string`, `number`, `boolean`, `null`, `map`或满足 JavaBean 规范的实体做为参数。\n为了更好地理解该方法，我们建立一个[示例应用](https://samplechat.wilddogio.com)举例说明。我们打算将定义一个 User 对象保存在下面引用对应的路径中：\n\n```java\nWilddog ref = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data/wildblog\");\n```\n我们添加一些用户，为每个用户保存唯一的用户名，同时保存全名和出生日期。由于每个用户的用户名都是独一无二的，所以最好使用  `setValue()`方法，而不是 `push()` 方法，因为我们已经有了独一无二的用户名作为 key 值，不需要在添加的时候重新生成唯一标识。\n\n首先，我们编写 User 类代码，将 User 对象以用户名作为 key 值添加到 Map 中。然后，为用户数据所在路径创建引用，调用 `setValue()` 方法将 Map 中的每个用户添加到数据库中。\n\n```java\npublic class User {\n    private int birthYear;\n    private String fullName;\n\n    public User() {}\n\n    public User(String fullName, int birthYear) {\n        this.fullName = fullName;\n        this.birthYear = birthYear;\n    }\n\n    public long getBirthYear() {\n        return birthYear;\n    }\n\n    public String getFullName() {\n        return fullName;\n    }\n}\n\nUser alanisawesome = new User(\"Alan Turing\", 1912);\nUser gracehop = new User(\"Grace Hopper\", 1906);\n\nMap<String, User> users = new HashMap<String, User>();\nusers.put(\"alanisawesome\", alanisawesome);\nusers.put(\"gracehop\", gracehop);\n\nWilddog usersRef = ref.child(\"users\");\n\nusersRef.setValue(users);\n```\n我们可以向setValue()方法传入自定义的Java对象作为参数，但需要**满足**如下条件：\n\n- 对象所属的类中存在默认的构造方法;\n- 类中所有需要写入数据库的属性都有getter方法。\n\n我们使用 Map 将数据保存到数据库中，因为 Map 中的元素会自动映射成为 JSON 对象，并保存到指定路径。现在，我们再次访问示例应用的[数据预览](https://samplechat.wilddogio.com/android/saving-data/wildblog/users)来预览数据，就可以看到上面示例代码中保存的数据。\n\n还有一种等价的操作方式，即直接保存数据到指定的路径，如下：\n```java\nWilddog usersRef = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\");\n// 使用父节点引用的child()方法，获得指向子数据节点的引用。\nusersRef.child(\"alanisawesome\").child(\"fullName\").setValue(\"Alan Turing\");\nusersRef.child(\"alanisawesome\").child(\"birthYear\").setValue(1912);\n// 也可以在child()方法的参数中使用 '/' 分隔多个子节点路径。\nusersRef.child(\"gracehop/name\").setValue(\"Grace Hopper\");\nusersRef.child(\"gracehop/birthYear\").setValue(1906);\n\n```\n上面介绍的两种保存数据的方式，一种是使用Map将所有数据一次性保存到数据库，另一种是将数据分别保存到数据库的指定路径，最终的效果都是一样的：\n```json\n{\n  \"users\": {\n    \"alanisawesome\": {\n      \"birthYear\": \"1912\",\n      \"fullName\": \"Alan Turing\"\n    },\n    \"gracehop\": {\n      \"birthYear\": \"1906\",\n      \"fullName\": \"Grace Hopper\"\n    }\n  }\n}\n```\n我们也可以不使用 User 对象，而使用 Map 来实现与上面相同的功能：\n```java\nWilddog usersRef = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\");\n\nMap<String, String> alanisawesomeMap = new HashMap<String, String>();\nalanisawesomeMap.put(\"birthYear\", \"1912\");\nalanisawesomeMap.put(\"fullName\", \"Alan Turing\");\n\nMap<String, String> gracehopMap = new HashMap<String, String>();\ngracehopMap.put(\"birthYear\", \"1906\");\ngracehopMap.put(\"fullName\", \"Grace Hopper\");\n\nMap<String, Map<String, String>> users = new HashMap<String, Map<String, String>>();\nusers.put(\"alanisawesome\", alanisawesomeMap);\nusers.put(\"gracehop\", gracehopMap);\n\nusersRef.setValue(users);\n```\n野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后 SDK 去将数据与云端进行同步。\n也就是说，当 `setValue()` 方法执行完的时候，数据可能还没有同步到云端。\n若要确保同步到云端完成，需要使用 `setValue()` 方法的第二个参数，该参数是一个回调函数，代码示例如下：\n\n```java\nvar ref = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data\");\nref.child(\"setValue\").setValue(\"hello\", new Wilddog.CompletionListener() {\n  public void onComplete(WilddogError error, Wilddog ref) {\n    if (error == null) {\n      System.out.println(\"数据已成功保存到云端\");\n    }\n  }\n});\n```\n绝大多数操作都可设置回调函数来确保操作的完成，具体使用参见 [API文档](/api/sync/android.html)。\n\n## 更新数据\n\n如果只更新指定子节点，而不覆盖其它的子节点，可以使用 `updateChildren()` 方法:\n\n```java\n//原数据如下\n{\n    \"gracehop\": {\n        \"nickname\": \"Nice Grace\",\n        \"date_of_birth\": \"December 9, 1906\",\n        \"full_name \": \"Grace Lee\"\n    }\n}\n```\n```js\n// 只更新 gracehop 的 nickname\nWilddog hopperRef = usersRef.child(\"gracehop\");\nMap<String, Object> children = new HashMap<String, Object>();\nchildren.put(\"name\", \"Amazing grace\");\nhopperRef.updateChildren(children);\n```\n\n这样会更新 gracehop 的 nickname 字段。如果我们用 `setValue()` 而不是 `updateChildren()`，那么 date_of_birth 和 full_name 都会被删除。\n\n`updateChildren()` 也支持**多路径更新**，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:\n```json\n//原数据如下\n{\n    \"a\": {\n        \"b\": {\n            \"c\": \"cc\",\n            \"d\": \"dd\"\n        },\n        \"x\": {\n            \"y\": \"yy\",\n            \"z\": \"zz\"\n        }\n    }\n}\n```\n```java\n// 同时更新 b 节点下的 d，和 x 节点下的 z\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/a\");\nMap<String, Object> children = new HashMap<String, Object>();\n\nchildren.put(\"b/d\", \"vvv\");\nchildren.put(\"x/z\", \"vvv\");\n\nref.updateChildren(children);\n```\n可以看到，标识路径的时候，这里必须要用 `b/d`, 和 `x/z` ,而**不能**这样写：\n```java\n// 错误的多路径更新写法！！！\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/a\");\n\nMap<String, Object> children = new HashMap<String, Object>();\nMap<String, Object> children1 = new HashMap<String, Object>();\nMap<String, Object> children2 = new HashMap<String, Object>();\n\nchildren1.put(\"d\", \"vvv\");\nchildren2.put(\"z\", \"vvv\");\n\nchildren.put(\"b\", children1);\nchildren.put(\"x\", children2);\n\nref.updateChildren(children);\n```\n这样相当于 `setValue()` 操作，会把之前的数据覆盖掉。\n\n## 追加新节点\n\n当多个用户同时试图在同一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，Wilddog `push()` 采用了生成唯一ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面 push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后(可用来排序)，Wilddog 采用了足够多的位数保证唯一性。\n\n用户可以用 `push` 向[博客应用](https://docs-examples.wilddogio.com/android/saving-data/wildblog)中写新内容：\n\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/android/saving-data/wildblog/posts\");\n\nWilddog newRef1 = ref.push();\nnewRef1.child(\"author\").setValue(\"gracehop\");\nnewRef1.child(\"title\").setValue(\"Announcing COBOL, a New Programming Language\");\n\nWilddog newRef2 = ref.push();\nnewRef2.child(\"author\").setValue(\"alanisawesome\");\nnewRef2.child(\"title\").setValue(\"The Turing Machine\");\n```\n\n产生的数据都有一个唯一ID,如下:\n```json\n{\n  \"posts\": {\n    \"-JRHTHaIs-jNPLXO\": {\n      \"author\": \"gracehop\",\n      \"title\": \"Announcing COBOL, a New Programming Language\"\n    },\n\n    \"-JRHTHaKuITFIhnj\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n```\n\n**获取唯一ID**\n调用 `push()` 会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 `getKey()` 来获取这个唯一ID\n\n```java\n// 通过push()来获得一个新的数据库地址\nWilddog newRef1 = ref.push();\n\n// 获取push()生成的唯一ID\nString postID = newRef1.getKey();\n```\n## 删除数据\n删除数据最简单的方法是在引用上对这些数据所处的位置调用 `removeValue()`,这会把该路径下的所有数据删除:\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/removeValue\");\n// 不带回调    \nref.removeValue();\n\n// 或带回调，效果同上。\nref.removeValue(new Wilddog.CompletionListener(){\n\n        public void onComplete(WilddogError error, Wilddog ref) {\n            if(error != null) {\n                System.out.println(error.getCode());\n            }\n            System.out.println(\"Remove Success!\");                \n        }\n    \n});\n```\n此外，还可以通过将 null 指定为另一个写入操作（例如，`setValue()` 或 `updateChildren()`）的值来删除数据。 您可以结合使用此方法与 `updateChildren()`，在单一 API 调用中来删除多个子节点。\n\n**注意**：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。\n\n## 事务操作\n处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。\n\n更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。\n\n举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：\n\n```java\nvar upvotesRef = new Wilddog('https://docs-examples.wilddogio.com/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes');\n\nupvotesRef.runTransaction(new Transaction.Handler() {\n    public Transaction.Result doTransaction(MutableData currentData) {\n        if(currentData.getValue() == null) {\n            currentData.setValue(1);\n        } else {\n            currentData.setValue((Long) currentData.getValue() + 1);\n        }\n\n        return Transaction.success(currentData); \n        // 也可以这样中止事务 Transaction.abort()\n    }\n    public void onComplete(WilddogError wilddogError, boolean committed, DataSnapshot currentData) {\n        // 事务完成后调用一次，获取事务完成的结果\n    }\n});\n```\n\n我们使用 `currentData.getValue() != null` 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。\n\n注意：doTransaction() 可能被多次被调用，必须处理currentData.getValue()为 null 的情况。当执行事务时，云端有数据存在，但是本地可能没有缓存，此时currentData.getValue()为 null。\n更多使用参见 [transaction()](/api/sync/android.html#runTransaction-Transaction-Handler)。\n\n\n","source":"guide/sync/android/save-data.md","raw":"title:  保存数据\n---\n\n如果你刚接触 Wilddog，**强烈建议**先去阅读[快速入门](/quickstart/sync/android.html)，以对 Wilddog 的相关概念有个基本的了解。\n\n以下四种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nsetValue() | 将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 \npush() | 在当前路径下新增一个子节点, 并返回子节点的引用。这个子节点的 key 是利用服务端的当前时间生成的随机字符串, 与 setValue() 配合使用，用于将数据新增到此路径下。\nupdateChildren() | 对子节点进行合并操作。不存在的子节点将会被新增，存在的子节点将会被替换。\nrunTransaction() | 提供事务性更新，用于并发更新操作的场景。\n\n## 写入数据\n\n`setValue()` 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。\n`setValue()` 可以传入几种数据类型 `string`, `number`, `boolean`, `null`, `map`或满足 JavaBean 规范的实体做为参数。\n为了更好地理解该方法，我们建立一个[示例应用](https://samplechat.wilddogio.com)举例说明。我们打算将定义一个 User 对象保存在下面引用对应的路径中：\n\n```java\nWilddog ref = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data/wildblog\");\n```\n我们添加一些用户，为每个用户保存唯一的用户名，同时保存全名和出生日期。由于每个用户的用户名都是独一无二的，所以最好使用  `setValue()`方法，而不是 `push()` 方法，因为我们已经有了独一无二的用户名作为 key 值，不需要在添加的时候重新生成唯一标识。\n\n首先，我们编写 User 类代码，将 User 对象以用户名作为 key 值添加到 Map 中。然后，为用户数据所在路径创建引用，调用 `setValue()` 方法将 Map 中的每个用户添加到数据库中。\n\n```java\npublic class User {\n    private int birthYear;\n    private String fullName;\n\n    public User() {}\n\n    public User(String fullName, int birthYear) {\n        this.fullName = fullName;\n        this.birthYear = birthYear;\n    }\n\n    public long getBirthYear() {\n        return birthYear;\n    }\n\n    public String getFullName() {\n        return fullName;\n    }\n}\n\nUser alanisawesome = new User(\"Alan Turing\", 1912);\nUser gracehop = new User(\"Grace Hopper\", 1906);\n\nMap<String, User> users = new HashMap<String, User>();\nusers.put(\"alanisawesome\", alanisawesome);\nusers.put(\"gracehop\", gracehop);\n\nWilddog usersRef = ref.child(\"users\");\n\nusersRef.setValue(users);\n```\n我们可以向setValue()方法传入自定义的Java对象作为参数，但需要**满足**如下条件：\n\n- 对象所属的类中存在默认的构造方法;\n- 类中所有需要写入数据库的属性都有getter方法。\n\n我们使用 Map 将数据保存到数据库中，因为 Map 中的元素会自动映射成为 JSON 对象，并保存到指定路径。现在，我们再次访问示例应用的[数据预览](https://samplechat.wilddogio.com/android/saving-data/wildblog/users)来预览数据，就可以看到上面示例代码中保存的数据。\n\n还有一种等价的操作方式，即直接保存数据到指定的路径，如下：\n```java\nWilddog usersRef = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\");\n// 使用父节点引用的child()方法，获得指向子数据节点的引用。\nusersRef.child(\"alanisawesome\").child(\"fullName\").setValue(\"Alan Turing\");\nusersRef.child(\"alanisawesome\").child(\"birthYear\").setValue(1912);\n// 也可以在child()方法的参数中使用 '/' 分隔多个子节点路径。\nusersRef.child(\"gracehop/name\").setValue(\"Grace Hopper\");\nusersRef.child(\"gracehop/birthYear\").setValue(1906);\n\n```\n上面介绍的两种保存数据的方式，一种是使用Map将所有数据一次性保存到数据库，另一种是将数据分别保存到数据库的指定路径，最终的效果都是一样的：\n```json\n{\n  \"users\": {\n    \"alanisawesome\": {\n      \"birthYear\": \"1912\",\n      \"fullName\": \"Alan Turing\"\n    },\n    \"gracehop\": {\n      \"birthYear\": \"1906\",\n      \"fullName\": \"Grace Hopper\"\n    }\n  }\n}\n```\n我们也可以不使用 User 对象，而使用 Map 来实现与上面相同的功能：\n```java\nWilddog usersRef = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\");\n\nMap<String, String> alanisawesomeMap = new HashMap<String, String>();\nalanisawesomeMap.put(\"birthYear\", \"1912\");\nalanisawesomeMap.put(\"fullName\", \"Alan Turing\");\n\nMap<String, String> gracehopMap = new HashMap<String, String>();\ngracehopMap.put(\"birthYear\", \"1906\");\ngracehopMap.put(\"fullName\", \"Grace Hopper\");\n\nMap<String, Map<String, String>> users = new HashMap<String, Map<String, String>>();\nusers.put(\"alanisawesome\", alanisawesomeMap);\nusers.put(\"gracehop\", gracehopMap);\n\nusersRef.setValue(users);\n```\n野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后 SDK 去将数据与云端进行同步。\n也就是说，当 `setValue()` 方法执行完的时候，数据可能还没有同步到云端。\n若要确保同步到云端完成，需要使用 `setValue()` 方法的第二个参数，该参数是一个回调函数，代码示例如下：\n\n```java\nvar ref = new Wilddog(\"https://samplechat.wilddogio.com/android/saving-data\");\nref.child(\"setValue\").setValue(\"hello\", new Wilddog.CompletionListener() {\n  public void onComplete(WilddogError error, Wilddog ref) {\n    if (error == null) {\n      System.out.println(\"数据已成功保存到云端\");\n    }\n  }\n});\n```\n绝大多数操作都可设置回调函数来确保操作的完成，具体使用参见 [API文档](/api/sync/android.html)。\n\n## 更新数据\n\n如果只更新指定子节点，而不覆盖其它的子节点，可以使用 `updateChildren()` 方法:\n\n```java\n//原数据如下\n{\n    \"gracehop\": {\n        \"nickname\": \"Nice Grace\",\n        \"date_of_birth\": \"December 9, 1906\",\n        \"full_name \": \"Grace Lee\"\n    }\n}\n```\n```js\n// 只更新 gracehop 的 nickname\nWilddog hopperRef = usersRef.child(\"gracehop\");\nMap<String, Object> children = new HashMap<String, Object>();\nchildren.put(\"name\", \"Amazing grace\");\nhopperRef.updateChildren(children);\n```\n\n这样会更新 gracehop 的 nickname 字段。如果我们用 `setValue()` 而不是 `updateChildren()`，那么 date_of_birth 和 full_name 都会被删除。\n\n`updateChildren()` 也支持**多路径更新**，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:\n```json\n//原数据如下\n{\n    \"a\": {\n        \"b\": {\n            \"c\": \"cc\",\n            \"d\": \"dd\"\n        },\n        \"x\": {\n            \"y\": \"yy\",\n            \"z\": \"zz\"\n        }\n    }\n}\n```\n```java\n// 同时更新 b 节点下的 d，和 x 节点下的 z\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/a\");\nMap<String, Object> children = new HashMap<String, Object>();\n\nchildren.put(\"b/d\", \"vvv\");\nchildren.put(\"x/z\", \"vvv\");\n\nref.updateChildren(children);\n```\n可以看到，标识路径的时候，这里必须要用 `b/d`, 和 `x/z` ,而**不能**这样写：\n```java\n// 错误的多路径更新写法！！！\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/a\");\n\nMap<String, Object> children = new HashMap<String, Object>();\nMap<String, Object> children1 = new HashMap<String, Object>();\nMap<String, Object> children2 = new HashMap<String, Object>();\n\nchildren1.put(\"d\", \"vvv\");\nchildren2.put(\"z\", \"vvv\");\n\nchildren.put(\"b\", children1);\nchildren.put(\"x\", children2);\n\nref.updateChildren(children);\n```\n这样相当于 `setValue()` 操作，会把之前的数据覆盖掉。\n\n## 追加新节点\n\n当多个用户同时试图在同一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，Wilddog `push()` 采用了生成唯一ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面 push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后(可用来排序)，Wilddog 采用了足够多的位数保证唯一性。\n\n用户可以用 `push` 向[博客应用](https://docs-examples.wilddogio.com/android/saving-data/wildblog)中写新内容：\n\n```java\nWilddog ref = new Wilddog(\"https://docs-examples.wilddogio.com/android/saving-data/wildblog/posts\");\n\nWilddog newRef1 = ref.push();\nnewRef1.child(\"author\").setValue(\"gracehop\");\nnewRef1.child(\"title\").setValue(\"Announcing COBOL, a New Programming Language\");\n\nWilddog newRef2 = ref.push();\nnewRef2.child(\"author\").setValue(\"alanisawesome\");\nnewRef2.child(\"title\").setValue(\"The Turing Machine\");\n```\n\n产生的数据都有一个唯一ID,如下:\n```json\n{\n  \"posts\": {\n    \"-JRHTHaIs-jNPLXO\": {\n      \"author\": \"gracehop\",\n      \"title\": \"Announcing COBOL, a New Programming Language\"\n    },\n\n    \"-JRHTHaKuITFIhnj\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n```\n\n**获取唯一ID**\n调用 `push()` 会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 `getKey()` 来获取这个唯一ID\n\n```java\n// 通过push()来获得一个新的数据库地址\nWilddog newRef1 = ref.push();\n\n// 获取push()生成的唯一ID\nString postID = newRef1.getKey();\n```\n## 删除数据\n删除数据最简单的方法是在引用上对这些数据所处的位置调用 `removeValue()`,这会把该路径下的所有数据删除:\n```java\nWilddog ref = new Wilddog(\"https://<appId>.wilddogio.com/removeValue\");\n// 不带回调    \nref.removeValue();\n\n// 或带回调，效果同上。\nref.removeValue(new Wilddog.CompletionListener(){\n\n        public void onComplete(WilddogError error, Wilddog ref) {\n            if(error != null) {\n                System.out.println(error.getCode());\n            }\n            System.out.println(\"Remove Success!\");                \n        }\n    \n});\n```\n此外，还可以通过将 null 指定为另一个写入操作（例如，`setValue()` 或 `updateChildren()`）的值来删除数据。 您可以结合使用此方法与 `updateChildren()`，在单一 API 调用中来删除多个子节点。\n\n**注意**：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。\n\n## 事务操作\n处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。\n\n更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。\n\n举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：\n\n```java\nvar upvotesRef = new Wilddog('https://docs-examples.wilddogio.com/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes');\n\nupvotesRef.runTransaction(new Transaction.Handler() {\n    public Transaction.Result doTransaction(MutableData currentData) {\n        if(currentData.getValue() == null) {\n            currentData.setValue(1);\n        } else {\n            currentData.setValue((Long) currentData.getValue() + 1);\n        }\n\n        return Transaction.success(currentData); \n        // 也可以这样中止事务 Transaction.abort()\n    }\n    public void onComplete(WilddogError wilddogError, boolean committed, DataSnapshot currentData) {\n        // 事务完成后调用一次，获取事务完成的结果\n    }\n});\n```\n\n我们使用 `currentData.getValue() != null` 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。\n\n注意：doTransaction() 可能被多次被调用，必须处理currentData.getValue()为 null 的情况。当执行事务时，云端有数据存在，但是本地可能没有缓存，此时currentData.getValue()为 null。\n更多使用参见 [transaction()](/api/sync/android.html#runTransaction-Transaction-Handler)。\n\n\n","date":"2016-09-06T03:38:22.537Z","updated":"2016-09-06T03:38:22.537Z","path":"guide/sync/android/save-data.html","comments":1,"layout":"page","_id":"cisswi9lg001oz4fwsza82uxk","content":"<p>如果你刚接触 Wilddog，<strong>强烈建议</strong>先去阅读<a href=\"/quickstart/sync/android.html\">快速入门</a>，以对 Wilddog 的相关概念有个基本的了解。</p>\n<p>以下四种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setValue()</td>\n<td>将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>push()</td>\n<td>在当前路径下新增一个子节点, 并返回子节点的引用。这个子节点的 key 是利用服务端的当前时间生成的随机字符串, 与 setValue() 配合使用，用于将数据新增到此路径下。</td>\n</tr>\n<tr>\n<td>updateChildren()</td>\n<td>对子节点进行合并操作。不存在的子节点将会被新增，存在的子节点将会被替换。</td>\n</tr>\n<tr>\n<td>runTransaction()</td>\n<td>提供事务性更新，用于并发更新操作的场景。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h2><p><code>setValue()</code> 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。<br><code>setValue()</code> 可以传入几种数据类型 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>map</code>或满足 JavaBean 规范的实体做为参数。<br>为了更好地理解该方法，我们建立一个<a href=\"https://samplechat.wilddogio.com\" target=\"_blank\" rel=\"external\">示例应用</a>举例说明。我们打算将定义一个 User 对象保存在下面引用对应的路径中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data/wildblog\"</span>);</div></pre></td></tr></table></figure>\n<p>我们添加一些用户，为每个用户保存唯一的用户名，同时保存全名和出生日期。由于每个用户的用户名都是独一无二的，所以最好使用  <code>setValue()</code>方法，而不是 <code>push()</code> 方法，因为我们已经有了独一无二的用户名作为 key 值，不需要在添加的时候重新生成唯一标识。</p>\n<p>首先，我们编写 User 类代码，将 User 对象以用户名作为 key 值添加到 Map 中。然后，为用户数据所在路径创建引用，调用 <code>setValue()</code> 方法将 Map 中的每个用户添加到数据库中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> birthYear;</div><div class=\"line\">    <span class=\"keyword\">private</span> String fullName;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String fullName, <span class=\"keyword\">int</span> birthYear)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fullName = fullName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.birthYear = birthYear;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getBirthYear</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> birthYear;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFullName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fullName;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">User alanisawesome = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Alan Turing\"</span>, <span class=\"number\">1912</span>);</div><div class=\"line\">User gracehop = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Grace Hopper\"</span>, <span class=\"number\">1906</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, User&gt; users = <span class=\"keyword\">new</span> HashMap&lt;String, User&gt;();</div><div class=\"line\">users.put(<span class=\"string\">\"alanisawesome\"</span>, alanisawesome);</div><div class=\"line\">users.put(<span class=\"string\">\"gracehop\"</span>, gracehop);</div><div class=\"line\"></div><div class=\"line\">Wilddog usersRef = ref.child(<span class=\"string\">\"users\"</span>);</div><div class=\"line\"></div><div class=\"line\">usersRef.setValue(users);</div></pre></td></tr></table></figure>\n<p>我们可以向setValue()方法传入自定义的Java对象作为参数，但需要<strong>满足</strong>如下条件：</p>\n<ul>\n<li>对象所属的类中存在默认的构造方法;</li>\n<li>类中所有需要写入数据库的属性都有getter方法。</li>\n</ul>\n<p>我们使用 Map 将数据保存到数据库中，因为 Map 中的元素会自动映射成为 JSON 对象，并保存到指定路径。现在，我们再次访问示例应用的<a href=\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\" target=\"_blank\" rel=\"external\">数据预览</a>来预览数据，就可以看到上面示例代码中保存的数据。</p>\n<p>还有一种等价的操作方式，即直接保存数据到指定的路径，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog usersRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\"</span>);</div><div class=\"line\"><span class=\"comment\">// 使用父节点引用的child()方法，获得指向子数据节点的引用。</span></div><div class=\"line\">usersRef.child(<span class=\"string\">\"alanisawesome\"</span>).child(<span class=\"string\">\"fullName\"</span>).setValue(<span class=\"string\">\"Alan Turing\"</span>);</div><div class=\"line\">usersRef.child(<span class=\"string\">\"alanisawesome\"</span>).child(<span class=\"string\">\"birthYear\"</span>).setValue(<span class=\"number\">1912</span>);</div><div class=\"line\"><span class=\"comment\">// 也可以在child()方法的参数中使用 '/' 分隔多个子节点路径。</span></div><div class=\"line\">usersRef.child(<span class=\"string\">\"gracehop/name\"</span>).setValue(<span class=\"string\">\"Grace Hopper\"</span>);</div><div class=\"line\">usersRef.child(<span class=\"string\">\"gracehop/birthYear\"</span>).setValue(<span class=\"number\">1906</span>);</div></pre></td></tr></table></figure></p>\n<p>上面介绍的两种保存数据的方式，一种是使用Map将所有数据一次性保存到数据库，另一种是将数据分别保存到数据库的指定路径，最终的效果都是一样的：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"alanisawesome\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"birthYear\"</span>: <span class=\"string\">\"1912\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"fullName\"</span>: <span class=\"string\">\"Alan Turing\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"gracehop\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"birthYear\"</span>: <span class=\"string\">\"1906\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"fullName\"</span>: <span class=\"string\">\"Grace Hopper\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们也可以不使用 User 对象，而使用 Map 来实现与上面相同的功能：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog usersRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, String&gt; alanisawesomeMap = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">alanisawesomeMap.put(<span class=\"string\">\"birthYear\"</span>, <span class=\"string\">\"1912\"</span>);</div><div class=\"line\">alanisawesomeMap.put(<span class=\"string\">\"fullName\"</span>, <span class=\"string\">\"Alan Turing\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, String&gt; gracehopMap = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">gracehopMap.put(<span class=\"string\">\"birthYear\"</span>, <span class=\"string\">\"1906\"</span>);</div><div class=\"line\">gracehopMap.put(<span class=\"string\">\"fullName\"</span>, <span class=\"string\">\"Grace Hopper\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, Map&lt;String, String&gt;&gt; users = <span class=\"keyword\">new</span> HashMap&lt;String, Map&lt;String, String&gt;&gt;();</div><div class=\"line\">users.put(<span class=\"string\">\"alanisawesome\"</span>, alanisawesomeMap);</div><div class=\"line\">users.put(<span class=\"string\">\"gracehop\"</span>, gracehopMap);</div><div class=\"line\"></div><div class=\"line\">usersRef.setValue(users);</div></pre></td></tr></table></figure></p>\n<p>野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后 SDK 去将数据与云端进行同步。<br>也就是说，当 <code>setValue()</code> 方法执行完的时候，数据可能还没有同步到云端。<br>若要确保同步到云端完成，需要使用 <code>setValue()</code> 方法的第二个参数，该参数是一个回调函数，代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">var ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"setValue\"</span>).setValue(<span class=\"string\">\"hello\"</span>, <span class=\"keyword\">new</span> Wilddog.CompletionListener() &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      System.out.println(<span class=\"string\">\"数据已成功保存到云端\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>绝大多数操作都可设置回调函数来确保操作的完成，具体使用参见 <a href=\"/api/sync/android.html\">API文档</a>。</p>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>如果只更新指定子节点，而不覆盖其它的子节点，可以使用 <code>updateChildren()</code> 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原数据如下</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"gracehop\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"nickname\"</span>: <span class=\"string\">\"Nice Grace\"</span>,</div><div class=\"line\">        <span class=\"string\">\"date_of_birth\"</span>: <span class=\"string\">\"December 9, 1906\"</span>,</div><div class=\"line\">        <span class=\"string\">\"full_name \"</span>: <span class=\"string\">\"Grace Lee\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只更新 gracehop 的 nickname</span></div><div class=\"line\">Wilddog hopperRef = usersRef.child(<span class=\"string\">\"gracehop\"</span>);</div><div class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; children = <span class=\"keyword\">new</span> HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Amazing grace\"</span>);</div><div class=\"line\">hopperRef.updateChildren(children);</div></pre></td></tr></table></figure>\n<p>这样会更新 gracehop 的 nickname 字段。如果我们用 <code>setValue()</code> 而不是 <code>updateChildren()</code>，那么 date_of_birth 和 full_name 都会被删除。</p>\n<p><code>updateChildren()</code> 也支持<strong>多路径更新</strong>，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:<br><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//原数据如下</div><div class=\"line\">&#123;</div><div class=\"line\">    \"a\": &#123;</div><div class=\"line\">        \"b\": &#123;</div><div class=\"line\">            \"c\": \"cc\",</div><div class=\"line\">            \"d\": \"dd\"</div><div class=\"line\">        &#125;,</div><div class=\"line\">        \"x\": &#123;</div><div class=\"line\">            \"y\": \"yy\",</div><div class=\"line\">            \"z\": \"zz\"</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同时更新 b 节点下的 d，和 x 节点下的 z</span></div><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a\"</span>);</div><div class=\"line\">Map&lt;String, Object&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\"></div><div class=\"line\">children.put(<span class=\"string\">\"b/d\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\">children.put(<span class=\"string\">\"x/z\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.updateChildren(children);</div></pre></td></tr></table></figure>\n<p>可以看到，标识路径的时候，这里必须要用 <code>b/d</code>, 和 <code>x/z</code> ,而<strong>不能</strong>这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误的多路径更新写法！！！</span></div><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, Object&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">Map&lt;String, Object&gt; children1 = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">Map&lt;String, Object&gt; children2 = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\"></div><div class=\"line\">children1.put(<span class=\"string\">\"d\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\">children2.put(<span class=\"string\">\"z\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\"></div><div class=\"line\">children.put(<span class=\"string\">\"b\"</span>, children1);</div><div class=\"line\">children.put(<span class=\"string\">\"x\"</span>, children2);</div><div class=\"line\"></div><div class=\"line\">ref.updateChildren(children);</div></pre></td></tr></table></figure></p>\n<p>这样相当于 <code>setValue()</code> 操作，会把之前的数据覆盖掉。</p>\n<h2 id=\"追加新节点\"><a href=\"#追加新节点\" class=\"headerlink\" title=\"追加新节点\"></a>追加新节点</h2><p>当多个用户同时试图在同一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，Wilddog <code>push()</code> 采用了生成唯一ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面 push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后(可用来排序)，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>用户可以用 <code>push</code> 向<a href=\"https://docs-examples.wilddogio.com/android/saving-data/wildblog\" target=\"_blank\" rel=\"external\">博客应用</a>中写新内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/android/saving-data/wildblog/posts\"</span>);</div><div class=\"line\"></div><div class=\"line\">Wilddog newRef1 = ref.push();</div><div class=\"line\">newRef1.child(<span class=\"string\">\"author\"</span>).setValue(<span class=\"string\">\"gracehop\"</span>);</div><div class=\"line\">newRef1.child(<span class=\"string\">\"title\"</span>).setValue(<span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span>);</div><div class=\"line\"></div><div class=\"line\">Wilddog newRef2 = ref.push();</div><div class=\"line\">newRef2.child(<span class=\"string\">\"author\"</span>).setValue(<span class=\"string\">\"alanisawesome\"</span>);</div><div class=\"line\">newRef2.child(<span class=\"string\">\"title\"</span>).setValue(<span class=\"string\">\"The Turing Machine\"</span>);</div></pre></td></tr></table></figure>\n<p>产生的数据都有一个唯一ID,如下:<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"posts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaIs-jNPLXO\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaKuITFIhnj\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>获取唯一ID</strong><br>调用 <code>push()</code> 会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 <code>getKey()</code> 来获取这个唯一ID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 通过push()来获得一个新的数据库地址</span></div><div class=\"line\">Wilddog newRef1 = ref.push();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取push()生成的唯一ID</span></div><div class=\"line\">String postID = newRef1.getKey();</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除数据最简单的方法是在引用上对这些数据所处的位置调用 <code>removeValue()</code>,这会把该路径下的所有数据删除:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/removeValue\"</span>);</div><div class=\"line\"><span class=\"comment\">// 不带回调    </span></div><div class=\"line\">ref.removeValue();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或带回调，效果同上。</span></div><div class=\"line\">ref.removeValue(<span class=\"keyword\">new</span> Wilddog.CompletionListener()&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                System.out.println(error.getCode());</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"Remove Success!\"</span>);                </div><div class=\"line\">        &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>此外，还可以通过将 null 指定为另一个写入操作（例如，<code>setValue()</code> 或 <code>updateChildren()</code>）的值来删除数据。 您可以结合使用此方法与 <code>updateChildren()</code>，在单一 API 调用中来删除多个子节点。</p>\n<p><strong>注意</strong>：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。</p>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。</p>\n<p>更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。</p>\n<p>举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">var upvotesRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">'https://docs-examples.wilddogio.com/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes'</span>);</div><div class=\"line\"></div><div class=\"line\">upvotesRef.runTransaction(<span class=\"keyword\">new</span> Transaction.Handler() &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> Transaction.<span class=\"function\">Result <span class=\"title\">doTransaction</span><span class=\"params\">(MutableData currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(currentData.getValue() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            currentData.setValue(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            currentData.setValue((Long) currentData.getValue() + <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> Transaction.success(currentData); </div><div class=\"line\">        <span class=\"comment\">// 也可以这样中止事务 Transaction.abort()</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError wilddogError, <span class=\"keyword\">boolean</span> committed, DataSnapshot currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 事务完成后调用一次，获取事务完成的结果</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>我们使用 <code>currentData.getValue() != null</code> 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。</p>\n<p>注意：doTransaction() 可能被多次被调用，必须处理currentData.getValue()为 null 的情况。当执行事务时，云端有数据存在，但是本地可能没有缓存，此时currentData.getValue()为 null。<br>更多使用参见 <a href=\"/api/sync/android.html#runTransaction-Transaction-Handler\">transaction()</a>。</p>\n","excerpt":"","more":"<p>如果你刚接触 Wilddog，<strong>强烈建议</strong>先去阅读<a href=\"/quickstart/sync/android.html\">快速入门</a>，以对 Wilddog 的相关概念有个基本的了解。</p>\n<p>以下四种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setValue()</td>\n<td>将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>push()</td>\n<td>在当前路径下新增一个子节点, 并返回子节点的引用。这个子节点的 key 是利用服务端的当前时间生成的随机字符串, 与 setValue() 配合使用，用于将数据新增到此路径下。</td>\n</tr>\n<tr>\n<td>updateChildren()</td>\n<td>对子节点进行合并操作。不存在的子节点将会被新增，存在的子节点将会被替换。</td>\n</tr>\n<tr>\n<td>runTransaction()</td>\n<td>提供事务性更新，用于并发更新操作的场景。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h2><p><code>setValue()</code> 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。<br><code>setValue()</code> 可以传入几种数据类型 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>map</code>或满足 JavaBean 规范的实体做为参数。<br>为了更好地理解该方法，我们建立一个<a href=\"https://samplechat.wilddogio.com\">示例应用</a>举例说明。我们打算将定义一个 User 对象保存在下面引用对应的路径中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data/wildblog\"</span>);</div></pre></td></tr></table></figure>\n<p>我们添加一些用户，为每个用户保存唯一的用户名，同时保存全名和出生日期。由于每个用户的用户名都是独一无二的，所以最好使用  <code>setValue()</code>方法，而不是 <code>push()</code> 方法，因为我们已经有了独一无二的用户名作为 key 值，不需要在添加的时候重新生成唯一标识。</p>\n<p>首先，我们编写 User 类代码，将 User 对象以用户名作为 key 值添加到 Map 中。然后，为用户数据所在路径创建引用，调用 <code>setValue()</code> 方法将 Map 中的每个用户添加到数据库中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> birthYear;</div><div class=\"line\">    <span class=\"keyword\">private</span> String fullName;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String fullName, <span class=\"keyword\">int</span> birthYear)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fullName = fullName;</div><div class=\"line\">        <span class=\"keyword\">this</span>.birthYear = birthYear;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getBirthYear</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> birthYear;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFullName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fullName;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">User alanisawesome = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Alan Turing\"</span>, <span class=\"number\">1912</span>);</div><div class=\"line\">User gracehop = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Grace Hopper\"</span>, <span class=\"number\">1906</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, User&gt; users = <span class=\"keyword\">new</span> HashMap&lt;String, User&gt;();</div><div class=\"line\">users.put(<span class=\"string\">\"alanisawesome\"</span>, alanisawesome);</div><div class=\"line\">users.put(<span class=\"string\">\"gracehop\"</span>, gracehop);</div><div class=\"line\"></div><div class=\"line\">Wilddog usersRef = ref.child(<span class=\"string\">\"users\"</span>);</div><div class=\"line\"></div><div class=\"line\">usersRef.setValue(users);</div></pre></td></tr></table></figure>\n<p>我们可以向setValue()方法传入自定义的Java对象作为参数，但需要<strong>满足</strong>如下条件：</p>\n<ul>\n<li>对象所属的类中存在默认的构造方法;</li>\n<li>类中所有需要写入数据库的属性都有getter方法。</li>\n</ul>\n<p>我们使用 Map 将数据保存到数据库中，因为 Map 中的元素会自动映射成为 JSON 对象，并保存到指定路径。现在，我们再次访问示例应用的<a href=\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\">数据预览</a>来预览数据，就可以看到上面示例代码中保存的数据。</p>\n<p>还有一种等价的操作方式，即直接保存数据到指定的路径，如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog usersRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\"</span>);</div><div class=\"line\"><span class=\"comment\">// 使用父节点引用的child()方法，获得指向子数据节点的引用。</span></div><div class=\"line\">usersRef.child(<span class=\"string\">\"alanisawesome\"</span>).child(<span class=\"string\">\"fullName\"</span>).setValue(<span class=\"string\">\"Alan Turing\"</span>);</div><div class=\"line\">usersRef.child(<span class=\"string\">\"alanisawesome\"</span>).child(<span class=\"string\">\"birthYear\"</span>).setValue(<span class=\"number\">1912</span>);</div><div class=\"line\"><span class=\"comment\">// 也可以在child()方法的参数中使用 '/' 分隔多个子节点路径。</span></div><div class=\"line\">usersRef.child(<span class=\"string\">\"gracehop/name\"</span>).setValue(<span class=\"string\">\"Grace Hopper\"</span>);</div><div class=\"line\">usersRef.child(<span class=\"string\">\"gracehop/birthYear\"</span>).setValue(<span class=\"number\">1906</span>);</div></pre></td></tr></table></figure></p>\n<p>上面介绍的两种保存数据的方式，一种是使用Map将所有数据一次性保存到数据库，另一种是将数据分别保存到数据库的指定路径，最终的效果都是一样的：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"alanisawesome\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"birthYear\"</span>: <span class=\"string\">\"1912\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"fullName\"</span>: <span class=\"string\">\"Alan Turing\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"gracehop\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"birthYear\"</span>: <span class=\"string\">\"1906\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"fullName\"</span>: <span class=\"string\">\"Grace Hopper\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们也可以不使用 User 对象，而使用 Map 来实现与上面相同的功能：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog usersRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data/wildblog/users\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, String&gt; alanisawesomeMap = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">alanisawesomeMap.put(<span class=\"string\">\"birthYear\"</span>, <span class=\"string\">\"1912\"</span>);</div><div class=\"line\">alanisawesomeMap.put(<span class=\"string\">\"fullName\"</span>, <span class=\"string\">\"Alan Turing\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, String&gt; gracehopMap = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">gracehopMap.put(<span class=\"string\">\"birthYear\"</span>, <span class=\"string\">\"1906\"</span>);</div><div class=\"line\">gracehopMap.put(<span class=\"string\">\"fullName\"</span>, <span class=\"string\">\"Grace Hopper\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, Map&lt;String, String&gt;&gt; users = <span class=\"keyword\">new</span> HashMap&lt;String, Map&lt;String, String&gt;&gt;();</div><div class=\"line\">users.put(<span class=\"string\">\"alanisawesome\"</span>, alanisawesomeMap);</div><div class=\"line\">users.put(<span class=\"string\">\"gracehop\"</span>, gracehopMap);</div><div class=\"line\"></div><div class=\"line\">usersRef.setValue(users);</div></pre></td></tr></table></figure></p>\n<p>野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后 SDK 去将数据与云端进行同步。<br>也就是说，当 <code>setValue()</code> 方法执行完的时候，数据可能还没有同步到云端。<br>若要确保同步到云端完成，需要使用 <code>setValue()</code> 方法的第二个参数，该参数是一个回调函数，代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">var ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://samplechat.wilddogio.com/android/saving-data\"</span>);</div><div class=\"line\">ref.child(<span class=\"string\">\"setValue\"</span>).setValue(<span class=\"string\">\"hello\"</span>, <span class=\"keyword\">new</span> Wilddog.CompletionListener() &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      System.out.println(<span class=\"string\">\"数据已成功保存到云端\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>绝大多数操作都可设置回调函数来确保操作的完成，具体使用参见 <a href=\"/api/sync/android.html\">API文档</a>。</p>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>如果只更新指定子节点，而不覆盖其它的子节点，可以使用 <code>updateChildren()</code> 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原数据如下</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"gracehop\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"nickname\"</span>: <span class=\"string\">\"Nice Grace\"</span>,</div><div class=\"line\">        <span class=\"string\">\"date_of_birth\"</span>: <span class=\"string\">\"December 9, 1906\"</span>,</div><div class=\"line\">        <span class=\"string\">\"full_name \"</span>: <span class=\"string\">\"Grace Lee\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只更新 gracehop 的 nickname</span></div><div class=\"line\">Wilddog hopperRef = usersRef.child(<span class=\"string\">\"gracehop\"</span>);</div><div class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; children = <span class=\"keyword\">new</span> HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt;();</div><div class=\"line\">children.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Amazing grace\"</span>);</div><div class=\"line\">hopperRef.updateChildren(children);</div></pre></td></tr></table></figure>\n<p>这样会更新 gracehop 的 nickname 字段。如果我们用 <code>setValue()</code> 而不是 <code>updateChildren()</code>，那么 date_of_birth 和 full_name 都会被删除。</p>\n<p><code>updateChildren()</code> 也支持<strong>多路径更新</strong>，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:<br><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//原数据如下</div><div class=\"line\">&#123;</div><div class=\"line\">    \"a\": &#123;</div><div class=\"line\">        \"b\": &#123;</div><div class=\"line\">            \"c\": \"cc\",</div><div class=\"line\">            \"d\": \"dd\"</div><div class=\"line\">        &#125;,</div><div class=\"line\">        \"x\": &#123;</div><div class=\"line\">            \"y\": \"yy\",</div><div class=\"line\">            \"z\": \"zz\"</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 同时更新 b 节点下的 d，和 x 节点下的 z</span></div><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a\"</span>);</div><div class=\"line\">Map&lt;String, Object&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\"></div><div class=\"line\">children.put(<span class=\"string\">\"b/d\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\">children.put(<span class=\"string\">\"x/z\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.updateChildren(children);</div></pre></td></tr></table></figure>\n<p>可以看到，标识路径的时候，这里必须要用 <code>b/d</code>, 和 <code>x/z</code> ,而<strong>不能</strong>这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误的多路径更新写法！！！</span></div><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/a\"</span>);</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, Object&gt; children = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">Map&lt;String, Object&gt; children1 = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">Map&lt;String, Object&gt; children2 = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\"></div><div class=\"line\">children1.put(<span class=\"string\">\"d\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\">children2.put(<span class=\"string\">\"z\"</span>, <span class=\"string\">\"vvv\"</span>);</div><div class=\"line\"></div><div class=\"line\">children.put(<span class=\"string\">\"b\"</span>, children1);</div><div class=\"line\">children.put(<span class=\"string\">\"x\"</span>, children2);</div><div class=\"line\"></div><div class=\"line\">ref.updateChildren(children);</div></pre></td></tr></table></figure></p>\n<p>这样相当于 <code>setValue()</code> 操作，会把之前的数据覆盖掉。</p>\n<h2 id=\"追加新节点\"><a href=\"#追加新节点\" class=\"headerlink\" title=\"追加新节点\"></a>追加新节点</h2><p>当多个用户同时试图在同一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，Wilddog <code>push()</code> 采用了生成唯一ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面 push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后(可用来排序)，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>用户可以用 <code>push</code> 向<a href=\"https://docs-examples.wilddogio.com/android/saving-data/wildblog\">博客应用</a>中写新内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://docs-examples.wilddogio.com/android/saving-data/wildblog/posts\"</span>);</div><div class=\"line\"></div><div class=\"line\">Wilddog newRef1 = ref.push();</div><div class=\"line\">newRef1.child(<span class=\"string\">\"author\"</span>).setValue(<span class=\"string\">\"gracehop\"</span>);</div><div class=\"line\">newRef1.child(<span class=\"string\">\"title\"</span>).setValue(<span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span>);</div><div class=\"line\"></div><div class=\"line\">Wilddog newRef2 = ref.push();</div><div class=\"line\">newRef2.child(<span class=\"string\">\"author\"</span>).setValue(<span class=\"string\">\"alanisawesome\"</span>);</div><div class=\"line\">newRef2.child(<span class=\"string\">\"title\"</span>).setValue(<span class=\"string\">\"The Turing Machine\"</span>);</div></pre></td></tr></table></figure>\n<p>产生的数据都有一个唯一ID,如下:<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"posts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaIs-jNPLXO\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaKuITFIhnj\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>获取唯一ID</strong><br>调用 <code>push()</code> 会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 <code>getKey()</code> 来获取这个唯一ID</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 通过push()来获得一个新的数据库地址</span></div><div class=\"line\">Wilddog newRef1 = ref.push();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取push()生成的唯一ID</span></div><div class=\"line\">String postID = newRef1.getKey();</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除数据最简单的方法是在引用上对这些数据所处的位置调用 <code>removeValue()</code>,这会把该路径下的所有数据删除:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog ref = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com/removeValue\"</span>);</div><div class=\"line\"><span class=\"comment\">// 不带回调    </span></div><div class=\"line\">ref.removeValue();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或带回调，效果同上。</span></div><div class=\"line\">ref.removeValue(<span class=\"keyword\">new</span> Wilddog.CompletionListener()&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError error, Wilddog ref)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(error != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                System.out.println(error.getCode());</div><div class=\"line\">            &#125;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"Remove Success!\"</span>);                </div><div class=\"line\">        &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>此外，还可以通过将 null 指定为另一个写入操作（例如，<code>setValue()</code> 或 <code>updateChildren()</code>）的值来删除数据。 您可以结合使用此方法与 <code>updateChildren()</code>，在单一 API 调用中来删除多个子节点。</p>\n<p><strong>注意</strong>：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。</p>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。</p>\n<p>更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。</p>\n<p>举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">var upvotesRef = <span class=\"keyword\">new</span> Wilddog(<span class=\"string\">'https://docs-examples.wilddogio.com/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes'</span>);</div><div class=\"line\"></div><div class=\"line\">upvotesRef.runTransaction(<span class=\"keyword\">new</span> Transaction.Handler() &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> Transaction.<span class=\"function\">Result <span class=\"title\">doTransaction</span><span class=\"params\">(MutableData currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(currentData.getValue() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            currentData.setValue(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            currentData.setValue((Long) currentData.getValue() + <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> Transaction.success(currentData); </div><div class=\"line\">        <span class=\"comment\">// 也可以这样中止事务 Transaction.abort()</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onComplete</span><span class=\"params\">(WilddogError wilddogError, <span class=\"keyword\">boolean</span> committed, DataSnapshot currentData)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 事务完成后调用一次，获取事务完成的结果</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>我们使用 <code>currentData.getValue() != null</code> 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。</p>\n<p>注意：doTransaction() 可能被多次被调用，必须处理currentData.getValue()为 null 的情况。当执行事务时，云端有数据存在，但是本地可能没有缓存，此时currentData.getValue()为 null。<br>更多使用参见 <a href=\"/api/sync/android.html#runTransaction-Transaction-Handler\">transaction()</a>。</p>\n"},{"title":"组织数据","_content":"\nWilddog 云端数据库属于 [NoSQL](http://baike.baidu.com/view/2677528.htm) 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： \n\n\n```json\n{\n  \"users\": {\n    \"mchen\": {\n      \"friends\": { \"brinchen\": true },\n      \"name\": \"Mary Chen\",\n      \"widgets\": { \"one\": true, \"three\": true }\n    },\n    \"brinchen\": { ... },\n    \"hmadi\": { ... }\n  }\n}\n```\n\n构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。\n\n## 避免层级过深\n\n尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。\n\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n```json\n{\n  // 一个非常差的充满嵌套的数据结构。请勿模仿。\n    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\",\n        \"messages\": {\n          \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n          \"m2\": { ... },\n          // 非常长的messages列表\n        }\n      }\n    }\n}\n```\n\n对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。\n\n#### 使数据扁平化\n\n如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：\n\n\n```json\n{\n    // rooms数据节点下仅包含房间的基本信息和唯一ID。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\"\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    },\n\n    //room成员可以很方便的的存取\n    \"members\": {\n      \"one\": {\n        \"mchen\": true,\n        \"hmadi\": true\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n\n    },\n\n    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。\n  //消息数据可以通过room ID方便的分页和查询。\n    \"messages\": {\n      \"one\": {\n        \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n        \"m2\": { ... },\n        \"m3\": { ... }\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    }\n\n  }\n```\n\n这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。\n\n## 使数据可扩展\n很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：\n\n\n```json\n{\n    \"users\": {\n      \"john\": {\n         \"todoList\": {\n            \"rec1\": \"Walk the dog\",\n            \"rec2\": \"Buy milk\",\n            \"rec3\": \"Win a gold medal in the Olympics\"\n         }\n      }\n    }\n  }\n\n```\n\n但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。\n\n但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：\n\n\n```json\n{\n    \"users\": {\n      \"mchen\": { \"name\": \"Mary Chen\" },\n      \"brinchen\": { \"name\": \"Byambyn Rinchen\" },\n      \"hmadi\": { \"name\": \"Hamadi Madi\" }\n    },\n    \"groups\": {\n      \"alpha\": {\n         \"name\": \"Alpha Tango\",\n         \"members\": {\n            \"m1\": \"mchen\",\n            \"m2\": \"brinchen\",\n            \"m3\": \"hamadi\"\n         }\n      },\n      \"bravo\": { ... },\n      \"charlie\": { ... }\n    }\n  }\n```\n\n看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。\n\n我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：\n\n```json\n{\n    \"users\": {\n      \"mchen\": {\n        \"name\": \"Mary Chen\",\n        // 在Mary的数据下，建立他所属group的索引。\n        \"groups\": {\n           // 这里的值是什么并不重要。重要的是这个子节点的key存在。\n           \"alpha\": true,\n           \"charlie\": true\n        }\n      },\n      ...\n    },\n    \"groups\": { ... }\n  }\n```\n\n我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。\n\n对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。\n\n为什么我们把 id 作为 key，而把 value 设置为`true`呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取`/users/mchen/groups/$group_id`，看它是否为 null 就可以了。\n\n如果我们要判断 Mary 是否属于 alpha group，示例如下：\n\n```js\n// 判断Mary是否属于alpha group\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\nref.once('value', function(snap) {\n  var result = snap.val() === null? 'is not' : 'is';\n  console.log('Mary ' + result + ' a member of alpha group');\n});\n```\n","source":"guide/sync/bestpractice/structure-data.md","raw":"title:  组织数据\n---\n\nWilddog 云端数据库属于 [NoSQL](http://baike.baidu.com/view/2677528.htm) 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： \n\n\n```json\n{\n  \"users\": {\n    \"mchen\": {\n      \"friends\": { \"brinchen\": true },\n      \"name\": \"Mary Chen\",\n      \"widgets\": { \"one\": true, \"three\": true }\n    },\n    \"brinchen\": { ... },\n    \"hmadi\": { ... }\n  }\n}\n```\n\n构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。\n\n## 避免层级过深\n\n尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。\n\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n```json\n{\n  // 一个非常差的充满嵌套的数据结构。请勿模仿。\n    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\",\n        \"messages\": {\n          \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n          \"m2\": { ... },\n          // 非常长的messages列表\n        }\n      }\n    }\n}\n```\n\n对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。\n\n#### 使数据扁平化\n\n如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：\n\n\n```json\n{\n    // rooms数据节点下仅包含房间的基本信息和唯一ID。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\"\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    },\n\n    //room成员可以很方便的的存取\n    \"members\": {\n      \"one\": {\n        \"mchen\": true,\n        \"hmadi\": true\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n\n    },\n\n    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。\n  //消息数据可以通过room ID方便的分页和查询。\n    \"messages\": {\n      \"one\": {\n        \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n        \"m2\": { ... },\n        \"m3\": { ... }\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    }\n\n  }\n```\n\n这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。\n\n## 使数据可扩展\n很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：\n\n\n```json\n{\n    \"users\": {\n      \"john\": {\n         \"todoList\": {\n            \"rec1\": \"Walk the dog\",\n            \"rec2\": \"Buy milk\",\n            \"rec3\": \"Win a gold medal in the Olympics\"\n         }\n      }\n    }\n  }\n\n```\n\n但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。\n\n但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：\n\n\n```json\n{\n    \"users\": {\n      \"mchen\": { \"name\": \"Mary Chen\" },\n      \"brinchen\": { \"name\": \"Byambyn Rinchen\" },\n      \"hmadi\": { \"name\": \"Hamadi Madi\" }\n    },\n    \"groups\": {\n      \"alpha\": {\n         \"name\": \"Alpha Tango\",\n         \"members\": {\n            \"m1\": \"mchen\",\n            \"m2\": \"brinchen\",\n            \"m3\": \"hamadi\"\n         }\n      },\n      \"bravo\": { ... },\n      \"charlie\": { ... }\n    }\n  }\n```\n\n看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。\n\n我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：\n\n```json\n{\n    \"users\": {\n      \"mchen\": {\n        \"name\": \"Mary Chen\",\n        // 在Mary的数据下，建立他所属group的索引。\n        \"groups\": {\n           // 这里的值是什么并不重要。重要的是这个子节点的key存在。\n           \"alpha\": true,\n           \"charlie\": true\n        }\n      },\n      ...\n    },\n    \"groups\": { ... }\n  }\n```\n\n我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。\n\n对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。\n\n为什么我们把 id 作为 key，而把 value 设置为`true`呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取`/users/mchen/groups/$group_id`，看它是否为 null 就可以了。\n\n如果我们要判断 Mary 是否属于 alpha group，示例如下：\n\n```js\n// 判断Mary是否属于alpha group\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\nref.once('value', function(snap) {\n  var result = snap.val() === null? 'is not' : 'is';\n  console.log('Mary ' + result + ' a member of alpha group');\n});\n```\n","date":"2016-09-07T13:24:23.116Z","updated":"2016-09-07T13:24:23.116Z","path":"guide/sync/bestpractice/structure-data.html","_id":"cisswi9lg001pz4fw77ancbrl","comments":1,"layout":"page","content":"<p>Wilddog 云端数据库属于 <a href=\"http://baike.baidu.com/view/2677528.htm\" target=\"_blank\" rel=\"external\">NoSQL</a> 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： </p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"users\": &#123;</div><div class=\"line\">    \"mchen\": &#123;</div><div class=\"line\">      \"friends\": &#123; \"brinchen\": true &#125;,</div><div class=\"line\">      \"name\": \"Mary Chen\",</div><div class=\"line\">      \"widgets\": &#123; \"one\": true, \"three\": true &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"brinchen\": &#123; ... &#125;,</div><div class=\"line\">    \"hmadi\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。</p>\n<h2 id=\"避免层级过深\"><a href=\"#避免层级过深\" class=\"headerlink\" title=\"避免层级过深\"></a>避免层级过深</h2><p>尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。</p>\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  // 一个非常差的充满嵌套的数据结构。请勿模仿。</div><div class=\"line\">    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\",</div><div class=\"line\">        \"messages\": &#123;</div><div class=\"line\">          \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">          \"m2\": &#123; ... &#125;,</div><div class=\"line\">          // 非常长的messages列表</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。</p>\n<h4 id=\"使数据扁平化\"><a href=\"#使数据扁平化\" class=\"headerlink\" title=\"使数据扁平化\"></a>使数据扁平化</h4><p>如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    // rooms数据节点下仅包含房间的基本信息和唯一ID。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\"</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //room成员可以很方便的的存取</div><div class=\"line\">    \"members\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"mchen\": true,</div><div class=\"line\">        \"hmadi\": true</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。</div><div class=\"line\">  //消息数据可以通过room ID方便的分页和查询。</div><div class=\"line\">    \"messages\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">        \"m2\": &#123; ... &#125;,</div><div class=\"line\">        \"m3\": &#123; ... &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。</p>\n<h2 id=\"使数据可扩展\"><a href=\"#使数据可扩展\" class=\"headerlink\" title=\"使数据可扩展\"></a>使数据可扩展</h2><p>很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"john\"</span>: &#123;</div><div class=\"line\">         <span class=\"attr\">\"todoList\"</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">\"rec1\"</span>: <span class=\"string\">\"Walk the dog\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec2\"</span>: <span class=\"string\">\"Buy milk\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec3\"</span>: <span class=\"string\">\"Win a gold medal in the Olympics\"</span></div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。</p>\n<p>但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123; \"name\": \"Mary Chen\" &#125;,</div><div class=\"line\">      \"brinchen\": &#123; \"name\": \"Byambyn Rinchen\" &#125;,</div><div class=\"line\">      \"hmadi\": &#123; \"name\": \"Hamadi Madi\" &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123;</div><div class=\"line\">      \"alpha\": &#123;</div><div class=\"line\">         \"name\": \"Alpha Tango\",</div><div class=\"line\">         \"members\": &#123;</div><div class=\"line\">            \"m1\": \"mchen\",</div><div class=\"line\">            \"m2\": \"brinchen\",</div><div class=\"line\">            \"m3\": \"hamadi\"</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"bravo\": &#123; ... &#125;,</div><div class=\"line\">      \"charlie\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。</p>\n<p>我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123;</div><div class=\"line\">        \"name\": \"Mary Chen\",</div><div class=\"line\">        // 在Mary的数据下，建立他所属group的索引。</div><div class=\"line\">        \"groups\": &#123;</div><div class=\"line\">           // 这里的值是什么并不重要。重要的是这个子节点的key存在。</div><div class=\"line\">           \"alpha\": true,</div><div class=\"line\">           \"charlie\": true</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。</p>\n<p>对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。</p>\n<p>为什么我们把 id 作为 key，而把 value 设置为<code>true</code>呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取<code>/users/mchen/groups/$group_id</code>，看它是否为 null 就可以了。</p>\n<p>如果我们要判断 Mary 是否属于 alpha group，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 判断Mary是否属于alpha group</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\">ref.once(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = snap.val() === <span class=\"literal\">null</span>? <span class=\"string\">'is not'</span> : <span class=\"string\">'is'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Mary '</span> + result + <span class=\"string\">' a member of alpha group'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Wilddog 云端数据库属于 <a href=\"http://baike.baidu.com/view/2677528.htm\">NoSQL</a> 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： </p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"users\": &#123;</div><div class=\"line\">    \"mchen\": &#123;</div><div class=\"line\">      \"friends\": &#123; \"brinchen\": true &#125;,</div><div class=\"line\">      \"name\": \"Mary Chen\",</div><div class=\"line\">      \"widgets\": &#123; \"one\": true, \"three\": true &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"brinchen\": &#123; ... &#125;,</div><div class=\"line\">    \"hmadi\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。</p>\n<h2 id=\"避免层级过深\"><a href=\"#避免层级过深\" class=\"headerlink\" title=\"避免层级过深\"></a>避免层级过深</h2><p>尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。</p>\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  // 一个非常差的充满嵌套的数据结构。请勿模仿。</div><div class=\"line\">    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\",</div><div class=\"line\">        \"messages\": &#123;</div><div class=\"line\">          \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">          \"m2\": &#123; ... &#125;,</div><div class=\"line\">          // 非常长的messages列表</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。</p>\n<h4 id=\"使数据扁平化\"><a href=\"#使数据扁平化\" class=\"headerlink\" title=\"使数据扁平化\"></a>使数据扁平化</h4><p>如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    // rooms数据节点下仅包含房间的基本信息和唯一ID。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\"</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //room成员可以很方便的的存取</div><div class=\"line\">    \"members\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"mchen\": true,</div><div class=\"line\">        \"hmadi\": true</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。</div><div class=\"line\">  //消息数据可以通过room ID方便的分页和查询。</div><div class=\"line\">    \"messages\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">        \"m2\": &#123; ... &#125;,</div><div class=\"line\">        \"m3\": &#123; ... &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。</p>\n<h2 id=\"使数据可扩展\"><a href=\"#使数据可扩展\" class=\"headerlink\" title=\"使数据可扩展\"></a>使数据可扩展</h2><p>很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"john\"</span>: &#123;</div><div class=\"line\">         <span class=\"attr\">\"todoList\"</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">\"rec1\"</span>: <span class=\"string\">\"Walk the dog\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec2\"</span>: <span class=\"string\">\"Buy milk\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec3\"</span>: <span class=\"string\">\"Win a gold medal in the Olympics\"</span></div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。</p>\n<p>但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123; \"name\": \"Mary Chen\" &#125;,</div><div class=\"line\">      \"brinchen\": &#123; \"name\": \"Byambyn Rinchen\" &#125;,</div><div class=\"line\">      \"hmadi\": &#123; \"name\": \"Hamadi Madi\" &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123;</div><div class=\"line\">      \"alpha\": &#123;</div><div class=\"line\">         \"name\": \"Alpha Tango\",</div><div class=\"line\">         \"members\": &#123;</div><div class=\"line\">            \"m1\": \"mchen\",</div><div class=\"line\">            \"m2\": \"brinchen\",</div><div class=\"line\">            \"m3\": \"hamadi\"</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"bravo\": &#123; ... &#125;,</div><div class=\"line\">      \"charlie\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。</p>\n<p>我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123;</div><div class=\"line\">        \"name\": \"Mary Chen\",</div><div class=\"line\">        // 在Mary的数据下，建立他所属group的索引。</div><div class=\"line\">        \"groups\": &#123;</div><div class=\"line\">           // 这里的值是什么并不重要。重要的是这个子节点的key存在。</div><div class=\"line\">           \"alpha\": true,</div><div class=\"line\">           \"charlie\": true</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。</p>\n<p>对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。</p>\n<p>为什么我们把 id 作为 key，而把 value 设置为<code>true</code>呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取<code>/users/mchen/groups/$group_id</code>，看它是否为 null 就可以了。</p>\n<p>如果我们要判断 Mary 是否属于 alpha group，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 判断Mary是否属于alpha group</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\">ref.once(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = snap.val() === <span class=\"literal\">null</span>? <span class=\"string\">'is not'</span> : <span class=\"string\">'is'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Mary '</span> + result + <span class=\"string\">' a member of alpha group'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"配置和移植","_content":"## 配置 SDK\n\nSDK 包含条件编译选项和用户参数，可对 SDK 进行配置(Arduino SDK不支持配置)。\n\n#### 配置条件编译选项\n\nLinux 和 Espressif 平台的编译选项在 make 时指定， WICED 平台的编译选项在 project/wiced/wiced.mk 中，MICO 平台则在工程的配置中。\n\n|APP_SEC_TYPE | 加密方式，目前支持轻量级加密库 tinydtls、ARM 官方加密库 mbedtls 和无加密 nosec；\n\n   PORT_TYPE : 运行的平台，目前支持 Linux 和 Espressif；\n\nLinux 和 Espressif 平台在 make 时指定选项，进行不同的编译，如：\n\n    make APP_SEC_TYPE=nosec PORT_TYPE=linux\n\n在其他平台中，上面的宏在 Makefile 中指定。如 WICED 平台中，Wilddog SDK被嵌入WICED编译框架。因此条件编译选项在 SDK 目录下的`project/wiced/wiced.mk`中，配置项和 Linux 平台中相似，`PORT_TYPE`设置为`wiced`。\n\n#### 配置用户参数\n\n用户参数在SDK 的 include 目录下 wilddog_config.h 中，包含如下参数：\n\n`WILDDOG_LITTLE_ENDIAN` : 目标机字节序，如果为小端则该宏定义的值为1；\n\n`WILDDOG_MACHINE_BITS` : 目标机位数，可为8/16/32/64；\n\n`WILDDOG_PROTO_MAXSIZE` : 应用层协议数据包最大长度，其范围为0~1300；\n\n`WILDDOG_REQ_QUEUE_NUM` : 请求队列的长度；\n\n`WILDDOG_RETRANSMITE_TIME` : 单次请求超时时间，单位为ms，超过该值没有收到服务端回应则触发回调函数,并返回超时。返回码参见`Wilddog_Return_T`；\n\n`WILDDOG_RECEIVE_TIMEOUT` : 接收数据最大等待时间，单位为ms。\n\n<hr>\n\n## 移植 SDK\n\nC/嵌入式 SDK 可以很容易的被移植到各个平台上。本文档以 WICED 平台此为例，说明如何移植 SDK，其他已移植平台可以参考 SDK 的 docs 目录下对应的文档，未移植平台则可以参考下面步骤。\n\n#### 将SDK拷贝到目标位置\n\n首先，将SDK解压，并拷贝到`WICED-SDK-3.1.2\\WICED-SDK\\apps`中，即SDK位于`WICED-SDK-3.1.2\\WICED-SDK\\apps\\wilddog-client-c\\`，注意，由于 WICED 平台不支持带 `-` 符号的文件夹，因此需要将 SDK 目录名字修改，这里修改成`wilddog_client_coap`。\n\nWICED 平台采用 WICED IDE，打开 WICED IDE，能够在工程下的`apps`目录下找到我们的  SDK。\n\n![](/images/c_wiced-wilddog.png)\n\n#### 移植条件编译选项\n\nWICED 平台需要用户为自己的 APP 编写 Makefile，且格式有严格要求，Makefile文件名称的前缀必须与目录名相同，以我们的例子为例，如下图：\n\n![](/images/c_wiced-make.png)\n\n在`project/wiced/wiced.mk`中添加编译选项，并补完 Makefile，详见`wiced.mk`文件。\n\n注意：如果你的平台不支持自定义 Makefile，那么请根据条件编译选项，将你所需的文件拷贝到项目中，避免出现重定义。需要选择拷贝的路径有：\n\n`APP_PROTO_TYPE` : src/networking 目录下，根据编译选项拷贝文件夹以及其中的文件；\n\n`APP_SEC_TYPE` ： src/secure 目录下，根据编译选项拷贝文件夹以及其中的文件，同时，增加全局宏定义 WILDDOG_PORT ，根据选用的加密方式不同值不相同，nosec 时 WILDDOG\\_PORT值设为5683,否则设为 5684；\n\n`PORT_TYPE` ： platform 目录下，根据编译选项拷贝文件夹以及其中的文件，如果你的平台不属于`linux`或`wiced`等已支持平台，那么你需要自己实现平台相关的函数接口。\n\n#### 实现平台相关代码\n\n需要实现的平台相关函数接口位于include/wilddog_port.h，如下：\n```c\nint wilddog_gethostbyname(Wilddog_Address_T* addr,char* host);\n\nint wilddog_openSocket(int* socketId);\n\nint wilddog_closeSocket(int socketId);\n\nint wilddog_send(int socketId,Wilddog_Address_T*,void* tosend,s32 tosendLength);\n\nint wilddog_receive(int socketId,Wilddog_Address_T*,void* toreceive,s32 toreceiveLength, s32 timeout);\n```\n注意：tinydtls 以及 mbedtls 因为涉及底层，如果需要移植，可能要针对这两个库进行一些调试工作。\n\n","source":"guide/sync/c/config-and-porting.md","raw":"title:  配置和移植\n---\n## 配置 SDK\n\nSDK 包含条件编译选项和用户参数，可对 SDK 进行配置(Arduino SDK不支持配置)。\n\n#### 配置条件编译选项\n\nLinux 和 Espressif 平台的编译选项在 make 时指定， WICED 平台的编译选项在 project/wiced/wiced.mk 中，MICO 平台则在工程的配置中。\n\n|APP_SEC_TYPE | 加密方式，目前支持轻量级加密库 tinydtls、ARM 官方加密库 mbedtls 和无加密 nosec；\n\n   PORT_TYPE : 运行的平台，目前支持 Linux 和 Espressif；\n\nLinux 和 Espressif 平台在 make 时指定选项，进行不同的编译，如：\n\n    make APP_SEC_TYPE=nosec PORT_TYPE=linux\n\n在其他平台中，上面的宏在 Makefile 中指定。如 WICED 平台中，Wilddog SDK被嵌入WICED编译框架。因此条件编译选项在 SDK 目录下的`project/wiced/wiced.mk`中，配置项和 Linux 平台中相似，`PORT_TYPE`设置为`wiced`。\n\n#### 配置用户参数\n\n用户参数在SDK 的 include 目录下 wilddog_config.h 中，包含如下参数：\n\n`WILDDOG_LITTLE_ENDIAN` : 目标机字节序，如果为小端则该宏定义的值为1；\n\n`WILDDOG_MACHINE_BITS` : 目标机位数，可为8/16/32/64；\n\n`WILDDOG_PROTO_MAXSIZE` : 应用层协议数据包最大长度，其范围为0~1300；\n\n`WILDDOG_REQ_QUEUE_NUM` : 请求队列的长度；\n\n`WILDDOG_RETRANSMITE_TIME` : 单次请求超时时间，单位为ms，超过该值没有收到服务端回应则触发回调函数,并返回超时。返回码参见`Wilddog_Return_T`；\n\n`WILDDOG_RECEIVE_TIMEOUT` : 接收数据最大等待时间，单位为ms。\n\n<hr>\n\n## 移植 SDK\n\nC/嵌入式 SDK 可以很容易的被移植到各个平台上。本文档以 WICED 平台此为例，说明如何移植 SDK，其他已移植平台可以参考 SDK 的 docs 目录下对应的文档，未移植平台则可以参考下面步骤。\n\n#### 将SDK拷贝到目标位置\n\n首先，将SDK解压，并拷贝到`WICED-SDK-3.1.2\\WICED-SDK\\apps`中，即SDK位于`WICED-SDK-3.1.2\\WICED-SDK\\apps\\wilddog-client-c\\`，注意，由于 WICED 平台不支持带 `-` 符号的文件夹，因此需要将 SDK 目录名字修改，这里修改成`wilddog_client_coap`。\n\nWICED 平台采用 WICED IDE，打开 WICED IDE，能够在工程下的`apps`目录下找到我们的  SDK。\n\n![](/images/c_wiced-wilddog.png)\n\n#### 移植条件编译选项\n\nWICED 平台需要用户为自己的 APP 编写 Makefile，且格式有严格要求，Makefile文件名称的前缀必须与目录名相同，以我们的例子为例，如下图：\n\n![](/images/c_wiced-make.png)\n\n在`project/wiced/wiced.mk`中添加编译选项，并补完 Makefile，详见`wiced.mk`文件。\n\n注意：如果你的平台不支持自定义 Makefile，那么请根据条件编译选项，将你所需的文件拷贝到项目中，避免出现重定义。需要选择拷贝的路径有：\n\n`APP_PROTO_TYPE` : src/networking 目录下，根据编译选项拷贝文件夹以及其中的文件；\n\n`APP_SEC_TYPE` ： src/secure 目录下，根据编译选项拷贝文件夹以及其中的文件，同时，增加全局宏定义 WILDDOG_PORT ，根据选用的加密方式不同值不相同，nosec 时 WILDDOG\\_PORT值设为5683,否则设为 5684；\n\n`PORT_TYPE` ： platform 目录下，根据编译选项拷贝文件夹以及其中的文件，如果你的平台不属于`linux`或`wiced`等已支持平台，那么你需要自己实现平台相关的函数接口。\n\n#### 实现平台相关代码\n\n需要实现的平台相关函数接口位于include/wilddog_port.h，如下：\n```c\nint wilddog_gethostbyname(Wilddog_Address_T* addr,char* host);\n\nint wilddog_openSocket(int* socketId);\n\nint wilddog_closeSocket(int socketId);\n\nint wilddog_send(int socketId,Wilddog_Address_T*,void* tosend,s32 tosendLength);\n\nint wilddog_receive(int socketId,Wilddog_Address_T*,void* toreceive,s32 toreceiveLength, s32 timeout);\n```\n注意：tinydtls 以及 mbedtls 因为涉及底层，如果需要移植，可能要针对这两个库进行一些调试工作。\n\n","date":"2016-09-06T03:38:22.538Z","updated":"2016-09-06T03:38:22.538Z","path":"guide/sync/c/config-and-porting.html","comments":1,"layout":"page","_id":"cisswi9lg001qz4fwnnwotc57","content":"<h2 id=\"配置-SDK\"><a href=\"#配置-SDK\" class=\"headerlink\" title=\"配置 SDK\"></a>配置 SDK</h2><p>SDK 包含条件编译选项和用户参数，可对 SDK 进行配置(Arduino SDK不支持配置)。</p>\n<h4 id=\"配置条件编译选项\"><a href=\"#配置条件编译选项\" class=\"headerlink\" title=\"配置条件编译选项\"></a>配置条件编译选项</h4><p>Linux 和 Espressif 平台的编译选项在 make 时指定， WICED 平台的编译选项在 project/wiced/wiced.mk 中，MICO 平台则在工程的配置中。</p>\n<p>|APP_SEC_TYPE | 加密方式，目前支持轻量级加密库 tinydtls、ARM 官方加密库 mbedtls 和无加密 nosec；</p>\n<p>   PORT_TYPE : 运行的平台，目前支持 Linux 和 Espressif；</p>\n<p>Linux 和 Espressif 平台在 make 时指定选项，进行不同的编译，如：</p>\n<pre><code>make APP_SEC_TYPE=nosec PORT_TYPE=linux\n</code></pre><p>在其他平台中，上面的宏在 Makefile 中指定。如 WICED 平台中，Wilddog SDK被嵌入WICED编译框架。因此条件编译选项在 SDK 目录下的<code>project/wiced/wiced.mk</code>中，配置项和 Linux 平台中相似，<code>PORT_TYPE</code>设置为<code>wiced</code>。</p>\n<h4 id=\"配置用户参数\"><a href=\"#配置用户参数\" class=\"headerlink\" title=\"配置用户参数\"></a>配置用户参数</h4><p>用户参数在SDK 的 include 目录下 wilddog_config.h 中，包含如下参数：</p>\n<p><code>WILDDOG_LITTLE_ENDIAN</code> : 目标机字节序，如果为小端则该宏定义的值为1；</p>\n<p><code>WILDDOG_MACHINE_BITS</code> : 目标机位数，可为8/16/32/64；</p>\n<p><code>WILDDOG_PROTO_MAXSIZE</code> : 应用层协议数据包最大长度，其范围为0~1300；</p>\n<p><code>WILDDOG_REQ_QUEUE_NUM</code> : 请求队列的长度；</p>\n<p><code>WILDDOG_RETRANSMITE_TIME</code> : 单次请求超时时间，单位为ms，超过该值没有收到服务端回应则触发回调函数,并返回超时。返回码参见<code>Wilddog_Return_T</code>；</p>\n<p><code>WILDDOG_RECEIVE_TIMEOUT</code> : 接收数据最大等待时间，单位为ms。</p>\n<hr>\n\n<h2 id=\"移植-SDK\"><a href=\"#移植-SDK\" class=\"headerlink\" title=\"移植 SDK\"></a>移植 SDK</h2><p>C/嵌入式 SDK 可以很容易的被移植到各个平台上。本文档以 WICED 平台此为例，说明如何移植 SDK，其他已移植平台可以参考 SDK 的 docs 目录下对应的文档，未移植平台则可以参考下面步骤。</p>\n<h4 id=\"将SDK拷贝到目标位置\"><a href=\"#将SDK拷贝到目标位置\" class=\"headerlink\" title=\"将SDK拷贝到目标位置\"></a>将SDK拷贝到目标位置</h4><p>首先，将SDK解压，并拷贝到<code>WICED-SDK-3.1.2\\WICED-SDK\\apps</code>中，即SDK位于<code>WICED-SDK-3.1.2\\WICED-SDK\\apps\\wilddog-client-c\\</code>，注意，由于 WICED 平台不支持带 <code>-</code> 符号的文件夹，因此需要将 SDK 目录名字修改，这里修改成<code>wilddog_client_coap</code>。</p>\n<p>WICED 平台采用 WICED IDE，打开 WICED IDE，能够在工程下的<code>apps</code>目录下找到我们的  SDK。</p>\n<p><img src=\"/images/c_wiced-wilddog.png\" alt=\"\"></p>\n<h4 id=\"移植条件编译选项\"><a href=\"#移植条件编译选项\" class=\"headerlink\" title=\"移植条件编译选项\"></a>移植条件编译选项</h4><p>WICED 平台需要用户为自己的 APP 编写 Makefile，且格式有严格要求，Makefile文件名称的前缀必须与目录名相同，以我们的例子为例，如下图：</p>\n<p><img src=\"/images/c_wiced-make.png\" alt=\"\"></p>\n<p>在<code>project/wiced/wiced.mk</code>中添加编译选项，并补完 Makefile，详见<code>wiced.mk</code>文件。</p>\n<p>注意：如果你的平台不支持自定义 Makefile，那么请根据条件编译选项，将你所需的文件拷贝到项目中，避免出现重定义。需要选择拷贝的路径有：</p>\n<p><code>APP_PROTO_TYPE</code> : src/networking 目录下，根据编译选项拷贝文件夹以及其中的文件；</p>\n<p><code>APP_SEC_TYPE</code> ： src/secure 目录下，根据编译选项拷贝文件夹以及其中的文件，同时，增加全局宏定义 WILDDOG_PORT ，根据选用的加密方式不同值不相同，nosec 时 WILDDOG_PORT值设为5683,否则设为 5684；</p>\n<p><code>PORT_TYPE</code> ： platform 目录下，根据编译选项拷贝文件夹以及其中的文件，如果你的平台不属于<code>linux</code>或<code>wiced</code>等已支持平台，那么你需要自己实现平台相关的函数接口。</p>\n<h4 id=\"实现平台相关代码\"><a href=\"#实现平台相关代码\" class=\"headerlink\" title=\"实现平台相关代码\"></a>实现平台相关代码</h4><p>需要实现的平台相关函数接口位于include/wilddog_port.h，如下：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_gethostbyname</span><span class=\"params\">(Wilddog_Address_T* addr,<span class=\"keyword\">char</span>* host)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_openSocket</span><span class=\"params\">(<span class=\"keyword\">int</span>* socketId)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_closeSocket</span><span class=\"params\">(<span class=\"keyword\">int</span> socketId)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_send</span><span class=\"params\">(<span class=\"keyword\">int</span> socketId,Wilddog_Address_T*,<span class=\"keyword\">void</span>* tosend,s32 tosendLength)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_receive</span><span class=\"params\">(<span class=\"keyword\">int</span> socketId,Wilddog_Address_T*,<span class=\"keyword\">void</span>* toreceive,s32 toreceiveLength, s32 timeout)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>注意：tinydtls 以及 mbedtls 因为涉及底层，如果需要移植，可能要针对这两个库进行一些调试工作。</p>\n","excerpt":"","more":"<h2 id=\"配置-SDK\"><a href=\"#配置-SDK\" class=\"headerlink\" title=\"配置 SDK\"></a>配置 SDK</h2><p>SDK 包含条件编译选项和用户参数，可对 SDK 进行配置(Arduino SDK不支持配置)。</p>\n<h4 id=\"配置条件编译选项\"><a href=\"#配置条件编译选项\" class=\"headerlink\" title=\"配置条件编译选项\"></a>配置条件编译选项</h4><p>Linux 和 Espressif 平台的编译选项在 make 时指定， WICED 平台的编译选项在 project/wiced/wiced.mk 中，MICO 平台则在工程的配置中。</p>\n<p>|APP_SEC_TYPE | 加密方式，目前支持轻量级加密库 tinydtls、ARM 官方加密库 mbedtls 和无加密 nosec；</p>\n<p>   PORT_TYPE : 运行的平台，目前支持 Linux 和 Espressif；</p>\n<p>Linux 和 Espressif 平台在 make 时指定选项，进行不同的编译，如：</p>\n<pre><code>make APP_SEC_TYPE=nosec PORT_TYPE=linux\n</code></pre><p>在其他平台中，上面的宏在 Makefile 中指定。如 WICED 平台中，Wilddog SDK被嵌入WICED编译框架。因此条件编译选项在 SDK 目录下的<code>project/wiced/wiced.mk</code>中，配置项和 Linux 平台中相似，<code>PORT_TYPE</code>设置为<code>wiced</code>。</p>\n<h4 id=\"配置用户参数\"><a href=\"#配置用户参数\" class=\"headerlink\" title=\"配置用户参数\"></a>配置用户参数</h4><p>用户参数在SDK 的 include 目录下 wilddog_config.h 中，包含如下参数：</p>\n<p><code>WILDDOG_LITTLE_ENDIAN</code> : 目标机字节序，如果为小端则该宏定义的值为1；</p>\n<p><code>WILDDOG_MACHINE_BITS</code> : 目标机位数，可为8/16/32/64；</p>\n<p><code>WILDDOG_PROTO_MAXSIZE</code> : 应用层协议数据包最大长度，其范围为0~1300；</p>\n<p><code>WILDDOG_REQ_QUEUE_NUM</code> : 请求队列的长度；</p>\n<p><code>WILDDOG_RETRANSMITE_TIME</code> : 单次请求超时时间，单位为ms，超过该值没有收到服务端回应则触发回调函数,并返回超时。返回码参见<code>Wilddog_Return_T</code>；</p>\n<p><code>WILDDOG_RECEIVE_TIMEOUT</code> : 接收数据最大等待时间，单位为ms。</p>\n<hr>\n\n<h2 id=\"移植-SDK\"><a href=\"#移植-SDK\" class=\"headerlink\" title=\"移植 SDK\"></a>移植 SDK</h2><p>C/嵌入式 SDK 可以很容易的被移植到各个平台上。本文档以 WICED 平台此为例，说明如何移植 SDK，其他已移植平台可以参考 SDK 的 docs 目录下对应的文档，未移植平台则可以参考下面步骤。</p>\n<h4 id=\"将SDK拷贝到目标位置\"><a href=\"#将SDK拷贝到目标位置\" class=\"headerlink\" title=\"将SDK拷贝到目标位置\"></a>将SDK拷贝到目标位置</h4><p>首先，将SDK解压，并拷贝到<code>WICED-SDK-3.1.2\\WICED-SDK\\apps</code>中，即SDK位于<code>WICED-SDK-3.1.2\\WICED-SDK\\apps\\wilddog-client-c\\</code>，注意，由于 WICED 平台不支持带 <code>-</code> 符号的文件夹，因此需要将 SDK 目录名字修改，这里修改成<code>wilddog_client_coap</code>。</p>\n<p>WICED 平台采用 WICED IDE，打开 WICED IDE，能够在工程下的<code>apps</code>目录下找到我们的  SDK。</p>\n<p><img src=\"/images/c_wiced-wilddog.png\" alt=\"\"></p>\n<h4 id=\"移植条件编译选项\"><a href=\"#移植条件编译选项\" class=\"headerlink\" title=\"移植条件编译选项\"></a>移植条件编译选项</h4><p>WICED 平台需要用户为自己的 APP 编写 Makefile，且格式有严格要求，Makefile文件名称的前缀必须与目录名相同，以我们的例子为例，如下图：</p>\n<p><img src=\"/images/c_wiced-make.png\" alt=\"\"></p>\n<p>在<code>project/wiced/wiced.mk</code>中添加编译选项，并补完 Makefile，详见<code>wiced.mk</code>文件。</p>\n<p>注意：如果你的平台不支持自定义 Makefile，那么请根据条件编译选项，将你所需的文件拷贝到项目中，避免出现重定义。需要选择拷贝的路径有：</p>\n<p><code>APP_PROTO_TYPE</code> : src/networking 目录下，根据编译选项拷贝文件夹以及其中的文件；</p>\n<p><code>APP_SEC_TYPE</code> ： src/secure 目录下，根据编译选项拷贝文件夹以及其中的文件，同时，增加全局宏定义 WILDDOG_PORT ，根据选用的加密方式不同值不相同，nosec 时 WILDDOG_PORT值设为5683,否则设为 5684；</p>\n<p><code>PORT_TYPE</code> ： platform 目录下，根据编译选项拷贝文件夹以及其中的文件，如果你的平台不属于<code>linux</code>或<code>wiced</code>等已支持平台，那么你需要自己实现平台相关的函数接口。</p>\n<h4 id=\"实现平台相关代码\"><a href=\"#实现平台相关代码\" class=\"headerlink\" title=\"实现平台相关代码\"></a>实现平台相关代码</h4><p>需要实现的平台相关函数接口位于include/wilddog_port.h，如下：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_gethostbyname</span><span class=\"params\">(Wilddog_Address_T* addr,<span class=\"keyword\">char</span>* host)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_openSocket</span><span class=\"params\">(<span class=\"keyword\">int</span>* socketId)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_closeSocket</span><span class=\"params\">(<span class=\"keyword\">int</span> socketId)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_send</span><span class=\"params\">(<span class=\"keyword\">int</span> socketId,Wilddog_Address_T*,<span class=\"keyword\">void</span>* tosend,s32 tosendLength)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wilddog_receive</span><span class=\"params\">(<span class=\"keyword\">int</span> socketId,Wilddog_Address_T*,<span class=\"keyword\">void</span>* toreceive,s32 toreceiveLength, s32 timeout)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>注意：tinydtls 以及 mbedtls 因为涉及底层，如果需要移植，可能要针对这两个库进行一些调试工作。</p>\n"},{"title":"离线功能","_content":"C/嵌入式 SDK 内部实现了数据的重传和连接的维持，使得客户端即使在弱网情况下也能继续工作。此外还提供在线和离线状态事件的接口，使得 Wilddog 云端能监听客户端的在线和离线状态。\n\n## 连接的维持\n\nC/嵌入式 SDK 是基于 UDP 和 Wilddog 云端进行交互的，一旦调用`wilddog_initWithUrl()`初始化，SDK 就会和你的 url 建立起连接并在其后发送心跳包维持该连接。SDK 内部实现了当前网络环境的探测，当探测到网络环境变差时心跳包的发送频率会提高。与此同时产生的代价时，刚启动 SDK时，会有短暂时间出现推送有延迟的情况。\n\n网络环境的探测和心跳包的发送是在`wilddog_trySync()`中实现的，最好在程序空闲时频繁调用，如下：\n\n``` c\n    while(1){\n        wilddog_trySync();\n    }\n```\n\n## 离线事件\n\nWilddog 云端实时监听每个客户端的连接状态，一旦客户端断开连接，触发离线事件，对数据执行写入，删除等操作。这些操作由你在注册离线事件时指定，目前 C/嵌入式 SDK 提供离线事件的方法如下：\n\n方法 |  说明 \n---- | ------\nwilddog_onDisconnectSetValue()  | 当客户端离线时，对当前节点执行写操作。 \nwilddog_onDisconnectPush()  | 当客户端离线时，在当前节点下新增一个子节点，子节点的 key 由云端生成。\nwilddog_onDisconnectRemoveValue()   | 当客户端离线时，删除当前节点的数据。\nwilddog_cancelDisconnectOperations()  | 取消之前所设置的离线事件。\nwilddog_goOffline()   | 客户端设置为离线状态。\nwilddog_goOnline()  | 客户端连接云端。\n\n**注意：客户端若没有调用 wilddog_goOffline() ,直接关机或者断网，离线事件的触发有最多 3 分钟的延迟**\n\n以下是使用`wilddog_onDisconnectSetValue()`方法，在客户端离线时，云端把客户端的状态设置为离线：\n\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline set error!\");\n        return;\n    }\n    wilddog_debug(\"offline set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL;\n\n    /* create a node the value is offline  */\n    p_node = wilddog_node_createUString(NULL,\"offline\");\n\n    //<url>即希望设置数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(\"<url>\");\n\n    //注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查\n    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (void*)&isFinish);\n    wilddog_node_delete(p_node);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n","source":"guide/sync/c/offline-capabilities.md","raw":"title:  离线功能\n---\nC/嵌入式 SDK 内部实现了数据的重传和连接的维持，使得客户端即使在弱网情况下也能继续工作。此外还提供在线和离线状态事件的接口，使得 Wilddog 云端能监听客户端的在线和离线状态。\n\n## 连接的维持\n\nC/嵌入式 SDK 是基于 UDP 和 Wilddog 云端进行交互的，一旦调用`wilddog_initWithUrl()`初始化，SDK 就会和你的 url 建立起连接并在其后发送心跳包维持该连接。SDK 内部实现了当前网络环境的探测，当探测到网络环境变差时心跳包的发送频率会提高。与此同时产生的代价时，刚启动 SDK时，会有短暂时间出现推送有延迟的情况。\n\n网络环境的探测和心跳包的发送是在`wilddog_trySync()`中实现的，最好在程序空闲时频繁调用，如下：\n\n``` c\n    while(1){\n        wilddog_trySync();\n    }\n```\n\n## 离线事件\n\nWilddog 云端实时监听每个客户端的连接状态，一旦客户端断开连接，触发离线事件，对数据执行写入，删除等操作。这些操作由你在注册离线事件时指定，目前 C/嵌入式 SDK 提供离线事件的方法如下：\n\n方法 |  说明 \n---- | ------\nwilddog_onDisconnectSetValue()  | 当客户端离线时，对当前节点执行写操作。 \nwilddog_onDisconnectPush()  | 当客户端离线时，在当前节点下新增一个子节点，子节点的 key 由云端生成。\nwilddog_onDisconnectRemoveValue()   | 当客户端离线时，删除当前节点的数据。\nwilddog_cancelDisconnectOperations()  | 取消之前所设置的离线事件。\nwilddog_goOffline()   | 客户端设置为离线状态。\nwilddog_goOnline()  | 客户端连接云端。\n\n**注意：客户端若没有调用 wilddog_goOffline() ,直接关机或者断网，离线事件的触发有最多 3 分钟的延迟**\n\n以下是使用`wilddog_onDisconnectSetValue()`方法，在客户端离线时，云端把客户端的状态设置为离线：\n\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline set error!\");\n        return;\n    }\n    wilddog_debug(\"offline set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL;\n\n    /* create a node the value is offline  */\n    p_node = wilddog_node_createUString(NULL,\"offline\");\n\n    //<url>即希望设置数据的url，如coaps://<appid>.wilddogio.com/a/b/c\n    wilddog = wilddog_initWithUrl(\"<url>\");\n\n    //注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查\n    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (void*)&isFinish);\n    wilddog_node_delete(p_node);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n","date":"2016-09-06T03:38:22.539Z","updated":"2016-09-06T03:38:22.539Z","path":"guide/sync/c/offline-capabilities.html","comments":1,"layout":"page","_id":"cisswi9lg001rz4fwaruu2nh3","content":"<p>C/嵌入式 SDK 内部实现了数据的重传和连接的维持，使得客户端即使在弱网情况下也能继续工作。此外还提供在线和离线状态事件的接口，使得 Wilddog 云端能监听客户端的在线和离线状态。</p>\n<h2 id=\"连接的维持\"><a href=\"#连接的维持\" class=\"headerlink\" title=\"连接的维持\"></a>连接的维持</h2><p>C/嵌入式 SDK 是基于 UDP 和 Wilddog 云端进行交互的，一旦调用<code>wilddog_initWithUrl()</code>初始化，SDK 就会和你的 url 建立起连接并在其后发送心跳包维持该连接。SDK 内部实现了当前网络环境的探测，当探测到网络环境变差时心跳包的发送频率会提高。与此同时产生的代价时，刚启动 SDK时，会有短暂时间出现推送有延迟的情况。</p>\n<p>网络环境的探测和心跳包的发送是在<code>wilddog_trySync()</code>中实现的，最好在程序空闲时频繁调用，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">    wilddog_trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>Wilddog 云端实时监听每个客户端的连接状态，一旦客户端断开连接，触发离线事件，对数据执行写入，删除等操作。这些操作由你在注册离线事件时指定，目前 C/嵌入式 SDK 提供离线事件的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wilddog_onDisconnectSetValue()</td>\n<td>当客户端离线时，对当前节点执行写操作。 </td>\n</tr>\n<tr>\n<td>wilddog_onDisconnectPush()</td>\n<td>当客户端离线时，在当前节点下新增一个子节点，子节点的 key 由云端生成。</td>\n</tr>\n<tr>\n<td>wilddog_onDisconnectRemoveValue()</td>\n<td>当客户端离线时，删除当前节点的数据。</td>\n</tr>\n<tr>\n<td>wilddog_cancelDisconnectOperations()</td>\n<td>取消之前所设置的离线事件。</td>\n</tr>\n<tr>\n<td>wilddog_goOffline()</td>\n<td>客户端设置为离线状态。</td>\n</tr>\n<tr>\n<td>wilddog_goOnline()</td>\n<td>客户端连接云端。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：客户端若没有调用 wilddog_goOffline() ,直接关机或者断网，离线事件的触发有最多 3 分钟的延迟</strong></p>\n<p>以下是使用<code>wilddog_onDisconnectSetValue()</code>方法，在客户端离线时，云端把客户端的状态设置为离线：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node the value is offline  */</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"literal\">NULL</span>,<span class=\"string\">\"offline\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望设置数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"&lt;url&gt;\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_node);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>C/嵌入式 SDK 内部实现了数据的重传和连接的维持，使得客户端即使在弱网情况下也能继续工作。此外还提供在线和离线状态事件的接口，使得 Wilddog 云端能监听客户端的在线和离线状态。</p>\n<h2 id=\"连接的维持\"><a href=\"#连接的维持\" class=\"headerlink\" title=\"连接的维持\"></a>连接的维持</h2><p>C/嵌入式 SDK 是基于 UDP 和 Wilddog 云端进行交互的，一旦调用<code>wilddog_initWithUrl()</code>初始化，SDK 就会和你的 url 建立起连接并在其后发送心跳包维持该连接。SDK 内部实现了当前网络环境的探测，当探测到网络环境变差时心跳包的发送频率会提高。与此同时产生的代价时，刚启动 SDK时，会有短暂时间出现推送有延迟的情况。</p>\n<p>网络环境的探测和心跳包的发送是在<code>wilddog_trySync()</code>中实现的，最好在程序空闲时频繁调用，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">    wilddog_trySync();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>Wilddog 云端实时监听每个客户端的连接状态，一旦客户端断开连接，触发离线事件，对数据执行写入，删除等操作。这些操作由你在注册离线事件时指定，目前 C/嵌入式 SDK 提供离线事件的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wilddog_onDisconnectSetValue()</td>\n<td>当客户端离线时，对当前节点执行写操作。 </td>\n</tr>\n<tr>\n<td>wilddog_onDisconnectPush()</td>\n<td>当客户端离线时，在当前节点下新增一个子节点，子节点的 key 由云端生成。</td>\n</tr>\n<tr>\n<td>wilddog_onDisconnectRemoveValue()</td>\n<td>当客户端离线时，删除当前节点的数据。</td>\n</tr>\n<tr>\n<td>wilddog_cancelDisconnectOperations()</td>\n<td>取消之前所设置的离线事件。</td>\n</tr>\n<tr>\n<td>wilddog_goOffline()</td>\n<td>客户端设置为离线状态。</td>\n</tr>\n<tr>\n<td>wilddog_goOnline()</td>\n<td>客户端连接云端。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：客户端若没有调用 wilddog_goOffline() ,直接关机或者断网，离线事件的触发有最多 3 分钟的延迟</strong></p>\n<p>以下是使用<code>wilddog_onDisconnectSetValue()</code>方法，在客户端离线时，云端把客户端的状态设置为离线：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node the value is offline  */</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"literal\">NULL</span>,<span class=\"string\">\"offline\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//&lt;url&gt;即希望设置数据的url，如coaps://&lt;appid&gt;.wilddogio.com/a/b/c</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"&lt;url&gt;\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查</span></div><div class=\"line\">    wilddog_onDisconnectSetValue(wilddog, p_node, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_node);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"读取和查询数据","_content":"本部分将介绍如何读取数据以及如何监听数据。\n\n## 读取数据\n设备在读取控制指令，如开关机，可以调用`wilddog_getValue()` 从云端读取数据。\n\n调用`wilddog_getValue()`读取数据的代码如下：\n- 1. C / RTOS / OpenWRT SDK\n```c\nwilddog_getValue(ref, callback, NULL);\n```\n- 2. Arduino SDK\n```c\nref->getValue(callback, NULL);\n```\n\n## 监听的事件类型\n\n大部分情况下，我们需要对用户的操作进行及时的反馈，循环读取数据非常耗费流量，我们需要的是每当数据发生变动时设备能收到推送。Wilddog 采用事件机制来监听数据，C/嵌入式 SDK 目前只提供一种数据事件：`value`，该事件用来读取当前节点的静态数据快照，初次获取到数据时被触发一次，此后每当数据发生变化都会被触发。回调函数被执行时候，当前节点下所有数据的静态快照会被作为参数传入。调用`addObserver`操作，可以和云端同步数据。\n\n调用`addObserver`监听数据的代码如下：\n- 1. C / RTOS / OpenWRT SDK\n```c\nwilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, NULL);\n```\n- 2. Arduino SDK\n```c\nref->addObserver(WD_ET_VALUECHANGE, callback, NULL);\n```\n\n回调函数 callback 会在云端推送新数据或者出错后被调用，在回调函数中，根据返回码能够知道同步是否成功，同时，会将读取的数据镜像作为参数传递到回调函数中。\n\n#### 取消监听\n\n通过 removeObserver 方法可以取消一个事件回调函数的绑定：\n\n- 1. C / RTOS / OpenWRT SDK\n```c\nwilddog_removeObserver(ref, WD_ET_VALUECHANGE);\n```\n- 2. Arduino SDK\n```c\nref->removeObserver(WD_ET_VALUECHANGE);\n```\n","source":"guide/sync/c/retrieve-data.md","raw":"title:  读取和查询数据\n---\n本部分将介绍如何读取数据以及如何监听数据。\n\n## 读取数据\n设备在读取控制指令，如开关机，可以调用`wilddog_getValue()` 从云端读取数据。\n\n调用`wilddog_getValue()`读取数据的代码如下：\n- 1. C / RTOS / OpenWRT SDK\n```c\nwilddog_getValue(ref, callback, NULL);\n```\n- 2. Arduino SDK\n```c\nref->getValue(callback, NULL);\n```\n\n## 监听的事件类型\n\n大部分情况下，我们需要对用户的操作进行及时的反馈，循环读取数据非常耗费流量，我们需要的是每当数据发生变动时设备能收到推送。Wilddog 采用事件机制来监听数据，C/嵌入式 SDK 目前只提供一种数据事件：`value`，该事件用来读取当前节点的静态数据快照，初次获取到数据时被触发一次，此后每当数据发生变化都会被触发。回调函数被执行时候，当前节点下所有数据的静态快照会被作为参数传入。调用`addObserver`操作，可以和云端同步数据。\n\n调用`addObserver`监听数据的代码如下：\n- 1. C / RTOS / OpenWRT SDK\n```c\nwilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, NULL);\n```\n- 2. Arduino SDK\n```c\nref->addObserver(WD_ET_VALUECHANGE, callback, NULL);\n```\n\n回调函数 callback 会在云端推送新数据或者出错后被调用，在回调函数中，根据返回码能够知道同步是否成功，同时，会将读取的数据镜像作为参数传递到回调函数中。\n\n#### 取消监听\n\n通过 removeObserver 方法可以取消一个事件回调函数的绑定：\n\n- 1. C / RTOS / OpenWRT SDK\n```c\nwilddog_removeObserver(ref, WD_ET_VALUECHANGE);\n```\n- 2. Arduino SDK\n```c\nref->removeObserver(WD_ET_VALUECHANGE);\n```\n","date":"2016-09-06T03:38:22.539Z","updated":"2016-09-06T03:38:22.539Z","path":"guide/sync/c/retrieve-data.html","comments":1,"layout":"page","_id":"cisswi9lg001sz4fw2ezgzagb","content":"<p>本部分将介绍如何读取数据以及如何监听数据。</p>\n<h2 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h2><p>设备在读取控制指令，如开关机，可以调用<code>wilddog_getValue()</code> 从云端读取数据。</p>\n<p>调用<code>wilddog_getValue()</code>读取数据的代码如下：</p>\n<ul>\n<li><ol>\n<li>C / RTOS / OpenWRT SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_getValue(ref, callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>Arduino SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref-&gt;getValue(callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>大部分情况下，我们需要对用户的操作进行及时的反馈，循环读取数据非常耗费流量，我们需要的是每当数据发生变动时设备能收到推送。Wilddog 采用事件机制来监听数据，C/嵌入式 SDK 目前只提供一种数据事件：<code>value</code>，该事件用来读取当前节点的静态数据快照，初次获取到数据时被触发一次，此后每当数据发生变化都会被触发。回调函数被执行时候，当前节点下所有数据的静态快照会被作为参数传入。调用<code>addObserver</code>操作，可以和云端同步数据。</p>\n<p>调用<code>addObserver</code>监听数据的代码如下：</p>\n<ul>\n<li><ol>\n<li>C / RTOS / OpenWRT SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>Arduino SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref-&gt;addObserver(WD_ET_VALUECHANGE, callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<p>回调函数 callback 会在云端推送新数据或者出错后被调用，在回调函数中，根据返回码能够知道同步是否成功，同时，会将读取的数据镜像作为参数传递到回调函数中。</p>\n<h4 id=\"取消监听\"><a href=\"#取消监听\" class=\"headerlink\" title=\"取消监听\"></a>取消监听</h4><p>通过 removeObserver 方法可以取消一个事件回调函数的绑定：</p>\n<ul>\n<li><ol>\n<li>C / RTOS / OpenWRT SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_removeObserver(ref, WD_ET_VALUECHANGE);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>Arduino SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref-&gt;removeObserver(WD_ET_VALUECHANGE);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n","excerpt":"","more":"<p>本部分将介绍如何读取数据以及如何监听数据。</p>\n<h2 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h2><p>设备在读取控制指令，如开关机，可以调用<code>wilddog_getValue()</code> 从云端读取数据。</p>\n<p>调用<code>wilddog_getValue()</code>读取数据的代码如下：</p>\n<ul>\n<li><ol>\n<li>C / RTOS / OpenWRT SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_getValue(ref, callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>Arduino SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref-&gt;getValue(callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>大部分情况下，我们需要对用户的操作进行及时的反馈，循环读取数据非常耗费流量，我们需要的是每当数据发生变动时设备能收到推送。Wilddog 采用事件机制来监听数据，C/嵌入式 SDK 目前只提供一种数据事件：<code>value</code>，该事件用来读取当前节点的静态数据快照，初次获取到数据时被触发一次，此后每当数据发生变化都会被触发。回调函数被执行时候，当前节点下所有数据的静态快照会被作为参数传入。调用<code>addObserver</code>操作，可以和云端同步数据。</p>\n<p>调用<code>addObserver</code>监听数据的代码如下：</p>\n<ul>\n<li><ol>\n<li>C / RTOS / OpenWRT SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_addObserver(ref, WD_ET_VALUECHANGE, callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>Arduino SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref-&gt;addObserver(WD_ET_VALUECHANGE, callback, <span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<p>回调函数 callback 会在云端推送新数据或者出错后被调用，在回调函数中，根据返回码能够知道同步是否成功，同时，会将读取的数据镜像作为参数传递到回调函数中。</p>\n<h4 id=\"取消监听\"><a href=\"#取消监听\" class=\"headerlink\" title=\"取消监听\"></a>取消监听</h4><p>通过 removeObserver 方法可以取消一个事件回调函数的绑定：</p>\n<ul>\n<li><ol>\n<li>C / RTOS / OpenWRT SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_removeObserver(ref, WD_ET_VALUECHANGE);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><ol>\n<li>Arduino SDK<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref-&gt;removeObserver(WD_ET_VALUECHANGE);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n"},{"title":"保存数据","_content":"\n以下两种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nwilddog_setValue() | 将数据写入当前节点，如果指节点已存在数据，那么数据将会被覆盖。 \nwilddog_push() | 添加数据到列表。向当前节点下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。\n \n\n## 用 wilddog_setValue() 写入数据\n\n\n`wilddog_setValue()`是最基本的写数据操作，它会立即将数据写入当前引用指向的节点，你可以在回调函数中检测是否修改成功。该节点下任何原有数据都将被删除和覆盖，包括其子节点的数据。\n例如，为房间利用`wilddog_setValue()`修改 led 状态信息，如下所示：\n\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline set error!\");\n        return;\n    }\n    wilddog_debug(\"offline set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T *p_head= NULL,*p_node = NULL;\n\n    /* create a node to \"wilddog\", led = on */\n    p_head = wilddog_node_createObject(NULL);\n    p_node = wilddog_node_createUString(\"led\",\"on\");\n    wilddog_node_addChild(p_head, p_node);\n    //<appid>即你应用的 appid\n    wilddog = wilddog_initWithUrl(\"coaps://<appid>.wilddogio.com/room\");\n\n    //注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查\n    wilddog_setValue(wilddog, p_head, onSetCallback, (void*)&isFinish);\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## 使用 wilddog_push() 追加新节点\n\n当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，`wilddog_push()`采用了生成唯一 ID 作为`key`的方式。通过这种方式，多个用户同时在一个节点下面`push`数据，他们的 key 一定是不同的。这个`key`是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。\n\n用户可以用`wilddog_push()`向`message`节点写新内容：\n```c\nSTATIC void onPushCallback(u8 *p_path,void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"push failed\");\n        return;\n    }\n    wilddog_debug(\"new path is %s\", p_path);\n    *(BOOL*)arg = TRUE;\n    return;\n}\n\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL, *p_head = NULL;\n\n    //建立一个object节点，即类似json中的{}\n    p_head = wilddog_node_createObject(NULL);\n\n    //建立一个key为2，value为数字1234的节点\n    p_node = wilddog_node_createUString(\"message\",\"something happen\");\n\n    //将节点p_node添加到object中\n    wilddog_node_addChild(p_head, p_node);\n    \n    //<appid>即你应用的appid\n    wilddog = wilddog_initWithUrl(\"coaps://<appid>.wilddogio.com/room\");\n\n    //把新的object推送到云端\n    //注意，这里省略了对wilddog_push返回值的检查\n    wilddog_push(wilddog, p_head, onPushCallback, (void *)&isFinish);\n\n    //数据已经推送，删除刚才建立的节点\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(isFinish){\n            wilddog_debug(\"push success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n**获取唯一ID**\n新增数据对应的`key`既为`wilddog_push()`所注册的回调函数中的第一个入参`p_path`，\n\n```c\n// 在回调中获取新增数据对应的 key\nSTATIC void onPushCallback(u8 *p_path,void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"push failed\");\n        return;\n    }\n    wilddog_debug(\"new key is %s\", p_path);\n    *(BOOL*)arg = TRUE;\n    return;\n}\n\n```\n## 删除数据\n删除引用所指向节点的所有数据通过调用`wilddog_removeValue()`实现，同时必须注册一个回调函数以判断删除操作是否成功。\n以下例子删除`/room/`节点下的所有数据，并在`onDeleteCallback()`中判断删除操作是否成功。\n\n```c\nSTATIC void onDeleteCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"delete failed!\");\n        return;\n    }\n    wilddog_debug(\"delete success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog;\n    //<appId> 为你自己的appId\n    wilddog = wilddog_initWithUrl(\"coaps://<appid>.wilddogio.com/room\");\n\n    //注意，这里省略了对wilddog_removeValue返回值的检查\n    wilddog_removeValue(wilddog, onDeleteCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"remove success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n","source":"guide/sync/c/save-data.md","raw":"title:  保存数据\n---\n\n以下两种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nwilddog_setValue() | 将数据写入当前节点，如果指节点已存在数据，那么数据将会被覆盖。 \nwilddog_push() | 添加数据到列表。向当前节点下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。\n \n\n## 用 wilddog_setValue() 写入数据\n\n\n`wilddog_setValue()`是最基本的写数据操作，它会立即将数据写入当前引用指向的节点，你可以在回调函数中检测是否修改成功。该节点下任何原有数据都将被删除和覆盖，包括其子节点的数据。\n例如，为房间利用`wilddog_setValue()`修改 led 状态信息，如下所示：\n\n```c\nSTATIC void onSetCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"offline set error!\");\n        return;\n    }\n    wilddog_debug(\"offline set success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T *p_head= NULL,*p_node = NULL;\n\n    /* create a node to \"wilddog\", led = on */\n    p_head = wilddog_node_createObject(NULL);\n    p_node = wilddog_node_createUString(\"led\",\"on\");\n    wilddog_node_addChild(p_head, p_node);\n    //<appid>即你应用的 appid\n    wilddog = wilddog_initWithUrl(\"coaps://<appid>.wilddogio.com/room\");\n\n    //注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查\n    wilddog_setValue(wilddog, p_head, onSetCallback, (void*)&isFinish);\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(TRUE == isFinish){\n            wilddog_debug(\"set success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n## 使用 wilddog_push() 追加新节点\n\n当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，`wilddog_push()`采用了生成唯一 ID 作为`key`的方式。通过这种方式，多个用户同时在一个节点下面`push`数据，他们的 key 一定是不同的。这个`key`是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。\n\n用户可以用`wilddog_push()`向`message`节点写新内容：\n```c\nSTATIC void onPushCallback(u8 *p_path,void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"push failed\");\n        return;\n    }\n    wilddog_debug(\"new path is %s\", p_path);\n    *(BOOL*)arg = TRUE;\n    return;\n}\n\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinish = FALSE;\n    Wilddog_T wilddog = 0;\n    Wilddog_Node_T * p_node = NULL, *p_head = NULL;\n\n    //建立一个object节点，即类似json中的{}\n    p_head = wilddog_node_createObject(NULL);\n\n    //建立一个key为2，value为数字1234的节点\n    p_node = wilddog_node_createUString(\"message\",\"something happen\");\n\n    //将节点p_node添加到object中\n    wilddog_node_addChild(p_head, p_node);\n    \n    //<appid>即你应用的appid\n    wilddog = wilddog_initWithUrl(\"coaps://<appid>.wilddogio.com/room\");\n\n    //把新的object推送到云端\n    //注意，这里省略了对wilddog_push返回值的检查\n    wilddog_push(wilddog, p_head, onPushCallback, (void *)&isFinish);\n\n    //数据已经推送，删除刚才建立的节点\n    wilddog_node_delete(p_head);\n\n    while(1){\n        if(isFinish){\n            wilddog_debug(\"push success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n\n**获取唯一ID**\n新增数据对应的`key`既为`wilddog_push()`所注册的回调函数中的第一个入参`p_path`，\n\n```c\n// 在回调中获取新增数据对应的 key\nSTATIC void onPushCallback(u8 *p_path,void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"push failed\");\n        return;\n    }\n    wilddog_debug(\"new key is %s\", p_path);\n    *(BOOL*)arg = TRUE;\n    return;\n}\n\n```\n## 删除数据\n删除引用所指向节点的所有数据通过调用`wilddog_removeValue()`实现，同时必须注册一个回调函数以判断删除操作是否成功。\n以下例子删除`/room/`节点下的所有数据，并在`onDeleteCallback()`中判断删除操作是否成功。\n\n```c\nSTATIC void onDeleteCallback(void* arg, Wilddog_Return_T err){\n    if(err < WILDDOG_HTTP_OK || err >= WILDDOG_HTTP_NOT_MODIFIED){\n        wilddog_debug(\"delete failed!\");\n        return;\n    }\n    wilddog_debug(\"delete success!\");\n    *(BOOL*)arg = TRUE;\n    return;\n}\nint main(void){\n    //用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE\n    //因此可以在main函数中得知是否成功\n    BOOL isFinished = FALSE;\n    Wilddog_T wilddog;\n    //<appId> 为你自己的appId\n    wilddog = wilddog_initWithUrl(\"coaps://<appid>.wilddogio.com/room\");\n\n    //注意，这里省略了对wilddog_removeValue返回值的检查\n    wilddog_removeValue(wilddog, onDeleteCallback, (void*)&isFinished);\n\n    while(1){\n        if(TRUE == isFinished){\n            wilddog_debug(\"remove success!\");\n            break;\n        }\n        wilddog_trySync();\n    }\n    wilddog_destroy(&wilddog);\n}\n```\n----\n","date":"2016-09-06T03:38:22.540Z","updated":"2016-09-06T03:38:22.540Z","path":"guide/sync/c/save-data.html","comments":1,"layout":"page","_id":"cisswi9lg001tz4fwkgy1gs6l","content":"<p>以下两种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wilddog_setValue()</td>\n<td>将数据写入当前节点，如果指节点已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>wilddog_push()</td>\n<td>添加数据到列表。向当前节点下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。</unique-post-id></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用-wilddog-setValue-写入数据\"><a href=\"#用-wilddog-setValue-写入数据\" class=\"headerlink\" title=\"用 wilddog_setValue() 写入数据\"></a>用 wilddog_setValue() 写入数据</h2><p><code>wilddog_setValue()</code>是最基本的写数据操作，它会立即将数据写入当前引用指向的节点，你可以在回调函数中检测是否修改成功。该节点下任何原有数据都将被删除和覆盖，包括其子节点的数据。<br>例如，为房间利用<code>wilddog_setValue()</code>修改 led 状态信息，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T *p_head= <span class=\"literal\">NULL</span>,*p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node to \"wilddog\", led = on */</span></div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"string\">\"led\"</span>,<span class=\"string\">\"on\"</span>);</div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    <span class=\"comment\">//&lt;appid&gt;即你应用的 appid</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appid&gt;.wilddogio.com/room\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查</span></div><div class=\"line\">    wilddog_setValue(wilddog, p_head, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"使用-wilddog-push-追加新节点\"><a href=\"#使用-wilddog-push-追加新节点\" class=\"headerlink\" title=\"使用 wilddog_push() 追加新节点\"></a>使用 wilddog_push() 追加新节点</h2><p>当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，<code>wilddog_push()</code>采用了生成唯一 ID 作为<code>key</code>的方式。通过这种方式，多个用户同时在一个节点下面<code>push</code>数据，他们的 key 一定是不同的。这个<code>key</code>是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>用户可以用<code>wilddog_push()</code>向<code>message</code>节点写新内容：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(u8 *p_path,<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"new path is %s\"</span>, p_path);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>, *p_head = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个object节点，即类似json中的&#123;&#125;</span></div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个key为2，value为数字1234的节点</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"string\">\"message\"</span>,<span class=\"string\">\"something happen\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将节点p_node添加到object中</span></div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//&lt;appid&gt;即你应用的appid</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appid&gt;.wilddogio.com/room\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//把新的object推送到云端</span></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_push返回值的检查</span></div><div class=\"line\">    wilddog_push(wilddog, p_head, onPushCallback, (<span class=\"keyword\">void</span> *)&amp;isFinish);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据已经推送，删除刚才建立的节点</span></div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"push success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>获取唯一ID</strong><br>新增数据对应的<code>key</code>既为<code>wilddog_push()</code>所注册的回调函数中的第一个入参<code>p_path</code>，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在回调中获取新增数据对应的 key</span></div><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(u8 *p_path,<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"new key is %s\"</span>, p_path);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除引用所指向节点的所有数据通过调用<code>wilddog_removeValue()</code>实现，同时必须注册一个回调函数以判断删除操作是否成功。<br>以下例子删除<code>/room/</code>节点下的所有数据，并在<code>onDeleteCallback()</code>中判断删除操作是否成功。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"delete failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"delete success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog;</div><div class=\"line\">    <span class=\"comment\">//&lt;appId&gt; 为你自己的appId</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appid&gt;.wilddogio.com/room\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_removeValue返回值的检查</span></div><div class=\"line\">    wilddog_removeValue(wilddog, onDeleteCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"remove success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n","excerpt":"","more":"<p>以下两种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>wilddog_setValue()</td>\n<td>将数据写入当前节点，如果指节点已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>wilddog_push()</td>\n<td>添加数据到列表。向当前节点下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用-wilddog-setValue-写入数据\"><a href=\"#用-wilddog-setValue-写入数据\" class=\"headerlink\" title=\"用 wilddog_setValue() 写入数据\"></a>用 wilddog_setValue() 写入数据</h2><p><code>wilddog_setValue()</code>是最基本的写数据操作，它会立即将数据写入当前引用指向的节点，你可以在回调函数中检测是否修改成功。该节点下任何原有数据都将被删除和覆盖，包括其子节点的数据。<br>例如，为房间利用<code>wilddog_setValue()</code>修改 led 状态信息，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onSetCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"offline set error!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"offline set success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T *p_head= <span class=\"literal\">NULL</span>,*p_node = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/* create a node to \"wilddog\", led = on */</span></div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"string\">\"led\"</span>,<span class=\"string\">\"on\"</span>);</div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    <span class=\"comment\">//&lt;appid&gt;即你应用的 appid</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appid&gt;.wilddogio.com/room\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_onDisconnectSetValue返回值的检查</span></div><div class=\"line\">    wilddog_setValue(wilddog, p_head, onSetCallback, (<span class=\"keyword\">void</span>*)&amp;isFinish);</div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"set success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"使用-wilddog-push-追加新节点\"><a href=\"#使用-wilddog-push-追加新节点\" class=\"headerlink\" title=\"使用 wilddog_push() 追加新节点\"></a>使用 wilddog_push() 追加新节点</h2><p>当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，<code>wilddog_push()</code>采用了生成唯一 ID 作为<code>key</code>的方式。通过这种方式，多个用户同时在一个节点下面<code>push</code>数据，他们的 key 一定是不同的。这个<code>key</code>是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>用户可以用<code>wilddog_push()</code>向<code>message</code>节点写新内容：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(u8 *p_path,<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"new path is %s\"</span>, p_path);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinish = FALSE;</div><div class=\"line\">    Wilddog_T wilddog = <span class=\"number\">0</span>;</div><div class=\"line\">    Wilddog_Node_T * p_node = <span class=\"literal\">NULL</span>, *p_head = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个object节点，即类似json中的&#123;&#125;</span></div><div class=\"line\">    p_head = wilddog_node_createObject(<span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//建立一个key为2，value为数字1234的节点</span></div><div class=\"line\">    p_node = wilddog_node_createUString(<span class=\"string\">\"message\"</span>,<span class=\"string\">\"something happen\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将节点p_node添加到object中</span></div><div class=\"line\">    wilddog_node_addChild(p_head, p_node);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//&lt;appid&gt;即你应用的appid</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appid&gt;.wilddogio.com/room\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//把新的object推送到云端</span></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_push返回值的检查</span></div><div class=\"line\">    wilddog_push(wilddog, p_head, onPushCallback, (<span class=\"keyword\">void</span> *)&amp;isFinish);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//数据已经推送，删除刚才建立的节点</span></div><div class=\"line\">    wilddog_node_delete(p_head);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(isFinish)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"push success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>获取唯一ID</strong><br>新增数据对应的<code>key</code>既为<code>wilddog_push()</code>所注册的回调函数中的第一个入参<code>p_path</code>，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在回调中获取新增数据对应的 key</span></div><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onPushCallback</span><span class=\"params\">(u8 *p_path,<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"push failed\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"new key is %s\"</span>, p_path);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除引用所指向节点的所有数据通过调用<code>wilddog_removeValue()</code>实现，同时必须注册一个回调函数以判断删除操作是否成功。<br>以下例子删除<code>/room/</code>节点下的所有数据，并在<code>onDeleteCallback()</code>中判断删除操作是否成功。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">STATIC <span class=\"keyword\">void</span> <span class=\"title\">onDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">void</span>* arg, Wilddog_Return_T err)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err &lt; WILDDOG_HTTP_OK || err &gt;= WILDDOG_HTTP_NOT_MODIFIED)&#123;</div><div class=\"line\">        wilddog_debug(<span class=\"string\">\"delete failed!\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_debug(<span class=\"string\">\"delete success!\"</span>);</div><div class=\"line\">    *(BOOL*)arg = TRUE;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//用户自定义参数，这里的用途为：初始化为FALSE，回调函数中设为TRUE</span></div><div class=\"line\">    <span class=\"comment\">//因此可以在main函数中得知是否成功</span></div><div class=\"line\">    BOOL isFinished = FALSE;</div><div class=\"line\">    Wilddog_T wilddog;</div><div class=\"line\">    <span class=\"comment\">//&lt;appId&gt; 为你自己的appId</span></div><div class=\"line\">    wilddog = wilddog_initWithUrl(<span class=\"string\">\"coaps://&lt;appid&gt;.wilddogio.com/room\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//注意，这里省略了对wilddog_removeValue返回值的检查</span></div><div class=\"line\">    wilddog_removeValue(wilddog, onDeleteCallback, (<span class=\"keyword\">void</span>*)&amp;isFinished);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(TRUE == isFinished)&#123;</div><div class=\"line\">            wilddog_debug(<span class=\"string\">\"remove success!\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        wilddog_trySync();</div><div class=\"line\">    &#125;</div><div class=\"line\">    wilddog_destroy(&amp;wilddog);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n"},{"title":"离线功能","_content":"Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。\n\n## 监控连接状态\n\n在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：`/.info/connected`。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。  \nObjective-C\n\n```objectivec\nWilddog *connectedRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/.info/connected\"];\n[connectedRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n  if([snapshot.value boolValue]) {\n    NSLog(@\"connected\");\n  } else {\n    NSLog(@\"not connected\");\n  }\n}];\n\n```\n\nSwift\n\n```swift\nvar connectedRef = Wilddog(url:\"https://<YOUR-WILDDOG-APP>.wilddogio.com/.info/connected\")\nconnectedRef.observeEventType(.Value, withBlock: { snapshot in\n    let connected = snapshot.value as? Bool\n    if connected != nil && connected! {\n        print(\"connected\")\n    } else {\n        print(\"not connected\")\n    }\n})\n\n```\n\n## 离线事件\n\n如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能可以实现这一需求。\n\n离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 `set`, `update`，`remove`都可以设置在离线事件中执行。\n\n下面是一个例子，使用`onDisconnect`方法，在离线的时候写入数据：\n\nObjective-C\n\n```objectivec\nWilddog *presenceRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/disconnectmessage\"];\n// 当客户端连接中断时，写入一个字符串\n[presenceRef onDisconnectSetValue:@\"I disconnected!\"];\n\n```\n\nSwift\n\n```swift\nvar presenceRef = Wilddog(url:\"https://<YOUR-WILDDOG-APP>.wilddogio.com/disconnectmessage\")\n// 当客户端连接中断时，写入一个字符串\npresenceRef.onDisconnectSetValue(\"I disconnected!\")\n\n```\n\n\n**离线事件是如何工作的**\n\n当进行了一个`onDisconnect`调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。\n\n客户端可以通过回调方法，确保离线事件被云端成功记录了：\n\nObjective-C\n\n```objectivec\n[presenceRef onDisconnectRemoveValueWithCompletionBlock:^(NSError* error, Wilddog* ref) {\n    if (error != nil) {\n        NSLog(@\"Could not establish onDisconnect event: %@\", error);\n    }\n}];\n\n```\n\nSwift\n\n```swift\npresenceRef.onDisconnectRemoveValueWithCompletionBlock({ error, ref in\n    if error != nil {\n        print(\"Could not establish onDisconnect event: \\(error)\")\n    }\n})\n\n```\n\n要取消一个离线事件，可以使用`cancel`方法：\n\nObjective-C\n\n```objectivec\n[presenceRef onDisconnectSetValue:@\"I disconnected\"];\n// 取消离线事件\n[presenceRef cancelDisconnectOperations];\n\n```\n\nSwift\n\n```swift\npresenceRef.onDisconnectSetValue(\"I disconnected\")\n// 取消离线事件\npresenceRef.cancelDisconnectOperations()\n\n```\n\n## 云端时间戳\nWilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和 `onDisconnect` 方法组合起来，很容易实现记录客户端断线时间的功能：\n\nObjective-C\n\n```objectivec\nWilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/users/joe/lastOnline\"];\n[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];\n\n```\n\nSwift\n\n```swift\nvar userLastOnlineRef = Wilddog(url:\"https://<YOUR-WILDDOG-APP>.wilddogio.com/users/joe/lastOnline\")\nuserLastOnlineRef.onDisconnectSetValue([\".sv\": \"timestamp\"])\n\n```\n\n## 离线功能的实现机制\n\nWilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果你之前设置了离线事件），重试连接等。\n另外，重试连接连上之后，之前设置的监听仍然有效。\n\n\n\n\n\n\n\n","source":"guide/sync/ios/offline-capabilities.md","raw":"title:  离线功能\n---\nWilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。\n\n## 监控连接状态\n\n在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：`/.info/connected`。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。  \nObjective-C\n\n```objectivec\nWilddog *connectedRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/.info/connected\"];\n[connectedRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n  if([snapshot.value boolValue]) {\n    NSLog(@\"connected\");\n  } else {\n    NSLog(@\"not connected\");\n  }\n}];\n\n```\n\nSwift\n\n```swift\nvar connectedRef = Wilddog(url:\"https://<YOUR-WILDDOG-APP>.wilddogio.com/.info/connected\")\nconnectedRef.observeEventType(.Value, withBlock: { snapshot in\n    let connected = snapshot.value as? Bool\n    if connected != nil && connected! {\n        print(\"connected\")\n    } else {\n        print(\"not connected\")\n    }\n})\n\n```\n\n## 离线事件\n\n如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能可以实现这一需求。\n\n离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 `set`, `update`，`remove`都可以设置在离线事件中执行。\n\n下面是一个例子，使用`onDisconnect`方法，在离线的时候写入数据：\n\nObjective-C\n\n```objectivec\nWilddog *presenceRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/disconnectmessage\"];\n// 当客户端连接中断时，写入一个字符串\n[presenceRef onDisconnectSetValue:@\"I disconnected!\"];\n\n```\n\nSwift\n\n```swift\nvar presenceRef = Wilddog(url:\"https://<YOUR-WILDDOG-APP>.wilddogio.com/disconnectmessage\")\n// 当客户端连接中断时，写入一个字符串\npresenceRef.onDisconnectSetValue(\"I disconnected!\")\n\n```\n\n\n**离线事件是如何工作的**\n\n当进行了一个`onDisconnect`调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。\n\n客户端可以通过回调方法，确保离线事件被云端成功记录了：\n\nObjective-C\n\n```objectivec\n[presenceRef onDisconnectRemoveValueWithCompletionBlock:^(NSError* error, Wilddog* ref) {\n    if (error != nil) {\n        NSLog(@\"Could not establish onDisconnect event: %@\", error);\n    }\n}];\n\n```\n\nSwift\n\n```swift\npresenceRef.onDisconnectRemoveValueWithCompletionBlock({ error, ref in\n    if error != nil {\n        print(\"Could not establish onDisconnect event: \\(error)\")\n    }\n})\n\n```\n\n要取消一个离线事件，可以使用`cancel`方法：\n\nObjective-C\n\n```objectivec\n[presenceRef onDisconnectSetValue:@\"I disconnected\"];\n// 取消离线事件\n[presenceRef cancelDisconnectOperations];\n\n```\n\nSwift\n\n```swift\npresenceRef.onDisconnectSetValue(\"I disconnected\")\n// 取消离线事件\npresenceRef.cancelDisconnectOperations()\n\n```\n\n## 云端时间戳\nWilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和 `onDisconnect` 方法组合起来，很容易实现记录客户端断线时间的功能：\n\nObjective-C\n\n```objectivec\nWilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:@\"https://<YOUR-WILDDOG-APP>.wilddogio.com/users/joe/lastOnline\"];\n[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];\n\n```\n\nSwift\n\n```swift\nvar userLastOnlineRef = Wilddog(url:\"https://<YOUR-WILDDOG-APP>.wilddogio.com/users/joe/lastOnline\")\nuserLastOnlineRef.onDisconnectSetValue([\".sv\": \"timestamp\"])\n\n```\n\n## 离线功能的实现机制\n\nWilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果你之前设置了离线事件），重试连接等。\n另外，重试连接连上之后，之前设置的监听仍然有效。\n\n\n\n\n\n\n\n","date":"2016-09-06T03:38:22.541Z","updated":"2016-09-06T03:38:22.541Z","path":"guide/sync/ios/offline-capabilities.html","comments":1,"layout":"page","_id":"cisswi9lg001uz4fwhzar82eh","content":"<p>Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。</p>\n<h2 id=\"监控连接状态\"><a href=\"#监控连接状态\" class=\"headerlink\" title=\"监控连接状态\"></a>监控连接状态</h2><p>在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：<code>/.info/connected</code>。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。<br>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *connectedRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/.info/connected\"</span>];</div><div class=\"line\">[connectedRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>([snapshot.value boolValue]) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"connected\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"not connected\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> connectedRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/.info/connected\"</span>)</div><div class=\"line\">connectedRef.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">let</span> connected = snapshot.value <span class=\"keyword\">as</span>? <span class=\"type\">Bool</span></div><div class=\"line\">    <span class=\"keyword\">if</span> connected != <span class=\"literal\">nil</span> &amp;&amp; connected! &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"connected\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"not connected\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能可以实现这一需求。</p>\n<p>离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 <code>set</code>, <code>update</code>，<code>remove</code>都可以设置在离线事件中执行。</p>\n<p>下面是一个例子，使用<code>onDisconnect</code>方法，在离线的时候写入数据：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *presenceRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/disconnectmessage\"</span>];</div><div class=\"line\"><span class=\"comment\">// 当客户端连接中断时，写入一个字符串</span></div><div class=\"line\">[presenceRef onDisconnectSetValue:<span class=\"string\">@\"I disconnected!\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> presenceRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/disconnectmessage\"</span>)</div><div class=\"line\"><span class=\"comment\">// 当客户端连接中断时，写入一个字符串</span></div><div class=\"line\">presenceRef.onDisconnectSetValue(<span class=\"string\">\"I disconnected!\"</span>)</div></pre></td></tr></table></figure>\n<p><strong>离线事件是如何工作的</strong></p>\n<p>当进行了一个<code>onDisconnect</code>调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。</p>\n<p>客户端可以通过回调方法，确保离线事件被云端成功记录了：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[presenceRef onDisconnectRemoveValueWithCompletionBlock:^(<span class=\"built_in\">NSError</span>* error, Wilddog* ref) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Could not establish onDisconnect event: %@\"</span>, error);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnectRemoveValueWithCompletionBlock(&#123; error, ref <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Could not establish onDisconnect event: \\(error)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>要取消一个离线事件，可以使用<code>cancel</code>方法：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[presenceRef onDisconnectSetValue:<span class=\"string\">@\"I disconnected\"</span>];</div><div class=\"line\"><span class=\"comment\">// 取消离线事件</span></div><div class=\"line\">[presenceRef cancelDisconnectOperations];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnectSetValue(<span class=\"string\">\"I disconnected\"</span>)</div><div class=\"line\"><span class=\"comment\">// 取消离线事件</span></div><div class=\"line\">presenceRef.cancelDisconnectOperations()</div></pre></td></tr></table></figure>\n<h2 id=\"云端时间戳\"><a href=\"#云端时间戳\" class=\"headerlink\" title=\"云端时间戳\"></a>云端时间戳</h2><p>Wilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和 <code>onDisconnect</code> 方法组合起来，很容易实现记录客户端断线时间的功能：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/users/joe/lastOnline\"</span>];</div><div class=\"line\">[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> userLastOnlineRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/users/joe/lastOnline\"</span>)</div><div class=\"line\">userLastOnlineRef.onDisconnectSetValue([<span class=\"string\">\".sv\"</span>: <span class=\"string\">\"timestamp\"</span>])</div></pre></td></tr></table></figure>\n<h2 id=\"离线功能的实现机制\"><a href=\"#离线功能的实现机制\" class=\"headerlink\" title=\"离线功能的实现机制\"></a>离线功能的实现机制</h2><p>Wilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果你之前设置了离线事件），重试连接等。<br>另外，重试连接连上之后，之前设置的监听仍然有效。</p>\n","excerpt":"","more":"<p>Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。</p>\n<h2 id=\"监控连接状态\"><a href=\"#监控连接状态\" class=\"headerlink\" title=\"监控连接状态\"></a>监控连接状态</h2><p>在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：<code>/.info/connected</code>。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。<br>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *connectedRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/.info/connected\"</span>];</div><div class=\"line\">[connectedRef observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>([snapshot.value boolValue]) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"connected\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"not connected\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> connectedRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/.info/connected\"</span>)</div><div class=\"line\">connectedRef.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">let</span> connected = snapshot.value <span class=\"keyword\">as</span>? <span class=\"type\">Bool</span></div><div class=\"line\">    <span class=\"keyword\">if</span> connected != <span class=\"literal\">nil</span> &amp;&amp; connected! &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"connected\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"not connected\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能可以实现这一需求。</p>\n<p>离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 <code>set</code>, <code>update</code>，<code>remove</code>都可以设置在离线事件中执行。</p>\n<p>下面是一个例子，使用<code>onDisconnect</code>方法，在离线的时候写入数据：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *presenceRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/disconnectmessage\"</span>];</div><div class=\"line\"><span class=\"comment\">// 当客户端连接中断时，写入一个字符串</span></div><div class=\"line\">[presenceRef onDisconnectSetValue:<span class=\"string\">@\"I disconnected!\"</span>];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> presenceRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/disconnectmessage\"</span>)</div><div class=\"line\"><span class=\"comment\">// 当客户端连接中断时，写入一个字符串</span></div><div class=\"line\">presenceRef.onDisconnectSetValue(<span class=\"string\">\"I disconnected!\"</span>)</div></pre></td></tr></table></figure>\n<p><strong>离线事件是如何工作的</strong></p>\n<p>当进行了一个<code>onDisconnect</code>调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。</p>\n<p>客户端可以通过回调方法，确保离线事件被云端成功记录了：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[presenceRef onDisconnectRemoveValueWithCompletionBlock:^(<span class=\"built_in\">NSError</span>* error, Wilddog* ref) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error != <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Could not establish onDisconnect event: %@\"</span>, error);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnectRemoveValueWithCompletionBlock(&#123; error, ref <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> error != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Could not establish onDisconnect event: \\(error)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>要取消一个离线事件，可以使用<code>cancel</code>方法：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[presenceRef onDisconnectSetValue:<span class=\"string\">@\"I disconnected\"</span>];</div><div class=\"line\"><span class=\"comment\">// 取消离线事件</span></div><div class=\"line\">[presenceRef cancelDisconnectOperations];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnectSetValue(<span class=\"string\">\"I disconnected\"</span>)</div><div class=\"line\"><span class=\"comment\">// 取消离线事件</span></div><div class=\"line\">presenceRef.cancelDisconnectOperations()</div></pre></td></tr></table></figure>\n<h2 id=\"云端时间戳\"><a href=\"#云端时间戳\" class=\"headerlink\" title=\"云端时间戳\"></a>云端时间戳</h2><p>Wilddog 提供了一种将云端时间戳作为数据写入的机制。这个机制和 <code>onDisconnect</code> 方法组合起来，很容易实现记录客户端断线时间的功能：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *userLastOnlineRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/users/joe/lastOnline\"</span>];</div><div class=\"line\">[userLastOnlineRef onDisconnectSetValue:kWilddogServerValueTimestamp];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> userLastOnlineRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://&lt;YOUR-WILDDOG-APP&gt;.wilddogio.com/users/joe/lastOnline\"</span>)</div><div class=\"line\">userLastOnlineRef.onDisconnectSetValue([<span class=\"string\">\".sv\"</span>: <span class=\"string\">\"timestamp\"</span>])</div></pre></td></tr></table></figure>\n<h2 id=\"离线功能的实现机制\"><a href=\"#离线功能的实现机制\" class=\"headerlink\" title=\"离线功能的实现机制\"></a>离线功能的实现机制</h2><p>Wilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果你之前设置了离线事件），重试连接等。<br>另外，重试连接连上之后，之前设置的监听仍然有效。</p>\n"},{"title":"读取和查询数据","_content":"本部分将介绍如何读取数据以及如何对数据进行排序和查询。\n需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。\n\n## 监听的事件类型\n\n使用 `observeEventType` 方法添加一个监听事件。一共有以下几种事件类型：\n\n事件     | 描述\n-------- | ---\nWEventTypeValue | 当程序初始化时或者节点下有任何数据发生变化时触发\nWEventTypeChildAdded | 当程序初始化时或者有新增子节点时触发\nWEventTypeChildChanged | 当某个子节点发生变化时触发\nWEventTypeChildRemoved\t| 当有子节点被删除时触发\nWEventTypeChildMoved | 当有子节点排序发生变化时触发\n\n将 `WEventTypeChildAdded`、`WEventTypeChildChanged` 和 `WEventTypeChildRemoved` 配合使用，即可监听到对子节点做出各种的更改。\n\n#### Value 事件 \n\n使用 `WEventTypeValue` 事件来读取当前节点下的所有数据的静态快照。\n此方法在初始化时会触发一次，此后每当有数据（包括任何子节点）变化都会被再次触发。初始化时，如果没有任何数据，则 `snapshot` 返回的 `value` 为 nil。\n数据（包括子节点）的快照会以事件回调形式返回。\n\n**注意**：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 Value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。\n例如，如果不是必要，尽量不要在根路径设置 Value 监听。\n\n让我们重温一下前一篇文章中博客的例子，来理解我们是如何从 Wilddog 数据库中读取数据的。我们的示例应用程序的博客文章是被存储在 url：`https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts `，若要了解博客实例展示的数据结构，请点击[博客实例数据库](https://docs-examples.wilddogio.com/web/saving-data)。为读取数据，我们可以这样做：\n\nObjective-C \n\n```objectivec\n// 获取一个我们帖子的引用\nWilddog *ref = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"];\n\n// 在帖子的引用下，绑定一个 block 去读取数据\n[ref observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"%@\", snapshot.value);\n} withCancelBlock:^(NSError *error) {\n    NSLog(@\"%@\", error.description);\n}];\n\n```\n\nSwift\n\n```swift\n// 获取一个我们帖子的引用\nvar ref = Wilddog(url:\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\")\n\n// 在帖子的引用下，绑定一个 block 去读取数据\nref.observeEventType(.Value, withBlock: { snapshot in\n    print(snapshot.value)\n}, withCancelBlock: { error in\n    print(error.description)\n})\n```\n\n\n用 `observeEventType` 方法监听收到一个 `WDataSnapshot`，其中包含着 Value 事件发生时，数据库中 ref 指定节点下的所有数据。 如果该位置不存在任何数据，则 `value` 为 nil。\n\n`WDataSnapshot` 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：\n\n方法     | 说明\n-------- | ---\nvalue | 返回当前快照的数据\nchildren    | 获取当前快照中，所有子节点的迭代器，可用来遍历快照中每一个子节点\nchildrenCount    | 返回当前节点中子节点的个数\nexists     | 如果 snapshot 对象包含数据返回 true，否则返回false\nhasChildren     | 检查是否存在某个子节点\n\n更多更详细的用法说明参见 [WDataSnapshot](/api/sync/ios.html#WDataSnapshot-Methods) 的 API 文档。\n\n#### Child 事件\n当某个节点的子节点发生改变时（如通过 `childByAutoId` 方法添加子节点，或通过 `updateChildValues` 更新子节点），就会触发 Child 事件。\n\n`WEventTypeChildAdded` 事件常用来获取当前路径下的子节点列表。初始化时将针对每个现有的子节点触发一次(例如：列表拥有10个子节点，那么该方法就会触发10次)。之后每当增加子节点时就会再次触发，在回调中只获取新增的子节点数据。\n\n每次子节点修改时，均会触发 `WEventTypeChildChanged` 事件。这包括对子节点的后代所做的任何修改。\n\n删除直接子节点时，将会触发 `WEventTypeChildRemoved` 事件。传递给回调块的快照包含已删除的子节点的数据。\n\n每当因更新（导致子节点重新排序）而触发 `WEventTypeChildChanged` 事件时，系统就会触发 `WEventTypeChildMoved` 事件。该事件用于通过 `orderByChild`、`orderByValue` 或 `orderByPriority` 中的任何一种进行排序的数据。\n\n对于 `WEventTypeChildAdded` 的理解可以看下面的这个例子：\n\nObjective-C \n\n```objectivec\n// 获取一个我们帖子的引用\nWilddog *ref = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"];\n\n// 获得新增加的数据\n[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n  NSLog(@\"%@\", snapshot.value[@\"author\"]);\n  NSLog(@\"%@\", snapshot.value[@\"title\"]);\n}];\n\n```\n\nSwift\n\n```swift\n// 获取一个我们帖子的引用\nvar ref = Wilddog(url:\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\")\n\n// 获得新增加的数据\nref.observeEventType(.ChildAdded, withBlock: { snapshot in\n    print(snapshot.value!.objectForKey(\"author\"))\n    print(snapshot.value!.objectForKey(\"title\"))\n})\n```\n\n## 一次性读取数据\n\n在某些情况下，你可能希望只返回一次回调。（例如，在初始化时，预期 UI 元素不会再发生更改时）。你可以使用 `observeSingleEventOfType` 方法简化这种情况：\n\n添加的事件回调仅触发一次，以后不会再次触发。\n\n对于只需加载一次且预计不会频繁变化，或是我们需要主动拉取的数据，这非常有用。 例如，上述示例中的博客应用([博客实例数据库](https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts))使用此方法，获取最初的博客数量，你会发现 `observeSingleEventOfType` 方法只回调了一次：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"];\n__block NSInteger count = 0;\n\n[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n    count++;\n    NSLog(@\"added -> %@\", snapshot.value);\n}];\n\n// 一次性读取数据。\n// snapshot.childrenCount 等于 WEventTypeChildAdded 事件返回的 snapshot.value 数量的计数总和 \n// WEventTypeValue 是最后触发的\n[ref observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"initial data loaded! %d\", count == snapshot.childrenCount);\n}];\n\n```\n\nSwift\n\n```swift\nvar ref = Wilddog(url:\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\")\nvar count:UInt = 0\n\nref.observeEventType(.ChildAdded, withBlock: { snapshot in\n    count++\n    print(\"added -> \\(snapshot.value)\")\n})\n\n// 一次性读取数据。\n// snapshot.childrenCount 等于 .ChildAdded 事件返回的 snapshot.value 数量的计数总和\n// .Value 是最后触发的\nref.observeEventType(.Value, withBlock: { snapshot in\n    print(\"initial data loaded! \\(count == snapshot.childrenCount)\")\n})\n\n```\n\n野狗数据实时同步的事件监听有以下几个重要的保证：\n\n监听事件的保证 |\n---- |\n本地数据状态发生了改变，事件就会触发 |\n事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致 |\n写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端 |\nValue 事件总是最后触发，并且能保证包含快照（`snapshot`）生成之前的所有改变 |\n\n## 移除监听\n\n当你退出 `ViewController` 时，观测程序不会自动停止同步数据。 如果未正确删除，观测程序会继续将数据同步到本地内存。 不再需要观测程序时，通过将关联的 `WilddogHandle` 传递给 `removeObserverWithHandle` 方法，即可将其删除。\n\n将回调快添加到引用时，会返回 `WilddogHandle`。这些句柄可用于删除回调块的监听。\n\nObjective-C\n\n```objectivec\nWilddogHandle handle = [ref observeEventType:WEventTypeValue withBlock:^(WDatasnapshot* snapshot) {\n    NSLog(@\"Snapshot value: %@\", snapshot.value)\n}];\n\n[ref removeObserverWithHandle:handle];\n\n```\n\nSwift\n\n```swift\nvar handle = ref.observeEventType(.Value, withBlock: { snapshot in\n    print(\"Snapshot value: \\(snapshot.value)\")\n})\n\nref.removeObserverWithHandle(handle)\n\n```\n\n\n如果已将多个侦听器添加到数据库引用，则会在引发事件时调用每个侦听器。 要在该位置停止同步数据，必须通过调用 `removeAllObservers` 方法删除其中的所有观测程序 (`removeAllObservers`方法的作用是取消之前用 `observeEventType `方法在该节点注册的所有监听事件。)。\n\nObjective-C\n\n```objectivec\n[ref removeAllObservers];\n\n```\n\nSwift\n\n```swift\nref.removeAllObservers()\n\n```\n\n在父节点上调用 `removeObserverWithHandle` 或者 `removeAllObservers` 时不会删除在其子节点上注册的监听。你还必须跟踪这些引用或句柄才能将其删除。\n\n\n\n## 排序和查询数据\n\n你可以使用 [WQuery](/api/sync/ios.html#WQuery-Methods) 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。\n只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。\n\n**注意**：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 [.indexOn](/api/sync/rule.html#indexOn) 规则，以便在服务器上添加索引以提高查询性能。详细操作参见[添加索引](/guide/sync/rules/introduce.html#数据索引)。\n\n#### 数据排序\n\n对数据排序前，要先指定按照`键`、`值`、`子节点的值`或按`优先级`这四种的哪一种排序。对应的方法如下：\n\n方法 | 用法\n----  | ----\nqueryOrderedByKey | 按子键对结果排序。\nqueryOrderedByValue | 按子值对结果排序。\nqueryOrderedByChild | 按指定子键的值对结果排序。\nqueryOrderedByPriority | 按节点的指定优先级对结果排序。\n\n**注意**：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。\n\n**按指定子键的值对结果排序**\n\n通过将子节点的路径名作为参数传递给`queryOrderedByChild:`，可以实现按指定子节点排序。例如，在恐龙的实例中（若要了解恐龙实例展示的数据结构，请点击[恐龙实例数据库](https://dinosaur-facts.wilddogio.com/dinosaurs)），要按照 height 进行排序，可以这样做：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[ref queryOrderedByChild:@\"height\"]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@ was %@ meters tall\", snapshot.key, snapshot.value[@\"height\"]);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").observeEventType(.ChildAdded, withBlock: { snapshot in\n    if let height = snapshot.value![\"height\"] as? Double {\n        print(\"\\(snapshot.key) was \\(height) meters tall\")\n    }\n})\n\n```\n\n**按子键对结果排序**\n\n使用`queryOrderedByKey`函数，可以实现按照数据节点的名称进行排序。下面的例子按照 alpha 字母顺序读取所有的恐龙数据：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[ref queryOrderedByKey]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@ was %@\", snapshot.key, snapshot.value[@\"height\"]);\n}];\n\n```\n\nSwift\n\n```swift\nvar ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByKey().observeEventType(.ChildAdded, withBlock: { snapshot in\n    if let height = snapshot.value![\"height\"] as? Double {\n        print(\"\\(snapshot.key) was \\(height)\")\n    }\n})\n\n```\n\n**按子值对结果排序**\n\n使用`queryOrderedByValue`方法，我们可以按照子节点的值进行排序。假设恐龙们进行了一场运动会，我们统计到它们的得分数据：\n\n```json\n{\n  \"scores\": {\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22\n  }\n}\n\n```\n要按照得分进行排序，我们可以构造一个这样的查询：\n\nObjective-C\n\n```objectivec\nWilddog *scoresRef = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/scores\"];\n[[scoresRef queryOrderedByValue] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"The %@ dinosaur's score is %@\", snapshot.key, snapshot.value);\n}];\n\n```\n\nSwift\n\n```swift\nlet scoresRef = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/scores\")\nscoresRef.queryOrderedByValue().observeEventType(.ChildAdded, withBlock: { snapshot in\n    if let score = snapshot.value as? Int {\n        print(\"The \\(snapshot.key) dinosaur's score is \\(score)\")\n    }\n})\n\n```\n\n\n#### 查询数据\n\n只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。\n\n方法 | 用法\n---- | ----\nqueryLimitedToFirst | 设置从第一条开始，一共返回多少条数据（节点）。\nqueryLimitedToLast | 设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。\nqueryStartingAtValue | 返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nqueryEndingAtValue | 返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nqueryEqualToValue | 返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。\n\n与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 `queryStartingAtValue` 与 `queryEndingAtValue` 方法将结果限制在指定的范围内。\n\n**限制结果数**\n\n你可以使用 `queryLimitedToFirst` 和 `lqueryLimitedToLast` 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 `queryLimitedToFirst` 将限制个数设置为 100，那么一开始最多只能收到 100 个 `WEventTypeChildAdded` 事件，即只返回前100条数据的快照。\n当数据发生更改时，对于进入到前100的数据，你会接收到 `WEventTypeChildAdded` 回调，对于从前100中删除的数据，你才会接收到 `WEventTypeChildRemoved` 事件，也就是说只有这100条里的数据变化才会触发事件。\n\n继续恐龙（[恐龙实例数据库](https://dinosaur-facts.wilddogio.com/dinosaurs)）的例子，我们可以获得体重最大的两种恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"weight\"] queryLimitedToLast:2] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"weight\").queryLimitedToLast(2)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        print(snapshot.key)\n})\n\n```\n\n我们为`ChildAdded`事件绑定的回调方法只会被执行2次。\n\n同理，我们可以使用`queryLimitedToFirst:`方法查询最矮的两种恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"height\"] queryLimitedToFirst:2]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").queryLimitedToFirst(2)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        print(snapshot.key)\n})\n\n```\n\n我们也可以组合`queryOrderedByValue`方法来使用 limit 类的查询。如果要构造出恐龙运动会得分的前3名，我们可以构造这样一个查询：\n\nObjective-C\n\n```objectivec\nWilddog *scoresRef = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/scores\"];\n[[[scoresRef queryOrderedByValue] queryLimitedToLast:3]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"The %@ dinosaur's score is %@\", snapshot.key, snapshot.value);\n}];\n\n```\n\nSwift\n\n```swift\nlet scoresRef = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/scores\")\nscoresRef.queryOrderedByValue().queryLimitedToLast(3).observeEventType(.ChildAdded, withBlock: { snapshot in\n    \n    print(\"The \\(snapshot.key) dinosaur's score is \\(snapshot.value)\")\n})\n\n```\n\n**range查询**\n\n使用`queryStartingAtValue:`，`queryEndingAtValue:`和`queryEqualToValue:`方法，可以为我们的查询指定任意的起止范围。如上面恐龙（[恐龙实例数据库](https://dinosaur-facts.wilddogio.com/dinosaurs)）的例子，如果要查询所有3米高以上的恐龙，可以组合`queryOrderByChild:`和`queryStartingAtValue:`查询：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"height\"] queryStartingAtValue:@3]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").queryStartingAtValue(3)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n\n按照字母排序，我们可以使用`queryEndingAtValue:`来查询所有名字排在 Pterodactyl 之前的恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByKey] queryEndingAtValue:@\"pterodactyl\"]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByKey().queryEndingAtValue(\"pterodactyl\")\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n\n注意，`queryStartingAtValue:`和`queryEndingAtValue:`是包含边界值的，也就是说“pterodactyl”符合上边的查询条件。\n\n我们可以同时使用`queryStartingAtValue:`和`queryStartingAtValue:`来限定一个范围。下面的例子查询出所有名字以字母“b”开头的恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[[ref queryOrderedByKey] queryStartingAtValue:@\"b\"] queryEndingAtValue:@\"b\\uf8ff\"]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByKey().queryStartingAtValue(\"b\").queryEndingAtValue(\"b\\u{f8ff}\")\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n这个例子中使用的“~”符号是 ASCII 中的126字符。因为它排在所有常规的 ASCII 字符之后，所以这个查询匹配所有以b开头的值。\n\n使用`queryEqualToValue:`函数，可以进行精准的查询。例如，查询所有的25米高的恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"height\"] queryEqualToValue:@25]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").queryEqualToValue(25)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n\n**总结**\n组合这些函数，我们可以构造出各种复杂的查询。例如，要找出长度小于 Stegosaurus 但最接近的恐龙的名字：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref childByAppendingPath:@\"stegosaurus\"] childByAppendingPath:@\"height\"]\n observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *stegosaurusHeightSnapshot) {\n     NSNumber *favoriteDinoHeight = stegosaurusHeightSnapshot.value;\n     WQuery *queryRef = [[[ref queryOrderedByChild:@\"height\"] queryEndingAtValue:favoriteDinoHeight] queryLimitedToLast:2];\n     [queryRef observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *querySnapshot) {\n         if (querySnapshot.childrenCount == 2) {\n             for (WDataSnapshot* child in querySnapshot.children) {\n                 NSLog(@\"The dinosaur just shorter than the stegasaurus is %@\", child.key);\n                 break;\n             }\n         } else {\n             NSLog(@\"The stegosaurus is the shortest dino\");\n         }\n     }];\n }];\n \n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.childByAppendingPath(\"stegosaurus\").childByAppendingPath(\"height\")\n    .observeEventType(.Value, withBlock: { stegosaurusHeightSnapshot in\n        if let favoriteDinoHeight = stegosaurusHeightSnapshot.value as? Double {\n            let queryRef = ref.queryOrderedByChild(\"height\").queryEndingAtValue(favoriteDinoHeight).queryLimitedToLast(2)\n            queryRef.observeSingleEventOfType(.Value, withBlock: { querySnapshot in\n                if querySnapshot.childrenCount == 2 {\n                    let child: WDataSnapshot = querySnapshot.children.nextObject() as! WDataSnapshot\n                    print(\"The dinosaur just shorter than the stegasaurus is \\(child.key)\");\n                } else {\n                    print(\"The stegosaurus is the shortest dino\");\n                }\n            })\n        }\n    })\n\n```\n\n#### 数据排序\n本小节介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**queryOrderedByChild**\n\n当使用`queryOrderedByChild:`时，按照子节点的公有属性 key 的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果 key 属性有多种数据类型时，排序不固定，此时不建议使用`queryOrderedByChild:`获取全量数据，例如，\n\n```json\n{\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    }, \n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }, \n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    }, \n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    }, \n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n\n```\n\n霸王龙的分数是`NString`类型，雷龙的分数是`BOOL`类型，而其他恐龙的分数是`NSNumber`类型，此时使用`queryOrderedByChild:`获得全量数据时，是一个看似固定的排序结果；但是配合使用`queryLimitedToFirst:`时，将获得不确定的结果。`NSObject`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`queryStartingAtValue:`、`queryEndingAtValue:`和`queryEqualToValue:`时，如果子节点的公有属性 key 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 `[[[ref queryOrderedByChild:@\"score\"]queryStartingAtValue:@60]queryLimitedToFirst:4]` 将得到下面的结果：\n\n```json\n{\n   \"no4\" : {\n       \"name\" : \"linhenykus\",\n       \"score\" : 80\n   },\n   \"no5\" : {\n       \"name\" : \"pterodactyl\",\n       \"score\" : 93\n   }\n}\n  \n```\n\n<p style='color:red'><em>注意：如果 path 与 value 的总长度超过1000字节时，使用 `queryOrderedByChild:` 将搜索不到该数据。</em></p>\n\n**queryOrderedByKey**\n\n当使用`queryOrderedByKey`对数据进行排序时，数据将会按照下面的规则，以字段名升序排列返回。注意，节点名只能是字符串类型。\n\n1, 节点名能转换为 32-bit 整数的子节点优先，按数值型升序排列。\n\n2, 接下来是字符串类型的节点名，按字典序排列。\n\n**queryOrderedByValue**\n\n当使用`queryOrderedByValue`时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用`queryOrderedByValue`获取全量数据，例如，\n\n```json\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n\n```\n\n霸王龙的分数是 `NSString`类型，雷龙的分数是 `BOOL` 类型，而其他恐龙的分数是 `NSNumber` 类型，此时使用 `queryOrderedByValue` 获得全量数据时，是一个看似固定的排序结果；但是配合使用`queryLimitedToFirst:`时，将获得不确定的结果。`NSObject`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`queryStartingAtValue:`、`queryEndingAtValue:`和`queryEqualToValue:`时，如果子节点的 value 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用`[[[ref queryOrderedByValue]queryStartingAtValue:@60]queryLimitedToFirst:4]`将得到下面的结果：\n\n```json\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n```\n<p style='color:red'><em>注意：如果 path 与 value 的总长度超过1000字节时，使用`queryOrderedByValue:`将搜索不到该数据。</em></p>\n\n**queryOrderedByPriority**\n\n当使用`queryOrderedByPriority`对数据进行排序时，子节点数据将按照优先级和字段名进行排序。注意，优先级的值只能是数值型或字符串。\n\n1, 没有优先级的数据（默认）优先。\n\n2, 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。\n\n3, 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。\n\n4, 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。\n\n\n\n","source":"guide/sync/ios/retrieve-data.md","raw":"title:  读取和查询数据\n---\n本部分将介绍如何读取数据以及如何对数据进行排序和查询。\n需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。\n\n## 监听的事件类型\n\n使用 `observeEventType` 方法添加一个监听事件。一共有以下几种事件类型：\n\n事件     | 描述\n-------- | ---\nWEventTypeValue | 当程序初始化时或者节点下有任何数据发生变化时触发\nWEventTypeChildAdded | 当程序初始化时或者有新增子节点时触发\nWEventTypeChildChanged | 当某个子节点发生变化时触发\nWEventTypeChildRemoved\t| 当有子节点被删除时触发\nWEventTypeChildMoved | 当有子节点排序发生变化时触发\n\n将 `WEventTypeChildAdded`、`WEventTypeChildChanged` 和 `WEventTypeChildRemoved` 配合使用，即可监听到对子节点做出各种的更改。\n\n#### Value 事件 \n\n使用 `WEventTypeValue` 事件来读取当前节点下的所有数据的静态快照。\n此方法在初始化时会触发一次，此后每当有数据（包括任何子节点）变化都会被再次触发。初始化时，如果没有任何数据，则 `snapshot` 返回的 `value` 为 nil。\n数据（包括子节点）的快照会以事件回调形式返回。\n\n**注意**：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 Value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。\n例如，如果不是必要，尽量不要在根路径设置 Value 监听。\n\n让我们重温一下前一篇文章中博客的例子，来理解我们是如何从 Wilddog 数据库中读取数据的。我们的示例应用程序的博客文章是被存储在 url：`https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts `，若要了解博客实例展示的数据结构，请点击[博客实例数据库](https://docs-examples.wilddogio.com/web/saving-data)。为读取数据，我们可以这样做：\n\nObjective-C \n\n```objectivec\n// 获取一个我们帖子的引用\nWilddog *ref = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"];\n\n// 在帖子的引用下，绑定一个 block 去读取数据\n[ref observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"%@\", snapshot.value);\n} withCancelBlock:^(NSError *error) {\n    NSLog(@\"%@\", error.description);\n}];\n\n```\n\nSwift\n\n```swift\n// 获取一个我们帖子的引用\nvar ref = Wilddog(url:\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\")\n\n// 在帖子的引用下，绑定一个 block 去读取数据\nref.observeEventType(.Value, withBlock: { snapshot in\n    print(snapshot.value)\n}, withCancelBlock: { error in\n    print(error.description)\n})\n```\n\n\n用 `observeEventType` 方法监听收到一个 `WDataSnapshot`，其中包含着 Value 事件发生时，数据库中 ref 指定节点下的所有数据。 如果该位置不存在任何数据，则 `value` 为 nil。\n\n`WDataSnapshot` 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：\n\n方法     | 说明\n-------- | ---\nvalue | 返回当前快照的数据\nchildren    | 获取当前快照中，所有子节点的迭代器，可用来遍历快照中每一个子节点\nchildrenCount    | 返回当前节点中子节点的个数\nexists     | 如果 snapshot 对象包含数据返回 true，否则返回false\nhasChildren     | 检查是否存在某个子节点\n\n更多更详细的用法说明参见 [WDataSnapshot](/api/sync/ios.html#WDataSnapshot-Methods) 的 API 文档。\n\n#### Child 事件\n当某个节点的子节点发生改变时（如通过 `childByAutoId` 方法添加子节点，或通过 `updateChildValues` 更新子节点），就会触发 Child 事件。\n\n`WEventTypeChildAdded` 事件常用来获取当前路径下的子节点列表。初始化时将针对每个现有的子节点触发一次(例如：列表拥有10个子节点，那么该方法就会触发10次)。之后每当增加子节点时就会再次触发，在回调中只获取新增的子节点数据。\n\n每次子节点修改时，均会触发 `WEventTypeChildChanged` 事件。这包括对子节点的后代所做的任何修改。\n\n删除直接子节点时，将会触发 `WEventTypeChildRemoved` 事件。传递给回调块的快照包含已删除的子节点的数据。\n\n每当因更新（导致子节点重新排序）而触发 `WEventTypeChildChanged` 事件时，系统就会触发 `WEventTypeChildMoved` 事件。该事件用于通过 `orderByChild`、`orderByValue` 或 `orderByPriority` 中的任何一种进行排序的数据。\n\n对于 `WEventTypeChildAdded` 的理解可以看下面的这个例子：\n\nObjective-C \n\n```objectivec\n// 获取一个我们帖子的引用\nWilddog *ref = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"];\n\n// 获得新增加的数据\n[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n  NSLog(@\"%@\", snapshot.value[@\"author\"]);\n  NSLog(@\"%@\", snapshot.value[@\"title\"]);\n}];\n\n```\n\nSwift\n\n```swift\n// 获取一个我们帖子的引用\nvar ref = Wilddog(url:\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\")\n\n// 获得新增加的数据\nref.observeEventType(.ChildAdded, withBlock: { snapshot in\n    print(snapshot.value!.objectForKey(\"author\"))\n    print(snapshot.value!.objectForKey(\"title\"))\n})\n```\n\n## 一次性读取数据\n\n在某些情况下，你可能希望只返回一次回调。（例如，在初始化时，预期 UI 元素不会再发生更改时）。你可以使用 `observeSingleEventOfType` 方法简化这种情况：\n\n添加的事件回调仅触发一次，以后不会再次触发。\n\n对于只需加载一次且预计不会频繁变化，或是我们需要主动拉取的数据，这非常有用。 例如，上述示例中的博客应用([博客实例数据库](https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts))使用此方法，获取最初的博客数量，你会发现 `observeSingleEventOfType` 方法只回调了一次：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"];\n__block NSInteger count = 0;\n\n[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n    count++;\n    NSLog(@\"added -> %@\", snapshot.value);\n}];\n\n// 一次性读取数据。\n// snapshot.childrenCount 等于 WEventTypeChildAdded 事件返回的 snapshot.value 数量的计数总和 \n// WEventTypeValue 是最后触发的\n[ref observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"initial data loaded! %d\", count == snapshot.childrenCount);\n}];\n\n```\n\nSwift\n\n```swift\nvar ref = Wilddog(url:\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\")\nvar count:UInt = 0\n\nref.observeEventType(.ChildAdded, withBlock: { snapshot in\n    count++\n    print(\"added -> \\(snapshot.value)\")\n})\n\n// 一次性读取数据。\n// snapshot.childrenCount 等于 .ChildAdded 事件返回的 snapshot.value 数量的计数总和\n// .Value 是最后触发的\nref.observeEventType(.Value, withBlock: { snapshot in\n    print(\"initial data loaded! \\(count == snapshot.childrenCount)\")\n})\n\n```\n\n野狗数据实时同步的事件监听有以下几个重要的保证：\n\n监听事件的保证 |\n---- |\n本地数据状态发生了改变，事件就会触发 |\n事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致 |\n写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端 |\nValue 事件总是最后触发，并且能保证包含快照（`snapshot`）生成之前的所有改变 |\n\n## 移除监听\n\n当你退出 `ViewController` 时，观测程序不会自动停止同步数据。 如果未正确删除，观测程序会继续将数据同步到本地内存。 不再需要观测程序时，通过将关联的 `WilddogHandle` 传递给 `removeObserverWithHandle` 方法，即可将其删除。\n\n将回调快添加到引用时，会返回 `WilddogHandle`。这些句柄可用于删除回调块的监听。\n\nObjective-C\n\n```objectivec\nWilddogHandle handle = [ref observeEventType:WEventTypeValue withBlock:^(WDatasnapshot* snapshot) {\n    NSLog(@\"Snapshot value: %@\", snapshot.value)\n}];\n\n[ref removeObserverWithHandle:handle];\n\n```\n\nSwift\n\n```swift\nvar handle = ref.observeEventType(.Value, withBlock: { snapshot in\n    print(\"Snapshot value: \\(snapshot.value)\")\n})\n\nref.removeObserverWithHandle(handle)\n\n```\n\n\n如果已将多个侦听器添加到数据库引用，则会在引发事件时调用每个侦听器。 要在该位置停止同步数据，必须通过调用 `removeAllObservers` 方法删除其中的所有观测程序 (`removeAllObservers`方法的作用是取消之前用 `observeEventType `方法在该节点注册的所有监听事件。)。\n\nObjective-C\n\n```objectivec\n[ref removeAllObservers];\n\n```\n\nSwift\n\n```swift\nref.removeAllObservers()\n\n```\n\n在父节点上调用 `removeObserverWithHandle` 或者 `removeAllObservers` 时不会删除在其子节点上注册的监听。你还必须跟踪这些引用或句柄才能将其删除。\n\n\n\n## 排序和查询数据\n\n你可以使用 [WQuery](/api/sync/ios.html#WQuery-Methods) 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。\n只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。\n\n**注意**：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 [.indexOn](/api/sync/rule.html#indexOn) 规则，以便在服务器上添加索引以提高查询性能。详细操作参见[添加索引](/guide/sync/rules/introduce.html#数据索引)。\n\n#### 数据排序\n\n对数据排序前，要先指定按照`键`、`值`、`子节点的值`或按`优先级`这四种的哪一种排序。对应的方法如下：\n\n方法 | 用法\n----  | ----\nqueryOrderedByKey | 按子键对结果排序。\nqueryOrderedByValue | 按子值对结果排序。\nqueryOrderedByChild | 按指定子键的值对结果排序。\nqueryOrderedByPriority | 按节点的指定优先级对结果排序。\n\n**注意**：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。\n\n**按指定子键的值对结果排序**\n\n通过将子节点的路径名作为参数传递给`queryOrderedByChild:`，可以实现按指定子节点排序。例如，在恐龙的实例中（若要了解恐龙实例展示的数据结构，请点击[恐龙实例数据库](https://dinosaur-facts.wilddogio.com/dinosaurs)），要按照 height 进行排序，可以这样做：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[ref queryOrderedByChild:@\"height\"]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@ was %@ meters tall\", snapshot.key, snapshot.value[@\"height\"]);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").observeEventType(.ChildAdded, withBlock: { snapshot in\n    if let height = snapshot.value![\"height\"] as? Double {\n        print(\"\\(snapshot.key) was \\(height) meters tall\")\n    }\n})\n\n```\n\n**按子键对结果排序**\n\n使用`queryOrderedByKey`函数，可以实现按照数据节点的名称进行排序。下面的例子按照 alpha 字母顺序读取所有的恐龙数据：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[ref queryOrderedByKey]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@ was %@\", snapshot.key, snapshot.value[@\"height\"]);\n}];\n\n```\n\nSwift\n\n```swift\nvar ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByKey().observeEventType(.ChildAdded, withBlock: { snapshot in\n    if let height = snapshot.value![\"height\"] as? Double {\n        print(\"\\(snapshot.key) was \\(height)\")\n    }\n})\n\n```\n\n**按子值对结果排序**\n\n使用`queryOrderedByValue`方法，我们可以按照子节点的值进行排序。假设恐龙们进行了一场运动会，我们统计到它们的得分数据：\n\n```json\n{\n  \"scores\": {\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22\n  }\n}\n\n```\n要按照得分进行排序，我们可以构造一个这样的查询：\n\nObjective-C\n\n```objectivec\nWilddog *scoresRef = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/scores\"];\n[[scoresRef queryOrderedByValue] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n    NSLog(@\"The %@ dinosaur's score is %@\", snapshot.key, snapshot.value);\n}];\n\n```\n\nSwift\n\n```swift\nlet scoresRef = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/scores\")\nscoresRef.queryOrderedByValue().observeEventType(.ChildAdded, withBlock: { snapshot in\n    if let score = snapshot.value as? Int {\n        print(\"The \\(snapshot.key) dinosaur's score is \\(score)\")\n    }\n})\n\n```\n\n\n#### 查询数据\n\n只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。\n\n方法 | 用法\n---- | ----\nqueryLimitedToFirst | 设置从第一条开始，一共返回多少条数据（节点）。\nqueryLimitedToLast | 设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。\nqueryStartingAtValue | 返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nqueryEndingAtValue | 返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nqueryEqualToValue | 返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。\n\n与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 `queryStartingAtValue` 与 `queryEndingAtValue` 方法将结果限制在指定的范围内。\n\n**限制结果数**\n\n你可以使用 `queryLimitedToFirst` 和 `lqueryLimitedToLast` 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 `queryLimitedToFirst` 将限制个数设置为 100，那么一开始最多只能收到 100 个 `WEventTypeChildAdded` 事件，即只返回前100条数据的快照。\n当数据发生更改时，对于进入到前100的数据，你会接收到 `WEventTypeChildAdded` 回调，对于从前100中删除的数据，你才会接收到 `WEventTypeChildRemoved` 事件，也就是说只有这100条里的数据变化才会触发事件。\n\n继续恐龙（[恐龙实例数据库](https://dinosaur-facts.wilddogio.com/dinosaurs)）的例子，我们可以获得体重最大的两种恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"weight\"] queryLimitedToLast:2] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"weight\").queryLimitedToLast(2)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        print(snapshot.key)\n})\n\n```\n\n我们为`ChildAdded`事件绑定的回调方法只会被执行2次。\n\n同理，我们可以使用`queryLimitedToFirst:`方法查询最矮的两种恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"height\"] queryLimitedToFirst:2]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").queryLimitedToFirst(2)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        print(snapshot.key)\n})\n\n```\n\n我们也可以组合`queryOrderedByValue`方法来使用 limit 类的查询。如果要构造出恐龙运动会得分的前3名，我们可以构造这样一个查询：\n\nObjective-C\n\n```objectivec\nWilddog *scoresRef = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/scores\"];\n[[[scoresRef queryOrderedByValue] queryLimitedToLast:3]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"The %@ dinosaur's score is %@\", snapshot.key, snapshot.value);\n}];\n\n```\n\nSwift\n\n```swift\nlet scoresRef = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/scores\")\nscoresRef.queryOrderedByValue().queryLimitedToLast(3).observeEventType(.ChildAdded, withBlock: { snapshot in\n    \n    print(\"The \\(snapshot.key) dinosaur's score is \\(snapshot.value)\")\n})\n\n```\n\n**range查询**\n\n使用`queryStartingAtValue:`，`queryEndingAtValue:`和`queryEqualToValue:`方法，可以为我们的查询指定任意的起止范围。如上面恐龙（[恐龙实例数据库](https://dinosaur-facts.wilddogio.com/dinosaurs)）的例子，如果要查询所有3米高以上的恐龙，可以组合`queryOrderByChild:`和`queryStartingAtValue:`查询：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"height\"] queryStartingAtValue:@3]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").queryStartingAtValue(3)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n\n按照字母排序，我们可以使用`queryEndingAtValue:`来查询所有名字排在 Pterodactyl 之前的恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByKey] queryEndingAtValue:@\"pterodactyl\"]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByKey().queryEndingAtValue(\"pterodactyl\")\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n\n注意，`queryStartingAtValue:`和`queryEndingAtValue:`是包含边界值的，也就是说“pterodactyl”符合上边的查询条件。\n\n我们可以同时使用`queryStartingAtValue:`和`queryStartingAtValue:`来限定一个范围。下面的例子查询出所有名字以字母“b”开头的恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[[ref queryOrderedByKey] queryStartingAtValue:@\"b\"] queryEndingAtValue:@\"b\\uf8ff\"]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByKey().queryStartingAtValue(\"b\").queryEndingAtValue(\"b\\u{f8ff}\")\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n这个例子中使用的“~”符号是 ASCII 中的126字符。因为它排在所有常规的 ASCII 字符之后，所以这个查询匹配所有以b开头的值。\n\n使用`queryEqualToValue:`函数，可以进行精准的查询。例如，查询所有的25米高的恐龙：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref queryOrderedByChild:@\"height\"] queryEqualToValue:@25]\n    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n\n    NSLog(@\"%@\", snapshot.key);\n}];\n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.queryOrderedByChild(\"height\").queryEqualToValue(25)\n    .observeEventType(.ChildAdded, withBlock: { snapshot in\n        \n        print(snapshot.key)\n})\n\n```\n\n**总结**\n组合这些函数，我们可以构造出各种复杂的查询。例如，要找出长度小于 Stegosaurus 但最接近的恐龙的名字：\n\nObjective-C\n\n```objectivec\nWilddog *ref = [[Wilddog alloc] initWithUrl:@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"];\n[[[ref childByAppendingPath:@\"stegosaurus\"] childByAppendingPath:@\"height\"]\n observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *stegosaurusHeightSnapshot) {\n     NSNumber *favoriteDinoHeight = stegosaurusHeightSnapshot.value;\n     WQuery *queryRef = [[[ref queryOrderedByChild:@\"height\"] queryEndingAtValue:favoriteDinoHeight] queryLimitedToLast:2];\n     [queryRef observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *querySnapshot) {\n         if (querySnapshot.childrenCount == 2) {\n             for (WDataSnapshot* child in querySnapshot.children) {\n                 NSLog(@\"The dinosaur just shorter than the stegasaurus is %@\", child.key);\n                 break;\n             }\n         } else {\n             NSLog(@\"The stegosaurus is the shortest dino\");\n         }\n     }];\n }];\n \n```\n\nSwift\n\n```swift\nlet ref = Wilddog(url:\"https://dinosaur-facts.wilddogio.com/dinosaurs\")\nref.childByAppendingPath(\"stegosaurus\").childByAppendingPath(\"height\")\n    .observeEventType(.Value, withBlock: { stegosaurusHeightSnapshot in\n        if let favoriteDinoHeight = stegosaurusHeightSnapshot.value as? Double {\n            let queryRef = ref.queryOrderedByChild(\"height\").queryEndingAtValue(favoriteDinoHeight).queryLimitedToLast(2)\n            queryRef.observeSingleEventOfType(.Value, withBlock: { querySnapshot in\n                if querySnapshot.childrenCount == 2 {\n                    let child: WDataSnapshot = querySnapshot.children.nextObject() as! WDataSnapshot\n                    print(\"The dinosaur just shorter than the stegasaurus is \\(child.key)\");\n                } else {\n                    print(\"The stegosaurus is the shortest dino\");\n                }\n            })\n        }\n    })\n\n```\n\n#### 数据排序\n本小节介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**queryOrderedByChild**\n\n当使用`queryOrderedByChild:`时，按照子节点的公有属性 key 的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果 key 属性有多种数据类型时，排序不固定，此时不建议使用`queryOrderedByChild:`获取全量数据，例如，\n\n```json\n{\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    }, \n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }, \n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    }, \n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    }, \n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n\n```\n\n霸王龙的分数是`NString`类型，雷龙的分数是`BOOL`类型，而其他恐龙的分数是`NSNumber`类型，此时使用`queryOrderedByChild:`获得全量数据时，是一个看似固定的排序结果；但是配合使用`queryLimitedToFirst:`时，将获得不确定的结果。`NSObject`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`queryStartingAtValue:`、`queryEndingAtValue:`和`queryEqualToValue:`时，如果子节点的公有属性 key 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 `[[[ref queryOrderedByChild:@\"score\"]queryStartingAtValue:@60]queryLimitedToFirst:4]` 将得到下面的结果：\n\n```json\n{\n   \"no4\" : {\n       \"name\" : \"linhenykus\",\n       \"score\" : 80\n   },\n   \"no5\" : {\n       \"name\" : \"pterodactyl\",\n       \"score\" : 93\n   }\n}\n  \n```\n\n<p style='color:red'><em>注意：如果 path 与 value 的总长度超过1000字节时，使用 `queryOrderedByChild:` 将搜索不到该数据。</em></p>\n\n**queryOrderedByKey**\n\n当使用`queryOrderedByKey`对数据进行排序时，数据将会按照下面的规则，以字段名升序排列返回。注意，节点名只能是字符串类型。\n\n1, 节点名能转换为 32-bit 整数的子节点优先，按数值型升序排列。\n\n2, 接下来是字符串类型的节点名，按字典序排列。\n\n**queryOrderedByValue**\n\n当使用`queryOrderedByValue`时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用`queryOrderedByValue`获取全量数据，例如，\n\n```json\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n\n```\n\n霸王龙的分数是 `NSString`类型，雷龙的分数是 `BOOL` 类型，而其他恐龙的分数是 `NSNumber` 类型，此时使用 `queryOrderedByValue` 获得全量数据时，是一个看似固定的排序结果；但是配合使用`queryLimitedToFirst:`时，将获得不确定的结果。`NSObject`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`queryStartingAtValue:`、`queryEndingAtValue:`和`queryEqualToValue:`时，如果子节点的 value 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用`[[[ref queryOrderedByValue]queryStartingAtValue:@60]queryLimitedToFirst:4]`将得到下面的结果：\n\n```json\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n```\n<p style='color:red'><em>注意：如果 path 与 value 的总长度超过1000字节时，使用`queryOrderedByValue:`将搜索不到该数据。</em></p>\n\n**queryOrderedByPriority**\n\n当使用`queryOrderedByPriority`对数据进行排序时，子节点数据将按照优先级和字段名进行排序。注意，优先级的值只能是数值型或字符串。\n\n1, 没有优先级的数据（默认）优先。\n\n2, 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。\n\n3, 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。\n\n4, 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。\n\n\n\n","date":"2016-09-06T03:38:22.541Z","updated":"2016-09-06T03:38:22.541Z","path":"guide/sync/ios/retrieve-data.html","comments":1,"layout":"page","_id":"cisswi9lg001vz4fw7r5abna3","content":"<p>本部分将介绍如何读取数据以及如何对数据进行排序和查询。<br>需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。</p>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>使用 <code>observeEventType</code> 方法添加一个监听事件。一共有以下几种事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WEventTypeValue</td>\n<td>当程序初始化时或者节点下有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildAdded</td>\n<td>当程序初始化时或者有新增子节点时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildChanged</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildRemoved</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildMoved</td>\n<td>当有子节点排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n<p>将 <code>WEventTypeChildAdded</code>、<code>WEventTypeChildChanged</code> 和 <code>WEventTypeChildRemoved</code> 配合使用，即可监听到对子节点做出各种的更改。</p>\n<h4 id=\"Value-事件\"><a href=\"#Value-事件\" class=\"headerlink\" title=\"Value 事件\"></a>Value 事件</h4><p>使用 <code>WEventTypeValue</code> 事件来读取当前节点下的所有数据的静态快照。<br>此方法在初始化时会触发一次，此后每当有数据（包括任何子节点）变化都会被再次触发。初始化时，如果没有任何数据，则 <code>snapshot</code> 返回的 <code>value</code> 为 nil。<br>数据（包括子节点）的快照会以事件回调形式返回。</p>\n<p><strong>注意</strong>：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 Value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。<br>例如，如果不是必要，尽量不要在根路径设置 Value 监听。</p>\n<p>让我们重温一下前一篇文章中博客的例子，来理解我们是如何从 Wilddog 数据库中读取数据的。我们的示例应用程序的博客文章是被存储在 url：<code>https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts</code>，若要了解博客实例展示的数据结构，请点击<a href=\"https://docs-examples.wilddogio.com/web/saving-data\" target=\"_blank\" rel=\"external\">博客实例数据库</a>。为读取数据，我们可以这样做：</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在帖子的引用下，绑定一个 block 去读取数据</span></div><div class=\"line\">[ref observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.value);</div><div class=\"line\">&#125; withCancelBlock:^(<span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error.description);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在帖子的引用下，绑定一个 block 去读取数据</span></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(snapshot.value)</div><div class=\"line\">&#125;, withCancelBlock: &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(error.description)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>用 <code>observeEventType</code> 方法监听收到一个 <code>WDataSnapshot</code>，其中包含着 Value 事件发生时，数据库中 ref 指定节点下的所有数据。 如果该位置不存在任何数据，则 <code>value</code> 为 nil。</p>\n<p><code>WDataSnapshot</code> 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>返回当前快照的数据</td>\n</tr>\n<tr>\n<td>children</td>\n<td>获取当前快照中，所有子节点的迭代器，可用来遍历快照中每一个子节点</td>\n</tr>\n<tr>\n<td>childrenCount</td>\n<td>返回当前节点中子节点的个数</td>\n</tr>\n<tr>\n<td>exists</td>\n<td>如果 snapshot 对象包含数据返回 true，否则返回false</td>\n</tr>\n<tr>\n<td>hasChildren</td>\n<td>检查是否存在某个子节点</td>\n</tr>\n</tbody>\n</table>\n<p>更多更详细的用法说明参见 <a href=\"/api/sync/ios.html#WDataSnapshot-Methods\">WDataSnapshot</a> 的 API 文档。</p>\n<h4 id=\"Child-事件\"><a href=\"#Child-事件\" class=\"headerlink\" title=\"Child 事件\"></a>Child 事件</h4><p>当某个节点的子节点发生改变时（如通过 <code>childByAutoId</code> 方法添加子节点，或通过 <code>updateChildValues</code> 更新子节点），就会触发 Child 事件。</p>\n<p><code>WEventTypeChildAdded</code> 事件常用来获取当前路径下的子节点列表。初始化时将针对每个现有的子节点触发一次(例如：列表拥有10个子节点，那么该方法就会触发10次)。之后每当增加子节点时就会再次触发，在回调中只获取新增的子节点数据。</p>\n<p>每次子节点修改时，均会触发 <code>WEventTypeChildChanged</code> 事件。这包括对子节点的后代所做的任何修改。</p>\n<p>删除直接子节点时，将会触发 <code>WEventTypeChildRemoved</code> 事件。传递给回调块的快照包含已删除的子节点的数据。</p>\n<p>每当因更新（导致子节点重新排序）而触发 <code>WEventTypeChildChanged</code> 事件时，系统就会触发 <code>WEventTypeChildMoved</code> 事件。该事件用于通过 <code>orderByChild</code>、<code>orderByValue</code> 或 <code>orderByPriority</code> 中的任何一种进行排序的数据。</p>\n<p>对于 <code>WEventTypeChildAdded</code> 的理解可以看下面的这个例子：</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获得新增加的数据</span></div><div class=\"line\">[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.value[<span class=\"string\">@\"author\"</span>]);</div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.value[<span class=\"string\">@\"title\"</span>]);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获得新增加的数据</span></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(snapshot.value!.objectForKey(<span class=\"string\">\"author\"</span>))</div><div class=\"line\">    <span class=\"built_in\">print</span>(snapshot.value!.objectForKey(<span class=\"string\">\"title\"</span>))</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"一次性读取数据\"><a href=\"#一次性读取数据\" class=\"headerlink\" title=\"一次性读取数据\"></a>一次性读取数据</h2><p>在某些情况下，你可能希望只返回一次回调。（例如，在初始化时，预期 UI 元素不会再发生更改时）。你可以使用 <code>observeSingleEventOfType</code> 方法简化这种情况：</p>\n<p>添加的事件回调仅触发一次，以后不会再次触发。</p>\n<p>对于只需加载一次且预计不会频繁变化，或是我们需要主动拉取的数据，这非常有用。 例如，上述示例中的博客应用(<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\" target=\"_blank\" rel=\"external\">博客实例数据库</a>)使用此方法，获取最初的博客数量，你会发现 <code>observeSingleEventOfType</code> 方法只回调了一次：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>];</div><div class=\"line\">__block <span class=\"built_in\">NSInteger</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    count++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"added -&gt; %@\"</span>, snapshot.value);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 一次性读取数据。</span></div><div class=\"line\"><span class=\"comment\">// snapshot.childrenCount 等于 WEventTypeChildAdded 事件返回的 snapshot.value 数量的计数总和 </span></div><div class=\"line\"><span class=\"comment\">// WEventTypeValue 是最后触发的</span></div><div class=\"line\">[ref observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"initial data loaded! %d\"</span>, count == snapshot.childrenCount);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">count</span>:<span class=\"type\">UInt</span> = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">count</span>++</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"added -&gt; \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 一次性读取数据。</span></div><div class=\"line\"><span class=\"comment\">// snapshot.childrenCount 等于 .ChildAdded 事件返回的 snapshot.value 数量的计数总和</span></div><div class=\"line\"><span class=\"comment\">// .Value 是最后触发的</span></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"initial data loaded! \\(count == snapshot.childrenCount)\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>野狗数据实时同步的事件监听有以下几个重要的保证：</p>\n<table>\n<thead>\n<tr>\n<th>监听事件的保证</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地数据状态发生了改变，事件就会触发</td>\n<td></td>\n</tr>\n<tr>\n<td>事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致</td>\n<td></td>\n</tr>\n<tr>\n<td>写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端</td>\n<td></td>\n</tr>\n<tr>\n<td>Value 事件总是最后触发，并且能保证包含快照（<code>snapshot</code>）生成之前的所有改变</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"移除监听\"><a href=\"#移除监听\" class=\"headerlink\" title=\"移除监听\"></a>移除监听</h2><p>当你退出 <code>ViewController</code> 时，观测程序不会自动停止同步数据。 如果未正确删除，观测程序会继续将数据同步到本地内存。 不再需要观测程序时，通过将关联的 <code>WilddogHandle</code> 传递给 <code>removeObserverWithHandle</code> 方法，即可将其删除。</p>\n<p>将回调快添加到引用时，会返回 <code>WilddogHandle</code>。这些句柄可用于删除回调块的监听。</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogHandle handle = [ref observeEventType:WEventTypeValue withBlock:^(WDatasnapshot* snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Snapshot value: %@\"</span>, snapshot.value)</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[ref removeObserverWithHandle:handle];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> handle = ref.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Snapshot value: \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">ref.removeObserverWithHandle(handle)</div></pre></td></tr></table></figure>\n<p>如果已将多个侦听器添加到数据库引用，则会在引发事件时调用每个侦听器。 要在该位置停止同步数据，必须通过调用 <code>removeAllObservers</code> 方法删除其中的所有观测程序 (<code>removeAllObservers</code>方法的作用是取消之前用 <code>observeEventType</code>方法在该节点注册的所有监听事件。)。</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[ref removeAllObservers];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.removeAllObservers()</div></pre></td></tr></table></figure>\n<p>在父节点上调用 <code>removeObserverWithHandle</code> 或者 <code>removeAllObservers</code> 时不会删除在其子节点上注册的监听。你还必须跟踪这些引用或句柄才能将其删除。</p>\n<h2 id=\"排序和查询数据\"><a href=\"#排序和查询数据\" class=\"headerlink\" title=\"排序和查询数据\"></a>排序和查询数据</h2><p>你可以使用 <a href=\"/api/sync/ios.html#WQuery-Methods\">WQuery</a> 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。<br>只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。</p>\n<p><strong>注意</strong>：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 规则，以便在服务器上添加索引以提高查询性能。详细操作参见<a href=\"/guide/sync/rules/introduce.html#数据索引\">添加索引</a>。</p>\n<h4 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>对数据排序前，要先指定按照<code>键</code>、<code>值</code>、<code>子节点的值</code>或按<code>优先级</code>这四种的哪一种排序。对应的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>queryOrderedByKey</td>\n<td>按子键对结果排序。</td>\n</tr>\n<tr>\n<td>queryOrderedByValue</td>\n<td>按子值对结果排序。</td>\n</tr>\n<tr>\n<td>queryOrderedByChild</td>\n<td>按指定子键的值对结果排序。</td>\n</tr>\n<tr>\n<td>queryOrderedByPriority</td>\n<td>按节点的指定优先级对结果排序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。</p>\n<p><strong>按指定子键的值对结果排序</strong></p>\n<p>通过将子节点的路径名作为参数传递给<code>queryOrderedByChild:</code>，可以实现按指定子节点排序。例如，在恐龙的实例中（若要了解恐龙实例展示的数据结构，请点击<a href=\"https://dinosaur-facts.wilddogio.com/dinosaurs\" target=\"_blank\" rel=\"external\">恐龙实例数据库</a>），要按照 height 进行排序，可以这样做：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ was %@ meters tall\"</span>, snapshot.key, snapshot.value[<span class=\"string\">@\"height\"</span>]);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> height = snapshot.value![<span class=\"string\">\"height\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"\\(snapshot.key) was \\(height) meters tall\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>按子键对结果排序</strong></p>\n<p>使用<code>queryOrderedByKey</code>函数，可以实现按照数据节点的名称进行排序。下面的例子按照 alpha 字母顺序读取所有的恐龙数据：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[ref queryOrderedByKey]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ was %@\"</span>, snapshot.key, snapshot.value[<span class=\"string\">@\"height\"</span>]);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByKey().observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> height = snapshot.value![<span class=\"string\">\"height\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"\\(snapshot.key) was \\(height)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>按子值对结果排序</strong></p>\n<p>使用<code>queryOrderedByValue</code>方法，我们可以按照子节点的值进行排序。假设恐龙们进行了一场运动会，我们统计到它们的得分数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要按照得分进行排序，我们可以构造一个这样的查询：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *scoresRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/scores\"</span>];</div><div class=\"line\">[[scoresRef queryOrderedByValue] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The %@ dinosaur's score is %@\"</span>, snapshot.key, snapshot.value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> scoresRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/scores\"</span>)</div><div class=\"line\">scoresRef.queryOrderedByValue().observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> score = snapshot.value <span class=\"keyword\">as</span>? <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The \\(snapshot.key) dinosaur's score is \\(score)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>queryLimitedToFirst</td>\n<td>设置从第一条开始，一共返回多少条数据（节点）。</td>\n</tr>\n<tr>\n<td>queryLimitedToLast</td>\n<td>设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。</td>\n</tr>\n<tr>\n<td>queryStartingAtValue</td>\n<td>返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>queryEndingAtValue</td>\n<td>返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>queryEqualToValue</td>\n<td>返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。</td>\n</tr>\n</tbody>\n</table>\n<p>与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 <code>queryStartingAtValue</code> 与 <code>queryEndingAtValue</code> 方法将结果限制在指定的范围内。</p>\n<p><strong>限制结果数</strong></p>\n<p>你可以使用 <code>queryLimitedToFirst</code> 和 <code>lqueryLimitedToLast</code> 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 <code>queryLimitedToFirst</code> 将限制个数设置为 100，那么一开始最多只能收到 100 个 <code>WEventTypeChildAdded</code> 事件，即只返回前100条数据的快照。<br>当数据发生更改时，对于进入到前100的数据，你会接收到 <code>WEventTypeChildAdded</code> 回调，对于从前100中删除的数据，你才会接收到 <code>WEventTypeChildRemoved</code> 事件，也就是说只有这100条里的数据变化才会触发事件。</p>\n<p>继续恐龙（<a href=\"https://dinosaur-facts.wilddogio.com/dinosaurs\" target=\"_blank\" rel=\"external\">恐龙实例数据库</a>）的例子，我们可以获得体重最大的两种恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"weight\"</span>] queryLimitedToLast:<span class=\"number\">2</span>] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"weight\"</span>).queryLimitedToLast(<span class=\"number\">2</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们为<code>ChildAdded</code>事件绑定的回调方法只会被执行2次。</p>\n<p>同理，我们可以使用<code>queryLimitedToFirst:</code>方法查询最矮的两种恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryLimitedToFirst:<span class=\"number\">2</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryLimitedToFirst(<span class=\"number\">2</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们也可以组合<code>queryOrderedByValue</code>方法来使用 limit 类的查询。如果要构造出恐龙运动会得分的前3名，我们可以构造这样一个查询：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *scoresRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/scores\"</span>];</div><div class=\"line\">[[[scoresRef queryOrderedByValue] queryLimitedToLast:<span class=\"number\">3</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The %@ dinosaur's score is %@\"</span>, snapshot.key, snapshot.value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> scoresRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/scores\"</span>)</div><div class=\"line\">scoresRef.queryOrderedByValue().queryLimitedToLast(<span class=\"number\">3</span>).observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The \\(snapshot.key) dinosaur's score is \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>range查询</strong></p>\n<p>使用<code>queryStartingAtValue:</code>，<code>queryEndingAtValue:</code>和<code>queryEqualToValue:</code>方法，可以为我们的查询指定任意的起止范围。如上面恐龙（<a href=\"https://dinosaur-facts.wilddogio.com/dinosaurs\" target=\"_blank\" rel=\"external\">恐龙实例数据库</a>）的例子，如果要查询所有3米高以上的恐龙，可以组合<code>queryOrderByChild:</code>和<code>queryStartingAtValue:</code>查询：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryStartingAtValue:@<span class=\"number\">3</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryStartingAtValue(<span class=\"number\">3</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>按照字母排序，我们可以使用<code>queryEndingAtValue:</code>来查询所有名字排在 Pterodactyl 之前的恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByKey] queryEndingAtValue:<span class=\"string\">@\"pterodactyl\"</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByKey().queryEndingAtValue(<span class=\"string\">\"pterodactyl\"</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意，<code>queryStartingAtValue:</code>和<code>queryEndingAtValue:</code>是包含边界值的，也就是说“pterodactyl”符合上边的查询条件。</p>\n<p>我们可以同时使用<code>queryStartingAtValue:</code>和<code>queryStartingAtValue:</code>来限定一个范围。下面的例子查询出所有名字以字母“b”开头的恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[[ref queryOrderedByKey] queryStartingAtValue:<span class=\"string\">@\"b\"</span>] queryEndingAtValue:<span class=\"string\">@\"b\\uf8ff\"</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByKey().queryStartingAtValue(<span class=\"string\">\"b\"</span>).queryEndingAtValue(<span class=\"string\">\"b\\u&#123;f8ff&#125;\"</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这个例子中使用的“~”符号是 ASCII 中的126字符。因为它排在所有常规的 ASCII 字符之后，所以这个查询匹配所有以b开头的值。</p>\n<p>使用<code>queryEqualToValue:</code>函数，可以进行精准的查询。例如，查询所有的25米高的恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryEqualToValue:@<span class=\"number\">25</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryEqualToValue(<span class=\"number\">25</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>总结</strong><br>组合这些函数，我们可以构造出各种复杂的查询。例如，要找出长度小于 Stegosaurus 但最接近的恐龙的名字：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref childByAppendingPath:<span class=\"string\">@\"stegosaurus\"</span>] childByAppendingPath:<span class=\"string\">@\"height\"</span>]</div><div class=\"line\"> observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *stegosaurusHeightSnapshot) &#123;</div><div class=\"line\">     <span class=\"built_in\">NSNumber</span> *favoriteDinoHeight = stegosaurusHeightSnapshot.value;</div><div class=\"line\">     WQuery *queryRef = [[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryEndingAtValue:favoriteDinoHeight] queryLimitedToLast:<span class=\"number\">2</span>];</div><div class=\"line\">     [queryRef observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *querySnapshot) &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (querySnapshot.childrenCount == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">for</span> (WDataSnapshot* child <span class=\"keyword\">in</span> querySnapshot.children) &#123;</div><div class=\"line\">                 <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The dinosaur just shorter than the stegasaurus is %@\"</span>, child.key);</div><div class=\"line\">                 <span class=\"keyword\">break</span>;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The stegosaurus is the shortest dino\"</span>);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;];</div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.childByAppendingPath(<span class=\"string\">\"stegosaurus\"</span>).childByAppendingPath(<span class=\"string\">\"height\"</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; stegosaurusHeightSnapshot <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> favoriteDinoHeight = stegosaurusHeightSnapshot.value <span class=\"keyword\">as</span>? <span class=\"type\">Double</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> queryRef = ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryEndingAtValue(favoriteDinoHeight).queryLimitedToLast(<span class=\"number\">2</span>)</div><div class=\"line\">            queryRef.observeSingleEventOfType(.<span class=\"type\">Value</span>, withBlock: &#123; querySnapshot <span class=\"keyword\">in</span></div><div class=\"line\">                <span class=\"keyword\">if</span> querySnapshot.childrenCount == <span class=\"number\">2</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">let</span> child: <span class=\"type\">WDataSnapshot</span> = querySnapshot.children.nextObject() <span class=\"keyword\">as</span>! <span class=\"type\">WDataSnapshot</span></div><div class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">\"The dinosaur just shorter than the stegasaurus is \\(child.key)\"</span>);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">\"The stegosaurus is the shortest dino\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"数据排序-1\"><a href=\"#数据排序-1\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>本小节介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>queryOrderedByChild</strong></p>\n<p>当使用<code>queryOrderedByChild:</code>时，按照子节点的公有属性 key 的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果 key 属性有多种数据类型时，排序不固定，此时不建议使用<code>queryOrderedByChild:</code>获取全量数据，例如，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"no1\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"tyrannosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"string\">\"120\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no2\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"bruhathkayosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">55</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no3\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"lambeosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">21</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no6\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"stegosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">5</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no7\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"triceratops\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">22</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no8\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"brontosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是<code>NString</code>类型，雷龙的分数是<code>BOOL</code>类型，而其他恐龙的分数是<code>NSNumber</code>类型，此时使用<code>queryOrderedByChild:</code>获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>queryLimitedToFirst:</code>时，将获得不确定的结果。<code>NSObject</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>queryStartingAtValue:</code>、<code>queryEndingAtValue:</code>和<code>queryEqualToValue:</code>时，如果子节点的公有属性 key 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 <code>[[[ref queryOrderedByChild:@&quot;score&quot;]queryStartingAtValue:@60]queryLimitedToFirst:4]</code> 将得到下面的结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">       <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">       <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">       <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">       <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p style=\"color:red\"><em>注意：如果 path 与 value 的总长度超过1000字节时，使用 <code>queryOrderedByChild:</code> 将搜索不到该数据。</em></p>\n\n<p><strong>queryOrderedByKey</strong></p>\n<p>当使用<code>queryOrderedByKey</code>对数据进行排序时，数据将会按照下面的规则，以字段名升序排列返回。注意，节点名只能是字符串类型。</p>\n<p>1, 节点名能转换为 32-bit 整数的子节点优先，按数值型升序排列。</p>\n<p>2, 接下来是字符串类型的节点名，按字典序排列。</p>\n<p><strong>queryOrderedByValue</strong></p>\n<p>当使用<code>queryOrderedByValue</code>时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用<code>queryOrderedByValue</code>获取全量数据，例如，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"tyrannosaurus\"</span> : <span class=\"string\">\"120\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"attr\">\"brontosaurus\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是 <code>NSString</code>类型，雷龙的分数是 <code>BOOL</code> 类型，而其他恐龙的分数是 <code>NSNumber</code> 类型，此时使用 <code>queryOrderedByValue</code> 获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>queryLimitedToFirst:</code>时，将获得不确定的结果。<code>NSObject</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>queryStartingAtValue:</code>、<code>queryEndingAtValue:</code>和<code>queryEqualToValue:</code>时，如果子节点的 value 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用<code>[[[ref queryOrderedByValue]queryStartingAtValue:@60]queryLimitedToFirst:4]</code>将得到下面的结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p style=\"color:red\"><em>注意：如果 path 与 value 的总长度超过1000字节时，使用<code>queryOrderedByValue:</code>将搜索不到该数据。</em></p>\n\n<p><strong>queryOrderedByPriority</strong></p>\n<p>当使用<code>queryOrderedByPriority</code>对数据进行排序时，子节点数据将按照优先级和字段名进行排序。注意，优先级的值只能是数值型或字符串。</p>\n<p>1, 没有优先级的数据（默认）优先。</p>\n<p>2, 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。</p>\n<p>3, 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。</p>\n<p>4, 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。</p>\n","excerpt":"","more":"<p>本部分将介绍如何读取数据以及如何对数据进行排序和查询。<br>需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。</p>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>使用 <code>observeEventType</code> 方法添加一个监听事件。一共有以下几种事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WEventTypeValue</td>\n<td>当程序初始化时或者节点下有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildAdded</td>\n<td>当程序初始化时或者有新增子节点时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildChanged</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildRemoved</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>WEventTypeChildMoved</td>\n<td>当有子节点排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n<p>将 <code>WEventTypeChildAdded</code>、<code>WEventTypeChildChanged</code> 和 <code>WEventTypeChildRemoved</code> 配合使用，即可监听到对子节点做出各种的更改。</p>\n<h4 id=\"Value-事件\"><a href=\"#Value-事件\" class=\"headerlink\" title=\"Value 事件\"></a>Value 事件</h4><p>使用 <code>WEventTypeValue</code> 事件来读取当前节点下的所有数据的静态快照。<br>此方法在初始化时会触发一次，此后每当有数据（包括任何子节点）变化都会被再次触发。初始化时，如果没有任何数据，则 <code>snapshot</code> 返回的 <code>value</code> 为 nil。<br>数据（包括子节点）的快照会以事件回调形式返回。</p>\n<p><strong>注意</strong>：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 Value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。<br>例如，如果不是必要，尽量不要在根路径设置 Value 监听。</p>\n<p>让我们重温一下前一篇文章中博客的例子，来理解我们是如何从 Wilddog 数据库中读取数据的。我们的示例应用程序的博客文章是被存储在 url：<code>https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts</code>，若要了解博客实例展示的数据结构，请点击<a href=\"https://docs-examples.wilddogio.com/web/saving-data\">博客实例数据库</a>。为读取数据，我们可以这样做：</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在帖子的引用下，绑定一个 block 去读取数据</span></div><div class=\"line\">[ref observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.value);</div><div class=\"line\">&#125; withCancelBlock:^(<span class=\"built_in\">NSError</span> *error) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, error.description);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在帖子的引用下，绑定一个 block 去读取数据</span></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(snapshot.value)</div><div class=\"line\">&#125;, withCancelBlock: &#123; error <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(error.description)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>用 <code>observeEventType</code> 方法监听收到一个 <code>WDataSnapshot</code>，其中包含着 Value 事件发生时，数据库中 ref 指定节点下的所有数据。 如果该位置不存在任何数据，则 <code>value</code> 为 nil。</p>\n<p><code>WDataSnapshot</code> 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>返回当前快照的数据</td>\n</tr>\n<tr>\n<td>children</td>\n<td>获取当前快照中，所有子节点的迭代器，可用来遍历快照中每一个子节点</td>\n</tr>\n<tr>\n<td>childrenCount</td>\n<td>返回当前节点中子节点的个数</td>\n</tr>\n<tr>\n<td>exists</td>\n<td>如果 snapshot 对象包含数据返回 true，否则返回false</td>\n</tr>\n<tr>\n<td>hasChildren</td>\n<td>检查是否存在某个子节点</td>\n</tr>\n</tbody>\n</table>\n<p>更多更详细的用法说明参见 <a href=\"/api/sync/ios.html#WDataSnapshot-Methods\">WDataSnapshot</a> 的 API 文档。</p>\n<h4 id=\"Child-事件\"><a href=\"#Child-事件\" class=\"headerlink\" title=\"Child 事件\"></a>Child 事件</h4><p>当某个节点的子节点发生改变时（如通过 <code>childByAutoId</code> 方法添加子节点，或通过 <code>updateChildValues</code> 更新子节点），就会触发 Child 事件。</p>\n<p><code>WEventTypeChildAdded</code> 事件常用来获取当前路径下的子节点列表。初始化时将针对每个现有的子节点触发一次(例如：列表拥有10个子节点，那么该方法就会触发10次)。之后每当增加子节点时就会再次触发，在回调中只获取新增的子节点数据。</p>\n<p>每次子节点修改时，均会触发 <code>WEventTypeChildChanged</code> 事件。这包括对子节点的后代所做的任何修改。</p>\n<p>删除直接子节点时，将会触发 <code>WEventTypeChildRemoved</code> 事件。传递给回调块的快照包含已删除的子节点的数据。</p>\n<p>每当因更新（导致子节点重新排序）而触发 <code>WEventTypeChildChanged</code> 事件时，系统就会触发 <code>WEventTypeChildMoved</code> 事件。该事件用于通过 <code>orderByChild</code>、<code>orderByValue</code> 或 <code>orderByPriority</code> 中的任何一种进行排序的数据。</p>\n<p>对于 <code>WEventTypeChildAdded</code> 的理解可以看下面的这个例子：</p>\n<p>Objective-C </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获得新增加的数据</span></div><div class=\"line\">[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.value[<span class=\"string\">@\"author\"</span>]);</div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.value[<span class=\"string\">@\"title\"</span>]);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取一个我们帖子的引用</span></div><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获得新增加的数据</span></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(snapshot.value!.objectForKey(<span class=\"string\">\"author\"</span>))</div><div class=\"line\">    <span class=\"built_in\">print</span>(snapshot.value!.objectForKey(<span class=\"string\">\"title\"</span>))</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"一次性读取数据\"><a href=\"#一次性读取数据\" class=\"headerlink\" title=\"一次性读取数据\"></a>一次性读取数据</h2><p>在某些情况下，你可能希望只返回一次回调。（例如，在初始化时，预期 UI 元素不会再发生更改时）。你可以使用 <code>observeSingleEventOfType</code> 方法简化这种情况：</p>\n<p>添加的事件回调仅触发一次，以后不会再次触发。</p>\n<p>对于只需加载一次且预计不会频繁变化，或是我们需要主动拉取的数据，这非常有用。 例如，上述示例中的博客应用(<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\">博客实例数据库</a>)使用此方法，获取最初的博客数量，你会发现 <code>observeSingleEventOfType</code> 方法只回调了一次：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>];</div><div class=\"line\">__block <span class=\"built_in\">NSInteger</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">[ref observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    count++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"added -&gt; %@\"</span>, snapshot.value);</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 一次性读取数据。</span></div><div class=\"line\"><span class=\"comment\">// snapshot.childrenCount 等于 WEventTypeChildAdded 事件返回的 snapshot.value 数量的计数总和 </span></div><div class=\"line\"><span class=\"comment\">// WEventTypeValue 是最后触发的</span></div><div class=\"line\">[ref observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"initial data loaded! %d\"</span>, count == snapshot.childrenCount);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\"</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">count</span>:<span class=\"type\">UInt</span> = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">count</span>++</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"added -&gt; \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 一次性读取数据。</span></div><div class=\"line\"><span class=\"comment\">// snapshot.childrenCount 等于 .ChildAdded 事件返回的 snapshot.value 数量的计数总和</span></div><div class=\"line\"><span class=\"comment\">// .Value 是最后触发的</span></div><div class=\"line\">ref.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"initial data loaded! \\(count == snapshot.childrenCount)\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>野狗数据实时同步的事件监听有以下几个重要的保证：</p>\n<table>\n<thead>\n<tr>\n<th>监听事件的保证</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地数据状态发生了改变，事件就会触发</td>\n<td></td>\n</tr>\n<tr>\n<td>事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致</td>\n<td></td>\n</tr>\n<tr>\n<td>写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端</td>\n<td></td>\n</tr>\n<tr>\n<td>Value 事件总是最后触发，并且能保证包含快照（<code>snapshot</code>）生成之前的所有改变</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"移除监听\"><a href=\"#移除监听\" class=\"headerlink\" title=\"移除监听\"></a>移除监听</h2><p>当你退出 <code>ViewController</code> 时，观测程序不会自动停止同步数据。 如果未正确删除，观测程序会继续将数据同步到本地内存。 不再需要观测程序时，通过将关联的 <code>WilddogHandle</code> 传递给 <code>removeObserverWithHandle</code> 方法，即可将其删除。</p>\n<p>将回调快添加到引用时，会返回 <code>WilddogHandle</code>。这些句柄可用于删除回调块的监听。</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">WilddogHandle handle = [ref observeEventType:WEventTypeValue withBlock:^(WDatasnapshot* snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Snapshot value: %@\"</span>, snapshot.value)</div><div class=\"line\">&#125;];</div><div class=\"line\"></div><div class=\"line\">[ref removeObserverWithHandle:handle];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> handle = ref.observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Snapshot value: \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">ref.removeObserverWithHandle(handle)</div></pre></td></tr></table></figure>\n<p>如果已将多个侦听器添加到数据库引用，则会在引发事件时调用每个侦听器。 要在该位置停止同步数据，必须通过调用 <code>removeAllObservers</code> 方法删除其中的所有观测程序 (<code>removeAllObservers</code>方法的作用是取消之前用 <code>observeEventType</code>方法在该节点注册的所有监听事件。)。</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[ref removeAllObservers];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.removeAllObservers()</div></pre></td></tr></table></figure>\n<p>在父节点上调用 <code>removeObserverWithHandle</code> 或者 <code>removeAllObservers</code> 时不会删除在其子节点上注册的监听。你还必须跟踪这些引用或句柄才能将其删除。</p>\n<h2 id=\"排序和查询数据\"><a href=\"#排序和查询数据\" class=\"headerlink\" title=\"排序和查询数据\"></a>排序和查询数据</h2><p>你可以使用 <a href=\"/api/sync/ios.html#WQuery-Methods\">WQuery</a> 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。<br>只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。</p>\n<p><strong>注意</strong>：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 规则，以便在服务器上添加索引以提高查询性能。详细操作参见<a href=\"/guide/sync/rules/introduce.html#数据索引\">添加索引</a>。</p>\n<h4 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>对数据排序前，要先指定按照<code>键</code>、<code>值</code>、<code>子节点的值</code>或按<code>优先级</code>这四种的哪一种排序。对应的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>queryOrderedByKey</td>\n<td>按子键对结果排序。</td>\n</tr>\n<tr>\n<td>queryOrderedByValue</td>\n<td>按子值对结果排序。</td>\n</tr>\n<tr>\n<td>queryOrderedByChild</td>\n<td>按指定子键的值对结果排序。</td>\n</tr>\n<tr>\n<td>queryOrderedByPriority</td>\n<td>按节点的指定优先级对结果排序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。</p>\n<p><strong>按指定子键的值对结果排序</strong></p>\n<p>通过将子节点的路径名作为参数传递给<code>queryOrderedByChild:</code>，可以实现按指定子节点排序。例如，在恐龙的实例中（若要了解恐龙实例展示的数据结构，请点击<a href=\"https://dinosaur-facts.wilddogio.com/dinosaurs\">恐龙实例数据库</a>），要按照 height 进行排序，可以这样做：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ was %@ meters tall\"</span>, snapshot.key, snapshot.value[<span class=\"string\">@\"height\"</span>]);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> height = snapshot.value![<span class=\"string\">\"height\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"\\(snapshot.key) was \\(height) meters tall\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>按子键对结果排序</strong></p>\n<p>使用<code>queryOrderedByKey</code>函数，可以实现按照数据节点的名称进行排序。下面的例子按照 alpha 字母顺序读取所有的恐龙数据：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[ref queryOrderedByKey]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ was %@\"</span>, snapshot.key, snapshot.value[<span class=\"string\">@\"height\"</span>]);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByKey().observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> height = snapshot.value![<span class=\"string\">\"height\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"\\(snapshot.key) was \\(height)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>按子值对结果排序</strong></p>\n<p>使用<code>queryOrderedByValue</code>方法，我们可以按照子节点的值进行排序。假设恐龙们进行了一场运动会，我们统计到它们的得分数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要按照得分进行排序，我们可以构造一个这样的查询：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *scoresRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/scores\"</span>];</div><div class=\"line\">[[scoresRef queryOrderedByValue] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The %@ dinosaur's score is %@\"</span>, snapshot.key, snapshot.value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> scoresRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/scores\"</span>)</div><div class=\"line\">scoresRef.queryOrderedByValue().observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> score = snapshot.value <span class=\"keyword\">as</span>? <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The \\(snapshot.key) dinosaur's score is \\(score)\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>queryLimitedToFirst</td>\n<td>设置从第一条开始，一共返回多少条数据（节点）。</td>\n</tr>\n<tr>\n<td>queryLimitedToLast</td>\n<td>设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。</td>\n</tr>\n<tr>\n<td>queryStartingAtValue</td>\n<td>返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>queryEndingAtValue</td>\n<td>返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>queryEqualToValue</td>\n<td>返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。</td>\n</tr>\n</tbody>\n</table>\n<p>与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 <code>queryStartingAtValue</code> 与 <code>queryEndingAtValue</code> 方法将结果限制在指定的范围内。</p>\n<p><strong>限制结果数</strong></p>\n<p>你可以使用 <code>queryLimitedToFirst</code> 和 <code>lqueryLimitedToLast</code> 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 <code>queryLimitedToFirst</code> 将限制个数设置为 100，那么一开始最多只能收到 100 个 <code>WEventTypeChildAdded</code> 事件，即只返回前100条数据的快照。<br>当数据发生更改时，对于进入到前100的数据，你会接收到 <code>WEventTypeChildAdded</code> 回调，对于从前100中删除的数据，你才会接收到 <code>WEventTypeChildRemoved</code> 事件，也就是说只有这100条里的数据变化才会触发事件。</p>\n<p>继续恐龙（<a href=\"https://dinosaur-facts.wilddogio.com/dinosaurs\">恐龙实例数据库</a>）的例子，我们可以获得体重最大的两种恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"weight\"</span>] queryLimitedToLast:<span class=\"number\">2</span>] observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"weight\"</span>).queryLimitedToLast(<span class=\"number\">2</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们为<code>ChildAdded</code>事件绑定的回调方法只会被执行2次。</p>\n<p>同理，我们可以使用<code>queryLimitedToFirst:</code>方法查询最矮的两种恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryLimitedToFirst:<span class=\"number\">2</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryLimitedToFirst(<span class=\"number\">2</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们也可以组合<code>queryOrderedByValue</code>方法来使用 limit 类的查询。如果要构造出恐龙运动会得分的前3名，我们可以构造这样一个查询：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *scoresRef = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/scores\"</span>];</div><div class=\"line\">[[[scoresRef queryOrderedByValue] queryLimitedToLast:<span class=\"number\">3</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The %@ dinosaur's score is %@\"</span>, snapshot.key, snapshot.value);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> scoresRef = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/scores\"</span>)</div><div class=\"line\">scoresRef.queryOrderedByValue().queryLimitedToLast(<span class=\"number\">3</span>).observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The \\(snapshot.key) dinosaur's score is \\(snapshot.value)\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>range查询</strong></p>\n<p>使用<code>queryStartingAtValue:</code>，<code>queryEndingAtValue:</code>和<code>queryEqualToValue:</code>方法，可以为我们的查询指定任意的起止范围。如上面恐龙（<a href=\"https://dinosaur-facts.wilddogio.com/dinosaurs\">恐龙实例数据库</a>）的例子，如果要查询所有3米高以上的恐龙，可以组合<code>queryOrderByChild:</code>和<code>queryStartingAtValue:</code>查询：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryStartingAtValue:@<span class=\"number\">3</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryStartingAtValue(<span class=\"number\">3</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>按照字母排序，我们可以使用<code>queryEndingAtValue:</code>来查询所有名字排在 Pterodactyl 之前的恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByKey] queryEndingAtValue:<span class=\"string\">@\"pterodactyl\"</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByKey().queryEndingAtValue(<span class=\"string\">\"pterodactyl\"</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意，<code>queryStartingAtValue:</code>和<code>queryEndingAtValue:</code>是包含边界值的，也就是说“pterodactyl”符合上边的查询条件。</p>\n<p>我们可以同时使用<code>queryStartingAtValue:</code>和<code>queryStartingAtValue:</code>来限定一个范围。下面的例子查询出所有名字以字母“b”开头的恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[[ref queryOrderedByKey] queryStartingAtValue:<span class=\"string\">@\"b\"</span>] queryEndingAtValue:<span class=\"string\">@\"b\\uf8ff\"</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByKey().queryStartingAtValue(<span class=\"string\">\"b\"</span>).queryEndingAtValue(<span class=\"string\">\"b\\u&#123;f8ff&#125;\"</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这个例子中使用的“~”符号是 ASCII 中的126字符。因为它排在所有常规的 ASCII 字符之后，所以这个查询匹配所有以b开头的值。</p>\n<p>使用<code>queryEqualToValue:</code>函数，可以进行精准的查询。例如，查询所有的25米高的恐龙：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryEqualToValue:@<span class=\"number\">25</span>]</div><div class=\"line\">    observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, snapshot.key);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryEqualToValue(<span class=\"number\">25</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">ChildAdded</span>, withBlock: &#123; snapshot <span class=\"keyword\">in</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(snapshot.key)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p><strong>总结</strong><br>组合这些函数，我们可以构造出各种复杂的查询。例如，要找出长度小于 Stegosaurus 但最接近的恐龙的名字：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *ref = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>];</div><div class=\"line\">[[[ref childByAppendingPath:<span class=\"string\">@\"stegosaurus\"</span>] childByAppendingPath:<span class=\"string\">@\"height\"</span>]</div><div class=\"line\"> observeEventType:WEventTypeValue withBlock:^(WDataSnapshot *stegosaurusHeightSnapshot) &#123;</div><div class=\"line\">     <span class=\"built_in\">NSNumber</span> *favoriteDinoHeight = stegosaurusHeightSnapshot.value;</div><div class=\"line\">     WQuery *queryRef = [[[ref queryOrderedByChild:<span class=\"string\">@\"height\"</span>] queryEndingAtValue:favoriteDinoHeight] queryLimitedToLast:<span class=\"number\">2</span>];</div><div class=\"line\">     [queryRef observeSingleEventOfType:WEventTypeValue withBlock:^(WDataSnapshot *querySnapshot) &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span> (querySnapshot.childrenCount == <span class=\"number\">2</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">for</span> (WDataSnapshot* child <span class=\"keyword\">in</span> querySnapshot.children) &#123;</div><div class=\"line\">                 <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The dinosaur just shorter than the stegasaurus is %@\"</span>, child.key);</div><div class=\"line\">                 <span class=\"keyword\">break</span>;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"The stegosaurus is the shortest dino\"</span>);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;];</div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> ref = <span class=\"type\">Wilddog</span>(url:<span class=\"string\">\"https://dinosaur-facts.wilddogio.com/dinosaurs\"</span>)</div><div class=\"line\">ref.childByAppendingPath(<span class=\"string\">\"stegosaurus\"</span>).childByAppendingPath(<span class=\"string\">\"height\"</span>)</div><div class=\"line\">    .observeEventType(.<span class=\"type\">Value</span>, withBlock: &#123; stegosaurusHeightSnapshot <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> favoriteDinoHeight = stegosaurusHeightSnapshot.value <span class=\"keyword\">as</span>? <span class=\"type\">Double</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> queryRef = ref.queryOrderedByChild(<span class=\"string\">\"height\"</span>).queryEndingAtValue(favoriteDinoHeight).queryLimitedToLast(<span class=\"number\">2</span>)</div><div class=\"line\">            queryRef.observeSingleEventOfType(.<span class=\"type\">Value</span>, withBlock: &#123; querySnapshot <span class=\"keyword\">in</span></div><div class=\"line\">                <span class=\"keyword\">if</span> querySnapshot.childrenCount == <span class=\"number\">2</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">let</span> child: <span class=\"type\">WDataSnapshot</span> = querySnapshot.children.nextObject() <span class=\"keyword\">as</span>! <span class=\"type\">WDataSnapshot</span></div><div class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">\"The dinosaur just shorter than the stegasaurus is \\(child.key)\"</span>);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"string\">\"The stegosaurus is the shortest dino\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"数据排序-1\"><a href=\"#数据排序-1\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>本小节介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>queryOrderedByChild</strong></p>\n<p>当使用<code>queryOrderedByChild:</code>时，按照子节点的公有属性 key 的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果 key 属性有多种数据类型时，排序不固定，此时不建议使用<code>queryOrderedByChild:</code>获取全量数据，例如，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"no1\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"tyrannosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"string\">\"120\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no2\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"bruhathkayosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">55</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no3\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"lambeosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">21</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no6\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"stegosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">5</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no7\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"triceratops\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">22</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no8\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"brontosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是<code>NString</code>类型，雷龙的分数是<code>BOOL</code>类型，而其他恐龙的分数是<code>NSNumber</code>类型，此时使用<code>queryOrderedByChild:</code>获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>queryLimitedToFirst:</code>时，将获得不确定的结果。<code>NSObject</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>queryStartingAtValue:</code>、<code>queryEndingAtValue:</code>和<code>queryEqualToValue:</code>时，如果子节点的公有属性 key 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 <code>[[[ref queryOrderedByChild:@&quot;score&quot;]queryStartingAtValue:@60]queryLimitedToFirst:4]</code> 将得到下面的结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">       <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">       <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">   &#125;,</div><div class=\"line\">   <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">       <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">       <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p style='color:red'><em>注意：如果 path 与 value 的总长度超过1000字节时，使用 <code>queryOrderedByChild:</code> 将搜索不到该数据。</em></p>\n\n<p><strong>queryOrderedByKey</strong></p>\n<p>当使用<code>queryOrderedByKey</code>对数据进行排序时，数据将会按照下面的规则，以字段名升序排列返回。注意，节点名只能是字符串类型。</p>\n<p>1, 节点名能转换为 32-bit 整数的子节点优先，按数值型升序排列。</p>\n<p>2, 接下来是字符串类型的节点名，按字典序排列。</p>\n<p><strong>queryOrderedByValue</strong></p>\n<p>当使用<code>queryOrderedByValue</code>时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用<code>queryOrderedByValue</code>获取全量数据，例如，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"tyrannosaurus\"</span> : <span class=\"string\">\"120\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"attr\">\"brontosaurus\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是 <code>NSString</code>类型，雷龙的分数是 <code>BOOL</code> 类型，而其他恐龙的分数是 <code>NSNumber</code> 类型，此时使用 <code>queryOrderedByValue</code> 获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>queryLimitedToFirst:</code>时，将获得不确定的结果。<code>NSObject</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>queryStartingAtValue:</code>、<code>queryEndingAtValue:</code>和<code>queryEqualToValue:</code>时，如果子节点的 value 包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用<code>[[[ref queryOrderedByValue]queryStartingAtValue:@60]queryLimitedToFirst:4]</code>将得到下面的结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p style='color:red'><em>注意：如果 path 与 value 的总长度超过1000字节时，使用<code>queryOrderedByValue:</code>将搜索不到该数据。</em></p>\n\n<p><strong>queryOrderedByPriority</strong></p>\n<p>当使用<code>queryOrderedByPriority</code>对数据进行排序时，子节点数据将按照优先级和字段名进行排序。注意，优先级的值只能是数值型或字符串。</p>\n<p>1, 没有优先级的数据（默认）优先。</p>\n<p>2, 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。</p>\n<p>3, 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。</p>\n<p>4, 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。</p>\n"},{"title":"保存数据","_content":"\n以下四种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nsetValue | 将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 \nchildByAutoId | 添加到数据列表。每次调用 `childByAutoId` 时，Wilddog 均会生成唯一 ID，如 `user-posts/<user-id>/<unique-post-id>`。\nupdateChildValues | 更新节点的数据。不存在的子节点将会被新增，存在子节点依然存在。 \nrunTransactionBlock | 提供事务性更新，用于并发更新操作的场景。 \n\n## 用 setValue 写入数据\n\n`setValue` 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。\n`setValue` 可以传入几种数据类型 `NSString`, `NSNumber`, `NSDictionary`, `NSArray` 做为参数。\n例如，可以使用 `setValue` 方法来添加用户，如下所示：\n\nObjective-C\n\n```objectivec\n[[[_ref childByAppendingPath:@\"users\"] childByAppendingPath:user.uid] setValue:@{@\"username\": username}];\n\n```\n\nSwift\n\n```swift     \nself.ref.childByAppendingPath(\"users\").childByAppendingPath(user!.uid).setValue([\"username\": username])\n\n```\n\n以这种方式使用 \t`setValue` 将覆盖指定位置的数据，包括所有子节点。 但是，你仍可在不重写整个对象的情况下更新子节点。 如果要允许用户更新其个人资料，则可按照如下所示更新用户名：\n\nObjective-C\n\n```objectivec\n[[[[_ref childByAppendingPath:@\"users\"] childByAppendingPath:user.uid] childByAppendingPath:@\"username\"] setValue:username];\n    \n```\n\nSwift\n\n```swift\nself.ref.childByAppendingPath(\"users/(user.uid)/username\").setValue(username)\n\n```\n\n## 用 childByAutoId 追加新节点\n\n当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，Wilddog `childByAutoId` 采用了生成唯一 ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面调用 `childByAutoId`方法写数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。\n\n我们可以通过下面的方式来向博客 app 写入 posts 数据：\n\nObjective-C\n\n```objectivec\nWilddog *postRef = [ref childByAppendingPath: @\"posts\"];\nNSDictionary *post1 = @{\n    @\"author\": @\"gracehop\",\n    @\"title\": @\"Announcing COBOL, a New Programming Language\"\n};\nWilddog *post1Ref = [ref childByAutoId];\n[post1Ref setValue: post1];\n\nNSDictionary *post2 = @{\n    @\"author\": @\"alanisawesome\",\n    @\"title\": @\"The Turing Machine\"\n};\nWilddog *post2Ref = [ref childByAutoId];\n[post2Ref setValue: post2];\n\n```\n\nSwift\n\n```swift\nlet postRef = ref.childByAppendingPath(\"posts\")\nlet post1 = [\"author\": \"gracehop\", \"title\": \"Announcing COBOL, a New Programming Language\"]\nlet post1Ref = postRef.childByAutoId()\npost1Ref.setValue(post1)\n\nlet post2 = [\"author\": \"alanisawesome\", \"title\": \"The Turing Machine\"]\nlet post2Ref = postRef.childByAutoId()\npost2Ref.setValue(post2)\n\n```\n\n由于使用了 `childByAutoId` 方法为每个博客 post 生成了基于时间戳的唯一标识，即使多个用户同时添加博客 post 也不会产生冲突。Wilddog 数据库中的数据结构如下：\n\n```json\n{\n  \"posts\": {\n    \"-JRHTHaIs-jNPLXOQivY\": {\n      \"author\": \"gracehop\",\n      \"title\": \"Announcing COBOL, a New Programming Language\"\n     },\n    \"-JRHTHaKuITFIhnj02kE\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n\n```\n\n## 用 updateChildValues 更新数据\n\n要同时向一个节点的特定子节点写入数据，而不覆盖其他子节点，请使用 `updateChildValues` 方法。\n\n例如，社交博客应用可能要创建一篇博文，同时将其更新为最新的活动源和发布用户的活动源。  \n为此，该博客应用使用如下代码\n\nObjective-C\n\n```objectivec\nNSString *key = [[_ref childByAppendingPath:@\"posts\"] childByAutoId].key;\nNSDictionary *post = @{@\"uid\": userID,\n                       @\"author\": username,\n                       @\"title\": title,\n                       @\"body\": body};\nNSDictionary *childUpdates = @{[@\"/posts/\" stringByAppendingString:key]: post,\n                               [NSString stringWithFormat:@\"/user-posts/%@/%@/\", userID, key]: post};\n[_ref updateChildValues:childUpdates];\n\n```\n\nSwift\n\n```swift\nlet key = ref.childByAppendingPath(\"posts\").childByAutoId().key\nlet post = [\"uid\": userID,\n            \"author\": username,\n            \"title\": title,\n            \"body\": body]\nlet childUpdates = [\"/posts/\\(key)\": post,\n                    \"/user-posts/\\(userID)/\\(key)/\": post]\nref.updateChildValues(childUpdates)\n\n```\n\n此示例使用 `childByAutoId` 在节点（其中包含 `/posts/$postid` 内所有用户博文）中创建一篇博文，同时使用 `getKey` 检索相应键。\n\n然后，可以使用该键在用户博文（位于 `/user-posts/$userid/$postid` 内）中创建第二个条目。\n\n通过使用这些路径，只需调用 `updateChildValues` 一次即可同步更新 JSON 树中的多个位置，例如，该示例如何在两个位置同时创建新博文。\n\n通过这种方式同步更新具有原子性：要么所有更新全部成功，要么全部失败。\n\n## 事务操作\n\n处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。\n\n更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。\n\n例如，在示例社交微博应用中，如果记录某篇微博的点赞数，使用事务处理可防止加点赞数时计数出错，保证数据的安全性和准确性，如下所示：\n\nObjective-C\n\n```objectivec\nWilddog *upvotesRef = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"];\n    \n[upvotesRef runTransactionBlock:^WTransactionResult *(WMutableData *currentData) {\n    NSNumber *value = currentData.value;\n    if (currentData.value == [NSNull null]) {\n        value = 0;\n    }\n    [currentData setValue:[NSNumber numberWithInt:(1 + [value intValue])]];\n    return [WTransactionResult successWithValue:currentData];\n}];\n\n```\n\nSwift\n\n```swift\nlet upvotesRef = Wilddog(url: \"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\")\n        \nupvotesRef.runTransactionBlock({\n     (currentData:WMutableData!) in\n     var value = currentData.value as? Int\n     if (value == nil) {\n         value = 0\n     }\n     currentData.value = value! + 1\n     return WTransactionResult.successWithValue(currentData)\n})\n\n```","source":"guide/sync/ios/save-data.md","raw":"title:  保存数据\n---\n\n以下四种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nsetValue | 将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 \nchildByAutoId | 添加到数据列表。每次调用 `childByAutoId` 时，Wilddog 均会生成唯一 ID，如 `user-posts/<user-id>/<unique-post-id>`。\nupdateChildValues | 更新节点的数据。不存在的子节点将会被新增，存在子节点依然存在。 \nrunTransactionBlock | 提供事务性更新，用于并发更新操作的场景。 \n\n## 用 setValue 写入数据\n\n`setValue` 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。\n`setValue` 可以传入几种数据类型 `NSString`, `NSNumber`, `NSDictionary`, `NSArray` 做为参数。\n例如，可以使用 `setValue` 方法来添加用户，如下所示：\n\nObjective-C\n\n```objectivec\n[[[_ref childByAppendingPath:@\"users\"] childByAppendingPath:user.uid] setValue:@{@\"username\": username}];\n\n```\n\nSwift\n\n```swift     \nself.ref.childByAppendingPath(\"users\").childByAppendingPath(user!.uid).setValue([\"username\": username])\n\n```\n\n以这种方式使用 \t`setValue` 将覆盖指定位置的数据，包括所有子节点。 但是，你仍可在不重写整个对象的情况下更新子节点。 如果要允许用户更新其个人资料，则可按照如下所示更新用户名：\n\nObjective-C\n\n```objectivec\n[[[[_ref childByAppendingPath:@\"users\"] childByAppendingPath:user.uid] childByAppendingPath:@\"username\"] setValue:username];\n    \n```\n\nSwift\n\n```swift\nself.ref.childByAppendingPath(\"users/(user.uid)/username\").setValue(username)\n\n```\n\n## 用 childByAutoId 追加新节点\n\n当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，Wilddog `childByAutoId` 采用了生成唯一 ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面调用 `childByAutoId`方法写数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。\n\n我们可以通过下面的方式来向博客 app 写入 posts 数据：\n\nObjective-C\n\n```objectivec\nWilddog *postRef = [ref childByAppendingPath: @\"posts\"];\nNSDictionary *post1 = @{\n    @\"author\": @\"gracehop\",\n    @\"title\": @\"Announcing COBOL, a New Programming Language\"\n};\nWilddog *post1Ref = [ref childByAutoId];\n[post1Ref setValue: post1];\n\nNSDictionary *post2 = @{\n    @\"author\": @\"alanisawesome\",\n    @\"title\": @\"The Turing Machine\"\n};\nWilddog *post2Ref = [ref childByAutoId];\n[post2Ref setValue: post2];\n\n```\n\nSwift\n\n```swift\nlet postRef = ref.childByAppendingPath(\"posts\")\nlet post1 = [\"author\": \"gracehop\", \"title\": \"Announcing COBOL, a New Programming Language\"]\nlet post1Ref = postRef.childByAutoId()\npost1Ref.setValue(post1)\n\nlet post2 = [\"author\": \"alanisawesome\", \"title\": \"The Turing Machine\"]\nlet post2Ref = postRef.childByAutoId()\npost2Ref.setValue(post2)\n\n```\n\n由于使用了 `childByAutoId` 方法为每个博客 post 生成了基于时间戳的唯一标识，即使多个用户同时添加博客 post 也不会产生冲突。Wilddog 数据库中的数据结构如下：\n\n```json\n{\n  \"posts\": {\n    \"-JRHTHaIs-jNPLXOQivY\": {\n      \"author\": \"gracehop\",\n      \"title\": \"Announcing COBOL, a New Programming Language\"\n     },\n    \"-JRHTHaKuITFIhnj02kE\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n\n```\n\n## 用 updateChildValues 更新数据\n\n要同时向一个节点的特定子节点写入数据，而不覆盖其他子节点，请使用 `updateChildValues` 方法。\n\n例如，社交博客应用可能要创建一篇博文，同时将其更新为最新的活动源和发布用户的活动源。  \n为此，该博客应用使用如下代码\n\nObjective-C\n\n```objectivec\nNSString *key = [[_ref childByAppendingPath:@\"posts\"] childByAutoId].key;\nNSDictionary *post = @{@\"uid\": userID,\n                       @\"author\": username,\n                       @\"title\": title,\n                       @\"body\": body};\nNSDictionary *childUpdates = @{[@\"/posts/\" stringByAppendingString:key]: post,\n                               [NSString stringWithFormat:@\"/user-posts/%@/%@/\", userID, key]: post};\n[_ref updateChildValues:childUpdates];\n\n```\n\nSwift\n\n```swift\nlet key = ref.childByAppendingPath(\"posts\").childByAutoId().key\nlet post = [\"uid\": userID,\n            \"author\": username,\n            \"title\": title,\n            \"body\": body]\nlet childUpdates = [\"/posts/\\(key)\": post,\n                    \"/user-posts/\\(userID)/\\(key)/\": post]\nref.updateChildValues(childUpdates)\n\n```\n\n此示例使用 `childByAutoId` 在节点（其中包含 `/posts/$postid` 内所有用户博文）中创建一篇博文，同时使用 `getKey` 检索相应键。\n\n然后，可以使用该键在用户博文（位于 `/user-posts/$userid/$postid` 内）中创建第二个条目。\n\n通过使用这些路径，只需调用 `updateChildValues` 一次即可同步更新 JSON 树中的多个位置，例如，该示例如何在两个位置同时创建新博文。\n\n通过这种方式同步更新具有原子性：要么所有更新全部成功，要么全部失败。\n\n## 事务操作\n\n处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。\n\n更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。\n\n例如，在示例社交微博应用中，如果记录某篇微博的点赞数，使用事务处理可防止加点赞数时计数出错，保证数据的安全性和准确性，如下所示：\n\nObjective-C\n\n```objectivec\nWilddog *upvotesRef = [[Wilddog alloc] initWithUrl: @\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"];\n    \n[upvotesRef runTransactionBlock:^WTransactionResult *(WMutableData *currentData) {\n    NSNumber *value = currentData.value;\n    if (currentData.value == [NSNull null]) {\n        value = 0;\n    }\n    [currentData setValue:[NSNumber numberWithInt:(1 + [value intValue])]];\n    return [WTransactionResult successWithValue:currentData];\n}];\n\n```\n\nSwift\n\n```swift\nlet upvotesRef = Wilddog(url: \"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\")\n        \nupvotesRef.runTransactionBlock({\n     (currentData:WMutableData!) in\n     var value = currentData.value as? Int\n     if (value == nil) {\n         value = 0\n     }\n     currentData.value = value! + 1\n     return WTransactionResult.successWithValue(currentData)\n})\n\n```","date":"2016-09-06T03:38:22.542Z","updated":"2016-09-06T03:38:22.542Z","path":"guide/sync/ios/save-data.html","comments":1,"layout":"page","_id":"cisswi9lg001wz4fw2g47qax8","content":"<p>以下四种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setValue</td>\n<td>将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>childByAutoId</td>\n<td>添加到数据列表。每次调用 <code>childByAutoId</code> 时，Wilddog 均会生成唯一 ID，如 <code>user-posts/&lt;user-id&gt;/&lt;unique-post-id&gt;</code>。</td>\n</tr>\n<tr>\n<td>updateChildValues</td>\n<td>更新节点的数据。不存在的子节点将会被新增，存在子节点依然存在。 </td>\n</tr>\n<tr>\n<td>runTransactionBlock</td>\n<td>提供事务性更新，用于并发更新操作的场景。 </td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用-setValue-写入数据\"><a href=\"#用-setValue-写入数据\" class=\"headerlink\" title=\"用 setValue 写入数据\"></a>用 setValue 写入数据</h2><p><code>setValue</code> 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。<br><code>setValue</code> 可以传入几种数据类型 <code>NSString</code>, <code>NSNumber</code>, <code>NSDictionary</code>, <code>NSArray</code> 做为参数。<br>例如，可以使用 <code>setValue</code> 方法来添加用户，如下所示：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[[_ref childByAppendingPath:<span class=\"string\">@\"users\"</span>] childByAppendingPath:user.uid] setValue:@&#123;<span class=\"string\">@\"username\"</span>: username&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.ref.childByAppendingPath(<span class=\"string\">\"users\"</span>).childByAppendingPath(user!.uid).setValue([<span class=\"string\">\"username\"</span>: username])</div></pre></td></tr></table></figure>\n<p>以这种方式使用     <code>setValue</code> 将覆盖指定位置的数据，包括所有子节点。 但是，你仍可在不重写整个对象的情况下更新子节点。 如果要允许用户更新其个人资料，则可按照如下所示更新用户名：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[[[_ref childByAppendingPath:<span class=\"string\">@\"users\"</span>] childByAppendingPath:user.uid] childByAppendingPath:<span class=\"string\">@\"username\"</span>] setValue:username];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.ref.childByAppendingPath(<span class=\"string\">\"users/(user.uid)/username\"</span>).setValue(username)</div></pre></td></tr></table></figure>\n<h2 id=\"用-childByAutoId-追加新节点\"><a href=\"#用-childByAutoId-追加新节点\" class=\"headerlink\" title=\"用 childByAutoId 追加新节点\"></a>用 childByAutoId 追加新节点</h2><p>当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，Wilddog <code>childByAutoId</code> 采用了生成唯一 ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面调用 <code>childByAutoId</code>方法写数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>我们可以通过下面的方式来向博客 app 写入 posts 数据：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *postRef = [ref childByAppendingPath: <span class=\"string\">@\"posts\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *post1 = @&#123;</div><div class=\"line\">    <span class=\"string\">@\"author\"</span>: <span class=\"string\">@\"gracehop\"</span>,</div><div class=\"line\">    <span class=\"string\">@\"title\"</span>: <span class=\"string\">@\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">Wilddog *post1Ref = [ref childByAutoId];</div><div class=\"line\">[post1Ref setValue: post1];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *post2 = @&#123;</div><div class=\"line\">    <span class=\"string\">@\"author\"</span>: <span class=\"string\">@\"alanisawesome\"</span>,</div><div class=\"line\">    <span class=\"string\">@\"title\"</span>: <span class=\"string\">@\"The Turing Machine\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">Wilddog *post2Ref = [ref childByAutoId];</div><div class=\"line\">[post2Ref setValue: post2];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> postRef = ref.childByAppendingPath(<span class=\"string\">\"posts\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> post1 = [<span class=\"string\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>, <span class=\"string\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> post1Ref = postRef.childByAutoId()</div><div class=\"line\">post1Ref.setValue(post1)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> post2 = [<span class=\"string\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>, <span class=\"string\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> post2Ref = postRef.childByAutoId()</div><div class=\"line\">post2Ref.setValue(post2)</div></pre></td></tr></table></figure>\n<p>由于使用了 <code>childByAutoId</code> 方法为每个博客 post 生成了基于时间戳的唯一标识，即使多个用户同时添加博客 post 也不会产生冲突。Wilddog 数据库中的数据结构如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"posts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaIs-jNPLXOQivY\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">     &#125;,</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaKuITFIhnj02kE\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"用-updateChildValues-更新数据\"><a href=\"#用-updateChildValues-更新数据\" class=\"headerlink\" title=\"用 updateChildValues 更新数据\"></a>用 updateChildValues 更新数据</h2><p>要同时向一个节点的特定子节点写入数据，而不覆盖其他子节点，请使用 <code>updateChildValues</code> 方法。</p>\n<p>例如，社交博客应用可能要创建一篇博文，同时将其更新为最新的活动源和发布用户的活动源。<br>为此，该博客应用使用如下代码</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *key = [[_ref childByAppendingPath:<span class=\"string\">@\"posts\"</span>] childByAutoId].key;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *post = @&#123;<span class=\"string\">@\"uid\"</span>: userID,</div><div class=\"line\">                       <span class=\"string\">@\"author\"</span>: username,</div><div class=\"line\">                       <span class=\"string\">@\"title\"</span>: title,</div><div class=\"line\">                       <span class=\"string\">@\"body\"</span>: body&#125;;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *childUpdates = @&#123;[<span class=\"string\">@\"/posts/\"</span> stringByAppendingString:key]: post,</div><div class=\"line\">                               [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"/user-posts/%@/%@/\"</span>, userID, key]: post&#125;;</div><div class=\"line\">[_ref updateChildValues:childUpdates];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> key = ref.childByAppendingPath(<span class=\"string\">\"posts\"</span>).childByAutoId().key</div><div class=\"line\"><span class=\"keyword\">let</span> post = [<span class=\"string\">\"uid\"</span>: userID,</div><div class=\"line\">            <span class=\"string\">\"author\"</span>: username,</div><div class=\"line\">            <span class=\"string\">\"title\"</span>: title,</div><div class=\"line\">            <span class=\"string\">\"body\"</span>: body]</div><div class=\"line\"><span class=\"keyword\">let</span> childUpdates = [<span class=\"string\">\"/posts/\\(key)\"</span>: post,</div><div class=\"line\">                    <span class=\"string\">\"/user-posts/\\(userID)/\\(key)/\"</span>: post]</div><div class=\"line\">ref.updateChildValues(childUpdates)</div></pre></td></tr></table></figure>\n<p>此示例使用 <code>childByAutoId</code> 在节点（其中包含 <code>/posts/$postid</code> 内所有用户博文）中创建一篇博文，同时使用 <code>getKey</code> 检索相应键。</p>\n<p>然后，可以使用该键在用户博文（位于 <code>/user-posts/$userid/$postid</code> 内）中创建第二个条目。</p>\n<p>通过使用这些路径，只需调用 <code>updateChildValues</code> 一次即可同步更新 JSON 树中的多个位置，例如，该示例如何在两个位置同时创建新博文。</p>\n<p>通过这种方式同步更新具有原子性：要么所有更新全部成功，要么全部失败。</p>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。</p>\n<p>更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。</p>\n<p>例如，在示例社交微博应用中，如果记录某篇微博的点赞数，使用事务处理可防止加点赞数时计数出错，保证数据的安全性和准确性，如下所示：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *upvotesRef = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>];</div><div class=\"line\">    </div><div class=\"line\">[upvotesRef runTransactionBlock:^WTransactionResult *(WMutableData *currentData) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSNumber</span> *value = currentData.value;</div><div class=\"line\">    <span class=\"keyword\">if</span> (currentData.value == [<span class=\"built_in\">NSNull</span> null]) &#123;</div><div class=\"line\">        value = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [currentData setValue:[<span class=\"built_in\">NSNumber</span> numberWithInt:(<span class=\"number\">1</span> + [value intValue])]];</div><div class=\"line\">    <span class=\"keyword\">return</span> [WTransactionResult successWithValue:currentData];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> upvotesRef = <span class=\"type\">Wilddog</span>(url: <span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>)</div><div class=\"line\">        </div><div class=\"line\">upvotesRef.runTransactionBlock(&#123;</div><div class=\"line\">     (currentData:<span class=\"type\">WMutableData</span>!) <span class=\"keyword\">in</span></div><div class=\"line\">     <span class=\"keyword\">var</span> value = currentData.value <span class=\"keyword\">as</span>? <span class=\"type\">Int</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (value == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">         value = <span class=\"number\">0</span></div><div class=\"line\">     &#125;</div><div class=\"line\">     currentData.value = value! + <span class=\"number\">1</span></div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"type\">WTransactionResult</span>.successWithValue(currentData)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","excerpt":"","more":"<p>以下四种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setValue</td>\n<td>将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>childByAutoId</td>\n<td>添加到数据列表。每次调用 <code>childByAutoId</code> 时，Wilddog 均会生成唯一 ID，如 <code>user-posts/&lt;user-id&gt;/&lt;unique-post-id&gt;</code>。</td>\n</tr>\n<tr>\n<td>updateChildValues</td>\n<td>更新节点的数据。不存在的子节点将会被新增，存在子节点依然存在。 </td>\n</tr>\n<tr>\n<td>runTransactionBlock</td>\n<td>提供事务性更新，用于并发更新操作的场景。 </td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"用-setValue-写入数据\"><a href=\"#用-setValue-写入数据\" class=\"headerlink\" title=\"用 setValue 写入数据\"></a>用 setValue 写入数据</h2><p><code>setValue</code> 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。<br><code>setValue</code> 可以传入几种数据类型 <code>NSString</code>, <code>NSNumber</code>, <code>NSDictionary</code>, <code>NSArray</code> 做为参数。<br>例如，可以使用 <code>setValue</code> 方法来添加用户，如下所示：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[[_ref childByAppendingPath:<span class=\"string\">@\"users\"</span>] childByAppendingPath:user.uid] setValue:@&#123;<span class=\"string\">@\"username\"</span>: username&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.ref.childByAppendingPath(<span class=\"string\">\"users\"</span>).childByAppendingPath(user!.uid).setValue([<span class=\"string\">\"username\"</span>: username])</div></pre></td></tr></table></figure>\n<p>以这种方式使用     <code>setValue</code> 将覆盖指定位置的数据，包括所有子节点。 但是，你仍可在不重写整个对象的情况下更新子节点。 如果要允许用户更新其个人资料，则可按照如下所示更新用户名：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[[[_ref childByAppendingPath:<span class=\"string\">@\"users\"</span>] childByAppendingPath:user.uid] childByAppendingPath:<span class=\"string\">@\"username\"</span>] setValue:username];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.ref.childByAppendingPath(<span class=\"string\">\"users/(user.uid)/username\"</span>).setValue(username)</div></pre></td></tr></table></figure>\n<h2 id=\"用-childByAutoId-追加新节点\"><a href=\"#用-childByAutoId-追加新节点\" class=\"headerlink\" title=\"用 childByAutoId 追加新节点\"></a>用 childByAutoId 追加新节点</h2><p>当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，Wilddog <code>childByAutoId</code> 采用了生成唯一 ID 作为 key 的方式。通过这种方式，多个用户同时在一个节点下面调用 <code>childByAutoId</code>方法写数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>我们可以通过下面的方式来向博客 app 写入 posts 数据：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *postRef = [ref childByAppendingPath: <span class=\"string\">@\"posts\"</span>];</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *post1 = @&#123;</div><div class=\"line\">    <span class=\"string\">@\"author\"</span>: <span class=\"string\">@\"gracehop\"</span>,</div><div class=\"line\">    <span class=\"string\">@\"title\"</span>: <span class=\"string\">@\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">Wilddog *post1Ref = [ref childByAutoId];</div><div class=\"line\">[post1Ref setValue: post1];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *post2 = @&#123;</div><div class=\"line\">    <span class=\"string\">@\"author\"</span>: <span class=\"string\">@\"alanisawesome\"</span>,</div><div class=\"line\">    <span class=\"string\">@\"title\"</span>: <span class=\"string\">@\"The Turing Machine\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">Wilddog *post2Ref = [ref childByAutoId];</div><div class=\"line\">[post2Ref setValue: post2];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> postRef = ref.childByAppendingPath(<span class=\"string\">\"posts\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> post1 = [<span class=\"string\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>, <span class=\"string\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> post1Ref = postRef.childByAutoId()</div><div class=\"line\">post1Ref.setValue(post1)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> post2 = [<span class=\"string\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>, <span class=\"string\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> post2Ref = postRef.childByAutoId()</div><div class=\"line\">post2Ref.setValue(post2)</div></pre></td></tr></table></figure>\n<p>由于使用了 <code>childByAutoId</code> 方法为每个博客 post 生成了基于时间戳的唯一标识，即使多个用户同时添加博客 post 也不会产生冲突。Wilddog 数据库中的数据结构如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"posts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaIs-jNPLXOQivY\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">     &#125;,</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaKuITFIhnj02kE\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"用-updateChildValues-更新数据\"><a href=\"#用-updateChildValues-更新数据\" class=\"headerlink\" title=\"用 updateChildValues 更新数据\"></a>用 updateChildValues 更新数据</h2><p>要同时向一个节点的特定子节点写入数据，而不覆盖其他子节点，请使用 <code>updateChildValues</code> 方法。</p>\n<p>例如，社交博客应用可能要创建一篇博文，同时将其更新为最新的活动源和发布用户的活动源。<br>为此，该博客应用使用如下代码</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *key = [[_ref childByAppendingPath:<span class=\"string\">@\"posts\"</span>] childByAutoId].key;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *post = @&#123;<span class=\"string\">@\"uid\"</span>: userID,</div><div class=\"line\">                       <span class=\"string\">@\"author\"</span>: username,</div><div class=\"line\">                       <span class=\"string\">@\"title\"</span>: title,</div><div class=\"line\">                       <span class=\"string\">@\"body\"</span>: body&#125;;</div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *childUpdates = @&#123;[<span class=\"string\">@\"/posts/\"</span> stringByAppendingString:key]: post,</div><div class=\"line\">                               [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"/user-posts/%@/%@/\"</span>, userID, key]: post&#125;;</div><div class=\"line\">[_ref updateChildValues:childUpdates];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> key = ref.childByAppendingPath(<span class=\"string\">\"posts\"</span>).childByAutoId().key</div><div class=\"line\"><span class=\"keyword\">let</span> post = [<span class=\"string\">\"uid\"</span>: userID,</div><div class=\"line\">            <span class=\"string\">\"author\"</span>: username,</div><div class=\"line\">            <span class=\"string\">\"title\"</span>: title,</div><div class=\"line\">            <span class=\"string\">\"body\"</span>: body]</div><div class=\"line\"><span class=\"keyword\">let</span> childUpdates = [<span class=\"string\">\"/posts/\\(key)\"</span>: post,</div><div class=\"line\">                    <span class=\"string\">\"/user-posts/\\(userID)/\\(key)/\"</span>: post]</div><div class=\"line\">ref.updateChildValues(childUpdates)</div></pre></td></tr></table></figure>\n<p>此示例使用 <code>childByAutoId</code> 在节点（其中包含 <code>/posts/$postid</code> 内所有用户博文）中创建一篇博文，同时使用 <code>getKey</code> 检索相应键。</p>\n<p>然后，可以使用该键在用户博文（位于 <code>/user-posts/$userid/$postid</code> 内）中创建第二个条目。</p>\n<p>通过使用这些路径，只需调用 <code>updateChildValues</code> 一次即可同步更新 JSON 树中的多个位置，例如，该示例如何在两个位置同时创建新博文。</p>\n<p>通过这种方式同步更新具有原子性：要么所有更新全部成功，要么全部失败。</p>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。</p>\n<p>更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。</p>\n<p>例如，在示例社交微博应用中，如果记录某篇微博的点赞数，使用事务处理可防止加点赞数时计数出错，保证数据的安全性和准确性，如下所示：</p>\n<p>Objective-C</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog *upvotesRef = [[Wilddog alloc] initWithUrl: <span class=\"string\">@\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>];</div><div class=\"line\">    </div><div class=\"line\">[upvotesRef runTransactionBlock:^WTransactionResult *(WMutableData *currentData) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSNumber</span> *value = currentData.value;</div><div class=\"line\">    <span class=\"keyword\">if</span> (currentData.value == [<span class=\"built_in\">NSNull</span> null]) &#123;</div><div class=\"line\">        value = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [currentData setValue:[<span class=\"built_in\">NSNumber</span> numberWithInt:(<span class=\"number\">1</span> + [value intValue])]];</div><div class=\"line\">    <span class=\"keyword\">return</span> [WTransactionResult successWithValue:currentData];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>Swift</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> upvotesRef = <span class=\"type\">Wilddog</span>(url: <span class=\"string\">\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>)</div><div class=\"line\">        </div><div class=\"line\">upvotesRef.runTransactionBlock(&#123;</div><div class=\"line\">     (currentData:<span class=\"type\">WMutableData</span>!) <span class=\"keyword\">in</span></div><div class=\"line\">     <span class=\"keyword\">var</span> value = currentData.value <span class=\"keyword\">as</span>? <span class=\"type\">Int</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (value == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">         value = <span class=\"number\">0</span></div><div class=\"line\">     &#125;</div><div class=\"line\">     currentData.value = value! + <span class=\"number\">1</span></div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"type\">WTransactionResult</span>.successWithValue(currentData)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"title":"REST 完整指南","_content":"\n## 使用入门\n\n在任何支持HTTPS的平台和语言中，都可以使用Wilddog REST API。在本指南中，我们使用命令行工具发送HTTPS请求。其他任何平台都可以参照该示例，使用 REST API。\n\n### 数据是一棵 JSON 树\n\n所有的数据都存储在各个 JSON 对象中，没有任何表的概念。当你把数据添加到这棵json 树中，这些数据就变成这棵树的子树。比如，我们在`users/mchen` 下增加 `widget`后，我们的数据是这样的:\n\n```\n{\n  \"users\": {\n    \"mchen\": {\n      \"friends\": { \"brinchen\": true },\n      \"name\": \"Mary Chen\",\n      // 新数据节点会增加在已经存在的JSON树中\n      \"widgets\": { \"one\": true, \"three\": true }\n    },\n    \"brinchen\": { ... },\n    \"hmadi\": { ... }\n  }\n}\n```\n\n### 使用数据URL\n\n通过REST API读取和写入数据时，我们在`curl`请求中包含一个指向数据地址的URL，这个URL会指向我们存储的所有数据。在这个示例中，我们将使用`https://docs-examples.wilddogio.com/web/data`这个地址。\n\n也可以直接访问子节点的数据，例如，要访问Mary Chen的name，只需要在URL之后追加`users/mchen/name`即可。\n\n```\ncurl https://docs-examples.wilddogio.com/web/data/users/mchen/name.json\n\n```\n\n### 限制和约束\n\n| 描述约束备注           |          |                                          |\n| :--------------- | :------- | :--------------------------------------- |\n| 树的深度             | 32       |                                          |\n| key的长度           | 768bytes | UTF-8 编码，不能包含`.` `$` `#` `[` `]` `/`和 ASCII控制字符0-31和127 |\n| 一个叶子节点的数据大小      | 1mb      | UTF-8 编码                                 |\n| 通过SDK写入的数据大小限制   | 2mb      | UTF-8 编码                                 |\n| 通过 REST 写入数据大小限制 | 4mb      |                                          |\n| 一次能读取的节点         | 2000     |                                          |\n| 一次条件查询能返回的最大条数   | 500      | 如使用 limitToFirst、limitToLast等            |\n\n### 特殊字符转义\n\n当节点的key值是特殊字符时可能导致发送的curl请求URL无效，此时我们需要将特殊字符转义\n\n| 特殊字符转义符 |      |\n| :------ | :--- |\n| ?       | %3F  |\n| %       | %25  |\n| +       | %2B  |\n| =       | %3D  |\n| &       | %26  |\n\n\n\n## 组织数据\n\n构造恰当的NoSQL存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。\n\n### 避免层级过深\n\n尽管可以使用JSON任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog的工作方式是当你查询某个节点，Wilddog会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织SQL关系型数据表一样。\n\n我们不推荐这种实践\n\n```js\n{\n    // 一个非常差的充满嵌套的数据结构。请勿模仿。\n    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\",\n        \"messages\": {\n          \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n          \"m2\": { ... },\n          // 非常长的messages列表\n        }\n      }\n    }\n}\n\n```\n\n对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的rooms这样一个很简单的操作，也会查询整个`rooms`数据节点，返回所有的rooms下的数据节点到客户端。\n\n### 使数据扁平化\n\n如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：\n\n```\n{\n    // rooms数据节点下仅包含房间的基本信息和唯一ID。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\"\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    },\n\n    //room成员可以很方便的的存取\n    \"members\": {\n      \"one\": {\n        \"mchen\": true,\n        \"hmadi\": true\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n\n    },\n\n    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。\n    //消息数据可以通过room ID方便的分页和查询。\n    \"messages\": {\n      \"one\": {\n        \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n        \"m2\": { ... },\n        \"m3\": { ... }\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    }\n\n  }\n```\n\n这样组织数据，就可以很方便的查询room列表了，只需要传输很少的字节数。message数据也可以很容易的查询。\n\n### 使数据可扩展\n\n很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：\n\n```\n{\n    \"users\": {\n      \"john\": {\n         \"todoList\": {\n            \"rec1\": \"Walk the dog\",\n            \"rec2\": \"Buy milk\",\n            \"rec3\": \"Win a gold medal in the Olympics\"\n         }\n      }\n    }\n  }\n\n```\n\n但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John可能有一个长达数千项的todo列表）。\n\n但仅仅如此可能还是不够的。考虑一个例子，users和groups之间的双向关系。user可以属于group，group包含一个user列表。乍看之下数据可能这样组织：\n\n```\n{\n    \"users\": {\n      \"mchen\": { \"name\": \"Mary Chen\" },\n      \"brinchen\": { \"name\": \"Byambyn Rinchen\" },\n      \"hmadi\": { \"name\": \"Hamadi Madi\" }\n    },\n    \"groups\": {\n      \"alpha\": {\n         \"name\": \"Alpha Tango\",\n         \"members\": {\n            \"m1\": \"mchen\",\n            \"m2\": \"brinchen\",\n            \"m3\": \"hamadi\"\n         }\n      },\n      \"bravo\": { ... },\n      \"charlie\": { ... }\n    }\n  }\n\n```\n\n看起来不错。但是当需要判断一个user属于哪些group的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的group，但这样做成本很高，也很慢。更糟糕的是，如果Mary没有权限查看所有的group时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。\n\n我们需要的是一种优雅的方式，可以列出Mary属于哪些group，只需要查询这些group就行了。数据可以这样组织：\n\n```js\n{\n    \"users\": {\n      \"mchen\": {\n        \"name\": \"Mary Chen\",\n        // 在Mary的数据下，建立他所属group的索引。\n        \"groups\": {\n           // 这里的值是什么并不重要。重要的是这个子节点的key存在。\n           \"alpha\": true,\n           \"charlie\": true\n        }\n      },\n      ...\n    },\n    \"groups\": { ... }\n  }\n\n```\n\n我们把关系数据同时存储在了Mary的记录下和group数据下，这样造成了数据的重复。如果要把Mary从一个组中删除，就需要更新两个地方。\n\n对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询Mary的个人信息，即使users和groups都有百万级的数据，且规则表达式禁止访问不相关的数据时。\n\n为什么我们把id作为key，而把value设置为`true`呢？这样做是有好处的。这样使得检查一个id是否存在变得非常简单，只需要读取`/users/mchen/groups/$group_id`，看它是否为null就可以了。\n\n\n\n## 操作数据\n\n### 操作数据的方式\n\n| method说明 |                                          |\n| :------- | :--------------------------------------- |\n| PUT      | 写入或更新路径下的数据，如 `messages/users/user1/<data>` |\n| PATCH    | 更新指定路径下的部分key值，但是不影响其他的数据                |\n| POST     | 在Wilddog数据库中增加一个节点，每次发送一个POST请求都会生成一个独一无二的ID，如`messages/users/<unique-id>/<data>` |\n| DELETE   | 删除指定数据路径下的数据                             |\n\n\n\n### 使用PUT来写入数据\n\nREST API基本的写入数据的操作是`PUT`。为了演示数据存储，我们将建立一个博客应用，应用的所有数据都存储在Wilddog应用对应的URl`https://docs-examples.wilddogio.com/rest/saving-data/wildblog`中。\n\n下面来存储一些用户的数据到数据库中，我们存储每个用户的唯一用户名，还存储全名和出生日期。由于用户名是独一无二的，所以适合使用`PUT`而不是`POST`方法，因为我们已经有作为key值的字段，不需要生成。\n\n使用`PUT`方法，我们可以写入`string`, `number`, `boolean`,`array`或者任意的JSON对象到我们的数据库，这里我们将传递一个JSON对象：\n\n```javascript\ncurl -X PUT -d '{\n  \"alanisawesome\": {\n    \"name\": \"Alan Turing\",\n    \"birthday\": \"June 23, 1912\"\n  }\n}' 'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users.json'\n```\n\n当一个JSON对象被存储到数据库中，对象的属性被自动映射到指定位置。如果我们定位到新添加的节点上，我们会看到值“Alan Turing”，我们也可以直接保存数据到子路径节点上：\n\n```javascript\ncurl -X PUT -d '\"Alan Turing\"' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/name.json'\n```\n\n```\ncurl -X PUT -d '\"June 23, 1912\"' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/birthday.json'\n```\n\n以上两个例子采用了两种方法写入数据：一次性写入一个JSON对象，和分别写入每个子数据节点。两种方式最终写入数据的结果是一样的：\n\n```\n{\n  \"users\": {\n    \"alanisawesome\": {\n      \"date_of_birth\": \"June 23, 1912\",\n      \"full_name\": \"Alan Turing\"\n    }\n  }\n}\n```\n\n成功的请求将返回HTTP 200 OK状态码，并且响应中会包含存储到数据库中的数据。上面的两个例子中，对于关注数据变化的其它客户端，第一个例子的做法仅仅触发一个事件，而第二个例子将触发两个事件。注意，如果要写入的路径节点下已经存在数据，第一种方法会覆盖已有的数据，而第二种方法只是修改两个子节点的值，而不会影响已有的其他子节点的数据。`PUT`方法等同于JavaScript SDK的`set()`方法。\n\n### 使用PATCH来更新数据\n\n使用`PATCH`请求，我们可以更新指定子节点的数据，而不覆盖其它已经存在的数据。例如使用`PATCH`请求为Turing添加nickname：\n\n```\ncurl -X PATCH -d '{\n  \"nickname\": \"ACE\"\n}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json'\n\n```\n\n上面的请求将`nickname`添加到`alanisawesome`对象而不删除子节点`name`和`birthday`。如果使用的是`PUT`请求，`name`和`birthday`将会被删除，因为他们没有出现在请求中。执行完`PATCH`请求之后，数据库中的数据如下：\n\n```\n{\n  \"users\": {\n    \"alanisawesome\": {\n      \"date_of_birth\": \"June 23, 1912\",\n      \"full_name\": \"Alan Turing\",\n      \"nickname\": \"ACE\"\n    }\n  }\n}\n\n```\n\n成功的请求将返回HTTP 200 OK状态码，并且响应中会包含更新到数据库中的数据。\n\n### 保存列表数据\n\n如果要给添加到数据库中的元素生成一个独一无二的、基于时间戳的key，我们可以使用`POST`请求。对于我们的`users`路径，我们自行定义user数据的key是很有必要的，因为每个用户都有有唯一用户名。但是当用户发表博客时，我们可以使用`POST`请求为博客数据自动生成key。\n\n```\ncurl -X POST -d '{\n  \"author\": \"alanisawesome\",\n  \"title\": \"The Turing Machine\"\n}' 'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/posts.json'\n\n```\n\n我们的`posts`路径下的数据将会是这样：\n\n```\n{\n  \"posts\": {\n    \"-JRHTHaKuITFIhnj02kE\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n\n```\n\n注意，`key-JRHTHaKuITFIhnj02kE`是自动生成的，因为我们使用的是`POST`请求。成功的请求将返回HTTP 200 OK状态码，并且响应中会包含新数据的key。\n\n```\n{\"name\":\"-JRHTHaKuITFIhnj02kE\"}\n\n```\n\n### 删除数据\n\n要删除Wilddog中的数据，我们可以发送`DELETE`请求到要删除数据对应的路径上。下面的命令将删除`users`路径上的`alanisawesome`：\n\n```\ncurl -X DELETE \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json'\n\n```\n\n成功的请求将返回HTTP 200 OK状态码，和一个空的JSON。\n\n### URI参数\n\n当向数据库写入数据时，REST API可以接受以下的参数：\n\n**auth**\n\n`auth`参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。auth参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含`auth`参数的`POST`请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。\n\n```\ncurl -X POST -d '{\"Authenticated POST request\"}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL'\n\n```\n\n**print**\n\n`print`参数让我们可以设置响应的内容格式。把`print=pretty`添加到请求中将会返回易读的格式。`GET`、`PUT`、`POST`和`PATCH`请求都支持`print=pretty`参数。\n\n#### **写入服务端数据**\n\n服务端数值使用占位符： `.sv`。`.sv`的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：\n\n```\ncurl -X PUT -d '{\".sv\": \"timestamp\"}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json'\n\n```\n\n服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考[百科](http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa)。\n\n#### **提高写入性能**\n\n如果我们要向数据库写入大量的数据，我们可以使用`print=silent`参数来提高写入性能和减少带宽占用。在正常的写操作中，服务器使用已经写入到数据库中的JSON数据来响应。当指定了`print=slient`参数，服务器会在数据传输完后立即关闭连接来减少带宽占用。\n\n如果我们需要发送大量的请求到数据库，我们可以在HTTPS请求头中添加`Keep-Alive`请求来复用连接。\n\n### 错误码\n\nREST API将在以下情况返回错误码：\n\n| 错误码描述                  |                                          |\n| :--------------------- | :--------------------------------------- |\n| 404 Not Found          | 通过HTTP请求而不是HTTPS请求                       |\n| 400 Bad Request        | 不能解析PUT或POST数据；丢失PUT或POST数据；PUT或POST数据过长；REST API调用路径中包含非法的子节点名字 |\n| 417 Expectation Failed | REST API调用没有指定Wilddog应用id                |\n| 403 Forbidden          | 请求违反规则表达式的约束                             |\n\n\n\n## 读取与监听数据\n\n### 使用GET方法读取数据\n\n我们可以发送`GET`请求到数据的URL来读取数据，让我们继续博客的示例，读取全部的博客数据。\n\n```\ncurl 'https://docs-examples.wilddogio.com/rest/saving-data/wdblog/posts.json?print=pretty'\n\n```\n\n成功的请求将返回HTTP 200 OK状态码，并且响应中会包含读取到的数据。\n\n### 添加URI参数\n\n当我们从数据库中读取数据的时候，REST API可以接受多个参数。下面是最常用的参数。想了解全部的参数，请参见 [REST API文档](/api/sync/rest.html)。\n\n**auth**`auth`参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。`auth`参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含`auth`参数的`POST`请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。\n\n```\ncurl -X POST -d '{\"Authenticated POST request\"}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL'\n\n```\n\n**print**指定`print=pretty`返回易读格式的数据。\n\n```\ncurl 'https://<appId>.wilddogio.com/users/jack/name.json?print=pretty'\n\n```\n\n指定`print=silent`返回204 No Content状态码\n\n```\ncurl 'https://<appId>.wilddogio.com/users/jack/name.json?print=silent'\n\n```\n\n**callback**为了让来自web客户端的rest请求实现跨域，你可以用JSONP将响应封装到JavaScript回调方法中。使用 `callback=` 让REST API将返回的数据封装到你指定的回调方法中。\n\n```\n<script>\n  function gotData(data) {\n    console.log(data);\n  }\n</script>\n<script src=\"https://<appId>.wilddogio.com/.json?callback=gotData\"></script>\n\n```\n\n**shallow**这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 `shallow=true` 将限制数据返回的深度。如果返回的数据是JSON原始类型 \\(如string, number 或 boolean\\)， 它的value将被返回。 如果数据的snapshot是 JSON 对象，每一个key的value都将被截断成布尔类型`true`。\n\n```\n{\n  \"message\": {\n    \"user\": {\n      \"name\": \"Chris\"\n    },\n    \"body\": \"Hello!\"\n  }\n}\n\n// REST请求路径为 /message.json?shallow=true\n// 返回的数据如下:\n{\n  \"user\": true,\n  \"body\": true\n}\n\n// REST请求路径为 /message/body.json?shallow=true\n// 返回的数据如下:\n\"Hello!\"\n\n```\n\n使用shallow参数后， 将不能使用其他查询参数。\n\n#### **读取服务端时间戳**\n\n当我们需要获取服务器的当前时间戳时，可以进行如下操作:\n\n```\ncurl 'https://<appId>.wilddogio.com/.json?sv=timestamp'\n\n```\n\n服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考[百科](http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa)。\n\n### 查询数据\n\n你可以使用一些参数来对数据进行查询。首先使用`orderBy`参数来指定数据的排列顺序，然后结合使用`limitToFirst`，`limitToLast`，`startAt`，`endAt`和`equalTo`参数来对数据进行查询。\n\n注意：使用REST API对数据进行查询时，返回的数据集没有固定的顺序，这是因为JSON解释器没有强制排序。如果需要排序，你需要自己在程序中对返回的数据进行排序。\n\n下面我们来举例如何进行数据查询。假设现在有一些关于恐龙的数据如下：\n\n```\n{\n  \"lambeosaurus\": {\n    \"height\": 2.1,\n    \"length\": 12.5,\n    \"weight\": 5000\n  },\n  \"stegosaurus\": {\n    \"height\": 4,\n    \"length\": 9,\n    \"weight\": 2500\n  }\n}\n\n```\n\n有四种方式对数据进行查询：按照子节点的value值，按照节点名称key，按照节点value值和节点优先级priority。查询条件以其中一个参数开头，后面必须与`limitToFirst`，`limitToLast`，`startAt`，`endAt`和`equalTo`这些参数配合使用。\n\n**按照子节点value值排序**将子节点的名称传给`orderBy`参数，就可以按照指定子节点的value值进行排序。 例如，想要查询所有的高度大于等于3米的恐龙，我们可以使用以下参数查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&startAt=3&print=pretty'\n\n```\n\n注意： 如果你想要在应用中按照某个子节点的value值排序，你需要在规则表达式中配置`\".indexOn\":\"<childkey>\"`。详细的文档请参考规则表达式API文档中关于 [.indexOn](/api/sync/rule.html#indexOn) 的介绍。\n\n**按照数据节点名称排序**可以通过使用`orderBy=\"$key\"`参数来按照节点名称查询数据。 下面的例子将返回名称在a到m之间所有的节点：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"$key\"&startAt=\"a\"&endAt=\"m\"&print=pretty'\n\n```\n\n**按照节点的value值排序**我们可以按照节点的value值进行排序。 例如，恐龙举办运动会，我们按照以下格式记录恐龙的成绩：\n\n```\n{\n  \"scores\": {\n    \"bruhathkayosaurus\": 55,\n    \"lambeosaurus\": 21,\n    \"linhenykus\": 80,\n    \"pterodactyl\": 93,\n    \"stegosaurus\": 5,\n    \"triceratops\": 22\n  }\n}\n\n```\n\n要查询所有成绩高于50分的恐龙，我们可以使用以下参数查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/scores.json?orderBy=\"$value\"&startAt=50&print=pretty'\n\n```\n\n参考数据排序部分的介绍，了解使用`orderBy=\"$value\"`参数查询时，数据是如何排序的。\n\n注意： 如果你想要在应用中按照节点的value值排序，你需要在规则表达式中配置`\".indexOn\" : \".value\"`。详细的文档请参考规则表达式API文档中关于 [.indexOn](old/sync/rules/api-rule#.indexOn) 的介绍。\n\n**按照优先级排序**可以使用`orderBy=\"$priority\"`参数来按照节点的优先级查询数据。详细的优先级介绍请参见 [API文档](sync/rules/api-rule.html#Priorities0)。\n\n### 复杂查询\n\n可以将多个参数进行组合使用，实现更复杂的查询功能。\n\n**limit查询**`limitToFirst`和`limitToLast`参数用来设置返回结果集的大小。例如，查询条件限制为100，如果记录数小于100，则会返回所有的数据，如果记录数超过100，则会返回其中的100条记录，使用`limitToFirst`得到最前面的100条记录，使用`limitToLast`得到最后面的100条记录。\n\n在恐龙数据库中使用`orderBy`和`limitToLast`，我们可以得到体重最重的两头恐龙的信息：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"weight\"&limitToLast=2&print=pretty'\n\n```\n\n同样，我们可以使用`limitToFirst`参数来得到高度最小的两头恐龙的信息：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&limitToFirst=2&print=pretty'\n\n```\n\n我们可以将`limitToLast`参数与`orderBy=\"$value\"`参数配合使用。例如，我们给恐龙运动会创建一个排行榜，查询分数最高的三头恐龙，则可以使用以下参数查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/scores.json?orderBy=\"$value\"&limitToLast=3&print=pretty'\n\n```\n\n**range查询**使用`startAt`，`endAt`和`equalTo`参数来设置查询范围的起点和终点。例如，我们想要查询至少3米高的恐龙，可以使用`orderBy`和`startAt`的组合查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&startAt=3&print=pretty'\n\n```\n\n我们可以使用`endAt`参数来查询名字的字典顺序在Pterodactyl之前的所有的恐龙：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"$key\"&endAt=\"pterodactyl\"&print=pretty'\n\n```\n\n我们可以使用`startAt`和`endAt`的组合来控制我们查询的范围。下面的例子是查询名字以b开头的所有的恐龙：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"$key\"&startAt=\"b\"&endAt=\"b~\"&print=pretty'\n\n```\n\n波浪线在ASCII中的编码是126，它排在ASCII中常规字符的后面，查询返回的是所有b开头的字符串。\n\n范围查询在分页中非常有用。\n\n\n\n## 数据排序\n\n这一部分主要介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**orderBy**当使用`orderBy`参数时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型，则排序不固定，此时不建议使用`orderBy`参数获取全量数据。例如，\n\n```\n{\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    },\n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    },\n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    },\n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n\n```\n\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`numberic`类型，此时使用 `orderBy`参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用`limitToFirst`或`limitToLast`时，将获得不确定的结果。\n\n当配合使用`startAt`、`endAt`和`equalTo`参数时，如果子节点的公有属性key包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 `orderBy=\"score\"&startAt=60` 将得到下面的结果：\n\n```\n  {\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }\n  }\n\n```\n\n`Object`类型数据的 value 值为 null，不会出现在结果中。\n\n_注意：如果path与value的总长度超过1000字节时，使用_`orderBy`_参数将搜索不到该数据。_\n\n**orderBy=\"$key\"**当使用`orderBy=\"$key\"`参数对数据进行排序时，数据将会按照key值增序排列。注意，key值只能是字符型。\n\n1. 1.key值能够被解析成数字的节点排在最前面，增序排列\n2. 2.接下来是字符型key值，按照字典顺序增序排列\n\n**orderBy=\"$value\"**当使用`orderBy=\"$value\"`参数时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型，则排序不固定， 此时不建议使用`orderBy=\"$value\"`获取全量数据，例如，\n\n```\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n\n```\n\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`numberic`类型，此时使用 `orderBy=\"$value\"`参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用`limitToFirst`或`limitToLast`参数时，将获得不确定的结果。\n\n当配合使用`startAt`、`endAt`和`equalTo`时，如果子节点的value包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 `orderBy=\"$value\"&startAt=60` 将得到下面的结果：\n\n```\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n\n```\n\n`Object`类型数据的 value 值为 null，不会出现在结果中。\n\n_注意：如果path与value的总长度超过1000字节时，使用_`orderBy=\"$value\"`_参数将搜索不到该数据。_\n\n**orderBy=\"$priority\"**当使用`orderBy=\"$priority\"`参数对数据进行排序时，数据的顺序取决于优先级以及key值。注意，优先级的值只能是数字型或字符型。\n\n1. 1.没有优先级的节点放在最前面\n2. 2.接着是数字型的优先级，按照优先级从小到大的顺序排列\n3. 3.接下来是字符型的优先级，按照优先级的字典顺序排列\n4. 4.当两个节点的优先级相同，就按照key值排序，数字型key在前（数值排序），其余类型的key在后（字典排序）\n\n关于优先级更多的内容，请参见 [API文档](/api/sync/rest.html#Priorities)。\n\n### Streaming\n\nWilddog REST端点支持 [EventSource\\/Server-Sent Events](http://www.w3.org/TR/eventsource/) 协议，使客户端可以持续得到指定节点下数据发生的变化。\n\n想要开始streaming，我们需要：\n\n1. 将客户端请求的Accept头设置为`text/event-stream`\n2. 考虑http跳转，特别是307状态码\n3. 如果数据访问需要校验权限，需要添加`auth`参数。\n\n当指定节点的数据发生变化时，服务器会发送事件回来。消息的结构符合`EventSource`协议：\n\n```\nevent: event name\ndata: JSON encoded data payload\n\n```\n\n服务器会返回以下的事件：\n\n|               |                                          |\n| :------------ | :--------------------------------------- |\n| put           | JSON格式数据，有两个key：path和data；path指向请求URL的路径；客户端应该使用消息中包含的数据替换本地缓存中的数据 |\n| patch         | JSON格式数据，有两个key：path和data；path指向请求URL的路径；对与数据的每一个key，客户端应该用消息中包含的key替代缓存中的key |\n| keep-alive    | 此事件的data为null，不需要任何操作                    |\n| auth\\_revoked | 该事件的数据是字符串，表示认证过期；认证参数失效后，该事件将被发送        |\n\n下面是服务器能够发送的事件示例：\n\n```\n// 设置整个缓存为 {\"a\": 1, \"b\": 2}\nevent: put\ndata: {\"path\": \"/\", \"data\": {\"a\": 1, \"b\": 2}}\n\n//将新数据放到key为c的缓存中，这样整个缓存是下面的结构\n// {\"a\": 1, \"b\": 2, \"c\": {\"foo\": true, \"bar\": false}}\n\nevent: put\ndata: {\"path\": \"/c\", \"data\": {\"foo\": true, \"bar\": false}}\n\n// 数据中的每个key，更新（或添加）相应的key到缓存的路径/c下\n// 最终的缓存为: {\"a\": 1, \"b\": 2, \"c\": {\"foo\": 3, \"bar\": false, \"baz\": 4}}\nevent: patch\ndata: {\"path\": \"/c\", \"data\": {\"foo\": 3, \"baz\": 4}}\n\n```\n\n\n\n## 安全\n\n安全是一个非常重大的话题，通常也是app开发中最困难的部分之一。Wilddog使用一种声明式的规则表达式，对数据的访问权限进行配置，让这一切变得简单。\n\n### 认证\n\n用户ID是一个非常重要概念，不同的用户拥有不同的数据和不同的权限，比如，在一个聊天程序中，每一条消息都有它的发布者，用户可以删除自己的消息，而不能删除别人的。安全的第一步是用户认证。\n\nWilddog 提供了以下终端用户认证的方式：\n\n* 集成微博，微信，QQ等社交平台的OAuth认证\n* Email\\/密码登录，并且提供用户管理\n* 匿名用户访问\n* 自定义token，方便用户集成已有的用户账户系统。\n\n### 授权\n\n知道用户的身份只是安全的一部分，一旦你知道谁在访问数据，你需要一种方式来控制访问权限。Wilddog提供了一种声明式的表达式语言，你可以在控制面板中的“规则表达式”tab下进行编辑。这些规则表达式让你可以管理数据的访问规则。规则级联应用到其子节点。\n\n```\n{\n  \"rules\": {\n    \"foo\": {\n      \".read\": true，\n      \".write\": false\n    }\n  }\n}\n\n```\n\n这个例子允许所有人访问数据节点 `foo`。\n\n规则表达式包含一系列内置对象和函数。最重要的一个内置对象是auth，它在终端用户认证的时候生成，包含终端用户的信息和用户的唯一id：auth.uid。\n\nauth对象是很多规则表达式的基础。\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user_id\": {\n        \".write\": \"$user_id == auth.uid\"\n      }\n    }\n  }\n}\n\n```\n\n这个规则保证了：只有终端用户的唯一id等于动态路径$user\\_id的值时，用户才能写入数据。\n\n### 数据校验\n\n规则表达式中还包含一个`.validate`规则，用于对数据进行校验，确保数据的格式正确。它的语法和`.read`与`.write`相同，不同的是`.validate`规则不会向下级联。\n\n```\n{\n  \"rules\": {\n    \"foo\": {\n      \".validate\": \"newData.isString() && newData.val().length() < 100\"\n    }\n  }\n}\n\n```\n\n这一规则确保了在\\/foo\\/节点下，写入的数据必须是字符串类型，且必须长度小于100。\n\n`.validate`规则可以使用的内置对象和方法与`.read`和`.write`相同。\n\n```\n{\n  \"rules\": {\n    \"user\": {\n      \".validate\": \"auth != null && newData.val() == auth.uid\"\n    }\n  }\n}\n\n```\n\n这一规则强制使写入\\/user\\/下的数据必须是当前登陆用户的唯一id。\n\n`.validate`规则并不是要彻底取消应用中的数据校验代码。为了获得更好的性能和用户体验，你仍然必须在应用代码中对数据进行校验。\n\n### 规则表达式设置\n\n使用REST API，你可以通过发送PUT请求到`/.settings/rules.json`路径为你的应用设置规则表达式。请求时你需要使用野狗的超级密钥，例如为了将所有读权限设置为true，可以发送如下的请求：\n\n```\ncurl -X PUT -d '{\"rules\":{\".read\":true}}' 'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n通过REST API编写应用的安全规则表达式可以作为你应用部署流程中的一部分。\n\n注：通过REST API修改rules将会覆盖已经存在的规则表达式。\n\n### 获取规则表达式\n\n类似的，我们可以通过发送GET请求到`/.settings/rules.json`路径来获取规则表达式的设置内容：\n\n```\ncurl  'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n返回的数据将包含app设置的规则表达式的全部内容。\n\n### 了解更多\n\n到此为止，你应该对Wilddog中的应用安全机制有了一个大体的了解。\n\n规则表达式是复杂且强大的，本开发向导中只涵盖了非常小的一部分。更多关于规则表达式的细节，请参考[规则表达式文档](/guide/sync/rules/guide.html)，这里将会讲述所有的内置方法和对象。\n\n","source":"guide/sync/rest/guide.md","raw":"title: REST 完整指南\n---\n\n## 使用入门\n\n在任何支持HTTPS的平台和语言中，都可以使用Wilddog REST API。在本指南中，我们使用命令行工具发送HTTPS请求。其他任何平台都可以参照该示例，使用 REST API。\n\n### 数据是一棵 JSON 树\n\n所有的数据都存储在各个 JSON 对象中，没有任何表的概念。当你把数据添加到这棵json 树中，这些数据就变成这棵树的子树。比如，我们在`users/mchen` 下增加 `widget`后，我们的数据是这样的:\n\n```\n{\n  \"users\": {\n    \"mchen\": {\n      \"friends\": { \"brinchen\": true },\n      \"name\": \"Mary Chen\",\n      // 新数据节点会增加在已经存在的JSON树中\n      \"widgets\": { \"one\": true, \"three\": true }\n    },\n    \"brinchen\": { ... },\n    \"hmadi\": { ... }\n  }\n}\n```\n\n### 使用数据URL\n\n通过REST API读取和写入数据时，我们在`curl`请求中包含一个指向数据地址的URL，这个URL会指向我们存储的所有数据。在这个示例中，我们将使用`https://docs-examples.wilddogio.com/web/data`这个地址。\n\n也可以直接访问子节点的数据，例如，要访问Mary Chen的name，只需要在URL之后追加`users/mchen/name`即可。\n\n```\ncurl https://docs-examples.wilddogio.com/web/data/users/mchen/name.json\n\n```\n\n### 限制和约束\n\n| 描述约束备注           |          |                                          |\n| :--------------- | :------- | :--------------------------------------- |\n| 树的深度             | 32       |                                          |\n| key的长度           | 768bytes | UTF-8 编码，不能包含`.` `$` `#` `[` `]` `/`和 ASCII控制字符0-31和127 |\n| 一个叶子节点的数据大小      | 1mb      | UTF-8 编码                                 |\n| 通过SDK写入的数据大小限制   | 2mb      | UTF-8 编码                                 |\n| 通过 REST 写入数据大小限制 | 4mb      |                                          |\n| 一次能读取的节点         | 2000     |                                          |\n| 一次条件查询能返回的最大条数   | 500      | 如使用 limitToFirst、limitToLast等            |\n\n### 特殊字符转义\n\n当节点的key值是特殊字符时可能导致发送的curl请求URL无效，此时我们需要将特殊字符转义\n\n| 特殊字符转义符 |      |\n| :------ | :--- |\n| ?       | %3F  |\n| %       | %25  |\n| +       | %2B  |\n| =       | %3D  |\n| &       | %26  |\n\n\n\n## 组织数据\n\n构造恰当的NoSQL存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。\n\n### 避免层级过深\n\n尽管可以使用JSON任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog的工作方式是当你查询某个节点，Wilddog会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织SQL关系型数据表一样。\n\n我们不推荐这种实践\n\n```js\n{\n    // 一个非常差的充满嵌套的数据结构。请勿模仿。\n    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\",\n        \"messages\": {\n          \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n          \"m2\": { ... },\n          // 非常长的messages列表\n        }\n      }\n    }\n}\n\n```\n\n对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的rooms这样一个很简单的操作，也会查询整个`rooms`数据节点，返回所有的rooms下的数据节点到客户端。\n\n### 使数据扁平化\n\n如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：\n\n```\n{\n    // rooms数据节点下仅包含房间的基本信息和唯一ID。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\"\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    },\n\n    //room成员可以很方便的的存取\n    \"members\": {\n      \"one\": {\n        \"mchen\": true,\n        \"hmadi\": true\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n\n    },\n\n    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。\n    //消息数据可以通过room ID方便的分页和查询。\n    \"messages\": {\n      \"one\": {\n        \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n        \"m2\": { ... },\n        \"m3\": { ... }\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    }\n\n  }\n```\n\n这样组织数据，就可以很方便的查询room列表了，只需要传输很少的字节数。message数据也可以很容易的查询。\n\n### 使数据可扩展\n\n很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：\n\n```\n{\n    \"users\": {\n      \"john\": {\n         \"todoList\": {\n            \"rec1\": \"Walk the dog\",\n            \"rec2\": \"Buy milk\",\n            \"rec3\": \"Win a gold medal in the Olympics\"\n         }\n      }\n    }\n  }\n\n```\n\n但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John可能有一个长达数千项的todo列表）。\n\n但仅仅如此可能还是不够的。考虑一个例子，users和groups之间的双向关系。user可以属于group，group包含一个user列表。乍看之下数据可能这样组织：\n\n```\n{\n    \"users\": {\n      \"mchen\": { \"name\": \"Mary Chen\" },\n      \"brinchen\": { \"name\": \"Byambyn Rinchen\" },\n      \"hmadi\": { \"name\": \"Hamadi Madi\" }\n    },\n    \"groups\": {\n      \"alpha\": {\n         \"name\": \"Alpha Tango\",\n         \"members\": {\n            \"m1\": \"mchen\",\n            \"m2\": \"brinchen\",\n            \"m3\": \"hamadi\"\n         }\n      },\n      \"bravo\": { ... },\n      \"charlie\": { ... }\n    }\n  }\n\n```\n\n看起来不错。但是当需要判断一个user属于哪些group的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的group，但这样做成本很高，也很慢。更糟糕的是，如果Mary没有权限查看所有的group时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。\n\n我们需要的是一种优雅的方式，可以列出Mary属于哪些group，只需要查询这些group就行了。数据可以这样组织：\n\n```js\n{\n    \"users\": {\n      \"mchen\": {\n        \"name\": \"Mary Chen\",\n        // 在Mary的数据下，建立他所属group的索引。\n        \"groups\": {\n           // 这里的值是什么并不重要。重要的是这个子节点的key存在。\n           \"alpha\": true,\n           \"charlie\": true\n        }\n      },\n      ...\n    },\n    \"groups\": { ... }\n  }\n\n```\n\n我们把关系数据同时存储在了Mary的记录下和group数据下，这样造成了数据的重复。如果要把Mary从一个组中删除，就需要更新两个地方。\n\n对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询Mary的个人信息，即使users和groups都有百万级的数据，且规则表达式禁止访问不相关的数据时。\n\n为什么我们把id作为key，而把value设置为`true`呢？这样做是有好处的。这样使得检查一个id是否存在变得非常简单，只需要读取`/users/mchen/groups/$group_id`，看它是否为null就可以了。\n\n\n\n## 操作数据\n\n### 操作数据的方式\n\n| method说明 |                                          |\n| :------- | :--------------------------------------- |\n| PUT      | 写入或更新路径下的数据，如 `messages/users/user1/<data>` |\n| PATCH    | 更新指定路径下的部分key值，但是不影响其他的数据                |\n| POST     | 在Wilddog数据库中增加一个节点，每次发送一个POST请求都会生成一个独一无二的ID，如`messages/users/<unique-id>/<data>` |\n| DELETE   | 删除指定数据路径下的数据                             |\n\n\n\n### 使用PUT来写入数据\n\nREST API基本的写入数据的操作是`PUT`。为了演示数据存储，我们将建立一个博客应用，应用的所有数据都存储在Wilddog应用对应的URl`https://docs-examples.wilddogio.com/rest/saving-data/wildblog`中。\n\n下面来存储一些用户的数据到数据库中，我们存储每个用户的唯一用户名，还存储全名和出生日期。由于用户名是独一无二的，所以适合使用`PUT`而不是`POST`方法，因为我们已经有作为key值的字段，不需要生成。\n\n使用`PUT`方法，我们可以写入`string`, `number`, `boolean`,`array`或者任意的JSON对象到我们的数据库，这里我们将传递一个JSON对象：\n\n```javascript\ncurl -X PUT -d '{\n  \"alanisawesome\": {\n    \"name\": \"Alan Turing\",\n    \"birthday\": \"June 23, 1912\"\n  }\n}' 'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users.json'\n```\n\n当一个JSON对象被存储到数据库中，对象的属性被自动映射到指定位置。如果我们定位到新添加的节点上，我们会看到值“Alan Turing”，我们也可以直接保存数据到子路径节点上：\n\n```javascript\ncurl -X PUT -d '\"Alan Turing\"' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/name.json'\n```\n\n```\ncurl -X PUT -d '\"June 23, 1912\"' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/birthday.json'\n```\n\n以上两个例子采用了两种方法写入数据：一次性写入一个JSON对象，和分别写入每个子数据节点。两种方式最终写入数据的结果是一样的：\n\n```\n{\n  \"users\": {\n    \"alanisawesome\": {\n      \"date_of_birth\": \"June 23, 1912\",\n      \"full_name\": \"Alan Turing\"\n    }\n  }\n}\n```\n\n成功的请求将返回HTTP 200 OK状态码，并且响应中会包含存储到数据库中的数据。上面的两个例子中，对于关注数据变化的其它客户端，第一个例子的做法仅仅触发一个事件，而第二个例子将触发两个事件。注意，如果要写入的路径节点下已经存在数据，第一种方法会覆盖已有的数据，而第二种方法只是修改两个子节点的值，而不会影响已有的其他子节点的数据。`PUT`方法等同于JavaScript SDK的`set()`方法。\n\n### 使用PATCH来更新数据\n\n使用`PATCH`请求，我们可以更新指定子节点的数据，而不覆盖其它已经存在的数据。例如使用`PATCH`请求为Turing添加nickname：\n\n```\ncurl -X PATCH -d '{\n  \"nickname\": \"ACE\"\n}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json'\n\n```\n\n上面的请求将`nickname`添加到`alanisawesome`对象而不删除子节点`name`和`birthday`。如果使用的是`PUT`请求，`name`和`birthday`将会被删除，因为他们没有出现在请求中。执行完`PATCH`请求之后，数据库中的数据如下：\n\n```\n{\n  \"users\": {\n    \"alanisawesome\": {\n      \"date_of_birth\": \"June 23, 1912\",\n      \"full_name\": \"Alan Turing\",\n      \"nickname\": \"ACE\"\n    }\n  }\n}\n\n```\n\n成功的请求将返回HTTP 200 OK状态码，并且响应中会包含更新到数据库中的数据。\n\n### 保存列表数据\n\n如果要给添加到数据库中的元素生成一个独一无二的、基于时间戳的key，我们可以使用`POST`请求。对于我们的`users`路径，我们自行定义user数据的key是很有必要的，因为每个用户都有有唯一用户名。但是当用户发表博客时，我们可以使用`POST`请求为博客数据自动生成key。\n\n```\ncurl -X POST -d '{\n  \"author\": \"alanisawesome\",\n  \"title\": \"The Turing Machine\"\n}' 'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/posts.json'\n\n```\n\n我们的`posts`路径下的数据将会是这样：\n\n```\n{\n  \"posts\": {\n    \"-JRHTHaKuITFIhnj02kE\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n\n```\n\n注意，`key-JRHTHaKuITFIhnj02kE`是自动生成的，因为我们使用的是`POST`请求。成功的请求将返回HTTP 200 OK状态码，并且响应中会包含新数据的key。\n\n```\n{\"name\":\"-JRHTHaKuITFIhnj02kE\"}\n\n```\n\n### 删除数据\n\n要删除Wilddog中的数据，我们可以发送`DELETE`请求到要删除数据对应的路径上。下面的命令将删除`users`路径上的`alanisawesome`：\n\n```\ncurl -X DELETE \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json'\n\n```\n\n成功的请求将返回HTTP 200 OK状态码，和一个空的JSON。\n\n### URI参数\n\n当向数据库写入数据时，REST API可以接受以下的参数：\n\n**auth**\n\n`auth`参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。auth参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含`auth`参数的`POST`请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。\n\n```\ncurl -X POST -d '{\"Authenticated POST request\"}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL'\n\n```\n\n**print**\n\n`print`参数让我们可以设置响应的内容格式。把`print=pretty`添加到请求中将会返回易读的格式。`GET`、`PUT`、`POST`和`PATCH`请求都支持`print=pretty`参数。\n\n#### **写入服务端数据**\n\n服务端数值使用占位符： `.sv`。`.sv`的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：\n\n```\ncurl -X PUT -d '{\".sv\": \"timestamp\"}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json'\n\n```\n\n服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考[百科](http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa)。\n\n#### **提高写入性能**\n\n如果我们要向数据库写入大量的数据，我们可以使用`print=silent`参数来提高写入性能和减少带宽占用。在正常的写操作中，服务器使用已经写入到数据库中的JSON数据来响应。当指定了`print=slient`参数，服务器会在数据传输完后立即关闭连接来减少带宽占用。\n\n如果我们需要发送大量的请求到数据库，我们可以在HTTPS请求头中添加`Keep-Alive`请求来复用连接。\n\n### 错误码\n\nREST API将在以下情况返回错误码：\n\n| 错误码描述                  |                                          |\n| :--------------------- | :--------------------------------------- |\n| 404 Not Found          | 通过HTTP请求而不是HTTPS请求                       |\n| 400 Bad Request        | 不能解析PUT或POST数据；丢失PUT或POST数据；PUT或POST数据过长；REST API调用路径中包含非法的子节点名字 |\n| 417 Expectation Failed | REST API调用没有指定Wilddog应用id                |\n| 403 Forbidden          | 请求违反规则表达式的约束                             |\n\n\n\n## 读取与监听数据\n\n### 使用GET方法读取数据\n\n我们可以发送`GET`请求到数据的URL来读取数据，让我们继续博客的示例，读取全部的博客数据。\n\n```\ncurl 'https://docs-examples.wilddogio.com/rest/saving-data/wdblog/posts.json?print=pretty'\n\n```\n\n成功的请求将返回HTTP 200 OK状态码，并且响应中会包含读取到的数据。\n\n### 添加URI参数\n\n当我们从数据库中读取数据的时候，REST API可以接受多个参数。下面是最常用的参数。想了解全部的参数，请参见 [REST API文档](/api/sync/rest.html)。\n\n**auth**`auth`参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。`auth`参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含`auth`参数的`POST`请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。\n\n```\ncurl -X POST -d '{\"Authenticated POST request\"}' \\\n  'https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL'\n\n```\n\n**print**指定`print=pretty`返回易读格式的数据。\n\n```\ncurl 'https://<appId>.wilddogio.com/users/jack/name.json?print=pretty'\n\n```\n\n指定`print=silent`返回204 No Content状态码\n\n```\ncurl 'https://<appId>.wilddogio.com/users/jack/name.json?print=silent'\n\n```\n\n**callback**为了让来自web客户端的rest请求实现跨域，你可以用JSONP将响应封装到JavaScript回调方法中。使用 `callback=` 让REST API将返回的数据封装到你指定的回调方法中。\n\n```\n<script>\n  function gotData(data) {\n    console.log(data);\n  }\n</script>\n<script src=\"https://<appId>.wilddogio.com/.json?callback=gotData\"></script>\n\n```\n\n**shallow**这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 `shallow=true` 将限制数据返回的深度。如果返回的数据是JSON原始类型 \\(如string, number 或 boolean\\)， 它的value将被返回。 如果数据的snapshot是 JSON 对象，每一个key的value都将被截断成布尔类型`true`。\n\n```\n{\n  \"message\": {\n    \"user\": {\n      \"name\": \"Chris\"\n    },\n    \"body\": \"Hello!\"\n  }\n}\n\n// REST请求路径为 /message.json?shallow=true\n// 返回的数据如下:\n{\n  \"user\": true,\n  \"body\": true\n}\n\n// REST请求路径为 /message/body.json?shallow=true\n// 返回的数据如下:\n\"Hello!\"\n\n```\n\n使用shallow参数后， 将不能使用其他查询参数。\n\n#### **读取服务端时间戳**\n\n当我们需要获取服务器的当前时间戳时，可以进行如下操作:\n\n```\ncurl 'https://<appId>.wilddogio.com/.json?sv=timestamp'\n\n```\n\n服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考[百科](http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa)。\n\n### 查询数据\n\n你可以使用一些参数来对数据进行查询。首先使用`orderBy`参数来指定数据的排列顺序，然后结合使用`limitToFirst`，`limitToLast`，`startAt`，`endAt`和`equalTo`参数来对数据进行查询。\n\n注意：使用REST API对数据进行查询时，返回的数据集没有固定的顺序，这是因为JSON解释器没有强制排序。如果需要排序，你需要自己在程序中对返回的数据进行排序。\n\n下面我们来举例如何进行数据查询。假设现在有一些关于恐龙的数据如下：\n\n```\n{\n  \"lambeosaurus\": {\n    \"height\": 2.1,\n    \"length\": 12.5,\n    \"weight\": 5000\n  },\n  \"stegosaurus\": {\n    \"height\": 4,\n    \"length\": 9,\n    \"weight\": 2500\n  }\n}\n\n```\n\n有四种方式对数据进行查询：按照子节点的value值，按照节点名称key，按照节点value值和节点优先级priority。查询条件以其中一个参数开头，后面必须与`limitToFirst`，`limitToLast`，`startAt`，`endAt`和`equalTo`这些参数配合使用。\n\n**按照子节点value值排序**将子节点的名称传给`orderBy`参数，就可以按照指定子节点的value值进行排序。 例如，想要查询所有的高度大于等于3米的恐龙，我们可以使用以下参数查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&startAt=3&print=pretty'\n\n```\n\n注意： 如果你想要在应用中按照某个子节点的value值排序，你需要在规则表达式中配置`\".indexOn\":\"<childkey>\"`。详细的文档请参考规则表达式API文档中关于 [.indexOn](/api/sync/rule.html#indexOn) 的介绍。\n\n**按照数据节点名称排序**可以通过使用`orderBy=\"$key\"`参数来按照节点名称查询数据。 下面的例子将返回名称在a到m之间所有的节点：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"$key\"&startAt=\"a\"&endAt=\"m\"&print=pretty'\n\n```\n\n**按照节点的value值排序**我们可以按照节点的value值进行排序。 例如，恐龙举办运动会，我们按照以下格式记录恐龙的成绩：\n\n```\n{\n  \"scores\": {\n    \"bruhathkayosaurus\": 55,\n    \"lambeosaurus\": 21,\n    \"linhenykus\": 80,\n    \"pterodactyl\": 93,\n    \"stegosaurus\": 5,\n    \"triceratops\": 22\n  }\n}\n\n```\n\n要查询所有成绩高于50分的恐龙，我们可以使用以下参数查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/scores.json?orderBy=\"$value\"&startAt=50&print=pretty'\n\n```\n\n参考数据排序部分的介绍，了解使用`orderBy=\"$value\"`参数查询时，数据是如何排序的。\n\n注意： 如果你想要在应用中按照节点的value值排序，你需要在规则表达式中配置`\".indexOn\" : \".value\"`。详细的文档请参考规则表达式API文档中关于 [.indexOn](old/sync/rules/api-rule#.indexOn) 的介绍。\n\n**按照优先级排序**可以使用`orderBy=\"$priority\"`参数来按照节点的优先级查询数据。详细的优先级介绍请参见 [API文档](sync/rules/api-rule.html#Priorities0)。\n\n### 复杂查询\n\n可以将多个参数进行组合使用，实现更复杂的查询功能。\n\n**limit查询**`limitToFirst`和`limitToLast`参数用来设置返回结果集的大小。例如，查询条件限制为100，如果记录数小于100，则会返回所有的数据，如果记录数超过100，则会返回其中的100条记录，使用`limitToFirst`得到最前面的100条记录，使用`limitToLast`得到最后面的100条记录。\n\n在恐龙数据库中使用`orderBy`和`limitToLast`，我们可以得到体重最重的两头恐龙的信息：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"weight\"&limitToLast=2&print=pretty'\n\n```\n\n同样，我们可以使用`limitToFirst`参数来得到高度最小的两头恐龙的信息：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&limitToFirst=2&print=pretty'\n\n```\n\n我们可以将`limitToLast`参数与`orderBy=\"$value\"`参数配合使用。例如，我们给恐龙运动会创建一个排行榜，查询分数最高的三头恐龙，则可以使用以下参数查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/scores.json?orderBy=\"$value\"&limitToLast=3&print=pretty'\n\n```\n\n**range查询**使用`startAt`，`endAt`和`equalTo`参数来设置查询范围的起点和终点。例如，我们想要查询至少3米高的恐龙，可以使用`orderBy`和`startAt`的组合查询：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"height\"&startAt=3&print=pretty'\n\n```\n\n我们可以使用`endAt`参数来查询名字的字典顺序在Pterodactyl之前的所有的恐龙：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"$key\"&endAt=\"pterodactyl\"&print=pretty'\n\n```\n\n我们可以使用`startAt`和`endAt`的组合来控制我们查询的范围。下面的例子是查询名字以b开头的所有的恐龙：\n\n```\ncurl 'https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=\"$key\"&startAt=\"b\"&endAt=\"b~\"&print=pretty'\n\n```\n\n波浪线在ASCII中的编码是126，它排在ASCII中常规字符的后面，查询返回的是所有b开头的字符串。\n\n范围查询在分页中非常有用。\n\n\n\n## 数据排序\n\n这一部分主要介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**orderBy**当使用`orderBy`参数时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型，则排序不固定，此时不建议使用`orderBy`参数获取全量数据。例如，\n\n```\n{\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    },\n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    },\n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    },\n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n\n```\n\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`numberic`类型，此时使用 `orderBy`参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用`limitToFirst`或`limitToLast`时，将获得不确定的结果。\n\n当配合使用`startAt`、`endAt`和`equalTo`参数时，如果子节点的公有属性key包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 `orderBy=\"score\"&startAt=60` 将得到下面的结果：\n\n```\n  {\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }\n  }\n\n```\n\n`Object`类型数据的 value 值为 null，不会出现在结果中。\n\n_注意：如果path与value的总长度超过1000字节时，使用_`orderBy`_参数将搜索不到该数据。_\n\n**orderBy=\"$key\"**当使用`orderBy=\"$key\"`参数对数据进行排序时，数据将会按照key值增序排列。注意，key值只能是字符型。\n\n1. 1.key值能够被解析成数字的节点排在最前面，增序排列\n2. 2.接下来是字符型key值，按照字典顺序增序排列\n\n**orderBy=\"$value\"**当使用`orderBy=\"$value\"`参数时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型，则排序不固定， 此时不建议使用`orderBy=\"$value\"`获取全量数据，例如，\n\n```\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n\n```\n\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`numberic`类型，此时使用 `orderBy=\"$value\"`参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用`limitToFirst`或`limitToLast`参数时，将获得不确定的结果。\n\n当配合使用`startAt`、`endAt`和`equalTo`时，如果子节点的value包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 `orderBy=\"$value\"&startAt=60` 将得到下面的结果：\n\n```\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n\n```\n\n`Object`类型数据的 value 值为 null，不会出现在结果中。\n\n_注意：如果path与value的总长度超过1000字节时，使用_`orderBy=\"$value\"`_参数将搜索不到该数据。_\n\n**orderBy=\"$priority\"**当使用`orderBy=\"$priority\"`参数对数据进行排序时，数据的顺序取决于优先级以及key值。注意，优先级的值只能是数字型或字符型。\n\n1. 1.没有优先级的节点放在最前面\n2. 2.接着是数字型的优先级，按照优先级从小到大的顺序排列\n3. 3.接下来是字符型的优先级，按照优先级的字典顺序排列\n4. 4.当两个节点的优先级相同，就按照key值排序，数字型key在前（数值排序），其余类型的key在后（字典排序）\n\n关于优先级更多的内容，请参见 [API文档](/api/sync/rest.html#Priorities)。\n\n### Streaming\n\nWilddog REST端点支持 [EventSource\\/Server-Sent Events](http://www.w3.org/TR/eventsource/) 协议，使客户端可以持续得到指定节点下数据发生的变化。\n\n想要开始streaming，我们需要：\n\n1. 将客户端请求的Accept头设置为`text/event-stream`\n2. 考虑http跳转，特别是307状态码\n3. 如果数据访问需要校验权限，需要添加`auth`参数。\n\n当指定节点的数据发生变化时，服务器会发送事件回来。消息的结构符合`EventSource`协议：\n\n```\nevent: event name\ndata: JSON encoded data payload\n\n```\n\n服务器会返回以下的事件：\n\n|               |                                          |\n| :------------ | :--------------------------------------- |\n| put           | JSON格式数据，有两个key：path和data；path指向请求URL的路径；客户端应该使用消息中包含的数据替换本地缓存中的数据 |\n| patch         | JSON格式数据，有两个key：path和data；path指向请求URL的路径；对与数据的每一个key，客户端应该用消息中包含的key替代缓存中的key |\n| keep-alive    | 此事件的data为null，不需要任何操作                    |\n| auth\\_revoked | 该事件的数据是字符串，表示认证过期；认证参数失效后，该事件将被发送        |\n\n下面是服务器能够发送的事件示例：\n\n```\n// 设置整个缓存为 {\"a\": 1, \"b\": 2}\nevent: put\ndata: {\"path\": \"/\", \"data\": {\"a\": 1, \"b\": 2}}\n\n//将新数据放到key为c的缓存中，这样整个缓存是下面的结构\n// {\"a\": 1, \"b\": 2, \"c\": {\"foo\": true, \"bar\": false}}\n\nevent: put\ndata: {\"path\": \"/c\", \"data\": {\"foo\": true, \"bar\": false}}\n\n// 数据中的每个key，更新（或添加）相应的key到缓存的路径/c下\n// 最终的缓存为: {\"a\": 1, \"b\": 2, \"c\": {\"foo\": 3, \"bar\": false, \"baz\": 4}}\nevent: patch\ndata: {\"path\": \"/c\", \"data\": {\"foo\": 3, \"baz\": 4}}\n\n```\n\n\n\n## 安全\n\n安全是一个非常重大的话题，通常也是app开发中最困难的部分之一。Wilddog使用一种声明式的规则表达式，对数据的访问权限进行配置，让这一切变得简单。\n\n### 认证\n\n用户ID是一个非常重要概念，不同的用户拥有不同的数据和不同的权限，比如，在一个聊天程序中，每一条消息都有它的发布者，用户可以删除自己的消息，而不能删除别人的。安全的第一步是用户认证。\n\nWilddog 提供了以下终端用户认证的方式：\n\n* 集成微博，微信，QQ等社交平台的OAuth认证\n* Email\\/密码登录，并且提供用户管理\n* 匿名用户访问\n* 自定义token，方便用户集成已有的用户账户系统。\n\n### 授权\n\n知道用户的身份只是安全的一部分，一旦你知道谁在访问数据，你需要一种方式来控制访问权限。Wilddog提供了一种声明式的表达式语言，你可以在控制面板中的“规则表达式”tab下进行编辑。这些规则表达式让你可以管理数据的访问规则。规则级联应用到其子节点。\n\n```\n{\n  \"rules\": {\n    \"foo\": {\n      \".read\": true，\n      \".write\": false\n    }\n  }\n}\n\n```\n\n这个例子允许所有人访问数据节点 `foo`。\n\n规则表达式包含一系列内置对象和函数。最重要的一个内置对象是auth，它在终端用户认证的时候生成，包含终端用户的信息和用户的唯一id：auth.uid。\n\nauth对象是很多规则表达式的基础。\n\n```\n{\n  \"rules\": {\n    \"users\": {\n      \"$user_id\": {\n        \".write\": \"$user_id == auth.uid\"\n      }\n    }\n  }\n}\n\n```\n\n这个规则保证了：只有终端用户的唯一id等于动态路径$user\\_id的值时，用户才能写入数据。\n\n### 数据校验\n\n规则表达式中还包含一个`.validate`规则，用于对数据进行校验，确保数据的格式正确。它的语法和`.read`与`.write`相同，不同的是`.validate`规则不会向下级联。\n\n```\n{\n  \"rules\": {\n    \"foo\": {\n      \".validate\": \"newData.isString() && newData.val().length() < 100\"\n    }\n  }\n}\n\n```\n\n这一规则确保了在\\/foo\\/节点下，写入的数据必须是字符串类型，且必须长度小于100。\n\n`.validate`规则可以使用的内置对象和方法与`.read`和`.write`相同。\n\n```\n{\n  \"rules\": {\n    \"user\": {\n      \".validate\": \"auth != null && newData.val() == auth.uid\"\n    }\n  }\n}\n\n```\n\n这一规则强制使写入\\/user\\/下的数据必须是当前登陆用户的唯一id。\n\n`.validate`规则并不是要彻底取消应用中的数据校验代码。为了获得更好的性能和用户体验，你仍然必须在应用代码中对数据进行校验。\n\n### 规则表达式设置\n\n使用REST API，你可以通过发送PUT请求到`/.settings/rules.json`路径为你的应用设置规则表达式。请求时你需要使用野狗的超级密钥，例如为了将所有读权限设置为true，可以发送如下的请求：\n\n```\ncurl -X PUT -d '{\"rules\":{\".read\":true}}' 'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n通过REST API编写应用的安全规则表达式可以作为你应用部署流程中的一部分。\n\n注：通过REST API修改rules将会覆盖已经存在的规则表达式。\n\n### 获取规则表达式\n\n类似的，我们可以通过发送GET请求到`/.settings/rules.json`路径来获取规则表达式的设置内容：\n\n```\ncurl  'https://<appId>.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET'\n\n```\n\n返回的数据将包含app设置的规则表达式的全部内容。\n\n### 了解更多\n\n到此为止，你应该对Wilddog中的应用安全机制有了一个大体的了解。\n\n规则表达式是复杂且强大的，本开发向导中只涵盖了非常小的一部分。更多关于规则表达式的细节，请参考[规则表达式文档](/guide/sync/rules/guide.html)，这里将会讲述所有的内置方法和对象。\n\n","date":"2016-09-06T03:38:22.543Z","updated":"2016-09-06T03:38:22.543Z","path":"guide/sync/rest/guide.html","comments":1,"layout":"page","_id":"cisswi9lw001xz4fwe9wun0z5","content":"<h2 id=\"使用入门\"><a href=\"#使用入门\" class=\"headerlink\" title=\"使用入门\"></a>使用入门</h2><p>在任何支持HTTPS的平台和语言中，都可以使用Wilddog REST API。在本指南中，我们使用命令行工具发送HTTPS请求。其他任何平台都可以参照该示例，使用 REST API。</p>\n<h3 id=\"数据是一棵-JSON-树\"><a href=\"#数据是一棵-JSON-树\" class=\"headerlink\" title=\"数据是一棵 JSON 树\"></a>数据是一棵 JSON 树</h3><p>所有的数据都存储在各个 JSON 对象中，没有任何表的概念。当你把数据添加到这棵json 树中，这些数据就变成这棵树的子树。比如，我们在<code>users/mchen</code> 下增加 <code>widget</code>后，我们的数据是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;users&quot;: &#123;</div><div class=\"line\">    &quot;mchen&quot;: &#123;</div><div class=\"line\">      &quot;friends&quot;: &#123; &quot;brinchen&quot;: true &#125;,</div><div class=\"line\">      &quot;name&quot;: &quot;Mary Chen&quot;,</div><div class=\"line\">      // 新数据节点会增加在已经存在的JSON树中</div><div class=\"line\">      &quot;widgets&quot;: &#123; &quot;one&quot;: true, &quot;three&quot;: true &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;brinchen&quot;: &#123; ... &#125;,</div><div class=\"line\">    &quot;hmadi&quot;: &#123; ... &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用数据URL\"><a href=\"#使用数据URL\" class=\"headerlink\" title=\"使用数据URL\"></a>使用数据URL</h3><p>通过REST API读取和写入数据时，我们在<code>curl</code>请求中包含一个指向数据地址的URL，这个URL会指向我们存储的所有数据。在这个示例中，我们将使用<code>https://docs-examples.wilddogio.com/web/data</code>这个地址。</p>\n<p>也可以直接访问子节点的数据，例如，要访问Mary Chen的name，只需要在URL之后追加<code>users/mchen/name</code>即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl https://docs-examples.wilddogio.com/web/data/users/mchen/name.json</div></pre></td></tr></table></figure>\n<h3 id=\"限制和约束\"><a href=\"#限制和约束\" class=\"headerlink\" title=\"限制和约束\"></a>限制和约束</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">描述约束备注</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">树的深度</td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">key的长度</td>\n<td style=\"text-align:left\">768bytes</td>\n<td style=\"text-align:left\">UTF-8 编码，不能包含<code>.</code> <code>$</code> <code>#</code> <code>[</code> <code>]</code> <code>/</code>和 ASCII控制字符0-31和127</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一个叶子节点的数据大小</td>\n<td style=\"text-align:left\">1mb</td>\n<td style=\"text-align:left\">UTF-8 编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过SDK写入的数据大小限制</td>\n<td style=\"text-align:left\">2mb</td>\n<td style=\"text-align:left\">UTF-8 编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过 REST 写入数据大小限制</td>\n<td style=\"text-align:left\">4mb</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一次能读取的节点</td>\n<td style=\"text-align:left\">2000</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一次条件查询能返回的最大条数</td>\n<td style=\"text-align:left\">500</td>\n<td style=\"text-align:left\">如使用 limitToFirst、limitToLast等</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"特殊字符转义\"><a href=\"#特殊字符转义\" class=\"headerlink\" title=\"特殊字符转义\"></a>特殊字符转义</h3><p>当节点的key值是特殊字符时可能导致发送的curl请求URL无效，此时我们需要将特殊字符转义</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特殊字符转义符</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:left\">%3F</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">%</td>\n<td style=\"text-align:left\">%25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">%2B</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">%3D</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&amp;</td>\n<td style=\"text-align:left\">%26</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"组织数据\"><a href=\"#组织数据\" class=\"headerlink\" title=\"组织数据\"></a>组织数据</h2><p>构造恰当的NoSQL存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。</p>\n<h3 id=\"避免层级过深\"><a href=\"#避免层级过深\" class=\"headerlink\" title=\"避免层级过深\"></a>避免层级过深</h3><p>尽管可以使用JSON任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog的工作方式是当你查询某个节点，Wilddog会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织SQL关系型数据表一样。</p>\n<p>我们不推荐这种实践</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// 一个非常差的充满嵌套的数据结构。请勿模仿。</span></div><div class=\"line\">    <span class=\"comment\">// 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。</span></div><div class=\"line\">    <span class=\"string\">\"rooms\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"one\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"room alpha\"</span>,</div><div class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"private\"</span>,</div><div class=\"line\">        <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">          <span class=\"string\">\"m1\"</span>: &#123; <span class=\"string\">\"sender\"</span>: <span class=\"string\">\"mchen\"</span>, <span class=\"string\">\"message\"</span>: <span class=\"string\">\"foo\"</span> &#125;,</div><div class=\"line\">          <span class=\"string\">\"m2\"</span>: &#123; ... &#125;,</div><div class=\"line\">          <span class=\"comment\">// 非常长的messages列表</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的rooms这样一个很简单的操作，也会查询整个<code>rooms</code>数据节点，返回所有的rooms下的数据节点到客户端。</p>\n<h3 id=\"使数据扁平化\"><a href=\"#使数据扁平化\" class=\"headerlink\" title=\"使数据扁平化\"></a>使数据扁平化</h3><p>如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    // rooms数据节点下仅包含房间的基本信息和唯一ID。</div><div class=\"line\">    &quot;rooms&quot;: &#123;</div><div class=\"line\">      &quot;one&quot;: &#123;</div><div class=\"line\">        &quot;name&quot;: &quot;room alpha&quot;,</div><div class=\"line\">        &quot;type&quot;: &quot;private&quot;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;two&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;three&quot;: &#123; ... &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //room成员可以很方便的的存取</div><div class=\"line\">    &quot;members&quot;: &#123;</div><div class=\"line\">      &quot;one&quot;: &#123;</div><div class=\"line\">        &quot;mchen&quot;: true,</div><div class=\"line\">        &quot;hmadi&quot;: true</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;two&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;three&quot;: &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。</div><div class=\"line\">    //消息数据可以通过room ID方便的分页和查询。</div><div class=\"line\">    &quot;messages&quot;: &#123;</div><div class=\"line\">      &quot;one&quot;: &#123;</div><div class=\"line\">        &quot;m1&quot;: &#123; &quot;sender&quot;: &quot;mchen&quot;, &quot;message&quot;: &quot;foo&quot; &#125;,</div><div class=\"line\">        &quot;m2&quot;: &#123; ... &#125;,</div><div class=\"line\">        &quot;m3&quot;: &#123; ... &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;two&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;three&quot;: &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这样组织数据，就可以很方便的查询room列表了，只需要传输很少的字节数。message数据也可以很容易的查询。</p>\n<h3 id=\"使数据可扩展\"><a href=\"#使数据可扩展\" class=\"headerlink\" title=\"使数据可扩展\"></a>使数据可扩展</h3><p>很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;john&quot;: &#123;</div><div class=\"line\">         &quot;todoList&quot;: &#123;</div><div class=\"line\">            &quot;rec1&quot;: &quot;Walk the dog&quot;,</div><div class=\"line\">            &quot;rec2&quot;: &quot;Buy milk&quot;,</div><div class=\"line\">            &quot;rec3&quot;: &quot;Win a gold medal in the Olympics&quot;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John可能有一个长达数千项的todo列表）。</p>\n<p>但仅仅如此可能还是不够的。考虑一个例子，users和groups之间的双向关系。user可以属于group，group包含一个user列表。乍看之下数据可能这样组织：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;mchen&quot;: &#123; &quot;name&quot;: &quot;Mary Chen&quot; &#125;,</div><div class=\"line\">      &quot;brinchen&quot;: &#123; &quot;name&quot;: &quot;Byambyn Rinchen&quot; &#125;,</div><div class=\"line\">      &quot;hmadi&quot;: &#123; &quot;name&quot;: &quot;Hamadi Madi&quot; &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;groups&quot;: &#123;</div><div class=\"line\">      &quot;alpha&quot;: &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;Alpha Tango&quot;,</div><div class=\"line\">         &quot;members&quot;: &#123;</div><div class=\"line\">            &quot;m1&quot;: &quot;mchen&quot;,</div><div class=\"line\">            &quot;m2&quot;: &quot;brinchen&quot;,</div><div class=\"line\">            &quot;m3&quot;: &quot;hamadi&quot;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;bravo&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;charlie&quot;: &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>看起来不错。但是当需要判断一个user属于哪些group的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的group，但这样做成本很高，也很慢。更糟糕的是，如果Mary没有权限查看所有的group时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。</p>\n<p>我们需要的是一种优雅的方式，可以列出Mary属于哪些group，只需要查询这些group就行了。数据可以这样组织：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"mchen\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Mary Chen\"</span>,</div><div class=\"line\">        <span class=\"comment\">// 在Mary的数据下，建立他所属group的索引。</span></div><div class=\"line\">        <span class=\"string\">\"groups\"</span>: &#123;</div><div class=\"line\">           <span class=\"comment\">// 这里的值是什么并不重要。重要的是这个子节点的key存在。</span></div><div class=\"line\">           <span class=\"string\">\"alpha\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">           <span class=\"string\">\"charlie\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"groups\"</span>: &#123; ... &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们把关系数据同时存储在了Mary的记录下和group数据下，这样造成了数据的重复。如果要把Mary从一个组中删除，就需要更新两个地方。</p>\n<p>对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询Mary的个人信息，即使users和groups都有百万级的数据，且规则表达式禁止访问不相关的数据时。</p>\n<p>为什么我们把id作为key，而把value设置为<code>true</code>呢？这样做是有好处的。这样使得检查一个id是否存在变得非常简单，只需要读取<code>/users/mchen/groups/$group_id</code>，看它是否为null就可以了。</p>\n<h2 id=\"操作数据\"><a href=\"#操作数据\" class=\"headerlink\" title=\"操作数据\"></a>操作数据</h2><h3 id=\"操作数据的方式\"><a href=\"#操作数据的方式\" class=\"headerlink\" title=\"操作数据的方式\"></a>操作数据的方式</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">method说明</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PUT</td>\n<td style=\"text-align:left\">写入或更新路径下的数据，如 <code>messages/users/user1/&lt;data&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PATCH</td>\n<td style=\"text-align:left\">更新指定路径下的部分key值，但是不影响其他的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">POST</td>\n<td style=\"text-align:left\">在Wilddog数据库中增加一个节点，每次发送一个POST请求都会生成一个独一无二的ID，如<code>messages/users/&lt;unique-id&gt;/&lt;data&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DELETE</td>\n<td style=\"text-align:left\">删除指定数据路径下的数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用PUT来写入数据\"><a href=\"#使用PUT来写入数据\" class=\"headerlink\" title=\"使用PUT来写入数据\"></a>使用PUT来写入数据</h3><p>REST API基本的写入数据的操作是<code>PUT</code>。为了演示数据存储，我们将建立一个博客应用，应用的所有数据都存储在Wilddog应用对应的URl<code>https://docs-examples.wilddogio.com/rest/saving-data/wildblog</code>中。</p>\n<p>下面来存储一些用户的数据到数据库中，我们存储每个用户的唯一用户名，还存储全名和出生日期。由于用户名是独一无二的，所以适合使用<code>PUT</code>而不是<code>POST</code>方法，因为我们已经有作为key值的字段，不需要生成。</p>\n<p>使用<code>PUT</code>方法，我们可以写入<code>string</code>, <code>number</code>, <code>boolean</code>,<code>array</code>或者任意的JSON对象到我们的数据库，这里我们将传递一个JSON对象：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d '&#123;</div><div class=\"line\">  \"alanisawesome\": &#123;</div><div class=\"line\">    \"name\": \"Alan Turing\",</div><div class=\"line\">    \"birthday\": \"June 23, 1912\"</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;' 'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users.json'</div></pre></td></tr></table></figure>\n<p>当一个JSON对象被存储到数据库中，对象的属性被自动映射到指定位置。如果我们定位到新添加的节点上，我们会看到值“Alan Turing”，我们也可以直接保存数据到子路径节点上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d <span class=\"string\">'\"Alan Turing\"'</span> \\</div><div class=\"line\">  <span class=\"string\">'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/name.json'</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&quot;June 23, 1912&quot;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/birthday.json&apos;</div></pre></td></tr></table></figure>\n<p>以上两个例子采用了两种方法写入数据：一次性写入一个JSON对象，和分别写入每个子数据节点。两种方式最终写入数据的结果是一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;users&quot;: &#123;</div><div class=\"line\">    &quot;alanisawesome&quot;: &#123;</div><div class=\"line\">      &quot;date_of_birth&quot;: &quot;June 23, 1912&quot;,</div><div class=\"line\">      &quot;full_name&quot;: &quot;Alan Turing&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，并且响应中会包含存储到数据库中的数据。上面的两个例子中，对于关注数据变化的其它客户端，第一个例子的做法仅仅触发一个事件，而第二个例子将触发两个事件。注意，如果要写入的路径节点下已经存在数据，第一种方法会覆盖已有的数据，而第二种方法只是修改两个子节点的值，而不会影响已有的其他子节点的数据。<code>PUT</code>方法等同于JavaScript SDK的<code>set()</code>方法。</p>\n<h3 id=\"使用PATCH来更新数据\"><a href=\"#使用PATCH来更新数据\" class=\"headerlink\" title=\"使用PATCH来更新数据\"></a>使用PATCH来更新数据</h3><p>使用<code>PATCH</code>请求，我们可以更新指定子节点的数据，而不覆盖其它已经存在的数据。例如使用<code>PATCH</code>请求为Turing添加nickname：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PATCH -d &apos;&#123;</div><div class=\"line\">  &quot;nickname&quot;: &quot;ACE&quot;</div><div class=\"line\">&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json&apos;</div></pre></td></tr></table></figure>\n<p>上面的请求将<code>nickname</code>添加到<code>alanisawesome</code>对象而不删除子节点<code>name</code>和<code>birthday</code>。如果使用的是<code>PUT</code>请求，<code>name</code>和<code>birthday</code>将会被删除，因为他们没有出现在请求中。执行完<code>PATCH</code>请求之后，数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;users&quot;: &#123;</div><div class=\"line\">    &quot;alanisawesome&quot;: &#123;</div><div class=\"line\">      &quot;date_of_birth&quot;: &quot;June 23, 1912&quot;,</div><div class=\"line\">      &quot;full_name&quot;: &quot;Alan Turing&quot;,</div><div class=\"line\">      &quot;nickname&quot;: &quot;ACE&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，并且响应中会包含更新到数据库中的数据。</p>\n<h3 id=\"保存列表数据\"><a href=\"#保存列表数据\" class=\"headerlink\" title=\"保存列表数据\"></a>保存列表数据</h3><p>如果要给添加到数据库中的元素生成一个独一无二的、基于时间戳的key，我们可以使用<code>POST</code>请求。对于我们的<code>users</code>路径，我们自行定义user数据的key是很有必要的，因为每个用户都有有唯一用户名。但是当用户发表博客时，我们可以使用<code>POST</code>请求为博客数据自动生成key。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;</div><div class=\"line\">  &quot;author&quot;: &quot;alanisawesome&quot;,</div><div class=\"line\">  &quot;title&quot;: &quot;The Turing Machine&quot;</div><div class=\"line\">&#125;&apos; &apos;https://docs-examples.wilddogio.com/rest/saving-data/wildblog/posts.json&apos;</div></pre></td></tr></table></figure>\n<p>我们的<code>posts</code>路径下的数据将会是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;posts&quot;: &#123;</div><div class=\"line\">    &quot;-JRHTHaKuITFIhnj02kE&quot;: &#123;</div><div class=\"line\">      &quot;author&quot;: &quot;alanisawesome&quot;,</div><div class=\"line\">      &quot;title&quot;: &quot;The Turing Machine&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，<code>key-JRHTHaKuITFIhnj02kE</code>是自动生成的，因为我们使用的是<code>POST</code>请求。成功的请求将返回HTTP 200 OK状态码，并且响应中会包含新数据的key。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&quot;name&quot;:&quot;-JRHTHaKuITFIhnj02kE&quot;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>要删除Wilddog中的数据，我们可以发送<code>DELETE</code>请求到要删除数据对应的路径上。下面的命令将删除<code>users</code>路径上的<code>alanisawesome</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X DELETE \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json&apos;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，和一个空的JSON。</p>\n<h3 id=\"URI参数\"><a href=\"#URI参数\" class=\"headerlink\" title=\"URI参数\"></a>URI参数</h3><p>当向数据库写入数据时，REST API可以接受以下的参数：</p>\n<p><strong>auth</strong></p>\n<p><code>auth</code>参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。auth参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含<code>auth</code>参数的<code>POST</code>请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;Authenticated POST request&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL&apos;</div></pre></td></tr></table></figure>\n<p><strong>print</strong></p>\n<p><code>print</code>参数让我们可以设置响应的内容格式。把<code>print=pretty</code>添加到请求中将会返回易读的格式。<code>GET</code>、<code>PUT</code>、<code>POST</code>和<code>PATCH</code>请求都支持<code>print=pretty</code>参数。</p>\n<h4 id=\"写入服务端数据\"><a href=\"#写入服务端数据\" class=\"headerlink\" title=\"写入服务端数据\"></a><strong>写入服务端数据</strong></h4><p>服务端数值使用占位符： <code>.sv</code>。<code>.sv</code>的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;.sv&quot;: &quot;timestamp&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json&apos;</div></pre></td></tr></table></figure>\n<p>服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考<a href=\"http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa\" target=\"_blank\" rel=\"external\">百科</a>。</p>\n<h4 id=\"提高写入性能\"><a href=\"#提高写入性能\" class=\"headerlink\" title=\"提高写入性能\"></a><strong>提高写入性能</strong></h4><p>如果我们要向数据库写入大量的数据，我们可以使用<code>print=silent</code>参数来提高写入性能和减少带宽占用。在正常的写操作中，服务器使用已经写入到数据库中的JSON数据来响应。当指定了<code>print=slient</code>参数，服务器会在数据传输完后立即关闭连接来减少带宽占用。</p>\n<p>如果我们需要发送大量的请求到数据库，我们可以在HTTPS请求头中添加<code>Keep-Alive</code>请求来复用连接。</p>\n<h3 id=\"错误码\"><a href=\"#错误码\" class=\"headerlink\" title=\"错误码\"></a>错误码</h3><p>REST API将在以下情况返回错误码：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">错误码描述</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">404 Not Found</td>\n<td style=\"text-align:left\">通过HTTP请求而不是HTTPS请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">不能解析PUT或POST数据；丢失PUT或POST数据；PUT或POST数据过长；REST API调用路径中包含非法的子节点名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">417 Expectation Failed</td>\n<td style=\"text-align:left\">REST API调用没有指定Wilddog应用id</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">403 Forbidden</td>\n<td style=\"text-align:left\">请求违反规则表达式的约束</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"读取与监听数据\"><a href=\"#读取与监听数据\" class=\"headerlink\" title=\"读取与监听数据\"></a>读取与监听数据</h2><h3 id=\"使用GET方法读取数据\"><a href=\"#使用GET方法读取数据\" class=\"headerlink\" title=\"使用GET方法读取数据\"></a>使用GET方法读取数据</h3><p>我们可以发送<code>GET</code>请求到数据的URL来读取数据，让我们继续博客的示例，读取全部的博客数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://docs-examples.wilddogio.com/rest/saving-data/wdblog/posts.json?print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，并且响应中会包含读取到的数据。</p>\n<h3 id=\"添加URI参数\"><a href=\"#添加URI参数\" class=\"headerlink\" title=\"添加URI参数\"></a>添加URI参数</h3><p>当我们从数据库中读取数据的时候，REST API可以接受多个参数。下面是最常用的参数。想了解全部的参数，请参见 <a href=\"/api/sync/rest.html\">REST API文档</a>。</p>\n<p><strong>auth</strong><code>auth</code>参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。<code>auth</code>参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含<code>auth</code>参数的<code>POST</code>请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;Authenticated POST request&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL&apos;</div></pre></td></tr></table></figure>\n<p><strong>print</strong>指定<code>print=pretty</code>返回易读格式的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/users/jack/name.json?print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>指定<code>print=silent</code>返回204 No Content状态码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/users/jack/name.json?print=silent&apos;</div></pre></td></tr></table></figure>\n<p><strong>callback</strong>为了让来自web客户端的rest请求实现跨域，你可以用JSONP将响应封装到JavaScript回调方法中。使用 <code>callback=</code> 让REST API将返回的数据封装到你指定的回调方法中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">  function gotData(data) &#123;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;https://&lt;appId&gt;.wilddogio.com/.json?callback=gotData&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p><strong>shallow</strong>这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 <code>shallow=true</code> 将限制数据返回的深度。如果返回的数据是JSON原始类型 (如string, number 或 boolean)， 它的value将被返回。 如果数据的snapshot是 JSON 对象，每一个key的value都将被截断成布尔类型<code>true</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;message&quot;: &#123;</div><div class=\"line\">    &quot;user&quot;: &#123;</div><div class=\"line\">      &quot;name&quot;: &quot;Chris&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;body&quot;: &quot;Hello!&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// REST请求路径为 /message.json?shallow=true</div><div class=\"line\">// 返回的数据如下:</div><div class=\"line\">&#123;</div><div class=\"line\">  &quot;user&quot;: true,</div><div class=\"line\">  &quot;body&quot;: true</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// REST请求路径为 /message/body.json?shallow=true</div><div class=\"line\">// 返回的数据如下:</div><div class=\"line\">&quot;Hello!&quot;</div></pre></td></tr></table></figure>\n<p>使用shallow参数后， 将不能使用其他查询参数。</p>\n<h4 id=\"读取服务端时间戳\"><a href=\"#读取服务端时间戳\" class=\"headerlink\" title=\"读取服务端时间戳\"></a><strong>读取服务端时间戳</strong></h4><p>当我们需要获取服务器的当前时间戳时，可以进行如下操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/.json?sv=timestamp&apos;</div></pre></td></tr></table></figure>\n<p>服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考<a href=\"http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa\" target=\"_blank\" rel=\"external\">百科</a>。</p>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>你可以使用一些参数来对数据进行查询。首先使用<code>orderBy</code>参数来指定数据的排列顺序，然后结合使用<code>limitToFirst</code>，<code>limitToLast</code>，<code>startAt</code>，<code>endAt</code>和<code>equalTo</code>参数来对数据进行查询。</p>\n<p>注意：使用REST API对数据进行查询时，返回的数据集没有固定的顺序，这是因为JSON解释器没有强制排序。如果需要排序，你需要自己在程序中对返回的数据进行排序。</p>\n<p>下面我们来举例如何进行数据查询。假设现在有一些关于恐龙的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;lambeosaurus&quot;: &#123;</div><div class=\"line\">    &quot;height&quot;: 2.1,</div><div class=\"line\">    &quot;length&quot;: 12.5,</div><div class=\"line\">    &quot;weight&quot;: 5000</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;stegosaurus&quot;: &#123;</div><div class=\"line\">    &quot;height&quot;: 4,</div><div class=\"line\">    &quot;length&quot;: 9,</div><div class=\"line\">    &quot;weight&quot;: 2500</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有四种方式对数据进行查询：按照子节点的value值，按照节点名称key，按照节点value值和节点优先级priority。查询条件以其中一个参数开头，后面必须与<code>limitToFirst</code>，<code>limitToLast</code>，<code>startAt</code>，<code>endAt</code>和<code>equalTo</code>这些参数配合使用。</p>\n<p><strong>按照子节点value值排序</strong>将子节点的名称传给<code>orderBy</code>参数，就可以按照指定子节点的value值进行排序。 例如，想要查询所有的高度大于等于3米的恐龙，我们可以使用以下参数查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;startAt=3&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>注意： 如果你想要在应用中按照某个子节点的value值排序，你需要在规则表达式中配置<code>&quot;.indexOn&quot;:&quot;&lt;childkey&gt;&quot;</code>。详细的文档请参考规则表达式API文档中关于 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 的介绍。</p>\n<p><strong>按照数据节点名称排序</strong>可以通过使用<code>orderBy=&quot;$key&quot;</code>参数来按照节点名称查询数据。 下面的例子将返回名称在a到m之间所有的节点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;$key&quot;&amp;startAt=&quot;a&quot;&amp;endAt=&quot;m&quot;&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p><strong>按照节点的value值排序</strong>我们可以按照节点的value值进行排序。 例如，恐龙举办运动会，我们按照以下格式记录恐龙的成绩：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scores&quot;: &#123;</div><div class=\"line\">    &quot;bruhathkayosaurus&quot;: 55,</div><div class=\"line\">    &quot;lambeosaurus&quot;: 21,</div><div class=\"line\">    &quot;linhenykus&quot;: 80,</div><div class=\"line\">    &quot;pterodactyl&quot;: 93,</div><div class=\"line\">    &quot;stegosaurus&quot;: 5,</div><div class=\"line\">    &quot;triceratops&quot;: 22</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要查询所有成绩高于50分的恐龙，我们可以使用以下参数查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/scores.json?orderBy=&quot;$value&quot;&amp;startAt=50&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>参考数据排序部分的介绍，了解使用<code>orderBy=&quot;$value&quot;</code>参数查询时，数据是如何排序的。</p>\n<p>注意： 如果你想要在应用中按照节点的value值排序，你需要在规则表达式中配置<code>&quot;.indexOn&quot; : &quot;.value&quot;</code>。详细的文档请参考规则表达式API文档中关于 <a href=\"old/sync/rules/api-rule#.indexOn\">.indexOn</a> 的介绍。</p>\n<p><strong>按照优先级排序</strong>可以使用<code>orderBy=&quot;$priority&quot;</code>参数来按照节点的优先级查询数据。详细的优先级介绍请参见 <a href=\"sync/rules/api-rule.html#Priorities0\">API文档</a>。</p>\n<h3 id=\"复杂查询\"><a href=\"#复杂查询\" class=\"headerlink\" title=\"复杂查询\"></a>复杂查询</h3><p>可以将多个参数进行组合使用，实现更复杂的查询功能。</p>\n<p><strong>limit查询</strong><code>limitToFirst</code>和<code>limitToLast</code>参数用来设置返回结果集的大小。例如，查询条件限制为100，如果记录数小于100，则会返回所有的数据，如果记录数超过100，则会返回其中的100条记录，使用<code>limitToFirst</code>得到最前面的100条记录，使用<code>limitToLast</code>得到最后面的100条记录。</p>\n<p>在恐龙数据库中使用<code>orderBy</code>和<code>limitToLast</code>，我们可以得到体重最重的两头恐龙的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;weight&quot;&amp;limitToLast=2&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>同样，我们可以使用<code>limitToFirst</code>参数来得到高度最小的两头恐龙的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;limitToFirst=2&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>我们可以将<code>limitToLast</code>参数与<code>orderBy=&quot;$value&quot;</code>参数配合使用。例如，我们给恐龙运动会创建一个排行榜，查询分数最高的三头恐龙，则可以使用以下参数查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/scores.json?orderBy=&quot;$value&quot;&amp;limitToLast=3&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p><strong>range查询</strong>使用<code>startAt</code>，<code>endAt</code>和<code>equalTo</code>参数来设置查询范围的起点和终点。例如，我们想要查询至少3米高的恐龙，可以使用<code>orderBy</code>和<code>startAt</code>的组合查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;startAt=3&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>我们可以使用<code>endAt</code>参数来查询名字的字典顺序在Pterodactyl之前的所有的恐龙：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;$key&quot;&amp;endAt=&quot;pterodactyl&quot;&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>我们可以使用<code>startAt</code>和<code>endAt</code>的组合来控制我们查询的范围。下面的例子是查询名字以b开头的所有的恐龙：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;$key&quot;&amp;startAt=&quot;b&quot;&amp;endAt=&quot;b~&quot;&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>波浪线在ASCII中的编码是126，它排在ASCII中常规字符的后面，查询返回的是所有b开头的字符串。</p>\n<p>范围查询在分页中非常有用。</p>\n<h2 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h2><p>这一部分主要介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>orderBy</strong>当使用<code>orderBy</code>参数时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型，则排序不固定，此时不建议使用<code>orderBy</code>参数获取全量数据。例如，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scores&quot;: &#123;</div><div class=\"line\">    &quot;no1&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;tyrannosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : &quot;120&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no2&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;bruhathkayosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : 55</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no3&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;lambeosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : 21</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no4&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;linhenykus&quot;,</div><div class=\"line\">        &quot;score&quot; : 80</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no5&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;pterodactyl&quot;,</div><div class=\"line\">        &quot;score&quot; : 93</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no6&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;stegosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : 5</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no7&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;triceratops&quot;,</div><div class=\"line\">        &quot;score&quot; : 22</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no8&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;brontosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : true</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>numberic</code>类型，此时使用 <code>orderBy</code>参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用<code>limitToFirst</code>或<code>limitToLast</code>时，将获得不确定的结果。</p>\n<p>当配合使用<code>startAt</code>、<code>endAt</code>和<code>equalTo</code>参数时，如果子节点的公有属性key包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 <code>orderBy=&quot;score&quot;&amp;startAt=60</code> 将得到下面的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;no4&quot; : &#123;</div><div class=\"line\">      &quot;name&quot; : &quot;linhenykus&quot;,</div><div class=\"line\">      &quot;score&quot; : 80</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;no5&quot; : &#123;</div><div class=\"line\">      &quot;name&quot; : &quot;pterodactyl&quot;,</div><div class=\"line\">      &quot;score&quot; : 93</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Object</code>类型数据的 value 值为 null，不会出现在结果中。</p>\n<p><em>注意：如果path与value的总长度超过1000字节时，使用</em><code>orderBy</code><em>参数将搜索不到该数据。</em></p>\n<p><strong>orderBy=”$key”</strong>当使用<code>orderBy=&quot;$key&quot;</code>参数对数据进行排序时，数据将会按照key值增序排列。注意，key值只能是字符型。</p>\n<ol>\n<li>1.key值能够被解析成数字的节点排在最前面，增序排列</li>\n<li>2.接下来是字符型key值，按照字典顺序增序排列</li>\n</ol>\n<p><strong>orderBy=”$value”</strong>当使用<code>orderBy=&quot;$value&quot;</code>参数时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型，则排序不固定， 此时不建议使用<code>orderBy=&quot;$value&quot;</code>获取全量数据，例如，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scores&quot;: &#123;</div><div class=\"line\">    &quot;tyrannosaurus&quot; : &quot;120&quot;,</div><div class=\"line\">    &quot;bruhathkayosaurus&quot; : 55,</div><div class=\"line\">    &quot;lambeosaurus&quot; : 21,</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93,</div><div class=\"line\">    &quot;stegosaurus&quot; : 5,</div><div class=\"line\">    &quot;triceratops&quot; : 22,</div><div class=\"line\">    &quot;brontosaurus&quot; : true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>numberic</code>类型，此时使用 <code>orderBy=&quot;$value&quot;</code>参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用<code>limitToFirst</code>或<code>limitToLast</code>参数时，将获得不确定的结果。</p>\n<p>当配合使用<code>startAt</code>、<code>endAt</code>和<code>equalTo</code>时，如果子节点的value包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 <code>orderBy=&quot;$value&quot;&amp;startAt=60</code> 将得到下面的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Object</code>类型数据的 value 值为 null，不会出现在结果中。</p>\n<p><em>注意：如果path与value的总长度超过1000字节时，使用</em><code>orderBy=&quot;$value&quot;</code><em>参数将搜索不到该数据。</em></p>\n<p><strong>orderBy=”$priority”</strong>当使用<code>orderBy=&quot;$priority&quot;</code>参数对数据进行排序时，数据的顺序取决于优先级以及key值。注意，优先级的值只能是数字型或字符型。</p>\n<ol>\n<li>1.没有优先级的节点放在最前面</li>\n<li>2.接着是数字型的优先级，按照优先级从小到大的顺序排列</li>\n<li>3.接下来是字符型的优先级，按照优先级的字典顺序排列</li>\n<li>4.当两个节点的优先级相同，就按照key值排序，数字型key在前（数值排序），其余类型的key在后（字典排序）</li>\n</ol>\n<p>关于优先级更多的内容，请参见 <a href=\"/api/sync/rest.html#Priorities\">API文档</a>。</p>\n<h3 id=\"Streaming\"><a href=\"#Streaming\" class=\"headerlink\" title=\"Streaming\"></a>Streaming</h3><p>Wilddog REST端点支持 <a href=\"http://www.w3.org/TR/eventsource/\" target=\"_blank\" rel=\"external\">EventSource\\/Server-Sent Events</a> 协议，使客户端可以持续得到指定节点下数据发生的变化。</p>\n<p>想要开始streaming，我们需要：</p>\n<ol>\n<li>将客户端请求的Accept头设置为<code>text/event-stream</code></li>\n<li>考虑http跳转，特别是307状态码</li>\n<li>如果数据访问需要校验权限，需要添加<code>auth</code>参数。</li>\n</ol>\n<p>当指定节点的数据发生变化时，服务器会发送事件回来。消息的结构符合<code>EventSource</code>协议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">event: event name</div><div class=\"line\">data: JSON encoded data payload</div></pre></td></tr></table></figure>\n<p>服务器会返回以下的事件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">put</td>\n<td style=\"text-align:left\">JSON格式数据，有两个key：path和data；path指向请求URL的路径；客户端应该使用消息中包含的数据替换本地缓存中的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">patch</td>\n<td style=\"text-align:left\">JSON格式数据，有两个key：path和data；path指向请求URL的路径；对与数据的每一个key，客户端应该用消息中包含的key替代缓存中的key</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">keep-alive</td>\n<td style=\"text-align:left\">此事件的data为null，不需要任何操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">auth_revoked</td>\n<td style=\"text-align:left\">该事件的数据是字符串，表示认证过期；认证参数失效后，该事件将被发送</td>\n</tr>\n</tbody>\n</table>\n<p>下面是服务器能够发送的事件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 设置整个缓存为 &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;</div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/&quot;, &quot;data&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">//将新数据放到key为c的缓存中，这样整个缓存是下面的结构</div><div class=\"line\">// &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">// 数据中的每个key，更新（或添加）相应的key到缓存的路径/c下</div><div class=\"line\">// 最终的缓存为: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: 3, &quot;bar&quot;: false, &quot;baz&quot;: 4&#125;&#125;</div><div class=\"line\">event: patch</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: 3, &quot;baz&quot;: 4&#125;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全是一个非常重大的话题，通常也是app开发中最困难的部分之一。Wilddog使用一种声明式的规则表达式，对数据的访问权限进行配置，让这一切变得简单。</p>\n<h3 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h3><p>用户ID是一个非常重要概念，不同的用户拥有不同的数据和不同的权限，比如，在一个聊天程序中，每一条消息都有它的发布者，用户可以删除自己的消息，而不能删除别人的。安全的第一步是用户认证。</p>\n<p>Wilddog 提供了以下终端用户认证的方式：</p>\n<ul>\n<li>集成微博，微信，QQ等社交平台的OAuth认证</li>\n<li>Email\\/密码登录，并且提供用户管理</li>\n<li>匿名用户访问</li>\n<li>自定义token，方便用户集成已有的用户账户系统。</li>\n</ul>\n<h3 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h3><p>知道用户的身份只是安全的一部分，一旦你知道谁在访问数据，你需要一种方式来控制访问权限。Wilddog提供了一种声明式的表达式语言，你可以在控制面板中的“规则表达式”tab下进行编辑。这些规则表达式让你可以管理数据的访问规则。规则级联应用到其子节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;foo&quot;: &#123;</div><div class=\"line\">      &quot;.read&quot;: true，</div><div class=\"line\">      &quot;.write&quot;: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个例子允许所有人访问数据节点 <code>foo</code>。</p>\n<p>规则表达式包含一系列内置对象和函数。最重要的一个内置对象是auth，它在终端用户认证的时候生成，包含终端用户的信息和用户的唯一id：auth.uid。</p>\n<p>auth对象是很多规则表达式的基础。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user_id&quot;: &#123;</div><div class=\"line\">        &quot;.write&quot;: &quot;$user_id == auth.uid&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个规则保证了：只有终端用户的唯一id等于动态路径$user_id的值时，用户才能写入数据。</p>\n<h3 id=\"数据校验\"><a href=\"#数据校验\" class=\"headerlink\" title=\"数据校验\"></a>数据校验</h3><p>规则表达式中还包含一个<code>.validate</code>规则，用于对数据进行校验，确保数据的格式正确。它的语法和<code>.read</code>与<code>.write</code>相同，不同的是<code>.validate</code>规则不会向下级联。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;foo&quot;: &#123;</div><div class=\"line\">      &quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length() &lt; 100&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一规则确保了在\\/foo\\/节点下，写入的数据必须是字符串类型，且必须长度小于100。</p>\n<p><code>.validate</code>规则可以使用的内置对象和方法与<code>.read</code>和<code>.write</code>相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;user&quot;: &#123;</div><div class=\"line\">      &quot;.validate&quot;: &quot;auth != null &amp;&amp; newData.val() == auth.uid&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一规则强制使写入\\/user\\/下的数据必须是当前登陆用户的唯一id。</p>\n<p><code>.validate</code>规则并不是要彻底取消应用中的数据校验代码。为了获得更好的性能和用户体验，你仍然必须在应用代码中对数据进行校验。</p>\n<h3 id=\"规则表达式设置\"><a href=\"#规则表达式设置\" class=\"headerlink\" title=\"规则表达式设置\"></a>规则表达式设置</h3><p>使用REST API，你可以通过发送PUT请求到<code>/.settings/rules.json</code>路径为你的应用设置规则表达式。请求时你需要使用野狗的超级密钥，例如为了将所有读权限设置为true，可以发送如下的请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;rules&quot;:&#123;&quot;.read&quot;:true&#125;&#125;&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<p>通过REST API编写应用的安全规则表达式可以作为你应用部署流程中的一部分。</p>\n<p>注：通过REST API修改rules将会覆盖已经存在的规则表达式。</p>\n<h3 id=\"获取规则表达式\"><a href=\"#获取规则表达式\" class=\"headerlink\" title=\"获取规则表达式\"></a>获取规则表达式</h3><p>类似的，我们可以通过发送GET请求到<code>/.settings/rules.json</code>路径来获取规则表达式的设置内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl  &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<p>返回的数据将包含app设置的规则表达式的全部内容。</p>\n<h3 id=\"了解更多\"><a href=\"#了解更多\" class=\"headerlink\" title=\"了解更多\"></a>了解更多</h3><p>到此为止，你应该对Wilddog中的应用安全机制有了一个大体的了解。</p>\n<p>规则表达式是复杂且强大的，本开发向导中只涵盖了非常小的一部分。更多关于规则表达式的细节，请参考<a href=\"/guide/sync/rules/guide.html\">规则表达式文档</a>，这里将会讲述所有的内置方法和对象。</p>\n","excerpt":"","more":"<h2 id=\"使用入门\"><a href=\"#使用入门\" class=\"headerlink\" title=\"使用入门\"></a>使用入门</h2><p>在任何支持HTTPS的平台和语言中，都可以使用Wilddog REST API。在本指南中，我们使用命令行工具发送HTTPS请求。其他任何平台都可以参照该示例，使用 REST API。</p>\n<h3 id=\"数据是一棵-JSON-树\"><a href=\"#数据是一棵-JSON-树\" class=\"headerlink\" title=\"数据是一棵 JSON 树\"></a>数据是一棵 JSON 树</h3><p>所有的数据都存储在各个 JSON 对象中，没有任何表的概念。当你把数据添加到这棵json 树中，这些数据就变成这棵树的子树。比如，我们在<code>users/mchen</code> 下增加 <code>widget</code>后，我们的数据是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;users&quot;: &#123;</div><div class=\"line\">    &quot;mchen&quot;: &#123;</div><div class=\"line\">      &quot;friends&quot;: &#123; &quot;brinchen&quot;: true &#125;,</div><div class=\"line\">      &quot;name&quot;: &quot;Mary Chen&quot;,</div><div class=\"line\">      // 新数据节点会增加在已经存在的JSON树中</div><div class=\"line\">      &quot;widgets&quot;: &#123; &quot;one&quot;: true, &quot;three&quot;: true &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;brinchen&quot;: &#123; ... &#125;,</div><div class=\"line\">    &quot;hmadi&quot;: &#123; ... &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用数据URL\"><a href=\"#使用数据URL\" class=\"headerlink\" title=\"使用数据URL\"></a>使用数据URL</h3><p>通过REST API读取和写入数据时，我们在<code>curl</code>请求中包含一个指向数据地址的URL，这个URL会指向我们存储的所有数据。在这个示例中，我们将使用<code>https://docs-examples.wilddogio.com/web/data</code>这个地址。</p>\n<p>也可以直接访问子节点的数据，例如，要访问Mary Chen的name，只需要在URL之后追加<code>users/mchen/name</code>即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl https://docs-examples.wilddogio.com/web/data/users/mchen/name.json</div></pre></td></tr></table></figure>\n<h3 id=\"限制和约束\"><a href=\"#限制和约束\" class=\"headerlink\" title=\"限制和约束\"></a>限制和约束</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">描述约束备注</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">树的深度</td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">key的长度</td>\n<td style=\"text-align:left\">768bytes</td>\n<td style=\"text-align:left\">UTF-8 编码，不能包含<code>.</code> <code>$</code> <code>#</code> <code>[</code> <code>]</code> <code>/</code>和 ASCII控制字符0-31和127</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一个叶子节点的数据大小</td>\n<td style=\"text-align:left\">1mb</td>\n<td style=\"text-align:left\">UTF-8 编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过SDK写入的数据大小限制</td>\n<td style=\"text-align:left\">2mb</td>\n<td style=\"text-align:left\">UTF-8 编码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过 REST 写入数据大小限制</td>\n<td style=\"text-align:left\">4mb</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一次能读取的节点</td>\n<td style=\"text-align:left\">2000</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一次条件查询能返回的最大条数</td>\n<td style=\"text-align:left\">500</td>\n<td style=\"text-align:left\">如使用 limitToFirst、limitToLast等</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"特殊字符转义\"><a href=\"#特殊字符转义\" class=\"headerlink\" title=\"特殊字符转义\"></a>特殊字符转义</h3><p>当节点的key值是特殊字符时可能导致发送的curl请求URL无效，此时我们需要将特殊字符转义</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特殊字符转义符</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:left\">%3F</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">%</td>\n<td style=\"text-align:left\">%25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:left\">%2B</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">%3D</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&amp;</td>\n<td style=\"text-align:left\">%26</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"组织数据\"><a href=\"#组织数据\" class=\"headerlink\" title=\"组织数据\"></a>组织数据</h2><p>构造恰当的NoSQL存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。</p>\n<h3 id=\"避免层级过深\"><a href=\"#避免层级过深\" class=\"headerlink\" title=\"避免层级过深\"></a>避免层级过深</h3><p>尽管可以使用JSON任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog的工作方式是当你查询某个节点，Wilddog会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织SQL关系型数据表一样。</p>\n<p>我们不推荐这种实践</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// 一个非常差的充满嵌套的数据结构。请勿模仿。</span></div><div class=\"line\">    <span class=\"comment\">// 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。</span></div><div class=\"line\">    <span class=\"string\">\"rooms\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"one\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"room alpha\"</span>,</div><div class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"private\"</span>,</div><div class=\"line\">        <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">          <span class=\"string\">\"m1\"</span>: &#123; <span class=\"string\">\"sender\"</span>: <span class=\"string\">\"mchen\"</span>, <span class=\"string\">\"message\"</span>: <span class=\"string\">\"foo\"</span> &#125;,</div><div class=\"line\">          <span class=\"string\">\"m2\"</span>: &#123; ... &#125;,</div><div class=\"line\">          <span class=\"comment\">// 非常长的messages列表</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的rooms这样一个很简单的操作，也会查询整个<code>rooms</code>数据节点，返回所有的rooms下的数据节点到客户端。</p>\n<h3 id=\"使数据扁平化\"><a href=\"#使数据扁平化\" class=\"headerlink\" title=\"使数据扁平化\"></a>使数据扁平化</h3><p>如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    // rooms数据节点下仅包含房间的基本信息和唯一ID。</div><div class=\"line\">    &quot;rooms&quot;: &#123;</div><div class=\"line\">      &quot;one&quot;: &#123;</div><div class=\"line\">        &quot;name&quot;: &quot;room alpha&quot;,</div><div class=\"line\">        &quot;type&quot;: &quot;private&quot;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;two&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;three&quot;: &#123; ... &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //room成员可以很方便的的存取</div><div class=\"line\">    &quot;members&quot;: &#123;</div><div class=\"line\">      &quot;one&quot;: &#123;</div><div class=\"line\">        &quot;mchen&quot;: true,</div><div class=\"line\">        &quot;hmadi&quot;: true</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;two&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;three&quot;: &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。</div><div class=\"line\">    //消息数据可以通过room ID方便的分页和查询。</div><div class=\"line\">    &quot;messages&quot;: &#123;</div><div class=\"line\">      &quot;one&quot;: &#123;</div><div class=\"line\">        &quot;m1&quot;: &#123; &quot;sender&quot;: &quot;mchen&quot;, &quot;message&quot;: &quot;foo&quot; &#125;,</div><div class=\"line\">        &quot;m2&quot;: &#123; ... &#125;,</div><div class=\"line\">        &quot;m3&quot;: &#123; ... &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;two&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;three&quot;: &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这样组织数据，就可以很方便的查询room列表了，只需要传输很少的字节数。message数据也可以很容易的查询。</p>\n<h3 id=\"使数据可扩展\"><a href=\"#使数据可扩展\" class=\"headerlink\" title=\"使数据可扩展\"></a>使数据可扩展</h3><p>很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;john&quot;: &#123;</div><div class=\"line\">         &quot;todoList&quot;: &#123;</div><div class=\"line\">            &quot;rec1&quot;: &quot;Walk the dog&quot;,</div><div class=\"line\">            &quot;rec2&quot;: &quot;Buy milk&quot;,</div><div class=\"line\">            &quot;rec3&quot;: &quot;Win a gold medal in the Olympics&quot;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John可能有一个长达数千项的todo列表）。</p>\n<p>但仅仅如此可能还是不够的。考虑一个例子，users和groups之间的双向关系。user可以属于group，group包含一个user列表。乍看之下数据可能这样组织：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;mchen&quot;: &#123; &quot;name&quot;: &quot;Mary Chen&quot; &#125;,</div><div class=\"line\">      &quot;brinchen&quot;: &#123; &quot;name&quot;: &quot;Byambyn Rinchen&quot; &#125;,</div><div class=\"line\">      &quot;hmadi&quot;: &#123; &quot;name&quot;: &quot;Hamadi Madi&quot; &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;groups&quot;: &#123;</div><div class=\"line\">      &quot;alpha&quot;: &#123;</div><div class=\"line\">         &quot;name&quot;: &quot;Alpha Tango&quot;,</div><div class=\"line\">         &quot;members&quot;: &#123;</div><div class=\"line\">            &quot;m1&quot;: &quot;mchen&quot;,</div><div class=\"line\">            &quot;m2&quot;: &quot;brinchen&quot;,</div><div class=\"line\">            &quot;m3&quot;: &quot;hamadi&quot;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &quot;bravo&quot;: &#123; ... &#125;,</div><div class=\"line\">      &quot;charlie&quot;: &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>看起来不错。但是当需要判断一个user属于哪些group的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的group，但这样做成本很高，也很慢。更糟糕的是，如果Mary没有权限查看所有的group时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。</p>\n<p>我们需要的是一种优雅的方式，可以列出Mary属于哪些group，只需要查询这些group就行了。数据可以这样组织：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"mchen\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Mary Chen\"</span>,</div><div class=\"line\">        <span class=\"comment\">// 在Mary的数据下，建立他所属group的索引。</span></div><div class=\"line\">        <span class=\"string\">\"groups\"</span>: &#123;</div><div class=\"line\">           <span class=\"comment\">// 这里的值是什么并不重要。重要的是这个子节点的key存在。</span></div><div class=\"line\">           <span class=\"string\">\"alpha\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">           <span class=\"string\">\"charlie\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"groups\"</span>: &#123; ... &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们把关系数据同时存储在了Mary的记录下和group数据下，这样造成了数据的重复。如果要把Mary从一个组中删除，就需要更新两个地方。</p>\n<p>对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询Mary的个人信息，即使users和groups都有百万级的数据，且规则表达式禁止访问不相关的数据时。</p>\n<p>为什么我们把id作为key，而把value设置为<code>true</code>呢？这样做是有好处的。这样使得检查一个id是否存在变得非常简单，只需要读取<code>/users/mchen/groups/$group_id</code>，看它是否为null就可以了。</p>\n<h2 id=\"操作数据\"><a href=\"#操作数据\" class=\"headerlink\" title=\"操作数据\"></a>操作数据</h2><h3 id=\"操作数据的方式\"><a href=\"#操作数据的方式\" class=\"headerlink\" title=\"操作数据的方式\"></a>操作数据的方式</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">method说明</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">PUT</td>\n<td style=\"text-align:left\">写入或更新路径下的数据，如 <code>messages/users/user1/&lt;data&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PATCH</td>\n<td style=\"text-align:left\">更新指定路径下的部分key值，但是不影响其他的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">POST</td>\n<td style=\"text-align:left\">在Wilddog数据库中增加一个节点，每次发送一个POST请求都会生成一个独一无二的ID，如<code>messages/users/&lt;unique-id&gt;/&lt;data&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DELETE</td>\n<td style=\"text-align:left\">删除指定数据路径下的数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"使用PUT来写入数据\"><a href=\"#使用PUT来写入数据\" class=\"headerlink\" title=\"使用PUT来写入数据\"></a>使用PUT来写入数据</h3><p>REST API基本的写入数据的操作是<code>PUT</code>。为了演示数据存储，我们将建立一个博客应用，应用的所有数据都存储在Wilddog应用对应的URl<code>https://docs-examples.wilddogio.com/rest/saving-data/wildblog</code>中。</p>\n<p>下面来存储一些用户的数据到数据库中，我们存储每个用户的唯一用户名，还存储全名和出生日期。由于用户名是独一无二的，所以适合使用<code>PUT</code>而不是<code>POST</code>方法，因为我们已经有作为key值的字段，不需要生成。</p>\n<p>使用<code>PUT</code>方法，我们可以写入<code>string</code>, <code>number</code>, <code>boolean</code>,<code>array</code>或者任意的JSON对象到我们的数据库，这里我们将传递一个JSON对象：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d '&#123;</div><div class=\"line\">  \"alanisawesome\": &#123;</div><div class=\"line\">    \"name\": \"Alan Turing\",</div><div class=\"line\">    \"birthday\": \"June 23, 1912\"</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;' 'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users.json'</div></pre></td></tr></table></figure>\n<p>当一个JSON对象被存储到数据库中，对象的属性被自动映射到指定位置。如果我们定位到新添加的节点上，我们会看到值“Alan Turing”，我们也可以直接保存数据到子路径节点上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d <span class=\"string\">'\"Alan Turing\"'</span> \\</div><div class=\"line\">  <span class=\"string\">'https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/name.json'</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&quot;June 23, 1912&quot;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/wildblog/users/alanisawesome/birthday.json&apos;</div></pre></td></tr></table></figure>\n<p>以上两个例子采用了两种方法写入数据：一次性写入一个JSON对象，和分别写入每个子数据节点。两种方式最终写入数据的结果是一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;users&quot;: &#123;</div><div class=\"line\">    &quot;alanisawesome&quot;: &#123;</div><div class=\"line\">      &quot;date_of_birth&quot;: &quot;June 23, 1912&quot;,</div><div class=\"line\">      &quot;full_name&quot;: &quot;Alan Turing&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，并且响应中会包含存储到数据库中的数据。上面的两个例子中，对于关注数据变化的其它客户端，第一个例子的做法仅仅触发一个事件，而第二个例子将触发两个事件。注意，如果要写入的路径节点下已经存在数据，第一种方法会覆盖已有的数据，而第二种方法只是修改两个子节点的值，而不会影响已有的其他子节点的数据。<code>PUT</code>方法等同于JavaScript SDK的<code>set()</code>方法。</p>\n<h3 id=\"使用PATCH来更新数据\"><a href=\"#使用PATCH来更新数据\" class=\"headerlink\" title=\"使用PATCH来更新数据\"></a>使用PATCH来更新数据</h3><p>使用<code>PATCH</code>请求，我们可以更新指定子节点的数据，而不覆盖其它已经存在的数据。例如使用<code>PATCH</code>请求为Turing添加nickname：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PATCH -d &apos;&#123;</div><div class=\"line\">  &quot;nickname&quot;: &quot;ACE&quot;</div><div class=\"line\">&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json&apos;</div></pre></td></tr></table></figure>\n<p>上面的请求将<code>nickname</code>添加到<code>alanisawesome</code>对象而不删除子节点<code>name</code>和<code>birthday</code>。如果使用的是<code>PUT</code>请求，<code>name</code>和<code>birthday</code>将会被删除，因为他们没有出现在请求中。执行完<code>PATCH</code>请求之后，数据库中的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;users&quot;: &#123;</div><div class=\"line\">    &quot;alanisawesome&quot;: &#123;</div><div class=\"line\">      &quot;date_of_birth&quot;: &quot;June 23, 1912&quot;,</div><div class=\"line\">      &quot;full_name&quot;: &quot;Alan Turing&quot;,</div><div class=\"line\">      &quot;nickname&quot;: &quot;ACE&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，并且响应中会包含更新到数据库中的数据。</p>\n<h3 id=\"保存列表数据\"><a href=\"#保存列表数据\" class=\"headerlink\" title=\"保存列表数据\"></a>保存列表数据</h3><p>如果要给添加到数据库中的元素生成一个独一无二的、基于时间戳的key，我们可以使用<code>POST</code>请求。对于我们的<code>users</code>路径，我们自行定义user数据的key是很有必要的，因为每个用户都有有唯一用户名。但是当用户发表博客时，我们可以使用<code>POST</code>请求为博客数据自动生成key。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;</div><div class=\"line\">  &quot;author&quot;: &quot;alanisawesome&quot;,</div><div class=\"line\">  &quot;title&quot;: &quot;The Turing Machine&quot;</div><div class=\"line\">&#125;&apos; &apos;https://docs-examples.wilddogio.com/rest/saving-data/wildblog/posts.json&apos;</div></pre></td></tr></table></figure>\n<p>我们的<code>posts</code>路径下的数据将会是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;posts&quot;: &#123;</div><div class=\"line\">    &quot;-JRHTHaKuITFIhnj02kE&quot;: &#123;</div><div class=\"line\">      &quot;author&quot;: &quot;alanisawesome&quot;,</div><div class=\"line\">      &quot;title&quot;: &quot;The Turing Machine&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，<code>key-JRHTHaKuITFIhnj02kE</code>是自动生成的，因为我们使用的是<code>POST</code>请求。成功的请求将返回HTTP 200 OK状态码，并且响应中会包含新数据的key。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;&quot;name&quot;:&quot;-JRHTHaKuITFIhnj02kE&quot;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>要删除Wilddog中的数据，我们可以发送<code>DELETE</code>请求到要删除数据对应的路径上。下面的命令将删除<code>users</code>路径上的<code>alanisawesome</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X DELETE \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/users/alanisawesome.json&apos;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，和一个空的JSON。</p>\n<h3 id=\"URI参数\"><a href=\"#URI参数\" class=\"headerlink\" title=\"URI参数\"></a>URI参数</h3><p>当向数据库写入数据时，REST API可以接受以下的参数：</p>\n<p><strong>auth</strong></p>\n<p><code>auth</code>参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。auth参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含<code>auth</code>参数的<code>POST</code>请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;Authenticated POST request&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL&apos;</div></pre></td></tr></table></figure>\n<p><strong>print</strong></p>\n<p><code>print</code>参数让我们可以设置响应的内容格式。把<code>print=pretty</code>添加到请求中将会返回易读的格式。<code>GET</code>、<code>PUT</code>、<code>POST</code>和<code>PATCH</code>请求都支持<code>print=pretty</code>参数。</p>\n<h4 id=\"写入服务端数据\"><a href=\"#写入服务端数据\" class=\"headerlink\" title=\"写入服务端数据\"></a><strong>写入服务端数据</strong></h4><p>服务端数值使用占位符： <code>.sv</code>。<code>.sv</code>的值就是我们期望的服务端数值类型。例如，当一个用户被创建的时候需要设置一个时间戳，我们应该如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;.sv&quot;: &quot;timestamp&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/alanisawesome/createdAt.json&apos;</div></pre></td></tr></table></figure>\n<p>服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考<a href=\"http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa\">百科</a>。</p>\n<h4 id=\"提高写入性能\"><a href=\"#提高写入性能\" class=\"headerlink\" title=\"提高写入性能\"></a><strong>提高写入性能</strong></h4><p>如果我们要向数据库写入大量的数据，我们可以使用<code>print=silent</code>参数来提高写入性能和减少带宽占用。在正常的写操作中，服务器使用已经写入到数据库中的JSON数据来响应。当指定了<code>print=slient</code>参数，服务器会在数据传输完后立即关闭连接来减少带宽占用。</p>\n<p>如果我们需要发送大量的请求到数据库，我们可以在HTTPS请求头中添加<code>Keep-Alive</code>请求来复用连接。</p>\n<h3 id=\"错误码\"><a href=\"#错误码\" class=\"headerlink\" title=\"错误码\"></a>错误码</h3><p>REST API将在以下情况返回错误码：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">错误码描述</th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">404 Not Found</td>\n<td style=\"text-align:left\">通过HTTP请求而不是HTTPS请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">400 Bad Request</td>\n<td style=\"text-align:left\">不能解析PUT或POST数据；丢失PUT或POST数据；PUT或POST数据过长；REST API调用路径中包含非法的子节点名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">417 Expectation Failed</td>\n<td style=\"text-align:left\">REST API调用没有指定Wilddog应用id</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">403 Forbidden</td>\n<td style=\"text-align:left\">请求违反规则表达式的约束</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"读取与监听数据\"><a href=\"#读取与监听数据\" class=\"headerlink\" title=\"读取与监听数据\"></a>读取与监听数据</h2><h3 id=\"使用GET方法读取数据\"><a href=\"#使用GET方法读取数据\" class=\"headerlink\" title=\"使用GET方法读取数据\"></a>使用GET方法读取数据</h3><p>我们可以发送<code>GET</code>请求到数据的URL来读取数据，让我们继续博客的示例，读取全部的博客数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://docs-examples.wilddogio.com/rest/saving-data/wdblog/posts.json?print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>成功的请求将返回HTTP 200 OK状态码，并且响应中会包含读取到的数据。</p>\n<h3 id=\"添加URI参数\"><a href=\"#添加URI参数\" class=\"headerlink\" title=\"添加URI参数\"></a>添加URI参数</h3><p>当我们从数据库中读取数据的时候，REST API可以接受多个参数。下面是最常用的参数。想了解全部的参数，请参见 <a href=\"/api/sync/rest.html\">REST API文档</a>。</p>\n<p><strong>auth</strong><code>auth</code>参数允许访问受Wilddog规则表达式保护的数据，并且支持所有的请求方式。<code>auth</code>参数的值可以是Wilddog应用的超级密钥，也可以是一个认证token。下面的例子中我们发送一个包含<code>auth</code>参数的<code>POST</code>请求，参数的值CREDENTIAL可以是超级密钥，也可以是认证token。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X POST -d &apos;&#123;&quot;Authenticated POST request&quot;&#125;&apos; \\</div><div class=\"line\">  &apos;https://docs-examples.wilddogio.com/rest/saving-data/auth-example.json?auth=CREDENTIAL&apos;</div></pre></td></tr></table></figure>\n<p><strong>print</strong>指定<code>print=pretty</code>返回易读格式的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/users/jack/name.json?print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>指定<code>print=silent</code>返回204 No Content状态码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/users/jack/name.json?print=silent&apos;</div></pre></td></tr></table></figure>\n<p><strong>callback</strong>为了让来自web客户端的rest请求实现跨域，你可以用JSONP将响应封装到JavaScript回调方法中。使用 <code>callback=</code> 让REST API将返回的数据封装到你指定的回调方法中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script&gt;</div><div class=\"line\">  function gotData(data) &#123;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;https://&lt;appId&gt;.wilddogio.com/.json?callback=gotData&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p><strong>shallow</strong>这是一个高级功能，目标是帮助处理大的数据集而不下载数据集的全部。设置 <code>shallow=true</code> 将限制数据返回的深度。如果返回的数据是JSON原始类型 (如string, number 或 boolean)， 它的value将被返回。 如果数据的snapshot是 JSON 对象，每一个key的value都将被截断成布尔类型<code>true</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;message&quot;: &#123;</div><div class=\"line\">    &quot;user&quot;: &#123;</div><div class=\"line\">      &quot;name&quot;: &quot;Chris&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;body&quot;: &quot;Hello!&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// REST请求路径为 /message.json?shallow=true</div><div class=\"line\">// 返回的数据如下:</div><div class=\"line\">&#123;</div><div class=\"line\">  &quot;user&quot;: true,</div><div class=\"line\">  &quot;body&quot;: true</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// REST请求路径为 /message/body.json?shallow=true</div><div class=\"line\">// 返回的数据如下:</div><div class=\"line\">&quot;Hello!&quot;</div></pre></td></tr></table></figure>\n<p>使用shallow参数后， 将不能使用其他查询参数。</p>\n<h4 id=\"读取服务端时间戳\"><a href=\"#读取服务端时间戳\" class=\"headerlink\" title=\"读取服务端时间戳\"></a><strong>读取服务端时间戳</strong></h4><p>当我们需要获取服务器的当前时间戳时，可以进行如下操作:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://&lt;appId&gt;.wilddogio.com/.json?sv=timestamp&apos;</div></pre></td></tr></table></figure>\n<p>服务端数值现在只支持时间戳，关于unix时间戳的百科，请参考<a href=\"http://baike.baidu.com/link?url=VQMFk3ej6ORZFtAhKYF5P6ow_p1XqZ5RgzFHNQFJNgc5U_DCT4nH6MVXkIvSmvO5gLP5DrB7ZsrnZc-2cT5bHa\">百科</a>。</p>\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>你可以使用一些参数来对数据进行查询。首先使用<code>orderBy</code>参数来指定数据的排列顺序，然后结合使用<code>limitToFirst</code>，<code>limitToLast</code>，<code>startAt</code>，<code>endAt</code>和<code>equalTo</code>参数来对数据进行查询。</p>\n<p>注意：使用REST API对数据进行查询时，返回的数据集没有固定的顺序，这是因为JSON解释器没有强制排序。如果需要排序，你需要自己在程序中对返回的数据进行排序。</p>\n<p>下面我们来举例如何进行数据查询。假设现在有一些关于恐龙的数据如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;lambeosaurus&quot;: &#123;</div><div class=\"line\">    &quot;height&quot;: 2.1,</div><div class=\"line\">    &quot;length&quot;: 12.5,</div><div class=\"line\">    &quot;weight&quot;: 5000</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;stegosaurus&quot;: &#123;</div><div class=\"line\">    &quot;height&quot;: 4,</div><div class=\"line\">    &quot;length&quot;: 9,</div><div class=\"line\">    &quot;weight&quot;: 2500</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有四种方式对数据进行查询：按照子节点的value值，按照节点名称key，按照节点value值和节点优先级priority。查询条件以其中一个参数开头，后面必须与<code>limitToFirst</code>，<code>limitToLast</code>，<code>startAt</code>，<code>endAt</code>和<code>equalTo</code>这些参数配合使用。</p>\n<p><strong>按照子节点value值排序</strong>将子节点的名称传给<code>orderBy</code>参数，就可以按照指定子节点的value值进行排序。 例如，想要查询所有的高度大于等于3米的恐龙，我们可以使用以下参数查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;startAt=3&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>注意： 如果你想要在应用中按照某个子节点的value值排序，你需要在规则表达式中配置<code>&quot;.indexOn&quot;:&quot;&lt;childkey&gt;&quot;</code>。详细的文档请参考规则表达式API文档中关于 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 的介绍。</p>\n<p><strong>按照数据节点名称排序</strong>可以通过使用<code>orderBy=&quot;$key&quot;</code>参数来按照节点名称查询数据。 下面的例子将返回名称在a到m之间所有的节点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;$key&quot;&amp;startAt=&quot;a&quot;&amp;endAt=&quot;m&quot;&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p><strong>按照节点的value值排序</strong>我们可以按照节点的value值进行排序。 例如，恐龙举办运动会，我们按照以下格式记录恐龙的成绩：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scores&quot;: &#123;</div><div class=\"line\">    &quot;bruhathkayosaurus&quot;: 55,</div><div class=\"line\">    &quot;lambeosaurus&quot;: 21,</div><div class=\"line\">    &quot;linhenykus&quot;: 80,</div><div class=\"line\">    &quot;pterodactyl&quot;: 93,</div><div class=\"line\">    &quot;stegosaurus&quot;: 5,</div><div class=\"line\">    &quot;triceratops&quot;: 22</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要查询所有成绩高于50分的恐龙，我们可以使用以下参数查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/scores.json?orderBy=&quot;$value&quot;&amp;startAt=50&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>参考数据排序部分的介绍，了解使用<code>orderBy=&quot;$value&quot;</code>参数查询时，数据是如何排序的。</p>\n<p>注意： 如果你想要在应用中按照节点的value值排序，你需要在规则表达式中配置<code>&quot;.indexOn&quot; : &quot;.value&quot;</code>。详细的文档请参考规则表达式API文档中关于 <a href=\"old/sync/rules/api-rule#.indexOn\">.indexOn</a> 的介绍。</p>\n<p><strong>按照优先级排序</strong>可以使用<code>orderBy=&quot;$priority&quot;</code>参数来按照节点的优先级查询数据。详细的优先级介绍请参见 <a href=\"sync/rules/api-rule.html#Priorities0\">API文档</a>。</p>\n<h3 id=\"复杂查询\"><a href=\"#复杂查询\" class=\"headerlink\" title=\"复杂查询\"></a>复杂查询</h3><p>可以将多个参数进行组合使用，实现更复杂的查询功能。</p>\n<p><strong>limit查询</strong><code>limitToFirst</code>和<code>limitToLast</code>参数用来设置返回结果集的大小。例如，查询条件限制为100，如果记录数小于100，则会返回所有的数据，如果记录数超过100，则会返回其中的100条记录，使用<code>limitToFirst</code>得到最前面的100条记录，使用<code>limitToLast</code>得到最后面的100条记录。</p>\n<p>在恐龙数据库中使用<code>orderBy</code>和<code>limitToLast</code>，我们可以得到体重最重的两头恐龙的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;weight&quot;&amp;limitToLast=2&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>同样，我们可以使用<code>limitToFirst</code>参数来得到高度最小的两头恐龙的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;limitToFirst=2&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>我们可以将<code>limitToLast</code>参数与<code>orderBy=&quot;$value&quot;</code>参数配合使用。例如，我们给恐龙运动会创建一个排行榜，查询分数最高的三头恐龙，则可以使用以下参数查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/scores.json?orderBy=&quot;$value&quot;&amp;limitToLast=3&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p><strong>range查询</strong>使用<code>startAt</code>，<code>endAt</code>和<code>equalTo</code>参数来设置查询范围的起点和终点。例如，我们想要查询至少3米高的恐龙，可以使用<code>orderBy</code>和<code>startAt</code>的组合查询：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;height&quot;&amp;startAt=3&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>我们可以使用<code>endAt</code>参数来查询名字的字典顺序在Pterodactyl之前的所有的恐龙：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;$key&quot;&amp;endAt=&quot;pterodactyl&quot;&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>我们可以使用<code>startAt</code>和<code>endAt</code>的组合来控制我们查询的范围。下面的例子是查询名字以b开头的所有的恐龙：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl &apos;https://dinosaur-facts.wilddogio.com/dinosaurs.json?orderBy=&quot;$key&quot;&amp;startAt=&quot;b&quot;&amp;endAt=&quot;b~&quot;&amp;print=pretty&apos;</div></pre></td></tr></table></figure>\n<p>波浪线在ASCII中的编码是126，它排在ASCII中常规字符的后面，查询返回的是所有b开头的字符串。</p>\n<p>范围查询在分页中非常有用。</p>\n<h2 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h2><p>这一部分主要介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>orderBy</strong>当使用<code>orderBy</code>参数时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型，则排序不固定，此时不建议使用<code>orderBy</code>参数获取全量数据。例如，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scores&quot;: &#123;</div><div class=\"line\">    &quot;no1&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;tyrannosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : &quot;120&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no2&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;bruhathkayosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : 55</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no3&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;lambeosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : 21</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no4&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;linhenykus&quot;,</div><div class=\"line\">        &quot;score&quot; : 80</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no5&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;pterodactyl&quot;,</div><div class=\"line\">        &quot;score&quot; : 93</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no6&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;stegosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : 5</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no7&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;triceratops&quot;,</div><div class=\"line\">        &quot;score&quot; : 22</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;no8&quot; : &#123;</div><div class=\"line\">        &quot;name&quot; : &quot;brontosaurus&quot;,</div><div class=\"line\">        &quot;score&quot; : true</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>numberic</code>类型，此时使用 <code>orderBy</code>参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用<code>limitToFirst</code>或<code>limitToLast</code>时，将获得不确定的结果。</p>\n<p>当配合使用<code>startAt</code>、<code>endAt</code>和<code>equalTo</code>参数时，如果子节点的公有属性key包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 <code>orderBy=&quot;score&quot;&amp;startAt=60</code> 将得到下面的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;no4&quot; : &#123;</div><div class=\"line\">      &quot;name&quot; : &quot;linhenykus&quot;,</div><div class=\"line\">      &quot;score&quot; : 80</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;no5&quot; : &#123;</div><div class=\"line\">      &quot;name&quot; : &quot;pterodactyl&quot;,</div><div class=\"line\">      &quot;score&quot; : 93</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Object</code>类型数据的 value 值为 null，不会出现在结果中。</p>\n<p><em>注意：如果path与value的总长度超过1000字节时，使用</em><code>orderBy</code><em>参数将搜索不到该数据。</em></p>\n<p><strong>orderBy=”$key”</strong>当使用<code>orderBy=&quot;$key&quot;</code>参数对数据进行排序时，数据将会按照key值增序排列。注意，key值只能是字符型。</p>\n<ol>\n<li>1.key值能够被解析成数字的节点排在最前面，增序排列</li>\n<li>2.接下来是字符型key值，按照字典顺序增序排列</li>\n</ol>\n<p><strong>orderBy=”$value”</strong>当使用<code>orderBy=&quot;$value&quot;</code>参数时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型，则排序不固定， 此时不建议使用<code>orderBy=&quot;$value&quot;</code>获取全量数据，例如，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scores&quot;: &#123;</div><div class=\"line\">    &quot;tyrannosaurus&quot; : &quot;120&quot;,</div><div class=\"line\">    &quot;bruhathkayosaurus&quot; : 55,</div><div class=\"line\">    &quot;lambeosaurus&quot; : 21,</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93,</div><div class=\"line\">    &quot;stegosaurus&quot; : 5,</div><div class=\"line\">    &quot;triceratops&quot; : 22,</div><div class=\"line\">    &quot;brontosaurus&quot; : true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>numberic</code>类型，此时使用 <code>orderBy=&quot;$value&quot;</code>参数获得全量数据，返回的是一个看似固定的排序结果；但是配合使用<code>limitToFirst</code>或<code>limitToLast</code>参数时，将获得不确定的结果。</p>\n<p>当配合使用<code>startAt</code>、<code>endAt</code>和<code>equalTo</code>时，如果子节点的value包含多种数据类型，将按照参数的类型排序，即只能返回这个类型的有序数据。 上面的数据如果使用 <code>orderBy=&quot;$value&quot;&amp;startAt=60</code> 将得到下面的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Object</code>类型数据的 value 值为 null，不会出现在结果中。</p>\n<p><em>注意：如果path与value的总长度超过1000字节时，使用</em><code>orderBy=&quot;$value&quot;</code><em>参数将搜索不到该数据。</em></p>\n<p><strong>orderBy=”$priority”</strong>当使用<code>orderBy=&quot;$priority&quot;</code>参数对数据进行排序时，数据的顺序取决于优先级以及key值。注意，优先级的值只能是数字型或字符型。</p>\n<ol>\n<li>1.没有优先级的节点放在最前面</li>\n<li>2.接着是数字型的优先级，按照优先级从小到大的顺序排列</li>\n<li>3.接下来是字符型的优先级，按照优先级的字典顺序排列</li>\n<li>4.当两个节点的优先级相同，就按照key值排序，数字型key在前（数值排序），其余类型的key在后（字典排序）</li>\n</ol>\n<p>关于优先级更多的内容，请参见 <a href=\"/api/sync/rest.html#Priorities\">API文档</a>。</p>\n<h3 id=\"Streaming\"><a href=\"#Streaming\" class=\"headerlink\" title=\"Streaming\"></a>Streaming</h3><p>Wilddog REST端点支持 <a href=\"http://www.w3.org/TR/eventsource/\">EventSource\\/Server-Sent Events</a> 协议，使客户端可以持续得到指定节点下数据发生的变化。</p>\n<p>想要开始streaming，我们需要：</p>\n<ol>\n<li>将客户端请求的Accept头设置为<code>text/event-stream</code></li>\n<li>考虑http跳转，特别是307状态码</li>\n<li>如果数据访问需要校验权限，需要添加<code>auth</code>参数。</li>\n</ol>\n<p>当指定节点的数据发生变化时，服务器会发送事件回来。消息的结构符合<code>EventSource</code>协议：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">event: event name</div><div class=\"line\">data: JSON encoded data payload</div></pre></td></tr></table></figure>\n<p>服务器会返回以下的事件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">put</td>\n<td style=\"text-align:left\">JSON格式数据，有两个key：path和data；path指向请求URL的路径；客户端应该使用消息中包含的数据替换本地缓存中的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">patch</td>\n<td style=\"text-align:left\">JSON格式数据，有两个key：path和data；path指向请求URL的路径；对与数据的每一个key，客户端应该用消息中包含的key替代缓存中的key</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">keep-alive</td>\n<td style=\"text-align:left\">此事件的data为null，不需要任何操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">auth_revoked</td>\n<td style=\"text-align:left\">该事件的数据是字符串，表示认证过期；认证参数失效后，该事件将被发送</td>\n</tr>\n</tbody>\n</table>\n<p>下面是服务器能够发送的事件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 设置整个缓存为 &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;</div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/&quot;, &quot;data&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">//将新数据放到key为c的缓存中，这样整个缓存是下面的结构</div><div class=\"line\">// &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">event: put</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: true, &quot;bar&quot;: false&#125;&#125;</div><div class=\"line\"></div><div class=\"line\">// 数据中的每个key，更新（或添加）相应的key到缓存的路径/c下</div><div class=\"line\">// 最终的缓存为: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;foo&quot;: 3, &quot;bar&quot;: false, &quot;baz&quot;: 4&#125;&#125;</div><div class=\"line\">event: patch</div><div class=\"line\">data: &#123;&quot;path&quot;: &quot;/c&quot;, &quot;data&quot;: &#123;&quot;foo&quot;: 3, &quot;baz&quot;: 4&#125;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全是一个非常重大的话题，通常也是app开发中最困难的部分之一。Wilddog使用一种声明式的规则表达式，对数据的访问权限进行配置，让这一切变得简单。</p>\n<h3 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h3><p>用户ID是一个非常重要概念，不同的用户拥有不同的数据和不同的权限，比如，在一个聊天程序中，每一条消息都有它的发布者，用户可以删除自己的消息，而不能删除别人的。安全的第一步是用户认证。</p>\n<p>Wilddog 提供了以下终端用户认证的方式：</p>\n<ul>\n<li>集成微博，微信，QQ等社交平台的OAuth认证</li>\n<li>Email\\/密码登录，并且提供用户管理</li>\n<li>匿名用户访问</li>\n<li>自定义token，方便用户集成已有的用户账户系统。</li>\n</ul>\n<h3 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h3><p>知道用户的身份只是安全的一部分，一旦你知道谁在访问数据，你需要一种方式来控制访问权限。Wilddog提供了一种声明式的表达式语言，你可以在控制面板中的“规则表达式”tab下进行编辑。这些规则表达式让你可以管理数据的访问规则。规则级联应用到其子节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;foo&quot;: &#123;</div><div class=\"line\">      &quot;.read&quot;: true，</div><div class=\"line\">      &quot;.write&quot;: false</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个例子允许所有人访问数据节点 <code>foo</code>。</p>\n<p>规则表达式包含一系列内置对象和函数。最重要的一个内置对象是auth，它在终端用户认证的时候生成，包含终端用户的信息和用户的唯一id：auth.uid。</p>\n<p>auth对象是很多规则表达式的基础。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;users&quot;: &#123;</div><div class=\"line\">      &quot;$user_id&quot;: &#123;</div><div class=\"line\">        &quot;.write&quot;: &quot;$user_id == auth.uid&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个规则保证了：只有终端用户的唯一id等于动态路径$user_id的值时，用户才能写入数据。</p>\n<h3 id=\"数据校验\"><a href=\"#数据校验\" class=\"headerlink\" title=\"数据校验\"></a>数据校验</h3><p>规则表达式中还包含一个<code>.validate</code>规则，用于对数据进行校验，确保数据的格式正确。它的语法和<code>.read</code>与<code>.write</code>相同，不同的是<code>.validate</code>规则不会向下级联。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;foo&quot;: &#123;</div><div class=\"line\">      &quot;.validate&quot;: &quot;newData.isString() &amp;&amp; newData.val().length() &lt; 100&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一规则确保了在\\/foo\\/节点下，写入的数据必须是字符串类型，且必须长度小于100。</p>\n<p><code>.validate</code>规则可以使用的内置对象和方法与<code>.read</code>和<code>.write</code>相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;rules&quot;: &#123;</div><div class=\"line\">    &quot;user&quot;: &#123;</div><div class=\"line\">      &quot;.validate&quot;: &quot;auth != null &amp;&amp; newData.val() == auth.uid&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一规则强制使写入\\/user\\/下的数据必须是当前登陆用户的唯一id。</p>\n<p><code>.validate</code>规则并不是要彻底取消应用中的数据校验代码。为了获得更好的性能和用户体验，你仍然必须在应用代码中对数据进行校验。</p>\n<h3 id=\"规则表达式设置\"><a href=\"#规则表达式设置\" class=\"headerlink\" title=\"规则表达式设置\"></a>规则表达式设置</h3><p>使用REST API，你可以通过发送PUT请求到<code>/.settings/rules.json</code>路径为你的应用设置规则表达式。请求时你需要使用野狗的超级密钥，例如为了将所有读权限设置为true，可以发送如下的请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl -X PUT -d &apos;&#123;&quot;rules&quot;:&#123;&quot;.read&quot;:true&#125;&#125;&apos; &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<p>通过REST API编写应用的安全规则表达式可以作为你应用部署流程中的一部分。</p>\n<p>注：通过REST API修改rules将会覆盖已经存在的规则表达式。</p>\n<h3 id=\"获取规则表达式\"><a href=\"#获取规则表达式\" class=\"headerlink\" title=\"获取规则表达式\"></a>获取规则表达式</h3><p>类似的，我们可以通过发送GET请求到<code>/.settings/rules.json</code>路径来获取规则表达式的设置内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">curl  &apos;https://&lt;appId&gt;.wilddogio.com/.settings/rules.json?auth=WILDDOG_SECRET&apos;</div></pre></td></tr></table></figure>\n<p>返回的数据将包含app设置的规则表达式的全部内容。</p>\n<h3 id=\"了解更多\"><a href=\"#了解更多\" class=\"headerlink\" title=\"了解更多\"></a>了解更多</h3><p>到此为止，你应该对Wilddog中的应用安全机制有了一个大体的了解。</p>\n<p>规则表达式是复杂且强大的，本开发向导中只涵盖了非常小的一部分。更多关于规则表达式的细节，请参考<a href=\"/guide/sync/rules/guide.html\">规则表达式文档</a>，这里将会讲述所有的内置方法和对象。</p>\n"},{"title":"Libraries","_content":"\n| Name                                     | Language | url                                      |\n| ---------------------------------------- | -------- | ---------------------------------------- |\n| [wilddog-php](https://github.com/wilddogteam/wilddog-php) | php      | [https://github.com/wilddogteam/wilddog-php](https://github.com/wilddogteam/wilddog-php) |\n\n","source":"guide/sync/rest/library.md","raw":"title: Libraries\n---\n\n| Name                                     | Language | url                                      |\n| ---------------------------------------- | -------- | ---------------------------------------- |\n| [wilddog-php](https://github.com/wilddogteam/wilddog-php) | php      | [https://github.com/wilddogteam/wilddog-php](https://github.com/wilddogteam/wilddog-php) |\n\n","date":"2016-09-06T03:38:22.543Z","updated":"2016-09-06T03:38:22.543Z","path":"guide/sync/rest/library.html","comments":1,"layout":"page","_id":"cisswi9lw001yz4fwp147dv9b","content":"<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Language</th>\n<th>url</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/wilddogteam/wilddog-php\" target=\"_blank\" rel=\"external\">wilddog-php</a></td>\n<td>php</td>\n<td><a href=\"https://github.com/wilddogteam/wilddog-php\" target=\"_blank\" rel=\"external\">https://github.com/wilddogteam/wilddog-php</a></td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Language</th>\n<th>url</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/wilddogteam/wilddog-php\">wilddog-php</a></td>\n<td>php</td>\n<td><a href=\"https://github.com/wilddogteam/wilddog-php\">https://github.com/wilddogteam/wilddog-php</a></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"规则表达式指南","_content":"\n## 安全表达式基础知识\n\n### 设置节点的读取权限\n\n```javascript\n\"rules\": {\n  \"message\"{\n    \"message1\"{    \n      \".read\": true,\n      \".write\":  true,\n      \".validate\": true\n    }\n    \"message2\"{\n      \".read\": true,\n      \".write\": false,\n      \".validate\": false\n    }\n  }\n}\n```\n\nmessage1节点，所有人都可以读取数据，所有人都可以输入数据，所有类型的数据都能够输入。\n\nmessage2节点，所有人都可以读取数据，所有人都不能输入数据，任何数据类型都不能输入。\n\n规则表达式使用 JSON结构，规则表达式的层级结构应该与数据库一致。\n\n注意：应用创建之后，系统默认为公开。所有人都能读写，为了你的数据安全，尽快配置规则表达式\n\n### 用$通配符选择子节点\n\n实际生产环境中，不可能为每一个数据节点单独配置规则，因此我们可以使用 $ 通配符来选择子节点。\n\n例如你储存了一个 message 的信息内容列表：\n\n```javascript\n{\n  \"messages\": {\n    \"message0\": {\n      \"content\": \"Hello\",\n      \"timestamp\": 1405704370369,\n      \"uid\":17343512\n    },\n    \"message1\": {\n      \"content\": \"Goodbye\",\n      \"timestamp\": 1405704395231,\n      \"uid\":72366233\n    },\n    ...\n  }\n}\n```\n\n不可能为每一个 message 配置规则。那么你可以使用$通配节点。例如\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"$message_content\": {\n        \".read\": true,\n        \".write\": true\n      }\n      \"$message_timestamp\": {\n        \".read\": false\n        \".write\": false\n      }\n    }\n  }\n}\n```\n\n还能够使用 $other 选择未列出的子节点：\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"$message_content\": {\n        \".read\": true,\n        \".write\": true\n      }\n      \"$other\": {\n        \".read\": false\n        \".write\": false\n      }\n    }\n  }\n}\n```\n\n除了content 可以读写之外，messages下的其他所有节点都不可读取。\n\n### 使用内置对象与内置函数\n\n规则表达式中提供了许多内置对象，利用这些内置对象提供的函数和属性，你可以配置各种规则。例如可以使用 auth对象进行授权:\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"$messages_timestamp\": {\n        \".read\": \"$messages_uid == auth.uid\"\n        \".write\": \"$messages_uid == auth.uid\"\n      }\n    }\n  }\n}\n```\n\n使用 auth对象能够迅速配置，只有当前用户才能够读写自己的数据的权限设置\n\nauth 代表已经登录的用户对象，\n\n规则表达式采用了一种类 javascript的语法，能够在表达式中使用内置对象和内置函数，最终返回的结果应该是 \"true\"或者\"false\"。\n\n**内置对象**\n\n内置对象描述now云端的时间戳，以毫秒为单位。root类型的对象，代表操作之前，数据根节点newData类型的对象，代表假设数据操作成功，之后此节点下的数据，也就是此节点下的旧数据和本次操作写入的新数据合并之后的数据。data类型的对象，代表此节点被操作前的原始数据。authAuth类型对象，代表已经登录用户对象。$variables节点的名称变量，代表动态路径的通配符。\n\n还有许多内置函数和运算符，可以查看 [规则表达式API 文档](/api/sync/rule.html)\n\n**data与 newData**\n\n内置对象data指的是写操作发生之前，当前节点的已有数据。newData则指的是，假定写操作会成功，那么写操作成功之后当前节点的数据。newData代表的是旧数据和即将写入的数据合并之后的数据。\n\n为了演示它们的用法，考虑一个这样的场景：我们需要一个规则，在指定的路径下，当前节点数据不存在的时候可以写入，也可以删除已存在的数据，但不能对已有数据进行修改：\n\n```javascript\n// data不存（没有旧数据）在或者newData不存在（删除数据）的情况下，可以写入。\n// 也就是说可以是全新写入，也可以是删除，但是不能修改已有数据。\n\".write\": \"!data.exists() || !newData.exists()\"\n```\n\n**使用 root 引用其他路径(Demo 需要修改)**\n\n通过使用内置变量root，data和newData，你可以访问到任何数据节点。\n\n参考下面的例子，只有当allow_writes节点的值为true，且父节点没有设置一个readOnly标志，且新写入的数据中存在名为message的子节点时，数据才被允许写入。\n\n```javascript\n{\n  \".write\": \"root.child('allow_writes').val() == true &&\n            !data.parent().child('readOnly').exists() &&\n            newData.child('message').exists()\"\n}\n```\n\n通过内置变量root,，$通配符，您可以定位并且选择任何数据节点。\n\n\n\n### 规则的级联\n\n规则表达式遵循一个自上向下延展的原则。如果一个数据节点上的.write或.read规则赋予了读或写的权限，那么它的所有的子节点也都将拥有读或写的权限。子节点上的规则不能覆盖父节点或祖先节点已经赋予的读或写的权限。参考下面的例子\n\n```javascript\n \"rules\": {\n     \"message\": {\n        // 允许/message/节点下的数据被读取\n        \".read\": \"data.child('content').val() == true\",\n        \"content\": {\n          // 当父节点的表达式授予了读权限时，这一规则设置false无效。\n          \".read\": false\n        }\n     }\n  }\n}\n```\n\n例如上面的例子，message节点已经设置了可读，那么无论子节点如何设置，子节点都是可读的。\n\n\n\n### 规则的原子性\n\n为了保证数据的安全，在一次操作中，只要任何一个数据节点没有访问权限，那么整个操作将会失败。参考这个例子：\n\n\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"message1\": {\n        \".read\": true\n      },\n      \"message2\": {\n        \".read\": false\n      }\n    }\n  }\n}\n```\n\n读取路径/messages会返回错误，即使 message1是可读的，但是因为 message2没有可读的权限，所以整个操作都会失败。\n\n## 数据校验\n\n### 基本校验\n可以通过.validate 对数据进行校验。\n\n```javascript\n{\n  \"messages:\"{\n      \"rules\": {\n            \"content\": {\n              \".read\": true,\n              \".write\": true,\n              // 写入/foo 的数据必须是字符串类型且长度小于100。\n              \".validate\": \"newData.isString() && newData.val().length() < 100\"\n            }\n       }\n   }\n}\n```\n\n内置变量自带了很多判断函数，例如 isString(), lenght()等。更多的判断函数可以参考 [规则表达式API 文档](/api/sync/rule.html)\n\n**.validate规则不会向下级联。如果在一次操作中，任何一个子节点的.validate规则失败，整个写操作都将失败。当数据被删除（也就是值为null）时，.validate表达式被忽略。**\n\n### 使用正则表达式校验数据\n\n我们可以使用内置的 match()函数来进行正则校验\n\n数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式\n\n1. \".validate\": \"newData.isString() &&  newData.val().matches(/^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$/)\"\n\nWilddog只支持一部分正则表达式的功能，已经能够满足绝大部分的需求，关于正则表达式校验的更多内容请看[正则表达式校验](/api/sync/rule.html#matches)。\n\n\n\n```javascript\n\".validate\": \"newData.isString() &&  newData.val().matches(/^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$/)\"\n```\n\n\n\n## 用户认证\n\n### 集成 Auth 身份认证\n\nWilddog Auth 身份认证集成 Sync 实时数据同步，能允许你控制每个用户对数据的控制权限。\n\n**说明**\n用户通过身份认证后，云端会自动将用户的信息填入规则表达式的 `auth` 变量。信息包括标识用户身份的 `Wilddog ID`（即uid）及已关联帐户的资料，例如 QQ、\n微信资料或电子邮件。你还可以通过自定义 `Token` 加入自定义字段以完成定制功能。\n\n### auth 变量\n\n用户没有进行身份认证前，`auth` 变量为 null 。使用 Wilddog Auth 对用户进行身份认证后，该变量会含有以下属性：\n\n属性 | 含义 \n---- | -----------\nprovider | 使用的身份认证方式（\"password\"、\"anonymous\"、\"qq\"、\"weibo\"、\"weixin\"或\"weixinmp\"）。\nuid | 标识用户唯一身份的 `Wilddog ID`。\n\n如下，保证每个认证用户只能向特定路径写入数据：\n\n```json\n{\n  \"rules\": {\n    \"users\": {\n      \"$user_id\": {\n        // 当认证用户的 uid 与 $user_id 这个 key 匹配时，\n        // 才能向此节点写入数据。\n        \".write\": \"$user_id === auth.uid\"\n      }\n    }\n  }\n}\n```\n### 组织你的数据结构\n\n我们再次提到了组织数据，因为它与规则表达式相配合，使规则的配置更加容易。我们再来举个例子，与上例类似，我们把所有用户信息存在 `users` 节点中，该节点的子节点是每个用户的 `uid` 值。你希望限制这些数据的访问权限，且确保只有已登录用户才可以查看自己的数据，就可以这样配置：\n\n```json\n{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".read\": \"auth != null && auth.uid == $uid\"\n      }\n    }\n  }\n}\n```\n\n### 使用自定义 Token\n\n对于希望实现自定义认证的开发者，Wilddog Auth 也允许开发者[在其服务器上创建自己的自定义 Token 来进行认证](/guide/auth/server/server.html)。\n你在创建自定义 Token 时，可以自定义额外的属性字段。这些额外的属性也会像 `uid`、`provider` 一样包含在 auth 变量中,但是使用起来发生了变化.\n目前自定义的额外属性会放在auth.token里面\n下面是一个添加并使用 `isAdmin` 自定义属性的规则示例：\n```json\n{\n  \"rules\": {\n    \"secret\": {\n      // auth 里的 `isAdmin` 为 true 时才可以读取数据。\n      \".read\": \"auth.token.isAdmin == true\"\n    }\n  }\n}\n```\n\n有关自定义 Token 的具体使用方法，参见[使用 Wilddog Server SDK 进行身份认证](/guide/auth/server/server.html)。\n\n## 数据索引\n\nWilddog提供了强大高效的查询方法，你可以按照任意子节点的顺序对数据进行查询。但是当你的数据量不断增加的时候，查询的效率也会逐渐降低。WildDog提供了数据索引来解决这个问题。你可以在规则表达式中使用 .indexOn 规则为节点建立索引，提高查询效率。\n\n**节点的名称key和优先级priority默认建立索引，不需要额外设置**\n\nWilddog 根据查询需求的不同，提供了两种.indexOn的索引方式，orderByChild和 orderByValue。\n\n### orderByChild 根据子节点索引\n\norderByChild 可以根据不同的子节点进行索引，例如我们现在有一些用户的信息：\n\n```javascript\n{\n  \"Jack\": {\n    \"age\" : 21,\n    \"score\" : 88,\n    \"weight\": 63\n  },\n  \"Lucy\": {\n    \"age\" : 22,\n    \"score\" : 91,\n    \"weight\" : 49\n  }\n}\n```\n\n假设在应用中，我们需要经常对用户的信息按照名称(key)、年龄(score)、分数(score)进行排序，但是不会按照体重(weight)排序，这样我们就可以通过Wilddog提供的.indexOn规则，为名称(key)、年龄(age)、分数(score)这些节点建立索引，来提高查询效率。\n\n我们可以使用如下的设置为高度、长度节点建立索引。名称即为节点的key值，已经默认建立了索引，所以不需要额外设置。\n\n```javascript\n{\n  \"rules\": {\n    \"dinosaurs\": {\n      \".indexOn\": [\"age\", \"score\"]\n    }\n  }\n}\n```\n\n### orderByValue 根据值索引\n\norderByValue 可以根据 value的值进行索引。例如我们需要为学生分数建立一个排行榜：\n\n```javascript\n{\n  \"scores\": {\n    \"Jack\" : 55,\n    \"Lucy\" : 81,\n    \"LiLei\" : 80,\n    \"HanMeimei\" : 93,\n    \"Michael\" : 66,\n    \"Jane\" : 78\n  }\n}\n```\n\n我们只需要对节点的 value 进行排序，因此我们可以在 /scores节点下对 value 进行索引：\n\n```javascript\n{\n  \"rules\": {\n    \"scores\": {\n      \".indexOn\": \".value\"\n    }\n  }\n}\n```\n\n","source":"guide/sync/rules/guide.md","raw":"title: 规则表达式指南\n---\n\n## 安全表达式基础知识\n\n### 设置节点的读取权限\n\n```javascript\n\"rules\": {\n  \"message\"{\n    \"message1\"{    \n      \".read\": true,\n      \".write\":  true,\n      \".validate\": true\n    }\n    \"message2\"{\n      \".read\": true,\n      \".write\": false,\n      \".validate\": false\n    }\n  }\n}\n```\n\nmessage1节点，所有人都可以读取数据，所有人都可以输入数据，所有类型的数据都能够输入。\n\nmessage2节点，所有人都可以读取数据，所有人都不能输入数据，任何数据类型都不能输入。\n\n规则表达式使用 JSON结构，规则表达式的层级结构应该与数据库一致。\n\n注意：应用创建之后，系统默认为公开。所有人都能读写，为了你的数据安全，尽快配置规则表达式\n\n### 用$通配符选择子节点\n\n实际生产环境中，不可能为每一个数据节点单独配置规则，因此我们可以使用 $ 通配符来选择子节点。\n\n例如你储存了一个 message 的信息内容列表：\n\n```javascript\n{\n  \"messages\": {\n    \"message0\": {\n      \"content\": \"Hello\",\n      \"timestamp\": 1405704370369,\n      \"uid\":17343512\n    },\n    \"message1\": {\n      \"content\": \"Goodbye\",\n      \"timestamp\": 1405704395231,\n      \"uid\":72366233\n    },\n    ...\n  }\n}\n```\n\n不可能为每一个 message 配置规则。那么你可以使用$通配节点。例如\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"$message_content\": {\n        \".read\": true,\n        \".write\": true\n      }\n      \"$message_timestamp\": {\n        \".read\": false\n        \".write\": false\n      }\n    }\n  }\n}\n```\n\n还能够使用 $other 选择未列出的子节点：\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"$message_content\": {\n        \".read\": true,\n        \".write\": true\n      }\n      \"$other\": {\n        \".read\": false\n        \".write\": false\n      }\n    }\n  }\n}\n```\n\n除了content 可以读写之外，messages下的其他所有节点都不可读取。\n\n### 使用内置对象与内置函数\n\n规则表达式中提供了许多内置对象，利用这些内置对象提供的函数和属性，你可以配置各种规则。例如可以使用 auth对象进行授权:\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"$messages_timestamp\": {\n        \".read\": \"$messages_uid == auth.uid\"\n        \".write\": \"$messages_uid == auth.uid\"\n      }\n    }\n  }\n}\n```\n\n使用 auth对象能够迅速配置，只有当前用户才能够读写自己的数据的权限设置\n\nauth 代表已经登录的用户对象，\n\n规则表达式采用了一种类 javascript的语法，能够在表达式中使用内置对象和内置函数，最终返回的结果应该是 \"true\"或者\"false\"。\n\n**内置对象**\n\n内置对象描述now云端的时间戳，以毫秒为单位。root类型的对象，代表操作之前，数据根节点newData类型的对象，代表假设数据操作成功，之后此节点下的数据，也就是此节点下的旧数据和本次操作写入的新数据合并之后的数据。data类型的对象，代表此节点被操作前的原始数据。authAuth类型对象，代表已经登录用户对象。$variables节点的名称变量，代表动态路径的通配符。\n\n还有许多内置函数和运算符，可以查看 [规则表达式API 文档](/api/sync/rule.html)\n\n**data与 newData**\n\n内置对象data指的是写操作发生之前，当前节点的已有数据。newData则指的是，假定写操作会成功，那么写操作成功之后当前节点的数据。newData代表的是旧数据和即将写入的数据合并之后的数据。\n\n为了演示它们的用法，考虑一个这样的场景：我们需要一个规则，在指定的路径下，当前节点数据不存在的时候可以写入，也可以删除已存在的数据，但不能对已有数据进行修改：\n\n```javascript\n// data不存（没有旧数据）在或者newData不存在（删除数据）的情况下，可以写入。\n// 也就是说可以是全新写入，也可以是删除，但是不能修改已有数据。\n\".write\": \"!data.exists() || !newData.exists()\"\n```\n\n**使用 root 引用其他路径(Demo 需要修改)**\n\n通过使用内置变量root，data和newData，你可以访问到任何数据节点。\n\n参考下面的例子，只有当allow_writes节点的值为true，且父节点没有设置一个readOnly标志，且新写入的数据中存在名为message的子节点时，数据才被允许写入。\n\n```javascript\n{\n  \".write\": \"root.child('allow_writes').val() == true &&\n            !data.parent().child('readOnly').exists() &&\n            newData.child('message').exists()\"\n}\n```\n\n通过内置变量root,，$通配符，您可以定位并且选择任何数据节点。\n\n\n\n### 规则的级联\n\n规则表达式遵循一个自上向下延展的原则。如果一个数据节点上的.write或.read规则赋予了读或写的权限，那么它的所有的子节点也都将拥有读或写的权限。子节点上的规则不能覆盖父节点或祖先节点已经赋予的读或写的权限。参考下面的例子\n\n```javascript\n \"rules\": {\n     \"message\": {\n        // 允许/message/节点下的数据被读取\n        \".read\": \"data.child('content').val() == true\",\n        \"content\": {\n          // 当父节点的表达式授予了读权限时，这一规则设置false无效。\n          \".read\": false\n        }\n     }\n  }\n}\n```\n\n例如上面的例子，message节点已经设置了可读，那么无论子节点如何设置，子节点都是可读的。\n\n\n\n### 规则的原子性\n\n为了保证数据的安全，在一次操作中，只要任何一个数据节点没有访问权限，那么整个操作将会失败。参考这个例子：\n\n\n\n```javascript\n{\n  \"rules\": {\n    \"messages\": {\n      \"message1\": {\n        \".read\": true\n      },\n      \"message2\": {\n        \".read\": false\n      }\n    }\n  }\n}\n```\n\n读取路径/messages会返回错误，即使 message1是可读的，但是因为 message2没有可读的权限，所以整个操作都会失败。\n\n## 数据校验\n\n### 基本校验\n可以通过.validate 对数据进行校验。\n\n```javascript\n{\n  \"messages:\"{\n      \"rules\": {\n            \"content\": {\n              \".read\": true,\n              \".write\": true,\n              // 写入/foo 的数据必须是字符串类型且长度小于100。\n              \".validate\": \"newData.isString() && newData.val().length() < 100\"\n            }\n       }\n   }\n}\n```\n\n内置变量自带了很多判断函数，例如 isString(), lenght()等。更多的判断函数可以参考 [规则表达式API 文档](/api/sync/rule.html)\n\n**.validate规则不会向下级联。如果在一次操作中，任何一个子节点的.validate规则失败，整个写操作都将失败。当数据被删除（也就是值为null）时，.validate表达式被忽略。**\n\n### 使用正则表达式校验数据\n\n我们可以使用内置的 match()函数来进行正则校验\n\n数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式\n\n1. \".validate\": \"newData.isString() &&  newData.val().matches(/^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$/)\"\n\nWilddog只支持一部分正则表达式的功能，已经能够满足绝大部分的需求，关于正则表达式校验的更多内容请看[正则表达式校验](/api/sync/rule.html#matches)。\n\n\n\n```javascript\n\".validate\": \"newData.isString() &&  newData.val().matches(/^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$/)\"\n```\n\n\n\n## 用户认证\n\n### 集成 Auth 身份认证\n\nWilddog Auth 身份认证集成 Sync 实时数据同步，能允许你控制每个用户对数据的控制权限。\n\n**说明**\n用户通过身份认证后，云端会自动将用户的信息填入规则表达式的 `auth` 变量。信息包括标识用户身份的 `Wilddog ID`（即uid）及已关联帐户的资料，例如 QQ、\n微信资料或电子邮件。你还可以通过自定义 `Token` 加入自定义字段以完成定制功能。\n\n### auth 变量\n\n用户没有进行身份认证前，`auth` 变量为 null 。使用 Wilddog Auth 对用户进行身份认证后，该变量会含有以下属性：\n\n属性 | 含义 \n---- | -----------\nprovider | 使用的身份认证方式（\"password\"、\"anonymous\"、\"qq\"、\"weibo\"、\"weixin\"或\"weixinmp\"）。\nuid | 标识用户唯一身份的 `Wilddog ID`。\n\n如下，保证每个认证用户只能向特定路径写入数据：\n\n```json\n{\n  \"rules\": {\n    \"users\": {\n      \"$user_id\": {\n        // 当认证用户的 uid 与 $user_id 这个 key 匹配时，\n        // 才能向此节点写入数据。\n        \".write\": \"$user_id === auth.uid\"\n      }\n    }\n  }\n}\n```\n### 组织你的数据结构\n\n我们再次提到了组织数据，因为它与规则表达式相配合，使规则的配置更加容易。我们再来举个例子，与上例类似，我们把所有用户信息存在 `users` 节点中，该节点的子节点是每个用户的 `uid` 值。你希望限制这些数据的访问权限，且确保只有已登录用户才可以查看自己的数据，就可以这样配置：\n\n```json\n{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".read\": \"auth != null && auth.uid == $uid\"\n      }\n    }\n  }\n}\n```\n\n### 使用自定义 Token\n\n对于希望实现自定义认证的开发者，Wilddog Auth 也允许开发者[在其服务器上创建自己的自定义 Token 来进行认证](/guide/auth/server/server.html)。\n你在创建自定义 Token 时，可以自定义额外的属性字段。这些额外的属性也会像 `uid`、`provider` 一样包含在 auth 变量中,但是使用起来发生了变化.\n目前自定义的额外属性会放在auth.token里面\n下面是一个添加并使用 `isAdmin` 自定义属性的规则示例：\n```json\n{\n  \"rules\": {\n    \"secret\": {\n      // auth 里的 `isAdmin` 为 true 时才可以读取数据。\n      \".read\": \"auth.token.isAdmin == true\"\n    }\n  }\n}\n```\n\n有关自定义 Token 的具体使用方法，参见[使用 Wilddog Server SDK 进行身份认证](/guide/auth/server/server.html)。\n\n## 数据索引\n\nWilddog提供了强大高效的查询方法，你可以按照任意子节点的顺序对数据进行查询。但是当你的数据量不断增加的时候，查询的效率也会逐渐降低。WildDog提供了数据索引来解决这个问题。你可以在规则表达式中使用 .indexOn 规则为节点建立索引，提高查询效率。\n\n**节点的名称key和优先级priority默认建立索引，不需要额外设置**\n\nWilddog 根据查询需求的不同，提供了两种.indexOn的索引方式，orderByChild和 orderByValue。\n\n### orderByChild 根据子节点索引\n\norderByChild 可以根据不同的子节点进行索引，例如我们现在有一些用户的信息：\n\n```javascript\n{\n  \"Jack\": {\n    \"age\" : 21,\n    \"score\" : 88,\n    \"weight\": 63\n  },\n  \"Lucy\": {\n    \"age\" : 22,\n    \"score\" : 91,\n    \"weight\" : 49\n  }\n}\n```\n\n假设在应用中，我们需要经常对用户的信息按照名称(key)、年龄(score)、分数(score)进行排序，但是不会按照体重(weight)排序，这样我们就可以通过Wilddog提供的.indexOn规则，为名称(key)、年龄(age)、分数(score)这些节点建立索引，来提高查询效率。\n\n我们可以使用如下的设置为高度、长度节点建立索引。名称即为节点的key值，已经默认建立了索引，所以不需要额外设置。\n\n```javascript\n{\n  \"rules\": {\n    \"dinosaurs\": {\n      \".indexOn\": [\"age\", \"score\"]\n    }\n  }\n}\n```\n\n### orderByValue 根据值索引\n\norderByValue 可以根据 value的值进行索引。例如我们需要为学生分数建立一个排行榜：\n\n```javascript\n{\n  \"scores\": {\n    \"Jack\" : 55,\n    \"Lucy\" : 81,\n    \"LiLei\" : 80,\n    \"HanMeimei\" : 93,\n    \"Michael\" : 66,\n    \"Jane\" : 78\n  }\n}\n```\n\n我们只需要对节点的 value 进行排序，因此我们可以在 /scores节点下对 value 进行索引：\n\n```javascript\n{\n  \"rules\": {\n    \"scores\": {\n      \".indexOn\": \".value\"\n    }\n  }\n}\n```\n\n","date":"2016-09-06T03:38:22.544Z","updated":"2016-09-06T03:38:22.544Z","path":"guide/sync/rules/guide.html","comments":1,"layout":"page","_id":"cisswi9lw001zz4fwrolnulwp","content":"<h2 id=\"安全表达式基础知识\"><a href=\"#安全表达式基础知识\" class=\"headerlink\" title=\"安全表达式基础知识\"></a>安全表达式基础知识</h2><h3 id=\"设置节点的读取权限\"><a href=\"#设置节点的读取权限\" class=\"headerlink\" title=\"设置节点的读取权限\"></a>设置节点的读取权限</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">  <span class=\"string\">\"message\"</span>&#123;</div><div class=\"line\">    <span class=\"string\">\"message1\"</span>&#123;    </div><div class=\"line\">      <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".write\"</span>:  <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".validate\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"string\">\"message2\"</span>&#123;</div><div class=\"line\">      <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"string\">\".validate\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>message1节点，所有人都可以读取数据，所有人都可以输入数据，所有类型的数据都能够输入。</p>\n<p>message2节点，所有人都可以读取数据，所有人都不能输入数据，任何数据类型都不能输入。</p>\n<p>规则表达式使用 JSON结构，规则表达式的层级结构应该与数据库一致。</p>\n<p>注意：应用创建之后，系统默认为公开。所有人都能读写，为了你的数据安全，尽快配置规则表达式</p>\n<h3 id=\"用-通配符选择子节点\"><a href=\"#用-通配符选择子节点\" class=\"headerlink\" title=\"用$通配符选择子节点\"></a>用$通配符选择子节点</h3><p>实际生产环境中，不可能为每一个数据节点单独配置规则，因此我们可以使用 $ 通配符来选择子节点。</p>\n<p>例如你储存了一个 message 的信息内容列表：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"message0\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"content\"</span>: <span class=\"string\">\"Hello\"</span>,</div><div class=\"line\">      <span class=\"string\">\"timestamp\"</span>: <span class=\"number\">1405704370369</span>,</div><div class=\"line\">      <span class=\"string\">\"uid\"</span>:<span class=\"number\">17343512</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"message1\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"content\"</span>: <span class=\"string\">\"Goodbye\"</span>,</div><div class=\"line\">      <span class=\"string\">\"timestamp\"</span>: <span class=\"number\">1405704395231</span>,</div><div class=\"line\">      <span class=\"string\">\"uid\"</span>:<span class=\"number\">72366233</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不可能为每一个 message 配置规则。那么你可以使用$通配节点。例如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$message_content\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"string\">\"$message_timestamp\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还能够使用 $other 选择未列出的子节点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$message_content\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"string\">\"$other\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了content 可以读写之外，messages下的其他所有节点都不可读取。</p>\n<h3 id=\"使用内置对象与内置函数\"><a href=\"#使用内置对象与内置函数\" class=\"headerlink\" title=\"使用内置对象与内置函数\"></a>使用内置对象与内置函数</h3><p>规则表达式中提供了许多内置对象，利用这些内置对象提供的函数和属性，你可以配置各种规则。例如可以使用 auth对象进行授权:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$messages_timestamp\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"string\">\"$messages_uid == auth.uid\"</span></div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"string\">\"$messages_uid == auth.uid\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用 auth对象能够迅速配置，只有当前用户才能够读写自己的数据的权限设置</p>\n<p>auth 代表已经登录的用户对象，</p>\n<p>规则表达式采用了一种类 javascript的语法，能够在表达式中使用内置对象和内置函数，最终返回的结果应该是 “true”或者”false”。</p>\n<p><strong>内置对象</strong></p>\n<p>内置对象描述now云端的时间戳，以毫秒为单位。root类型的对象，代表操作之前，数据根节点newData类型的对象，代表假设数据操作成功，之后此节点下的数据，也就是此节点下的旧数据和本次操作写入的新数据合并之后的数据。data类型的对象，代表此节点被操作前的原始数据。authAuth类型对象，代表已经登录用户对象。$variables节点的名称变量，代表动态路径的通配符。</p>\n<p>还有许多内置函数和运算符，可以查看 <a href=\"/api/sync/rule.html\">规则表达式API 文档</a></p>\n<p><strong>data与 newData</strong></p>\n<p>内置对象data指的是写操作发生之前，当前节点的已有数据。newData则指的是，假定写操作会成功，那么写操作成功之后当前节点的数据。newData代表的是旧数据和即将写入的数据合并之后的数据。</p>\n<p>为了演示它们的用法，考虑一个这样的场景：我们需要一个规则，在指定的路径下，当前节点数据不存在的时候可以写入，也可以删除已存在的数据，但不能对已有数据进行修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// data不存（没有旧数据）在或者newData不存在（删除数据）的情况下，可以写入。</span></div><div class=\"line\"><span class=\"comment\">// 也就是说可以是全新写入，也可以是删除，但是不能修改已有数据。</span></div><div class=\"line\"><span class=\"string\">\".write\"</span>: <span class=\"string\">\"!data.exists() || !newData.exists()\"</span></div></pre></td></tr></table></figure>\n<p><strong>使用 root 引用其他路径(Demo 需要修改)</strong></p>\n<p>通过使用内置变量root，data和newData，你可以访问到任何数据节点。</p>\n<p>参考下面的例子，只有当allow_writes节点的值为true，且父节点没有设置一个readOnly标志，且新写入的数据中存在名为message的子节点时，数据才被允许写入。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \".write\": \"root.child('allow_writes').val() == true &amp;&amp;</div><div class=\"line\">            !data.parent().child('readOnly').exists() &amp;&amp;</div><div class=\"line\">            newData.child('message').exists()\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过内置变量root,，$通配符，您可以定位并且选择任何数据节点。</p>\n<h3 id=\"规则的级联\"><a href=\"#规则的级联\" class=\"headerlink\" title=\"规则的级联\"></a>规则的级联</h3><p>规则表达式遵循一个自上向下延展的原则。如果一个数据节点上的.write或.read规则赋予了读或写的权限，那么它的所有的子节点也都将拥有读或写的权限。子节点上的规则不能覆盖父节点或祖先节点已经赋予的读或写的权限。参考下面的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">     <span class=\"string\">\"message\"</span>: &#123;</div><div class=\"line\">        <span class=\"comment\">// 允许/message/节点下的数据被读取</span></div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"string\">\"data.child('content').val() == true\"</span>,</div><div class=\"line\">        <span class=\"string\">\"content\"</span>: &#123;</div><div class=\"line\">          <span class=\"comment\">// 当父节点的表达式授予了读权限时，这一规则设置false无效。</span></div><div class=\"line\">          <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如上面的例子，message节点已经设置了可读，那么无论子节点如何设置，子节点都是可读的。</p>\n<h3 id=\"规则的原子性\"><a href=\"#规则的原子性\" class=\"headerlink\" title=\"规则的原子性\"></a>规则的原子性</h3><p>为了保证数据的安全，在一次操作中，只要任何一个数据节点没有访问权限，那么整个操作将会失败。参考这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"message1\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"string\">\"message2\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>读取路径/messages会返回错误，即使 message1是可读的，但是因为 message2没有可读的权限，所以整个操作都会失败。</p>\n<h2 id=\"数据校验\"><a href=\"#数据校验\" class=\"headerlink\" title=\"数据校验\"></a>数据校验</h2><h3 id=\"基本校验\"><a href=\"#基本校验\" class=\"headerlink\" title=\"基本校验\"></a>基本校验</h3><p>可以通过.validate 对数据进行校验。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"messages:\"</span>&#123;</div><div class=\"line\">      <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"content\"</span>: &#123;</div><div class=\"line\">              <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">              <span class=\"string\">\".write\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">              <span class=\"comment\">// 写入/foo 的数据必须是字符串类型且长度小于100。</span></div><div class=\"line\">              <span class=\"string\">\".validate\"</span>: <span class=\"string\">\"newData.isString() &amp;&amp; newData.val().length() &lt; 100\"</span></div><div class=\"line\">            &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内置变量自带了很多判断函数，例如 isString(), lenght()等。更多的判断函数可以参考 <a href=\"/api/sync/rule.html\">规则表达式API 文档</a></p>\n<p><strong>.validate规则不会向下级联。如果在一次操作中，任何一个子节点的.validate规则失败，整个写操作都将失败。当数据被删除（也就是值为null）时，.validate表达式被忽略。</strong></p>\n<h3 id=\"使用正则表达式校验数据\"><a href=\"#使用正则表达式校验数据\" class=\"headerlink\" title=\"使用正则表达式校验数据\"></a>使用正则表达式校验数据</h3><p>我们可以使用内置的 match()函数来进行正则校验</p>\n<p>数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式</p>\n<ol>\n<li>“.validate”: “newData.isString() &amp;&amp;  newData.val().matches(/^(19|20)[0-9][0-9]<a href=\"0[1-9]|1[012]\">-\\/. </a><a href=\"0[1-9]|[12][0-9]|3[01]\">-\\/. </a>$/)”</li>\n</ol>\n<p>Wilddog只支持一部分正则表达式的功能，已经能够满足绝大部分的需求，关于正则表达式校验的更多内容请看<a href=\"/api/sync/rule.html#matches\">正则表达式校验</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\".validate\"</span>: <span class=\"string\">\"newData.isString() &amp;&amp;  newData.val().matches(/^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$/)\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"用户认证\"><a href=\"#用户认证\" class=\"headerlink\" title=\"用户认证\"></a>用户认证</h2><h3 id=\"集成-Auth-身份认证\"><a href=\"#集成-Auth-身份认证\" class=\"headerlink\" title=\"集成 Auth 身份认证\"></a>集成 Auth 身份认证</h3><p>Wilddog Auth 身份认证集成 Sync 实时数据同步，能允许你控制每个用户对数据的控制权限。</p>\n<p><strong>说明</strong><br>用户通过身份认证后，云端会自动将用户的信息填入规则表达式的 <code>auth</code> 变量。信息包括标识用户身份的 <code>Wilddog ID</code>（即uid）及已关联帐户的资料，例如 QQ、<br>微信资料或电子邮件。你还可以通过自定义 <code>Token</code> 加入自定义字段以完成定制功能。</p>\n<h3 id=\"auth-变量\"><a href=\"#auth-变量\" class=\"headerlink\" title=\"auth 变量\"></a>auth 变量</h3><p>用户没有进行身份认证前，<code>auth</code> 变量为 null 。使用 Wilddog Auth 对用户进行身份认证后，该变量会含有以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>provider</td>\n<td>使用的身份认证方式（”password”、”anonymous”、”qq”、”weibo”、”weixin”或”weixinmp”）。</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>标识用户唯一身份的 <code>Wilddog ID</code>。</td>\n</tr>\n</tbody>\n</table>\n<p>如下，保证每个认证用户只能向特定路径写入数据：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"rules\": &#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"$user_id\": &#123;</div><div class=\"line\">        // 当认证用户的 uid 与 $user_id 这个 key 匹配时，</div><div class=\"line\">        // 才能向此节点写入数据。</div><div class=\"line\">        \".write\": \"$user_id === auth.uid\"</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"组织你的数据结构\"><a href=\"#组织你的数据结构\" class=\"headerlink\" title=\"组织你的数据结构\"></a>组织你的数据结构</h3><p>我们再次提到了组织数据，因为它与规则表达式相配合，使规则的配置更加容易。我们再来举个例子，与上例类似，我们把所有用户信息存在 <code>users</code> 节点中，该节点的子节点是每个用户的 <code>uid</code> 值。你希望限制这些数据的访问权限，且确保只有已登录用户才可以查看自己的数据，就可以这样配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"$uid\"</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">\".read\"</span>: <span class=\"string\">\"auth != null &amp;&amp; auth.uid == $uid\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用自定义-Token\"><a href=\"#使用自定义-Token\" class=\"headerlink\" title=\"使用自定义 Token\"></a>使用自定义 Token</h3><p>对于希望实现自定义认证的开发者，Wilddog Auth 也允许开发者<a href=\"/guide/auth/server/server.html\">在其服务器上创建自己的自定义 Token 来进行认证</a>。<br>你在创建自定义 Token 时，可以自定义额外的属性字段。这些额外的属性也会像 <code>uid</code>、<code>provider</code> 一样包含在 auth 变量中,但是使用起来发生了变化.<br>目前自定义的额外属性会放在auth.token里面<br>下面是一个添加并使用 <code>isAdmin</code> 自定义属性的规则示例：<br><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"rules\": &#123;</div><div class=\"line\">    \"secret\": &#123;</div><div class=\"line\">      // auth 里的 `isAdmin` 为 true 时才可以读取数据。</div><div class=\"line\">      \".read\": \"auth.token.isAdmin == true\"</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有关自定义 Token 的具体使用方法，参见<a href=\"/guide/auth/server/server.html\">使用 Wilddog Server SDK 进行身份认证</a>。</p>\n<h2 id=\"数据索引\"><a href=\"#数据索引\" class=\"headerlink\" title=\"数据索引\"></a>数据索引</h2><p>Wilddog提供了强大高效的查询方法，你可以按照任意子节点的顺序对数据进行查询。但是当你的数据量不断增加的时候，查询的效率也会逐渐降低。WildDog提供了数据索引来解决这个问题。你可以在规则表达式中使用 .indexOn 规则为节点建立索引，提高查询效率。</p>\n<p><strong>节点的名称key和优先级priority默认建立索引，不需要额外设置</strong></p>\n<p>Wilddog 根据查询需求的不同，提供了两种.indexOn的索引方式，orderByChild和 orderByValue。</p>\n<h3 id=\"orderByChild-根据子节点索引\"><a href=\"#orderByChild-根据子节点索引\" class=\"headerlink\" title=\"orderByChild 根据子节点索引\"></a>orderByChild 根据子节点索引</h3><p>orderByChild 可以根据不同的子节点进行索引，例如我们现在有一些用户的信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"Jack\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"age\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"string\">\"score\"</span> : <span class=\"number\">88</span>,</div><div class=\"line\">    <span class=\"string\">\"weight\"</span>: <span class=\"number\">63</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"Lucy\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"age\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"string\">\"score\"</span> : <span class=\"number\">91</span>,</div><div class=\"line\">    <span class=\"string\">\"weight\"</span> : <span class=\"number\">49</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设在应用中，我们需要经常对用户的信息按照名称(key)、年龄(score)、分数(score)进行排序，但是不会按照体重(weight)排序，这样我们就可以通过Wilddog提供的.indexOn规则，为名称(key)、年龄(age)、分数(score)这些节点建立索引，来提高查询效率。</p>\n<p>我们可以使用如下的设置为高度、长度节点建立索引。名称即为节点的key值，已经默认建立了索引，所以不需要额外设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"dinosaurs\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".indexOn\"</span>: [<span class=\"string\">\"age\"</span>, <span class=\"string\">\"score\"</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"orderByValue-根据值索引\"><a href=\"#orderByValue-根据值索引\" class=\"headerlink\" title=\"orderByValue 根据值索引\"></a>orderByValue 根据值索引</h3><p>orderByValue 可以根据 value的值进行索引。例如我们需要为学生分数建立一个排行榜：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"Jack\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"string\">\"Lucy\"</span> : <span class=\"number\">81</span>,</div><div class=\"line\">    <span class=\"string\">\"LiLei\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"string\">\"HanMeimei\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"string\">\"Michael\"</span> : <span class=\"number\">66</span>,</div><div class=\"line\">    <span class=\"string\">\"Jane\"</span> : <span class=\"number\">78</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们只需要对节点的 value 进行排序，因此我们可以在 /scores节点下对 value 进行索引：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"scores\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".indexOn\"</span>: <span class=\"string\">\".value\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"安全表达式基础知识\"><a href=\"#安全表达式基础知识\" class=\"headerlink\" title=\"安全表达式基础知识\"></a>安全表达式基础知识</h2><h3 id=\"设置节点的读取权限\"><a href=\"#设置节点的读取权限\" class=\"headerlink\" title=\"设置节点的读取权限\"></a>设置节点的读取权限</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">  <span class=\"string\">\"message\"</span>&#123;</div><div class=\"line\">    <span class=\"string\">\"message1\"</span>&#123;    </div><div class=\"line\">      <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".write\"</span>:  <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".validate\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"string\">\"message2\"</span>&#123;</div><div class=\"line\">      <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"string\">\".validate\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>message1节点，所有人都可以读取数据，所有人都可以输入数据，所有类型的数据都能够输入。</p>\n<p>message2节点，所有人都可以读取数据，所有人都不能输入数据，任何数据类型都不能输入。</p>\n<p>规则表达式使用 JSON结构，规则表达式的层级结构应该与数据库一致。</p>\n<p>注意：应用创建之后，系统默认为公开。所有人都能读写，为了你的数据安全，尽快配置规则表达式</p>\n<h3 id=\"用-通配符选择子节点\"><a href=\"#用-通配符选择子节点\" class=\"headerlink\" title=\"用$通配符选择子节点\"></a>用$通配符选择子节点</h3><p>实际生产环境中，不可能为每一个数据节点单独配置规则，因此我们可以使用 $ 通配符来选择子节点。</p>\n<p>例如你储存了一个 message 的信息内容列表：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"message0\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"content\"</span>: <span class=\"string\">\"Hello\"</span>,</div><div class=\"line\">      <span class=\"string\">\"timestamp\"</span>: <span class=\"number\">1405704370369</span>,</div><div class=\"line\">      <span class=\"string\">\"uid\"</span>:<span class=\"number\">17343512</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"message1\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"content\"</span>: <span class=\"string\">\"Goodbye\"</span>,</div><div class=\"line\">      <span class=\"string\">\"timestamp\"</span>: <span class=\"number\">1405704395231</span>,</div><div class=\"line\">      <span class=\"string\">\"uid\"</span>:<span class=\"number\">72366233</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不可能为每一个 message 配置规则。那么你可以使用$通配节点。例如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$message_content\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"string\">\"$message_timestamp\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还能够使用 $other 选择未列出的子节点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$message_content\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"string\">\"$other\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了content 可以读写之外，messages下的其他所有节点都不可读取。</p>\n<h3 id=\"使用内置对象与内置函数\"><a href=\"#使用内置对象与内置函数\" class=\"headerlink\" title=\"使用内置对象与内置函数\"></a>使用内置对象与内置函数</h3><p>规则表达式中提供了许多内置对象，利用这些内置对象提供的函数和属性，你可以配置各种规则。例如可以使用 auth对象进行授权:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$messages_timestamp\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"string\">\"$messages_uid == auth.uid\"</span></div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"string\">\"$messages_uid == auth.uid\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用 auth对象能够迅速配置，只有当前用户才能够读写自己的数据的权限设置</p>\n<p>auth 代表已经登录的用户对象，</p>\n<p>规则表达式采用了一种类 javascript的语法，能够在表达式中使用内置对象和内置函数，最终返回的结果应该是 “true”或者”false”。</p>\n<p><strong>内置对象</strong></p>\n<p>内置对象描述now云端的时间戳，以毫秒为单位。root类型的对象，代表操作之前，数据根节点newData类型的对象，代表假设数据操作成功，之后此节点下的数据，也就是此节点下的旧数据和本次操作写入的新数据合并之后的数据。data类型的对象，代表此节点被操作前的原始数据。authAuth类型对象，代表已经登录用户对象。$variables节点的名称变量，代表动态路径的通配符。</p>\n<p>还有许多内置函数和运算符，可以查看 <a href=\"/api/sync/rule.html\">规则表达式API 文档</a></p>\n<p><strong>data与 newData</strong></p>\n<p>内置对象data指的是写操作发生之前，当前节点的已有数据。newData则指的是，假定写操作会成功，那么写操作成功之后当前节点的数据。newData代表的是旧数据和即将写入的数据合并之后的数据。</p>\n<p>为了演示它们的用法，考虑一个这样的场景：我们需要一个规则，在指定的路径下，当前节点数据不存在的时候可以写入，也可以删除已存在的数据，但不能对已有数据进行修改：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// data不存（没有旧数据）在或者newData不存在（删除数据）的情况下，可以写入。</span></div><div class=\"line\"><span class=\"comment\">// 也就是说可以是全新写入，也可以是删除，但是不能修改已有数据。</span></div><div class=\"line\"><span class=\"string\">\".write\"</span>: <span class=\"string\">\"!data.exists() || !newData.exists()\"</span></div></pre></td></tr></table></figure>\n<p><strong>使用 root 引用其他路径(Demo 需要修改)</strong></p>\n<p>通过使用内置变量root，data和newData，你可以访问到任何数据节点。</p>\n<p>参考下面的例子，只有当allow_writes节点的值为true，且父节点没有设置一个readOnly标志，且新写入的数据中存在名为message的子节点时，数据才被允许写入。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \".write\": \"root.child('allow_writes').val() == true &amp;&amp;</div><div class=\"line\">            !data.parent().child('readOnly').exists() &amp;&amp;</div><div class=\"line\">            newData.child('message').exists()\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过内置变量root,，$通配符，您可以定位并且选择任何数据节点。</p>\n<h3 id=\"规则的级联\"><a href=\"#规则的级联\" class=\"headerlink\" title=\"规则的级联\"></a>规则的级联</h3><p>规则表达式遵循一个自上向下延展的原则。如果一个数据节点上的.write或.read规则赋予了读或写的权限，那么它的所有的子节点也都将拥有读或写的权限。子节点上的规则不能覆盖父节点或祖先节点已经赋予的读或写的权限。参考下面的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">     <span class=\"string\">\"message\"</span>: &#123;</div><div class=\"line\">        <span class=\"comment\">// 允许/message/节点下的数据被读取</span></div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"string\">\"data.child('content').val() == true\"</span>,</div><div class=\"line\">        <span class=\"string\">\"content\"</span>: &#123;</div><div class=\"line\">          <span class=\"comment\">// 当父节点的表达式授予了读权限时，这一规则设置false无效。</span></div><div class=\"line\">          <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如上面的例子，message节点已经设置了可读，那么无论子节点如何设置，子节点都是可读的。</p>\n<h3 id=\"规则的原子性\"><a href=\"#规则的原子性\" class=\"headerlink\" title=\"规则的原子性\"></a>规则的原子性</h3><p>为了保证数据的安全，在一次操作中，只要任何一个数据节点没有访问权限，那么整个操作将会失败。参考这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"messages\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"message1\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"string\">\"message2\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".read\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>读取路径/messages会返回错误，即使 message1是可读的，但是因为 message2没有可读的权限，所以整个操作都会失败。</p>\n<h2 id=\"数据校验\"><a href=\"#数据校验\" class=\"headerlink\" title=\"数据校验\"></a>数据校验</h2><h3 id=\"基本校验\"><a href=\"#基本校验\" class=\"headerlink\" title=\"基本校验\"></a>基本校验</h3><p>可以通过.validate 对数据进行校验。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"messages:\"</span>&#123;</div><div class=\"line\">      <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"content\"</span>: &#123;</div><div class=\"line\">              <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">              <span class=\"string\">\".write\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">              <span class=\"comment\">// 写入/foo 的数据必须是字符串类型且长度小于100。</span></div><div class=\"line\">              <span class=\"string\">\".validate\"</span>: <span class=\"string\">\"newData.isString() &amp;&amp; newData.val().length() &lt; 100\"</span></div><div class=\"line\">            &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>内置变量自带了很多判断函数，例如 isString(), lenght()等。更多的判断函数可以参考 <a href=\"/api/sync/rule.html\">规则表达式API 文档</a></p>\n<p><strong>.validate规则不会向下级联。如果在一次操作中，任何一个子节点的.validate规则失败，整个写操作都将失败。当数据被删除（也就是值为null）时，.validate表达式被忽略。</strong></p>\n<h3 id=\"使用正则表达式校验数据\"><a href=\"#使用正则表达式校验数据\" class=\"headerlink\" title=\"使用正则表达式校验数据\"></a>使用正则表达式校验数据</h3><p>我们可以使用内置的 match()函数来进行正则校验</p>\n<p>数据需要满足是字符串，并且字符串是1900-2099年间的YYYY-MM-DD格式</p>\n<ol>\n<li>“.validate”: “newData.isString() &amp;&amp;  newData.val().matches(/^(19|20)[0-9][0-9]<a href=\"0[1-9]|1[012]\">-\\/. </a><a href=\"0[1-9]|[12][0-9]|3[01]\">-\\/. </a>$/)”</li>\n</ol>\n<p>Wilddog只支持一部分正则表达式的功能，已经能够满足绝大部分的需求，关于正则表达式校验的更多内容请看<a href=\"/api/sync/rule.html#matches\">正则表达式校验</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\".validate\"</span>: <span class=\"string\">\"newData.isString() &amp;&amp;  newData.val().matches(/^(19|20)[0-9][0-9][-\\\\/. ](0[1-9]|1[012])[-\\\\/. ](0[1-9]|[12][0-9]|3[01])$/)\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"用户认证\"><a href=\"#用户认证\" class=\"headerlink\" title=\"用户认证\"></a>用户认证</h2><h3 id=\"集成-Auth-身份认证\"><a href=\"#集成-Auth-身份认证\" class=\"headerlink\" title=\"集成 Auth 身份认证\"></a>集成 Auth 身份认证</h3><p>Wilddog Auth 身份认证集成 Sync 实时数据同步，能允许你控制每个用户对数据的控制权限。</p>\n<p><strong>说明</strong><br>用户通过身份认证后，云端会自动将用户的信息填入规则表达式的 <code>auth</code> 变量。信息包括标识用户身份的 <code>Wilddog ID</code>（即uid）及已关联帐户的资料，例如 QQ、<br>微信资料或电子邮件。你还可以通过自定义 <code>Token</code> 加入自定义字段以完成定制功能。</p>\n<h3 id=\"auth-变量\"><a href=\"#auth-变量\" class=\"headerlink\" title=\"auth 变量\"></a>auth 变量</h3><p>用户没有进行身份认证前，<code>auth</code> 变量为 null 。使用 Wilddog Auth 对用户进行身份认证后，该变量会含有以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>provider</td>\n<td>使用的身份认证方式（”password”、”anonymous”、”qq”、”weibo”、”weixin”或”weixinmp”）。</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>标识用户唯一身份的 <code>Wilddog ID</code>。</td>\n</tr>\n</tbody>\n</table>\n<p>如下，保证每个认证用户只能向特定路径写入数据：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"rules\": &#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"$user_id\": &#123;</div><div class=\"line\">        // 当认证用户的 uid 与 $user_id 这个 key 匹配时，</div><div class=\"line\">        // 才能向此节点写入数据。</div><div class=\"line\">        \".write\": \"$user_id === auth.uid\"</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"组织你的数据结构\"><a href=\"#组织你的数据结构\" class=\"headerlink\" title=\"组织你的数据结构\"></a>组织你的数据结构</h3><p>我们再次提到了组织数据，因为它与规则表达式相配合，使规则的配置更加容易。我们再来举个例子，与上例类似，我们把所有用户信息存在 <code>users</code> 节点中，该节点的子节点是每个用户的 <code>uid</code> 值。你希望限制这些数据的访问权限，且确保只有已登录用户才可以查看自己的数据，就可以这样配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"$uid\"</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">\".read\"</span>: <span class=\"string\">\"auth != null &amp;&amp; auth.uid == $uid\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用自定义-Token\"><a href=\"#使用自定义-Token\" class=\"headerlink\" title=\"使用自定义 Token\"></a>使用自定义 Token</h3><p>对于希望实现自定义认证的开发者，Wilddog Auth 也允许开发者<a href=\"/guide/auth/server/server.html\">在其服务器上创建自己的自定义 Token 来进行认证</a>。<br>你在创建自定义 Token 时，可以自定义额外的属性字段。这些额外的属性也会像 <code>uid</code>、<code>provider</code> 一样包含在 auth 变量中,但是使用起来发生了变化.<br>目前自定义的额外属性会放在auth.token里面<br>下面是一个添加并使用 <code>isAdmin</code> 自定义属性的规则示例：<br><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"rules\": &#123;</div><div class=\"line\">    \"secret\": &#123;</div><div class=\"line\">      // auth 里的 `isAdmin` 为 true 时才可以读取数据。</div><div class=\"line\">      \".read\": \"auth.token.isAdmin == true\"</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有关自定义 Token 的具体使用方法，参见<a href=\"/guide/auth/server/server.html\">使用 Wilddog Server SDK 进行身份认证</a>。</p>\n<h2 id=\"数据索引\"><a href=\"#数据索引\" class=\"headerlink\" title=\"数据索引\"></a>数据索引</h2><p>Wilddog提供了强大高效的查询方法，你可以按照任意子节点的顺序对数据进行查询。但是当你的数据量不断增加的时候，查询的效率也会逐渐降低。WildDog提供了数据索引来解决这个问题。你可以在规则表达式中使用 .indexOn 规则为节点建立索引，提高查询效率。</p>\n<p><strong>节点的名称key和优先级priority默认建立索引，不需要额外设置</strong></p>\n<p>Wilddog 根据查询需求的不同，提供了两种.indexOn的索引方式，orderByChild和 orderByValue。</p>\n<h3 id=\"orderByChild-根据子节点索引\"><a href=\"#orderByChild-根据子节点索引\" class=\"headerlink\" title=\"orderByChild 根据子节点索引\"></a>orderByChild 根据子节点索引</h3><p>orderByChild 可以根据不同的子节点进行索引，例如我们现在有一些用户的信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"Jack\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"age\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"string\">\"score\"</span> : <span class=\"number\">88</span>,</div><div class=\"line\">    <span class=\"string\">\"weight\"</span>: <span class=\"number\">63</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"Lucy\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"age\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"string\">\"score\"</span> : <span class=\"number\">91</span>,</div><div class=\"line\">    <span class=\"string\">\"weight\"</span> : <span class=\"number\">49</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设在应用中，我们需要经常对用户的信息按照名称(key)、年龄(score)、分数(score)进行排序，但是不会按照体重(weight)排序，这样我们就可以通过Wilddog提供的.indexOn规则，为名称(key)、年龄(age)、分数(score)这些节点建立索引，来提高查询效率。</p>\n<p>我们可以使用如下的设置为高度、长度节点建立索引。名称即为节点的key值，已经默认建立了索引，所以不需要额外设置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"dinosaurs\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".indexOn\"</span>: [<span class=\"string\">\"age\"</span>, <span class=\"string\">\"score\"</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"orderByValue-根据值索引\"><a href=\"#orderByValue-根据值索引\" class=\"headerlink\" title=\"orderByValue 根据值索引\"></a>orderByValue 根据值索引</h3><p>orderByValue 可以根据 value的值进行索引。例如我们需要为学生分数建立一个排行榜：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"Jack\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"string\">\"Lucy\"</span> : <span class=\"number\">81</span>,</div><div class=\"line\">    <span class=\"string\">\"LiLei\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"string\">\"HanMeimei\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"string\">\"Michael\"</span> : <span class=\"number\">66</span>,</div><div class=\"line\">    <span class=\"string\">\"Jane\"</span> : <span class=\"number\">78</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们只需要对节点的 value 进行排序，因此我们可以在 /scores节点下对 value 进行索引：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"scores\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".indexOn\"</span>: <span class=\"string\">\".value\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"规则表达式简介","_content":"\nWilddog非常重视数据的安全问题。在过去的开发过程中，数据的安全问题，一直令开发者头疼，不仅功能不全而且配置复杂。\n\nWilddog提供了一种类 javascript语法的规则表达式来解决你的安全问题。\n\n规则表达式符合 JSON规范，你可以通过编写少量的规则表达式实现强大的安全功能，包括设置读写权限，用户授权，数据校验和数据索引。\n\n规则是声明式的，即独立于主产品逻辑之外。这样是有好处的：安全性不完全依赖于客户端，无需中间服务器即可保护数据安全，真正解决无后端应用中的安全问题。\n\n你可以在控制台-实时数据同步-读写权限中配置规则表达式。\n\n![img](/images/rule-overview.png)\n\n规则表达式有四种类型，读、写以及校验，我们能够通过灵活配置这几个个规则，实现访问权限控制和数据校验还有建立索引。\n\n| 规则类型      | 描述                             |\n| --------- | ------------------------------ |\n| .read     | 定义了数据是否可以被用户读取                 |\n| .write    | 定义了数据是否可以被用户写入                 |\n| .validate | 定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等 |\n| .indexOn  | 为节点数据建立索引，提高查询效率               |\n\n\n\n规则类型描述.read定义了数据是否可以被用户读取.write定义了数据是否可以被用户写入.validate定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等.indexon为节点数据建立索引，提高查询效率\n\n通过配置规则表达式，可以很轻松的实现各种安全功能：\n\n\n\n### 设置读写权限\n\n.read .write 你可以设置你数据中任意节点的可读和可写性。\n\n```javascript\n{\n  \"rules\": {\n    \"foo\": {\n      \".read\": true,\n      \".write\": false\n    }\n  }\n}\n```\n\n使用.read 与 .write 可以声明了/foo节点以及子节点的读写权限，true为允许，false 为禁止。\n\ntrue与 false 可以通过表达式来表示。\n\n\n\n### 用户认证\n\n内置的 auth对象，你可以授权给不同的用户，只允许授权的用户进行数据操作。\n\n```javascript\n{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".write\": \"$uid === auth.uid\"\n      }\n    }\n  }\n}\n```\n\n通过使用 auth对象，只允许允许写入 uid，\n\n\n\n### 校验数据\n\n.validate 你可以校验数据的合法性，只允许符合规则的数据存入。\n\n```javascript\n{\n  \"rules\": {\n    \"foo\": {\n      \".validate\": \"newData.isString() && newData.val().length < 100\"\n    }\n  }\n}\n```\n\n使用.validate 表达式使 foo节点只允许通过使用字符串类型，并且只允许存入长度<100的值。\n\n\n\n### 数据索引\n\n通过.indexOn，你可以针对数据节点进行索引，提高查询数据的速度。\n\n```javascript\n{\n  \"rules\": {\n    \"dinosaurs\": {\n      \".indexOn\": [\"height\", \"length\"]\n    }\n  }\n}\n```\n\n使用了.indexOn对 student的子节点 age，score进行索引，进行查询的时候将会提高效率。","source":"guide/sync/rules/introduce.md","raw":"\ntitle: 规则表达式简介\n---\n\nWilddog非常重视数据的安全问题。在过去的开发过程中，数据的安全问题，一直令开发者头疼，不仅功能不全而且配置复杂。\n\nWilddog提供了一种类 javascript语法的规则表达式来解决你的安全问题。\n\n规则表达式符合 JSON规范，你可以通过编写少量的规则表达式实现强大的安全功能，包括设置读写权限，用户授权，数据校验和数据索引。\n\n规则是声明式的，即独立于主产品逻辑之外。这样是有好处的：安全性不完全依赖于客户端，无需中间服务器即可保护数据安全，真正解决无后端应用中的安全问题。\n\n你可以在控制台-实时数据同步-读写权限中配置规则表达式。\n\n![img](/images/rule-overview.png)\n\n规则表达式有四种类型，读、写以及校验，我们能够通过灵活配置这几个个规则，实现访问权限控制和数据校验还有建立索引。\n\n| 规则类型      | 描述                             |\n| --------- | ------------------------------ |\n| .read     | 定义了数据是否可以被用户读取                 |\n| .write    | 定义了数据是否可以被用户写入                 |\n| .validate | 定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等 |\n| .indexOn  | 为节点数据建立索引，提高查询效率               |\n\n\n\n规则类型描述.read定义了数据是否可以被用户读取.write定义了数据是否可以被用户写入.validate定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等.indexon为节点数据建立索引，提高查询效率\n\n通过配置规则表达式，可以很轻松的实现各种安全功能：\n\n\n\n### 设置读写权限\n\n.read .write 你可以设置你数据中任意节点的可读和可写性。\n\n```javascript\n{\n  \"rules\": {\n    \"foo\": {\n      \".read\": true,\n      \".write\": false\n    }\n  }\n}\n```\n\n使用.read 与 .write 可以声明了/foo节点以及子节点的读写权限，true为允许，false 为禁止。\n\ntrue与 false 可以通过表达式来表示。\n\n\n\n### 用户认证\n\n内置的 auth对象，你可以授权给不同的用户，只允许授权的用户进行数据操作。\n\n```javascript\n{\n  \"rules\": {\n    \"users\": {\n      \"$uid\": {\n        \".write\": \"$uid === auth.uid\"\n      }\n    }\n  }\n}\n```\n\n通过使用 auth对象，只允许允许写入 uid，\n\n\n\n### 校验数据\n\n.validate 你可以校验数据的合法性，只允许符合规则的数据存入。\n\n```javascript\n{\n  \"rules\": {\n    \"foo\": {\n      \".validate\": \"newData.isString() && newData.val().length < 100\"\n    }\n  }\n}\n```\n\n使用.validate 表达式使 foo节点只允许通过使用字符串类型，并且只允许存入长度<100的值。\n\n\n\n### 数据索引\n\n通过.indexOn，你可以针对数据节点进行索引，提高查询数据的速度。\n\n```javascript\n{\n  \"rules\": {\n    \"dinosaurs\": {\n      \".indexOn\": [\"height\", \"length\"]\n    }\n  }\n}\n```\n\n使用了.indexOn对 student的子节点 age，score进行索引，进行查询的时候将会提高效率。","date":"2016-09-06T03:38:22.545Z","updated":"2016-09-06T03:38:22.545Z","path":"guide/sync/rules/introduce.html","comments":1,"layout":"page","_id":"cisswi9lw0020z4fwy524ovuj","content":"<p>Wilddog非常重视数据的安全问题。在过去的开发过程中，数据的安全问题，一直令开发者头疼，不仅功能不全而且配置复杂。</p>\n<p>Wilddog提供了一种类 javascript语法的规则表达式来解决你的安全问题。</p>\n<p>规则表达式符合 JSON规范，你可以通过编写少量的规则表达式实现强大的安全功能，包括设置读写权限，用户授权，数据校验和数据索引。</p>\n<p>规则是声明式的，即独立于主产品逻辑之外。这样是有好处的：安全性不完全依赖于客户端，无需中间服务器即可保护数据安全，真正解决无后端应用中的安全问题。</p>\n<p>你可以在控制台-实时数据同步-读写权限中配置规则表达式。</p>\n<p><img src=\"/images/rule-overview.png\" alt=\"img\"></p>\n<p>规则表达式有四种类型，读、写以及校验，我们能够通过灵活配置这几个个规则，实现访问权限控制和数据校验还有建立索引。</p>\n<table>\n<thead>\n<tr>\n<th>规则类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.read</td>\n<td>定义了数据是否可以被用户读取</td>\n</tr>\n<tr>\n<td>.write</td>\n<td>定义了数据是否可以被用户写入</td>\n</tr>\n<tr>\n<td>.validate</td>\n<td>定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等</td>\n</tr>\n<tr>\n<td>.indexOn</td>\n<td>为节点数据建立索引，提高查询效率</td>\n</tr>\n</tbody>\n</table>\n<p>规则类型描述.read定义了数据是否可以被用户读取.write定义了数据是否可以被用户写入.validate定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等.indexon为节点数据建立索引，提高查询效率</p>\n<p>通过配置规则表达式，可以很轻松的实现各种安全功能：</p>\n<h3 id=\"设置读写权限\"><a href=\"#设置读写权限\" class=\"headerlink\" title=\"设置读写权限\"></a>设置读写权限</h3><p>.read .write 你可以设置你数据中任意节点的可读和可写性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"foo\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用.read 与 .write 可以声明了/foo节点以及子节点的读写权限，true为允许，false 为禁止。</p>\n<p>true与 false 可以通过表达式来表示。</p>\n<h3 id=\"用户认证\"><a href=\"#用户认证\" class=\"headerlink\" title=\"用户认证\"></a>用户认证</h3><p>内置的 auth对象，你可以授权给不同的用户，只允许授权的用户进行数据操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$uid\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"string\">\"$uid === auth.uid\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过使用 auth对象，只允许允许写入 uid，</p>\n<h3 id=\"校验数据\"><a href=\"#校验数据\" class=\"headerlink\" title=\"校验数据\"></a>校验数据</h3><p>.validate 你可以校验数据的合法性，只允许符合规则的数据存入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"foo\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".validate\"</span>: <span class=\"string\">\"newData.isString() &amp;&amp; newData.val().length &lt; 100\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用.validate 表达式使 foo节点只允许通过使用字符串类型，并且只允许存入长度&lt;100的值。</p>\n<h3 id=\"数据索引\"><a href=\"#数据索引\" class=\"headerlink\" title=\"数据索引\"></a>数据索引</h3><p>通过.indexOn，你可以针对数据节点进行索引，提高查询数据的速度。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"dinosaurs\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".indexOn\"</span>: [<span class=\"string\">\"height\"</span>, <span class=\"string\">\"length\"</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用了.indexOn对 student的子节点 age，score进行索引，进行查询的时候将会提高效率。</p>\n","excerpt":"","more":"<p>Wilddog非常重视数据的安全问题。在过去的开发过程中，数据的安全问题，一直令开发者头疼，不仅功能不全而且配置复杂。</p>\n<p>Wilddog提供了一种类 javascript语法的规则表达式来解决你的安全问题。</p>\n<p>规则表达式符合 JSON规范，你可以通过编写少量的规则表达式实现强大的安全功能，包括设置读写权限，用户授权，数据校验和数据索引。</p>\n<p>规则是声明式的，即独立于主产品逻辑之外。这样是有好处的：安全性不完全依赖于客户端，无需中间服务器即可保护数据安全，真正解决无后端应用中的安全问题。</p>\n<p>你可以在控制台-实时数据同步-读写权限中配置规则表达式。</p>\n<p><img src=\"/images/rule-overview.png\" alt=\"img\"></p>\n<p>规则表达式有四种类型，读、写以及校验，我们能够通过灵活配置这几个个规则，实现访问权限控制和数据校验还有建立索引。</p>\n<table>\n<thead>\n<tr>\n<th>规则类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.read</td>\n<td>定义了数据是否可以被用户读取</td>\n</tr>\n<tr>\n<td>.write</td>\n<td>定义了数据是否可以被用户写入</td>\n</tr>\n<tr>\n<td>.validate</td>\n<td>定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等</td>\n</tr>\n<tr>\n<td>.indexOn</td>\n<td>为节点数据建立索引，提高查询效率</td>\n</tr>\n</tbody>\n</table>\n<p>规则类型描述.read定义了数据是否可以被用户读取.write定义了数据是否可以被用户写入.validate定义了什么样的数据是正确的格式，是否有某些子属性，数据类型等.indexon为节点数据建立索引，提高查询效率</p>\n<p>通过配置规则表达式，可以很轻松的实现各种安全功能：</p>\n<h3 id=\"设置读写权限\"><a href=\"#设置读写权限\" class=\"headerlink\" title=\"设置读写权限\"></a>设置读写权限</h3><p>.read .write 你可以设置你数据中任意节点的可读和可写性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"foo\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".read\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">\".write\"</span>: <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用.read 与 .write 可以声明了/foo节点以及子节点的读写权限，true为允许，false 为禁止。</p>\n<p>true与 false 可以通过表达式来表示。</p>\n<h3 id=\"用户认证\"><a href=\"#用户认证\" class=\"headerlink\" title=\"用户认证\"></a>用户认证</h3><p>内置的 auth对象，你可以授权给不同的用户，只允许授权的用户进行数据操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\"$uid\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\".write\"</span>: <span class=\"string\">\"$uid === auth.uid\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过使用 auth对象，只允许允许写入 uid，</p>\n<h3 id=\"校验数据\"><a href=\"#校验数据\" class=\"headerlink\" title=\"校验数据\"></a>校验数据</h3><p>.validate 你可以校验数据的合法性，只允许符合规则的数据存入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"foo\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".validate\"</span>: <span class=\"string\">\"newData.isString() &amp;&amp; newData.val().length &lt; 100\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用.validate 表达式使 foo节点只允许通过使用字符串类型，并且只允许存入长度&lt;100的值。</p>\n<h3 id=\"数据索引\"><a href=\"#数据索引\" class=\"headerlink\" title=\"数据索引\"></a>数据索引</h3><p>通过.indexOn，你可以针对数据节点进行索引，提高查询数据的速度。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"rules\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"dinosaurs\"</span>: &#123;</div><div class=\"line\">      <span class=\"string\">\".indexOn\"</span>: [<span class=\"string\">\"height\"</span>, <span class=\"string\">\"length\"</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用了.indexOn对 student的子节点 age，score进行索引，进行查询的时候将会提高效率。</p>\n"},{"title":"离线功能","_content":"Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。\n\n## 监控连接状态\n\n在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar connectedRef = wilddog.sync().ref(\"/.info/connected\");\n\nconnectedRef.on(\"value\", function(snap) {\n  if (snap.val() === true) {\n    alert(\"connected\");\n  } else {\n    alert(\"not connected\");\n  }\n});\n```\n/.info/connected的值是boolean类型的，它不会和云端进行同步。\n\n## 离线事件\n\n如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。\n\n离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 set, update，remove，都可以设置在离线事件中执行。\n\n下面是一个例子，使用`onDisconnect()`方法，在离线的时候写入数据：\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar presenceRef = wilddog.sync().ref(\"disconnectmessage\");\n\n// 当客户端连接断开时，写入一个字符串\npresenceRef.onDisconnect().set(\"I disconnected!\");\n```\n\n**离线事件是如何工作的**\n\n当进行了一个`onDisconnect()`调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。\n\n客户端可以通过回调方法，确保离线事件被云端成功记录了：\n\n```js\npresenceRef.onDisconnect().remove( function(err) {\n  if(err) {\n    console.error('could not establish onDisconnect event', err);\n  }\n});\n```\n\n要取消一个离线事件，可以使用`cancel()`方法：\n\n```js\nvar onDisconnectRef = presenceRef.onDisconnect();\nonDisconnectRef.set('I disconnected');\n// 要取消离线事件\nonDisconnectRef.cancel();\n```\n## 云端时间戳\nWilddog 提供了一种将[云端时间戳](/api/sync/web.html#TIMESTAMP)作为数据写入的机制。这个机制和`onDisconnect()`方法组合起来，很容易实现记录客户端断线时间的功能：\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar userLastOnlineRef = wilddog.sync().ref(\"/users/joe/lastOnline\");\n\nuserLastOnlineRef.onDisconnect().set(wilddog.sync().ServerValue.TIMESTAMP);\n```\n\n另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 `/.info/serverTimeOffset` 中,你可以通过`on` 或者`once` 监听 `value` 事件来获取这个数据:\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar serverTsRef = wilddog.sync().ref(\"/.info/serverTimeOffset\");\n\nserverTsRef.on('value',function(snapshot){\n  var offset = snapshot.val();\n  serverTime = (new Date).getTime() + offset ; // 获取当前服务端时间\n})\n```\n如果你只是想简单的获取服务器时间，可以用 REST API [Server Values](https://z.wilddog.com/rest/api#Server-Values0)。即向 `https://<appId>.wilddogio.com/.json?sv=timestamp` 发一个 `GET` 请求即可。\n\n## 手动建立或断开连接\nWilddog 也提供了手动建立或者断开连接的方法。示例如下：\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar connectedRef = wilddog.sync().ref(\"/.info/connected\");\n\n// 监听连接状态\nconnectedRef.on(\"value\", function(snap) {\n  if (snap.val() === true) {\n    console.log(\"connected\");\n  } else {\n    console.log(\"I disconnected\");\n  }\n});\n\nsetTimeout(function(){\n  // 断开连接\n  wilddog.sync().goOffline(); \n  setTimeout(function(){\n    // 重新建连\n    wilddog.sync().goOnline();\n  },3000);\n},3000);\n```\n另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 `goOffline` 和 `goOnline` 会控制`全局`的在线和离线。 \n\n## 离线功能的实现机制\n\nWilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有），重试连接等。\n另外，重试连接连上之后，之前设置的监听仍然有效。\n\n\n\n\n\n\n\n","source":"guide/sync/web/offline-capabilities.md","raw":"title:  离线功能\n---\nWilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。\n\n## 监控连接状态\n\n在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。\n``` js\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar connectedRef = wilddog.sync().ref(\"/.info/connected\");\n\nconnectedRef.on(\"value\", function(snap) {\n  if (snap.val() === true) {\n    alert(\"connected\");\n  } else {\n    alert(\"not connected\");\n  }\n});\n```\n/.info/connected的值是boolean类型的，它不会和云端进行同步。\n\n## 离线事件\n\n如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。\n\n离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 set, update，remove，都可以设置在离线事件中执行。\n\n下面是一个例子，使用`onDisconnect()`方法，在离线的时候写入数据：\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar presenceRef = wilddog.sync().ref(\"disconnectmessage\");\n\n// 当客户端连接断开时，写入一个字符串\npresenceRef.onDisconnect().set(\"I disconnected!\");\n```\n\n**离线事件是如何工作的**\n\n当进行了一个`onDisconnect()`调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。\n\n客户端可以通过回调方法，确保离线事件被云端成功记录了：\n\n```js\npresenceRef.onDisconnect().remove( function(err) {\n  if(err) {\n    console.error('could not establish onDisconnect event', err);\n  }\n});\n```\n\n要取消一个离线事件，可以使用`cancel()`方法：\n\n```js\nvar onDisconnectRef = presenceRef.onDisconnect();\nonDisconnectRef.set('I disconnected');\n// 要取消离线事件\nonDisconnectRef.cancel();\n```\n## 云端时间戳\nWilddog 提供了一种将[云端时间戳](/api/sync/web.html#TIMESTAMP)作为数据写入的机制。这个机制和`onDisconnect()`方法组合起来，很容易实现记录客户端断线时间的功能：\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar userLastOnlineRef = wilddog.sync().ref(\"/users/joe/lastOnline\");\n\nuserLastOnlineRef.onDisconnect().set(wilddog.sync().ServerValue.TIMESTAMP);\n```\n\n另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 `/.info/serverTimeOffset` 中,你可以通过`on` 或者`once` 监听 `value` 事件来获取这个数据:\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar serverTsRef = wilddog.sync().ref(\"/.info/serverTimeOffset\");\n\nserverTsRef.on('value',function(snapshot){\n  var offset = snapshot.val();\n  serverTime = (new Date).getTime() + offset ; // 获取当前服务端时间\n})\n```\n如果你只是想简单的获取服务器时间，可以用 REST API [Server Values](https://z.wilddog.com/rest/api#Server-Values0)。即向 `https://<appId>.wilddogio.com/.json?sv=timestamp` 发一个 `GET` 请求即可。\n\n## 手动建立或断开连接\nWilddog 也提供了手动建立或者断开连接的方法。示例如下：\n\n```js\nvar config = {\n  authDomain: \"samplechat.wilddog.com\",\n  syncURL: \"https://samplechat.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar connectedRef = wilddog.sync().ref(\"/.info/connected\");\n\n// 监听连接状态\nconnectedRef.on(\"value\", function(snap) {\n  if (snap.val() === true) {\n    console.log(\"connected\");\n  } else {\n    console.log(\"I disconnected\");\n  }\n});\n\nsetTimeout(function(){\n  // 断开连接\n  wilddog.sync().goOffline(); \n  setTimeout(function(){\n    // 重新建连\n    wilddog.sync().goOnline();\n  },3000);\n},3000);\n```\n另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 `goOffline` 和 `goOnline` 会控制`全局`的在线和离线。 \n\n## 离线功能的实现机制\n\nWilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有），重试连接等。\n另外，重试连接连上之后，之前设置的监听仍然有效。\n\n\n\n\n\n\n\n","date":"2016-09-06T03:38:22.545Z","updated":"2016-09-06T03:38:22.545Z","path":"guide/sync/web/offline-capabilities.html","comments":1,"layout":"page","_id":"cisswi9lw0021z4fwaeyie00m","content":"<p>Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。</p>\n<h2 id=\"监控连接状态\"><a href=\"#监控连接状态\" class=\"headerlink\" title=\"监控连接状态\"></a>监控连接状态</h2><p>在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> connectedRef = wilddog.sync().ref(<span class=\"string\">\"/.info/connected\"</span>);</div><div class=\"line\"></div><div class=\"line\">connectedRef.on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (snap.val() === <span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    alert(<span class=\"string\">\"connected\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    alert(<span class=\"string\">\"not connected\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>/.info/connected的值是boolean类型的，它不会和云端进行同步。</p>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。</p>\n<p>离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 set, update，remove，都可以设置在离线事件中执行。</p>\n<p>下面是一个例子，使用<code>onDisconnect()</code>方法，在离线的时候写入数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> presenceRef = wilddog.sync().ref(<span class=\"string\">\"disconnectmessage\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当客户端连接断开时，写入一个字符串</span></div><div class=\"line\">presenceRef.onDisconnect().set(<span class=\"string\">\"I disconnected!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>离线事件是如何工作的</strong></p>\n<p>当进行了一个<code>onDisconnect()</code>调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。</p>\n<p>客户端可以通过回调方法，确保离线事件被云端成功记录了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnect().remove( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">'could not establish onDisconnect event'</span>, err);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>要取消一个离线事件，可以使用<code>cancel()</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> onDisconnectRef = presenceRef.onDisconnect();</div><div class=\"line\">onDisconnectRef.set(<span class=\"string\">'I disconnected'</span>);</div><div class=\"line\"><span class=\"comment\">// 要取消离线事件</span></div><div class=\"line\">onDisconnectRef.cancel();</div></pre></td></tr></table></figure>\n<h2 id=\"云端时间戳\"><a href=\"#云端时间戳\" class=\"headerlink\" title=\"云端时间戳\"></a>云端时间戳</h2><p>Wilddog 提供了一种将<a href=\"/api/sync/web.html#TIMESTAMP\">云端时间戳</a>作为数据写入的机制。这个机制和<code>onDisconnect()</code>方法组合起来，很容易实现记录客户端断线时间的功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> userLastOnlineRef = wilddog.sync().ref(<span class=\"string\">\"/users/joe/lastOnline\"</span>);</div><div class=\"line\"></div><div class=\"line\">userLastOnlineRef.onDisconnect().set(wilddog.sync().ServerValue.TIMESTAMP);</div></pre></td></tr></table></figure>\n<p>另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 <code>/.info/serverTimeOffset</code> 中,你可以通过<code>on</code> 或者<code>once</code> 监听 <code>value</code> 事件来获取这个数据:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> serverTsRef = wilddog.sync().ref(<span class=\"string\">\"/.info/serverTimeOffset\"</span>);</div><div class=\"line\"></div><div class=\"line\">serverTsRef.on(<span class=\"string\">'value'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> offset = snapshot.val();</div><div class=\"line\">  serverTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>).getTime() + offset ; <span class=\"comment\">// 获取当前服务端时间</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果你只是想简单的获取服务器时间，可以用 REST API <a href=\"https://z.wilddog.com/rest/api#Server-Values0\" target=\"_blank\" rel=\"external\">Server Values</a>。即向 <code>https://&lt;appId&gt;.wilddogio.com/.json?sv=timestamp</code> 发一个 <code>GET</code> 请求即可。</p>\n<h2 id=\"手动建立或断开连接\"><a href=\"#手动建立或断开连接\" class=\"headerlink\" title=\"手动建立或断开连接\"></a>手动建立或断开连接</h2><p>Wilddog 也提供了手动建立或者断开连接的方法。示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> connectedRef = wilddog.sync().ref(<span class=\"string\">\"/.info/connected\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听连接状态</span></div><div class=\"line\">connectedRef.on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (snap.val() === <span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"connected\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I disconnected\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 断开连接</span></div><div class=\"line\">  wilddog.sync().goOffline(); </div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 重新建连</span></div><div class=\"line\">    wilddog.sync().goOnline();</div><div class=\"line\">  &#125;,<span class=\"number\">3000</span>);</div><div class=\"line\">&#125;,<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure>\n<p>另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 <code>goOffline</code> 和 <code>goOnline</code> 会控制<code>全局</code>的在线和离线。 </p>\n<h2 id=\"离线功能的实现机制\"><a href=\"#离线功能的实现机制\" class=\"headerlink\" title=\"离线功能的实现机制\"></a>离线功能的实现机制</h2><p>Wilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有），重试连接等。<br>另外，重试连接连上之后，之前设置的监听仍然有效。</p>\n","excerpt":"","more":"<p>Wilddog 内部的实现机制能使你的应用在弱网环境下仍能继续工作。此外，还能监听客户端的在线状态，以及设置离线事件。</p>\n<h2 id=\"监控连接状态\"><a href=\"#监控连接状态\" class=\"headerlink\" title=\"监控连接状态\"></a>监控连接状态</h2><p>在许多应用场景下，客户端需要知道自己是否在线。Wilddog 客户端提供了一个特殊的数据地址：/.info/connected。每当客户端的连接状态发生改变时，这个地址的数据都会被更新。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> connectedRef = wilddog.sync().ref(<span class=\"string\">\"/.info/connected\"</span>);</div><div class=\"line\"></div><div class=\"line\">connectedRef.on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (snap.val() === <span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    alert(<span class=\"string\">\"connected\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    alert(<span class=\"string\">\"not connected\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>/.info/connected的值是boolean类型的，它不会和云端进行同步。</p>\n<h2 id=\"离线事件\"><a href=\"#离线事件\" class=\"headerlink\" title=\"离线事件\"></a>离线事件</h2><p>如果你想在监听到客户端断线后自动触发一些事件。例如，当一个用户的网络连接中断时，希望标记这个用户为“离线”状态。Wilddog 提供的离线事件功能实现这一需求。</p>\n<p>离线事件能在云端检测到客户端连接断开时，将指定的数据写入云数据库中。不论是客户端主动断开，还是意外的网络中断，甚至是客户端应用崩溃，这些数据写入动作都将会被执行。因此我们可以依靠这个功能，在用户离线的时候，做一些数据清理工作。Wilddog 支持的所有数据写入动作，包括 set, update，remove，都可以设置在离线事件中执行。</p>\n<p>下面是一个例子，使用<code>onDisconnect()</code>方法，在离线的时候写入数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> presenceRef = wilddog.sync().ref(<span class=\"string\">\"disconnectmessage\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当客户端连接断开时，写入一个字符串</span></div><div class=\"line\">presenceRef.onDisconnect().set(<span class=\"string\">\"I disconnected!\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>离线事件是如何工作的</strong></p>\n<p>当进行了一个<code>onDisconnect()</code>调用之后，这个事件将会被记录在云端。云端会监控每一个客户端的连接。如果发生了超时，或者客户端主动断开连接，云端就触发记录的离线事件。</p>\n<p>客户端可以通过回调方法，确保离线事件被云端成功记录了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">presenceRef.onDisconnect().remove( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(<span class=\"string\">'could not establish onDisconnect event'</span>, err);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>要取消一个离线事件，可以使用<code>cancel()</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> onDisconnectRef = presenceRef.onDisconnect();</div><div class=\"line\">onDisconnectRef.set(<span class=\"string\">'I disconnected'</span>);</div><div class=\"line\"><span class=\"comment\">// 要取消离线事件</span></div><div class=\"line\">onDisconnectRef.cancel();</div></pre></td></tr></table></figure>\n<h2 id=\"云端时间戳\"><a href=\"#云端时间戳\" class=\"headerlink\" title=\"云端时间戳\"></a>云端时间戳</h2><p>Wilddog 提供了一种将<a href=\"/api/sync/web.html#TIMESTAMP\">云端时间戳</a>作为数据写入的机制。这个机制和<code>onDisconnect()</code>方法组合起来，很容易实现记录客户端断线时间的功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> userLastOnlineRef = wilddog.sync().ref(<span class=\"string\">\"/users/joe/lastOnline\"</span>);</div><div class=\"line\"></div><div class=\"line\">userLastOnlineRef.onDisconnect().set(wilddog.sync().ServerValue.TIMESTAMP);</div></pre></td></tr></table></figure>\n<p>另外，Wilddog 提供一种查看本地时间和服务器时间差的机制。本地时间和客户端时间差保存在 <code>/.info/serverTimeOffset</code> 中,你可以通过<code>on</code> 或者<code>once</code> 监听 <code>value</code> 事件来获取这个数据:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> serverTsRef = wilddog.sync().ref(<span class=\"string\">\"/.info/serverTimeOffset\"</span>);</div><div class=\"line\"></div><div class=\"line\">serverTsRef.on(<span class=\"string\">'value'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> offset = snapshot.val();</div><div class=\"line\">  serverTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>).getTime() + offset ; <span class=\"comment\">// 获取当前服务端时间</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果你只是想简单的获取服务器时间，可以用 REST API <a href=\"https://z.wilddog.com/rest/api#Server-Values0\">Server Values</a>。即向 <code>https://&lt;appId&gt;.wilddogio.com/.json?sv=timestamp</code> 发一个 <code>GET</code> 请求即可。</p>\n<h2 id=\"手动建立或断开连接\"><a href=\"#手动建立或断开连接\" class=\"headerlink\" title=\"手动建立或断开连接\"></a>手动建立或断开连接</h2><p>Wilddog 也提供了手动建立或者断开连接的方法。示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"samplechat.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://samplechat.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> connectedRef = wilddog.sync().ref(<span class=\"string\">\"/.info/connected\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听连接状态</span></div><div class=\"line\">connectedRef.on(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (snap.val() === <span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"connected\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I disconnected\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 断开连接</span></div><div class=\"line\">  wilddog.sync().goOffline(); </div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 重新建连</span></div><div class=\"line\">    wilddog.sync().goOnline();</div><div class=\"line\">  &#125;,<span class=\"number\">3000</span>);</div><div class=\"line\">&#125;,<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure>\n<p>另外，需要说明的是，一个客户端可以实例化多个 Wilddog 对象，但多个对象不会创建多个连接，会复用同一个长连接。 并且 <code>goOffline</code> 和 <code>goOnline</code> 会控制<code>全局</code>的在线和离线。 </p>\n<h2 id=\"离线功能的实现机制\"><a href=\"#离线功能的实现机制\" class=\"headerlink\" title=\"离线功能的实现机制\"></a>离线功能的实现机制</h2><p>Wilddog 云端会每隔 20s 发一个心跳包给客户端，用于检测与客户端的连接是否正常。如果一些异常情况，如程序崩溃、断电、手机没有信号等导致客户端断开连接，服务端无法立即感知到客户端断开，只能等到心跳超时后才确定客户端已经离线。此时才会执行一些操作，如执行离线事件（如果设置的有），重试连接等。<br>另外，重试连接连上之后，之前设置的监听仍然有效。</p>\n"},{"title":"读取和查询数据","_content":"本部分将介绍如何读取数据以及如何对数据进行排序和查询。\n需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。\n\n## 监听的事件类型\n\n使用 [on()](/api/sync/web.html#on) 方法添加一个监听事件。一共有以下几种事件类型：\n\n事件     | 描述\n-------- | ---\nvalue | 当程序初始化时或有任何数据发生变化时触发\nchild_added    | 当程序初始化时或有新增子节点时触发\nchild_changed     | 当某个子节点发生变化时触发\nchild_removed\t    | 当有子节点被删除时触发\nchild_moved     | 当有子节点排序发生变化时触发\n\n将 child_added、child_changed 和 child_removed 配合使用，即可监听到对子节点做出各种的更改。\n\n#### value 事件 \n\n使用 value 事件来读取当前节点下的所有数据的静态快照。\n此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。\n数据（包括子节点）的快照会以事件回调形式返回。\n\n**注意**：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。\n例如，如果不是必要，尽量不要在根路径设置 value 监听。\n\n下面的例子演示了获取[示例应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop)中 gracehop 的个人信息。\n\n```js\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/web/saving-data/wildblog/users/gracehop\");\n\nref.on('value', function(snapshot) {\n\tconsole.log(JSON.stringify(snapshot.val())); // 这里我们把数据转成 json 格式\n});\n// 控制台输出：\n// {\"date_of_birth\":\"December 9, 1906\",\"full_name\":\"Grace Hopper\",\"nickname\":\"Amazing Grace\"}\n```\n回调的数据快照 `snapshot` 对象会包含指定路径下的数据。使用 `.val()` 方法来获取 snapshot 中的数据。\n`snapshot` 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：\n\n方法     | 说明\n-------- | ---\nval() | 返回当前快照的数据\nforEach()    | 遍历快照中每一个子节点\nnumChildren()    | 返回当前节点中子节点的个数\nexists()     | 如果 snapshot 对象包含数据返回 true，否则返回false\nhasChild()     | 检查是否存在某个子节点\n\n更多更详细的用法说明参见 [API](/api/sync/web.html#DataSnapshot-Methods) 文档。\n\n#### child 事件\n当某个节点的子节点发生改变时（如通过 `push()` 方法添加子节点，或通过 `update()` 更新子节点），就会触发 `child 事件`。\n\n`child_added` 事件常用来获取当前路径下的子节点列表。初始化时会触发一次并获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。\n\n对子节点修改时会触发 `child_changed` 事件，这个修改包括对子节点里更深层的节点所做的修改。此时 `snapshot` 数据快照更新为有修改的子节点的当前快照。\n\n删除直接子节点时，将会触发 `child_removed` 事件。\n\n每当因更新（导致子节点重新排序）而触发 `child_changed` 事件时，系统就会触发 `child_moved` 事件。该事件用于通过 `orderByChild`、`orderByValue` 或 `orderByPriority` 中的任何一种进行排序的数据。\n\n\n灵活组合使用这些事件对于监听数据库中某个特定节点将会非常有用。 例如，在[博客应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts)中，我们可以这样监听博客的变化状态：\n\n```js\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar postsRef = wilddog.sync().ref(\"/web/saving-data/wildblog/posts\");\n\npostsRef.on('child_added', function(data) {\n  console.log(data.val().author + \" 发布了一篇名为《\" + data.val().title + \"》的博客\");\n});\n\npostsRef.on('child_changed', function(data) {\n  console.log(data.val().author + \" 更新博客标题为《\" + data.val().title + \"》\");\n});\n\npostsRef.on('child_removed', function(data) {\n  console.log( \"博客《\" + data.val().title + \"》被删除\");\n});\n```\n\n## 移除监听\n\n通过`off()`方法可以移除一个监听事件，参数为你具体要移除的事件回调：\n\n```js\nref.off(\"value\", originalCallback);\n```\n如果在不带任何参数的情况下在该节点位置调用 `off()`，则将移除该节点位置的所有监听。\n\n在父节点上调用 `off()` 时不会自动删除在其子节点上注册的监听。\n\n## 监听事件的保证\n\n野狗数据实时同步的事件监听有以下几个重要的保证：\n\n监听事件的保证 |\n---- |\n本地数据状态发生了改变，事件就会触发。 |\n事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。 |\n写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。 |\nValue 事件总是最后触发，并且能保证包含快照（`snapshot`）生成之前的所有改变。 |\n\n\n## 一次性读取数据\n\n在某些场景下，也许需要事件的回调方法只被触发一次，然后立即取消。可以使用`once()`方法：\n```js\nref.once(\"value\", function(data) {\n  // 执行业务处理，此回调方法只会被调用一次\n})\n```\n\n## 排序和查询数据\n\n你可以使用 [Query](/api/sync/web.html#Query-Methods) 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。\n只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。\n\n**注意**：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 [.indexOn](/api/sync/rule.html#indexOn) 规则，以便在服务器上添加索引以提高查询性能。详细操作参见[添加索引](/guide/sync/rules/guide.html#数据索引)。\n\n#### 数据排序\n\n对数据排序前，要先指定按照`键`、`值`、`子节点的值`或按`优先级`这四种的哪一种排序。对应的方法如下：\n\n方法 | 用法\n----  | ----\norderByChild() | 按指定子节点的值对结果排序。\norderByKey() | 按键对结果排序。\norderByValue() | 按值对结果排序。\norderByPriority() | 按优先级对结果排序。\n\n**注意**：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。\n\n下面这个示例演示了在[恐龙示例面板应用](https://dinosaur-facts.wilddogio.com)中如何按照恐龙的身高进行排序。\n```js\nvar config = {\n  authDomain: \"dinosaur-facts.wilddog.com\",\n  syncURL: \"https://dinosaur-facts.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"dinosaurs\");\n  \nref.orderByChild(\"height\").on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key() + \" was \" + snapshot.val().height + \" meters tall\");\n});\n```\n调用 `orderByChild()` 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 \"height\"，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见[排序规则](#排序规则)。\n\n\n#### 查询数据\n\n只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。\n\n方法 | 用法\n---- | ----\nlimitToFirst() | 设置从第一条开始，一共返回多少条数据（节点）。\nlimitToLast() | 设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。\nstartAt() | 返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nendAt() | 返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nequalTo() | 返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。\n\n与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 `startAt()` 与 `endAt()` 方法将结果限制在指定的范围内。\n\n**限制结果数**\n\n你可以使用 `limitToFirst()` 和 `limitToLast()` 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 `limitToFirst(100)` 将限制个数设置为 100，那么一开始最多只能收到 100 个 `child_added` 事件，即只返回前100条数据的快照。\n当数据发生更改时，对于进入到前100的数据，你会接收到 `child_added` 事件，对于从前100中消失的数据，你才会接收到 `child_removed` 事件，也就是说只有这100条里的数据变化才会触发事件。\n\n继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：\n\n```js\nref.orderByChild(\"height\").limitToLast(3).on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key() + \" was \" + snapshot.val().height + \" meters tall\");\n});\n```\n或者你只关心哪些[恐龙](https://dinosaur-facts.wilddogio.com/scores)的得分超过60了：\n\n```js\nvar config = {\n  authDomain: \"dinosaur-facts.wilddog.com\",\n  syncURL: \"https://dinosaur-facts.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"scores\");\n  \nref.orderByValue().startAt(60).on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key() + \" is \" + snapshot.val());\n});\n```\n如上例所示，使用 `startAt()`、`endAt()` 和 `equalTo()` 为查询选择任意起点、终点或等量点。这可以用于`数据分页`和`精确查询`。\n关于分页的具体实现，可参考[如何实现分页](https://coding.net/u/wilddog/p/wilddog-gist-js/git/tree/master/src/pagination)。\n\n#### 排序规则\n\n本小节介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**orderByChild**\n\n当使用`orderByChild(key)`时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用`\norderByChild(key)`获取全量数据，例如，\n```json\n   {\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    }, \n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }, \n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    }, \n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    }, \n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n```\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`number`类型，此时使用`orderByChild(key)`获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 `orderByChild('score').startAt(60).limitToFirst(4)` 将得到下面的结果：\n```json\n  {\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }\n  }\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用 `orderByChild(key)`将搜索不到该数据。</em></p>\n\n\n\n**orderByKey**\n\n当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。\n\n**orderByValue**\n\n当使用`orderByValue()`时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用`orderByValue()`获取全量数据，例如，\n```json\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n```\n霸王龙的分数是 `string`类型，雷龙的分数是 `boolean` 类型，而其他恐龙的分数是 `numberic` 类型，此时使用 `orderByValue()` 获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的value值为null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用```orderByValue().startAt(60).limitToFirst(4)```将得到下面的结果：\n```json\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用`orderByValue()`将搜索不到该数据。</em></p>\n\n**orderByPriority**\n当使用`orderByPriority()`对数据进行排序时，子节点数据将按照优先级和字段名进行排序。\n**注意**：优先级的值只能是数值型或字符串。\n优先级的设置可参考 [setPriority()](/api/sync/web.html#setPriority)\n\n- １. 没有设置优先级的数据优先。\n\n- ２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。\n\n- ３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。\n\n- ４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。\n\n\n\n","source":"guide/sync/web/retrieve-data.md","raw":"title:  读取和查询数据\n---\n本部分将介绍如何读取数据以及如何对数据进行排序和查询。\n需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。\n\n## 监听的事件类型\n\n使用 [on()](/api/sync/web.html#on) 方法添加一个监听事件。一共有以下几种事件类型：\n\n事件     | 描述\n-------- | ---\nvalue | 当程序初始化时或有任何数据发生变化时触发\nchild_added    | 当程序初始化时或有新增子节点时触发\nchild_changed     | 当某个子节点发生变化时触发\nchild_removed\t    | 当有子节点被删除时触发\nchild_moved     | 当有子节点排序发生变化时触发\n\n将 child_added、child_changed 和 child_removed 配合使用，即可监听到对子节点做出各种的更改。\n\n#### value 事件 \n\n使用 value 事件来读取当前节点下的所有数据的静态快照。\n此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。\n数据（包括子节点）的快照会以事件回调形式返回。\n\n**注意**：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。\n例如，如果不是必要，尽量不要在根路径设置 value 监听。\n\n下面的例子演示了获取[示例应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop)中 gracehop 的个人信息。\n\n```js\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/web/saving-data/wildblog/users/gracehop\");\n\nref.on('value', function(snapshot) {\n\tconsole.log(JSON.stringify(snapshot.val())); // 这里我们把数据转成 json 格式\n});\n// 控制台输出：\n// {\"date_of_birth\":\"December 9, 1906\",\"full_name\":\"Grace Hopper\",\"nickname\":\"Amazing Grace\"}\n```\n回调的数据快照 `snapshot` 对象会包含指定路径下的数据。使用 `.val()` 方法来获取 snapshot 中的数据。\n`snapshot` 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：\n\n方法     | 说明\n-------- | ---\nval() | 返回当前快照的数据\nforEach()    | 遍历快照中每一个子节点\nnumChildren()    | 返回当前节点中子节点的个数\nexists()     | 如果 snapshot 对象包含数据返回 true，否则返回false\nhasChild()     | 检查是否存在某个子节点\n\n更多更详细的用法说明参见 [API](/api/sync/web.html#DataSnapshot-Methods) 文档。\n\n#### child 事件\n当某个节点的子节点发生改变时（如通过 `push()` 方法添加子节点，或通过 `update()` 更新子节点），就会触发 `child 事件`。\n\n`child_added` 事件常用来获取当前路径下的子节点列表。初始化时会触发一次并获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。\n\n对子节点修改时会触发 `child_changed` 事件，这个修改包括对子节点里更深层的节点所做的修改。此时 `snapshot` 数据快照更新为有修改的子节点的当前快照。\n\n删除直接子节点时，将会触发 `child_removed` 事件。\n\n每当因更新（导致子节点重新排序）而触发 `child_changed` 事件时，系统就会触发 `child_moved` 事件。该事件用于通过 `orderByChild`、`orderByValue` 或 `orderByPriority` 中的任何一种进行排序的数据。\n\n\n灵活组合使用这些事件对于监听数据库中某个特定节点将会非常有用。 例如，在[博客应用](https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts)中，我们可以这样监听博客的变化状态：\n\n```js\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar postsRef = wilddog.sync().ref(\"/web/saving-data/wildblog/posts\");\n\npostsRef.on('child_added', function(data) {\n  console.log(data.val().author + \" 发布了一篇名为《\" + data.val().title + \"》的博客\");\n});\n\npostsRef.on('child_changed', function(data) {\n  console.log(data.val().author + \" 更新博客标题为《\" + data.val().title + \"》\");\n});\n\npostsRef.on('child_removed', function(data) {\n  console.log( \"博客《\" + data.val().title + \"》被删除\");\n});\n```\n\n## 移除监听\n\n通过`off()`方法可以移除一个监听事件，参数为你具体要移除的事件回调：\n\n```js\nref.off(\"value\", originalCallback);\n```\n如果在不带任何参数的情况下在该节点位置调用 `off()`，则将移除该节点位置的所有监听。\n\n在父节点上调用 `off()` 时不会自动删除在其子节点上注册的监听。\n\n## 监听事件的保证\n\n野狗数据实时同步的事件监听有以下几个重要的保证：\n\n监听事件的保证 |\n---- |\n本地数据状态发生了改变，事件就会触发。 |\n事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。 |\n写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。 |\nValue 事件总是最后触发，并且能保证包含快照（`snapshot`）生成之前的所有改变。 |\n\n\n## 一次性读取数据\n\n在某些场景下，也许需要事件的回调方法只被触发一次，然后立即取消。可以使用`once()`方法：\n```js\nref.once(\"value\", function(data) {\n  // 执行业务处理，此回调方法只会被调用一次\n})\n```\n\n## 排序和查询数据\n\n你可以使用 [Query](/api/sync/web.html#Query-Methods) 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。\n只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。\n\n**注意**：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 [.indexOn](/api/sync/rule.html#indexOn) 规则，以便在服务器上添加索引以提高查询性能。详细操作参见[添加索引](/guide/sync/rules/guide.html#数据索引)。\n\n#### 数据排序\n\n对数据排序前，要先指定按照`键`、`值`、`子节点的值`或按`优先级`这四种的哪一种排序。对应的方法如下：\n\n方法 | 用法\n----  | ----\norderByChild() | 按指定子节点的值对结果排序。\norderByKey() | 按键对结果排序。\norderByValue() | 按值对结果排序。\norderByPriority() | 按优先级对结果排序。\n\n**注意**：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。\n\n下面这个示例演示了在[恐龙示例面板应用](https://dinosaur-facts.wilddogio.com)中如何按照恐龙的身高进行排序。\n```js\nvar config = {\n  authDomain: \"dinosaur-facts.wilddog.com\",\n  syncURL: \"https://dinosaur-facts.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"dinosaurs\");\n  \nref.orderByChild(\"height\").on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key() + \" was \" + snapshot.val().height + \" meters tall\");\n});\n```\n调用 `orderByChild()` 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 \"height\"，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见[排序规则](#排序规则)。\n\n\n#### 查询数据\n\n只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。\n\n方法 | 用法\n---- | ----\nlimitToFirst() | 设置从第一条开始，一共返回多少条数据（节点）。\nlimitToLast() | 设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。\nstartAt() | 返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nendAt() | 返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。\nequalTo() | 返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。\n\n与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 `startAt()` 与 `endAt()` 方法将结果限制在指定的范围内。\n\n**限制结果数**\n\n你可以使用 `limitToFirst()` 和 `limitToLast()` 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 `limitToFirst(100)` 将限制个数设置为 100，那么一开始最多只能收到 100 个 `child_added` 事件，即只返回前100条数据的快照。\n当数据发生更改时，对于进入到前100的数据，你会接收到 `child_added` 事件，对于从前100中消失的数据，你才会接收到 `child_removed` 事件，也就是说只有这100条里的数据变化才会触发事件。\n\n继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：\n\n```js\nref.orderByChild(\"height\").limitToLast(3).on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key() + \" was \" + snapshot.val().height + \" meters tall\");\n});\n```\n或者你只关心哪些[恐龙](https://dinosaur-facts.wilddogio.com/scores)的得分超过60了：\n\n```js\nvar config = {\n  authDomain: \"dinosaur-facts.wilddog.com\",\n  syncURL: \"https://dinosaur-facts.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"scores\");\n  \nref.orderByValue().startAt(60).on(\"child_added\", function(snapshot) {\n  console.log(snapshot.key() + \" is \" + snapshot.val());\n});\n```\n如上例所示，使用 `startAt()`、`endAt()` 和 `equalTo()` 为查询选择任意起点、终点或等量点。这可以用于`数据分页`和`精确查询`。\n关于分页的具体实现，可参考[如何实现分页](https://coding.net/u/wilddog/p/wilddog-gist-js/git/tree/master/src/pagination)。\n\n#### 排序规则\n\n本小节介绍在使用各种排序方式时，数据究竟是如何排序的。\n\n**orderByChild**\n\n当使用`orderByChild(key)`时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用`\norderByChild(key)`获取全量数据，例如，\n```json\n   {\n  \"scores\": {\n    \"no1\" : {\n        \"name\" : \"tyrannosaurus\",\n        \"score\" : \"120\"\n    },\n    \"no2\" : {\n        \"name\" : \"bruhathkayosaurus\",\n        \"score\" : 55\n    },\n    \"no3\" : {\n        \"name\" : \"lambeosaurus\",\n        \"score\" : 21\n    },\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    }, \n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }, \n    \"no6\" : {\n        \"name\" : \"stegosaurus\",\n        \"score\" : 5\n    }, \n    \"no7\" : {\n        \"name\" : \"triceratops\",\n        \"score\" : 22\n    }, \n    \"no8\" : {\n        \"name\" : \"brontosaurus\",\n        \"score\" : true\n    }\n  }\n}\n```\n霸王龙的分数是`string`类型，雷龙的分数是`boolean`类型，而其他恐龙的分数是`number`类型，此时使用`orderByChild(key)`获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的 value 值为 null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 `orderByChild('score').startAt(60).limitToFirst(4)` 将得到下面的结果：\n```json\n  {\n    \"no4\" : {\n        \"name\" : \"linhenykus\",\n        \"score\" : 80\n    },\n    \"no5\" : {\n        \"name\" : \"pterodactyl\",\n        \"score\" : 93\n    }\n  }\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用 `orderByChild(key)`将搜索不到该数据。</em></p>\n\n\n\n**orderByKey**\n\n当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。\n\n**orderByValue**\n\n当使用`orderByValue()`时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用`orderByValue()`获取全量数据，例如，\n```json\n{\n  \"scores\": {\n    \"tyrannosaurus\" : \"120\",\n    \"bruhathkayosaurus\" : 55,\n    \"lambeosaurus\" : 21,\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93,\n    \"stegosaurus\" : 5,\n    \"triceratops\" : 22,\n    \"brontosaurus\" : true\n  }\n}\n```\n霸王龙的分数是 `string`类型，雷龙的分数是 `boolean` 类型，而其他恐龙的分数是 `numberic` 类型，此时使用 `orderByValue()` 获得全量数据时，是一个看似固定的排序结果；但是配合使用`limitToFirst()`时，将获得不确定的结果。`Object`类型数据的value值为null，不会出现在结果中。\n当配合使用`startAt()`、`endAt()`和`equalTo()`时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用```orderByValue().startAt(60).limitToFirst(4)```将得到下面的结果：\n```json\n{\n    \"linhenykus\" : 80,\n    \"pterodactyl\" : 93\n}\n```\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用`orderByValue()`将搜索不到该数据。</em></p>\n\n**orderByPriority**\n当使用`orderByPriority()`对数据进行排序时，子节点数据将按照优先级和字段名进行排序。\n**注意**：优先级的值只能是数值型或字符串。\n优先级的设置可参考 [setPriority()](/api/sync/web.html#setPriority)\n\n- １. 没有设置优先级的数据优先。\n\n- ２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。\n\n- ３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。\n\n- ４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。\n\n\n\n","date":"2016-09-06T03:38:22.546Z","updated":"2016-09-06T03:38:22.546Z","path":"guide/sync/web/retrieve-data.html","comments":1,"layout":"page","_id":"cisswi9lw0022z4fwykgy5kkz","content":"<p>本部分将介绍如何读取数据以及如何对数据进行排序和查询。<br>需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。</p>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>使用 <a href=\"/api/sync/web.html#on\">on()</a> 方法添加一个监听事件。一共有以下几种事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>当程序初始化时或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>child_added</td>\n<td>当程序初始化时或有新增子节点时触发</td>\n</tr>\n<tr>\n<td>child_changed</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>child_removed</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>child_moved</td>\n<td>当有子节点排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n<p>将 child_added、child_changed 和 child_removed 配合使用，即可监听到对子节点做出各种的更改。</p>\n<h4 id=\"value-事件\"><a href=\"#value-事件\" class=\"headerlink\" title=\"value 事件\"></a>value 事件</h4><p>使用 value 事件来读取当前节点下的所有数据的静态快照。<br>此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。<br>数据（包括子节点）的快照会以事件回调形式返回。</p>\n<p><strong>注意</strong>：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。<br>例如，如果不是必要，尽量不要在根路径设置 value 监听。</p>\n<p>下面的例子演示了获取<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\" target=\"_blank\" rel=\"external\">示例应用</a>中 gracehop 的个人信息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/web/saving-data/wildblog/users/gracehop\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(snapshot.val())); <span class=\"comment\">// 这里我们把数据转成 json 格式</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// 控制台输出：</span></div><div class=\"line\"><span class=\"comment\">// &#123;\"date_of_birth\":\"December 9, 1906\",\"full_name\":\"Grace Hopper\",\"nickname\":\"Amazing Grace\"&#125;</span></div></pre></td></tr></table></figure>\n<p>回调的数据快照 <code>snapshot</code> 对象会包含指定路径下的数据。使用 <code>.val()</code> 方法来获取 snapshot 中的数据。<br><code>snapshot</code> 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val()</td>\n<td>返回当前快照的数据</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>遍历快照中每一个子节点</td>\n</tr>\n<tr>\n<td>numChildren()</td>\n<td>返回当前节点中子节点的个数</td>\n</tr>\n<tr>\n<td>exists()</td>\n<td>如果 snapshot 对象包含数据返回 true，否则返回false</td>\n</tr>\n<tr>\n<td>hasChild()</td>\n<td>检查是否存在某个子节点</td>\n</tr>\n</tbody>\n</table>\n<p>更多更详细的用法说明参见 <a href=\"/api/sync/web.html#DataSnapshot-Methods\">API</a> 文档。</p>\n<h4 id=\"child-事件\"><a href=\"#child-事件\" class=\"headerlink\" title=\"child 事件\"></a>child 事件</h4><p>当某个节点的子节点发生改变时（如通过 <code>push()</code> 方法添加子节点，或通过 <code>update()</code> 更新子节点），就会触发 <code>child 事件</code>。</p>\n<p><code>child_added</code> 事件常用来获取当前路径下的子节点列表。初始化时会触发一次并获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。</p>\n<p>对子节点修改时会触发 <code>child_changed</code> 事件，这个修改包括对子节点里更深层的节点所做的修改。此时 <code>snapshot</code> 数据快照更新为有修改的子节点的当前快照。</p>\n<p>删除直接子节点时，将会触发 <code>child_removed</code> 事件。</p>\n<p>每当因更新（导致子节点重新排序）而触发 <code>child_changed</code> 事件时，系统就会触发 <code>child_moved</code> 事件。该事件用于通过 <code>orderByChild</code>、<code>orderByValue</code> 或 <code>orderByPriority</code> 中的任何一种进行排序的数据。</p>\n<p>灵活组合使用这些事件对于监听数据库中某个特定节点将会非常有用。 例如，在<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\" target=\"_blank\" rel=\"external\">博客应用</a>中，我们可以这样监听博客的变化状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> postsRef = wilddog.sync().ref(<span class=\"string\">\"/web/saving-data/wildblog/posts\"</span>);</div><div class=\"line\"></div><div class=\"line\">postsRef.on(<span class=\"string\">'child_added'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data.val().author + <span class=\"string\">\" 发布了一篇名为《\"</span> + data.val().title + <span class=\"string\">\"》的博客\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">postsRef.on(<span class=\"string\">'child_changed'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data.val().author + <span class=\"string\">\" 更新博客标题为《\"</span> + data.val().title + <span class=\"string\">\"》\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">postsRef.on(<span class=\"string\">'child_removed'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"博客《\"</span> + data.val().title + <span class=\"string\">\"》被删除\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"移除监听\"><a href=\"#移除监听\" class=\"headerlink\" title=\"移除监听\"></a>移除监听</h2><p>通过<code>off()</code>方法可以移除一个监听事件，参数为你具体要移除的事件回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.off(<span class=\"string\">\"value\"</span>, originalCallback);</div></pre></td></tr></table></figure>\n<p>如果在不带任何参数的情况下在该节点位置调用 <code>off()</code>，则将移除该节点位置的所有监听。</p>\n<p>在父节点上调用 <code>off()</code> 时不会自动删除在其子节点上注册的监听。</p>\n<h2 id=\"监听事件的保证\"><a href=\"#监听事件的保证\" class=\"headerlink\" title=\"监听事件的保证\"></a>监听事件的保证</h2><p>野狗数据实时同步的事件监听有以下几个重要的保证：</p>\n<table>\n<thead>\n<tr>\n<th>监听事件的保证</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地数据状态发生了改变，事件就会触发。</td>\n<td></td>\n</tr>\n<tr>\n<td>事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。</td>\n<td></td>\n</tr>\n<tr>\n<td>写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。</td>\n<td></td>\n</tr>\n<tr>\n<td>Value 事件总是最后触发，并且能保证包含快照（<code>snapshot</code>）生成之前的所有改变。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一次性读取数据\"><a href=\"#一次性读取数据\" class=\"headerlink\" title=\"一次性读取数据\"></a>一次性读取数据</h2><p>在某些场景下，也许需要事件的回调方法只被触发一次，然后立即取消。可以使用<code>once()</code>方法：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 执行业务处理，此回调方法只会被调用一次</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"排序和查询数据\"><a href=\"#排序和查询数据\" class=\"headerlink\" title=\"排序和查询数据\"></a>排序和查询数据</h2><p>你可以使用 <a href=\"/api/sync/web.html#Query-Methods\">Query</a> 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。<br>只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。</p>\n<p><strong>注意</strong>：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 规则，以便在服务器上添加索引以提高查询性能。详细操作参见<a href=\"/guide/sync/rules/guide.html#数据索引\">添加索引</a>。</p>\n<h4 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>对数据排序前，要先指定按照<code>键</code>、<code>值</code>、<code>子节点的值</code>或按<code>优先级</code>这四种的哪一种排序。对应的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>orderByChild()</td>\n<td>按指定子节点的值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByKey()</td>\n<td>按键对结果排序。</td>\n</tr>\n<tr>\n<td>orderByValue()</td>\n<td>按值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByPriority()</td>\n<td>按优先级对结果排序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。</p>\n<p>下面这个示例演示了在<a href=\"https://dinosaur-facts.wilddogio.com\" target=\"_blank\" rel=\"external\">恐龙示例面板应用</a>中如何按照恐龙的身高进行排序。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"dinosaur-facts.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://dinosaur-facts.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"dinosaurs\"</span>);</div><div class=\"line\">  </div><div class=\"line\">ref.orderByChild(<span class=\"string\">\"height\"</span>).on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\" was \"</span> + snapshot.val().height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用 <code>orderByChild()</code> 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 “height”，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见<a href=\"#排序规则\">排序规则</a>。</p>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>limitToFirst()</td>\n<td>设置从第一条开始，一共返回多少条数据（节点）。</td>\n</tr>\n<tr>\n<td>limitToLast()</td>\n<td>设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。</td>\n</tr>\n<tr>\n<td>startAt()</td>\n<td>返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>endAt()</td>\n<td>返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>equalTo()</td>\n<td>返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。</td>\n</tr>\n</tbody>\n</table>\n<p>与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 <code>startAt()</code> 与 <code>endAt()</code> 方法将结果限制在指定的范围内。</p>\n<p><strong>限制结果数</strong></p>\n<p>你可以使用 <code>limitToFirst()</code> 和 <code>limitToLast()</code> 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 <code>limitToFirst(100)</code> 将限制个数设置为 100，那么一开始最多只能收到 100 个 <code>child_added</code> 事件，即只返回前100条数据的快照。<br>当数据发生更改时，对于进入到前100的数据，你会接收到 <code>child_added</code> 事件，对于从前100中消失的数据，你才会接收到 <code>child_removed</code> 事件，也就是说只有这100条里的数据变化才会触发事件。</p>\n<p>继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.orderByChild(<span class=\"string\">\"height\"</span>).limitToLast(<span class=\"number\">3</span>).on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\" was \"</span> + snapshot.val().height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>或者你只关心哪些<a href=\"https://dinosaur-facts.wilddogio.com/scores\" target=\"_blank\" rel=\"external\">恐龙</a>的得分超过60了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"dinosaur-facts.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://dinosaur-facts.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"scores\"</span>);</div><div class=\"line\">  </div><div class=\"line\">ref.orderByValue().startAt(<span class=\"number\">60</span>).on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\" is \"</span> + snapshot.val());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如上例所示，使用 <code>startAt()</code>、<code>endAt()</code> 和 <code>equalTo()</code> 为查询选择任意起点、终点或等量点。这可以用于<code>数据分页</code>和<code>精确查询</code>。<br>关于分页的具体实现，可参考<a href=\"https://coding.net/u/wilddog/p/wilddog-gist-js/git/tree/master/src/pagination\" target=\"_blank\" rel=\"external\">如何实现分页</a>。</p>\n<h4 id=\"排序规则\"><a href=\"#排序规则\" class=\"headerlink\" title=\"排序规则\"></a>排序规则</h4><p>本小节介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>orderByChild</strong></p>\n<p>当使用<code>orderByChild(key)</code>时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用<code>orderByChild(key)</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">   &#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"no1\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"tyrannosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"string\">\"120\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no2\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"bruhathkayosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">55</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no3\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"lambeosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">21</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no6\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"stegosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">5</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no7\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"triceratops\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">22</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no8\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"brontosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>number</code>类型，此时使用<code>orderByChild(key)</code>获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 <code>orderByChild(&#39;score&#39;).startAt(60).limitToFirst(4)</code> 将得到下面的结果：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style=\"color:red\"><em>注意：如果path与value的总长度超过1000字节时，使用 <code>orderByChild(key)</code>将搜索不到该数据。</em></p>\n\n\n\n<p><strong>orderByKey</strong></p>\n<p>当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。</p>\n<p><strong>orderByValue</strong></p>\n<p>当使用<code>orderByValue()</code>时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用<code>orderByValue()</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"tyrannosaurus\"</span> : <span class=\"string\">\"120\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"attr\">\"brontosaurus\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是 <code>string</code>类型，雷龙的分数是 <code>boolean</code> 类型，而其他恐龙的分数是 <code>numberic</code> 类型，此时使用 <code>orderByValue()</code> 获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的value值为null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">```json</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style=\"color:red\"><em>注意：如果path与value的总长度超过1000字节时，使用<code>orderByValue()</code>将搜索不到该数据。</em></p>\n\n<p><strong>orderByPriority</strong><br>当使用<code>orderByPriority()</code>对数据进行排序时，子节点数据将按照优先级和字段名进行排序。<br><strong>注意</strong>：优先级的值只能是数值型或字符串。<br>优先级的设置可参考 <a href=\"/api/sync/web.html#setPriority\">setPriority()</a></p>\n<ul>\n<li><p>１. 没有设置优先级的数据优先。</p>\n</li>\n<li><p>２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。</p>\n</li>\n<li><p>３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。</p>\n</li>\n<li><p>４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>本部分将介绍如何读取数据以及如何对数据进行排序和查询。<br>需要先提到的一点是，Wilddog SDK 的数据读取都是建立在添加监听的基础上，然后在监听的回调函数中完成对数据的读取。</p>\n<h2 id=\"监听的事件类型\"><a href=\"#监听的事件类型\" class=\"headerlink\" title=\"监听的事件类型\"></a>监听的事件类型</h2><p>使用 <a href=\"/api/sync/web.html#on\">on()</a> 方法添加一个监听事件。一共有以下几种事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>当程序初始化时或有任何数据发生变化时触发</td>\n</tr>\n<tr>\n<td>child_added</td>\n<td>当程序初始化时或有新增子节点时触发</td>\n</tr>\n<tr>\n<td>child_changed</td>\n<td>当某个子节点发生变化时触发</td>\n</tr>\n<tr>\n<td>child_removed</td>\n<td>当有子节点被删除时触发</td>\n</tr>\n<tr>\n<td>child_moved</td>\n<td>当有子节点排序发生变化时触发</td>\n</tr>\n</tbody>\n</table>\n<p>将 child_added、child_changed 和 child_removed 配合使用，即可监听到对子节点做出各种的更改。</p>\n<h4 id=\"value-事件\"><a href=\"#value-事件\" class=\"headerlink\" title=\"value 事件\"></a>value 事件</h4><p>使用 value 事件来读取当前节点下的所有数据的静态快照。<br>此方法在初始化时会触发一次，此后每当有数据变化都会被再次触发。初始化时，如果没有任何数据，则会返回 null。<br>数据（包括子节点）的快照会以事件回调形式返回。</p>\n<p><strong>注意</strong>：每当指定路径下的数据（包括更深层节点数据）有改变时，都会触发 value 事件。所以，为了聚焦你只关心的数据并降低快照的大小，你应该把要监听的节点路径设置的更加精确。<br>例如，如果不是必要，尽量不要在根路径设置 value 监听。</p>\n<p>下面的例子演示了获取<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/users/gracehop\">示例应用</a>中 gracehop 的个人信息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/web/saving-data/wildblog/users/gracehop\"</span>);</div><div class=\"line\"></div><div class=\"line\">ref.on(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(snapshot.val())); <span class=\"comment\">// 这里我们把数据转成 json 格式</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// 控制台输出：</span></div><div class=\"line\"><span class=\"comment\">// &#123;\"date_of_birth\":\"December 9, 1906\",\"full_name\":\"Grace Hopper\",\"nickname\":\"Amazing Grace\"&#125;</span></div></pre></td></tr></table></figure>\n<p>回调的数据快照 <code>snapshot</code> 对象会包含指定路径下的数据。使用 <code>.val()</code> 方法来获取 snapshot 中的数据。<br><code>snapshot</code> 里封装了一些常用的方法，帮助你更方便的处理数据，常用的列举如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val()</td>\n<td>返回当前快照的数据</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>遍历快照中每一个子节点</td>\n</tr>\n<tr>\n<td>numChildren()</td>\n<td>返回当前节点中子节点的个数</td>\n</tr>\n<tr>\n<td>exists()</td>\n<td>如果 snapshot 对象包含数据返回 true，否则返回false</td>\n</tr>\n<tr>\n<td>hasChild()</td>\n<td>检查是否存在某个子节点</td>\n</tr>\n</tbody>\n</table>\n<p>更多更详细的用法说明参见 <a href=\"/api/sync/web.html#DataSnapshot-Methods\">API</a> 文档。</p>\n<h4 id=\"child-事件\"><a href=\"#child-事件\" class=\"headerlink\" title=\"child 事件\"></a>child 事件</h4><p>当某个节点的子节点发生改变时（如通过 <code>push()</code> 方法添加子节点，或通过 <code>update()</code> 更新子节点），就会触发 <code>child 事件</code>。</p>\n<p><code>child_added</code> 事件常用来获取当前路径下的子节点列表。初始化时会触发一次并获取所有子节点，之后每当增加子节点时就会再次触发获取新增的子节点。</p>\n<p>对子节点修改时会触发 <code>child_changed</code> 事件，这个修改包括对子节点里更深层的节点所做的修改。此时 <code>snapshot</code> 数据快照更新为有修改的子节点的当前快照。</p>\n<p>删除直接子节点时，将会触发 <code>child_removed</code> 事件。</p>\n<p>每当因更新（导致子节点重新排序）而触发 <code>child_changed</code> 事件时，系统就会触发 <code>child_moved</code> 事件。该事件用于通过 <code>orderByChild</code>、<code>orderByValue</code> 或 <code>orderByPriority</code> 中的任何一种进行排序的数据。</p>\n<p>灵活组合使用这些事件对于监听数据库中某个特定节点将会非常有用。 例如，在<a href=\"https://docs-examples.wilddogio.com/web/saving-data/wildblog/posts\">博客应用</a>中，我们可以这样监听博客的变化状态：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> postsRef = wilddog.sync().ref(<span class=\"string\">\"/web/saving-data/wildblog/posts\"</span>);</div><div class=\"line\"></div><div class=\"line\">postsRef.on(<span class=\"string\">'child_added'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data.val().author + <span class=\"string\">\" 发布了一篇名为《\"</span> + data.val().title + <span class=\"string\">\"》的博客\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">postsRef.on(<span class=\"string\">'child_changed'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data.val().author + <span class=\"string\">\" 更新博客标题为《\"</span> + data.val().title + <span class=\"string\">\"》\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">postsRef.on(<span class=\"string\">'child_removed'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"博客《\"</span> + data.val().title + <span class=\"string\">\"》被删除\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"移除监听\"><a href=\"#移除监听\" class=\"headerlink\" title=\"移除监听\"></a>移除监听</h2><p>通过<code>off()</code>方法可以移除一个监听事件，参数为你具体要移除的事件回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.off(<span class=\"string\">\"value\"</span>, originalCallback);</div></pre></td></tr></table></figure>\n<p>如果在不带任何参数的情况下在该节点位置调用 <code>off()</code>，则将移除该节点位置的所有监听。</p>\n<p>在父节点上调用 <code>off()</code> 时不会自动删除在其子节点上注册的监听。</p>\n<h2 id=\"监听事件的保证\"><a href=\"#监听事件的保证\" class=\"headerlink\" title=\"监听事件的保证\"></a>监听事件的保证</h2><p>野狗数据实时同步的事件监听有以下几个重要的保证：</p>\n<table>\n<thead>\n<tr>\n<th>监听事件的保证</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>本地数据状态发生了改变，事件就会触发。</td>\n<td></td>\n</tr>\n<tr>\n<td>事件始终会保证数据的最终一致性和正确性，可能由于本地操作、断线等问题造成临时不一致，但最终数据会保持一致。</td>\n<td></td>\n</tr>\n<tr>\n<td>写到一个客户端的数据总会写到服务端并且按照顺序广播到其他端。</td>\n<td></td>\n</tr>\n<tr>\n<td>Value 事件总是最后触发，并且能保证包含快照（<code>snapshot</code>）生成之前的所有改变。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"一次性读取数据\"><a href=\"#一次性读取数据\" class=\"headerlink\" title=\"一次性读取数据\"></a>一次性读取数据</h2><p>在某些场景下，也许需要事件的回调方法只被触发一次，然后立即取消。可以使用<code>once()</code>方法：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.once(<span class=\"string\">\"value\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 执行业务处理，此回调方法只会被调用一次</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"排序和查询数据\"><a href=\"#排序和查询数据\" class=\"headerlink\" title=\"排序和查询数据\"></a>排序和查询数据</h2><p>你可以使用 <a href=\"/api/sync/web.html#Query-Methods\">Query</a> 类 API 进行数据排序。Wilddog 支持按键、按值、按子节点的值或按优先级对数据进行排序。<br>只有在对数据排序之后，你才可以进行具体的查询操作，从而获取你想要的特定数据。</p>\n<p><strong>注意</strong>：排序和过滤的开销可能会很大，在客户端执行这些操作时尤其如此。 如果你的应用使用了查询，请定义 <a href=\"/api/sync/rule.html#indexOn\">.indexOn</a> 规则，以便在服务器上添加索引以提高查询性能。详细操作参见<a href=\"/guide/sync/rules/guide.html#数据索引\">添加索引</a>。</p>\n<h4 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h4><p>对数据排序前，要先指定按照<code>键</code>、<code>值</code>、<code>子节点的值</code>或按<code>优先级</code>这四种的哪一种排序。对应的方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>orderByChild()</td>\n<td>按指定子节点的值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByKey()</td>\n<td>按键对结果排序。</td>\n</tr>\n<tr>\n<td>orderByValue()</td>\n<td>按值对结果排序。</td>\n</tr>\n<tr>\n<td>orderByPriority()</td>\n<td>按优先级对结果排序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：每次只能使用一种排序方法。对同一查询调用多个排序方法会引发错误。作为一种变通的方法，你可以先按一种方式查询，然后自行在结果集中进行第二次查询。</p>\n<p>下面这个示例演示了在<a href=\"https://dinosaur-facts.wilddogio.com\">恐龙示例面板应用</a>中如何按照恐龙的身高进行排序。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"dinosaur-facts.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://dinosaur-facts.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"dinosaurs\"</span>);</div><div class=\"line\">  </div><div class=\"line\">ref.orderByChild(<span class=\"string\">\"height\"</span>).on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\" was \"</span> + snapshot.val().height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用 <code>orderByChild()</code> 方法可指定排序所依据的特定子节点，在本例中，这个子节点就是身高 “height”，然后在按照这个子节点的值进行排序。 如需了解有关如何对其他数据类型进行排序的详细信息，请参见<a href=\"#排序规则\">排序规则</a>。</p>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>只有对数据排序进行之后，才能查找数据，你可以结合使用以下方法来构造查找的条件。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>limitToFirst()</td>\n<td>设置从第一条开始，一共返回多少条数据（节点）。</td>\n</tr>\n<tr>\n<td>limitToLast()</td>\n<td>设置从最后一条开始，一共返回多少条（返回结果仍是升序，降序要自己处理）。</td>\n</tr>\n<tr>\n<td>startAt()</td>\n<td>返回大于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>endAt()</td>\n<td>返回小于或等于指定的键、值或优先级的数据，具体取决于所选的排序方法。</td>\n</tr>\n<tr>\n<td>equalTo()</td>\n<td>返回等于指定的键、值或优先级的数据，具体取决于所选的排序方法。可用于精确查询。</td>\n</tr>\n</tbody>\n</table>\n<p>与排序依据方法不同，你可以结合使用这些过滤方法。例如，你可以结合使用 <code>startAt()</code> 与 <code>endAt()</code> 方法将结果限制在指定的范围内。</p>\n<p><strong>限制结果数</strong></p>\n<p>你可以使用 <code>limitToFirst()</code> 和 <code>limitToLast()</code> 方法为某个给定的事件设置要监听的子节点的最大数量。 例如，如果你使用 <code>limitToFirst(100)</code> 将限制个数设置为 100，那么一开始最多只能收到 100 个 <code>child_added</code> 事件，即只返回前100条数据的快照。<br>当数据发生更改时，对于进入到前100的数据，你会接收到 <code>child_added</code> 事件，对于从前100中消失的数据，你才会接收到 <code>child_removed</code> 事件，也就是说只有这100条里的数据变化才会触发事件。</p>\n<p>继续上面示例，如果你只想知道最高的是哪三条恐龙，就可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.orderByChild(<span class=\"string\">\"height\"</span>).limitToLast(<span class=\"number\">3</span>).on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\" was \"</span> + snapshot.val().height + <span class=\"string\">\" meters tall\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>或者你只关心哪些<a href=\"https://dinosaur-facts.wilddogio.com/scores\">恐龙</a>的得分超过60了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"dinosaur-facts.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://dinosaur-facts.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"scores\"</span>);</div><div class=\"line\">  </div><div class=\"line\">ref.orderByValue().startAt(<span class=\"number\">60</span>).on(<span class=\"string\">\"child_added\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(snapshot.key() + <span class=\"string\">\" is \"</span> + snapshot.val());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如上例所示，使用 <code>startAt()</code>、<code>endAt()</code> 和 <code>equalTo()</code> 为查询选择任意起点、终点或等量点。这可以用于<code>数据分页</code>和<code>精确查询</code>。<br>关于分页的具体实现，可参考<a href=\"https://coding.net/u/wilddog/p/wilddog-gist-js/git/tree/master/src/pagination\">如何实现分页</a>。</p>\n<h4 id=\"排序规则\"><a href=\"#排序规则\" class=\"headerlink\" title=\"排序规则\"></a>排序规则</h4><p>本小节介绍在使用各种排序方式时，数据究竟是如何排序的。</p>\n<p><strong>orderByChild</strong></p>\n<p>当使用<code>orderByChild(key)</code>时，按照子节点的公有属性key的value进行排序。仅当value为单一的数据类型时，排序有意义。如果key属性有多种数据类型时，排序不固定，此时不建议使用<code>orderByChild(key)</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">   &#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"no1\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"tyrannosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"string\">\"120\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no2\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"bruhathkayosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">55</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no3\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"lambeosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">21</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no6\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"stegosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">5</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no7\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"triceratops\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"number\">22</span></div><div class=\"line\">    &#125;, </div><div class=\"line\">    <span class=\"attr\">\"no8\"</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"brontosaurus\"</span>,</div><div class=\"line\">        <span class=\"attr\">\"score\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是<code>string</code>类型，雷龙的分数是<code>boolean</code>类型，而其他恐龙的分数是<code>number</code>类型，此时使用<code>orderByChild(key)</code>获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的 value 值为 null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的公有属性key包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用 <code>orderByChild(&#39;score&#39;).startAt(60).limitToFirst(4)</code> 将得到下面的结果：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"no4\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"linhenykus\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">80</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">\"no5\"</span> : &#123;</div><div class=\"line\">      <span class=\"attr\">\"name\"</span> : <span class=\"string\">\"pterodactyl\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"score\"</span> : <span class=\"number\">93</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用 <code>orderByChild(key)</code>将搜索不到该数据。</em></p>\n\n\n\n<p><strong>orderByKey</strong></p>\n<p>当使用 orderByKey() 对数据进行排序时，系统会按键名以字典顺序升序排列。</p>\n<p><strong>orderByValue</strong></p>\n<p>当使用<code>orderByValue()</code>时，按照直接子节点的 value 进行排序。仅当 value 为单一的数据类型时，排序有意义。如果子节点包含多种数据类型时，排序不固定，此时不建议使用<code>orderByValue()</code>获取全量数据，例如，<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"scores\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"tyrannosaurus\"</span> : <span class=\"string\">\"120\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"bruhathkayosaurus\"</span> : <span class=\"number\">55</span>,</div><div class=\"line\">    <span class=\"attr\">\"lambeosaurus\"</span> : <span class=\"number\">21</span>,</div><div class=\"line\">    <span class=\"attr\">\"linhenykus\"</span> : <span class=\"number\">80</span>,</div><div class=\"line\">    <span class=\"attr\">\"pterodactyl\"</span> : <span class=\"number\">93</span>,</div><div class=\"line\">    <span class=\"attr\">\"stegosaurus\"</span> : <span class=\"number\">5</span>,</div><div class=\"line\">    <span class=\"attr\">\"triceratops\"</span> : <span class=\"number\">22</span>,</div><div class=\"line\">    <span class=\"attr\">\"brontosaurus\"</span> : <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>霸王龙的分数是 <code>string</code>类型，雷龙的分数是 <code>boolean</code> 类型，而其他恐龙的分数是 <code>numberic</code> 类型，此时使用 <code>orderByValue()</code> 获得全量数据时，是一个看似固定的排序结果；但是配合使用<code>limitToFirst()</code>时，将获得不确定的结果。<code>Object</code>类型数据的value值为null，不会出现在结果中。<br>当配合使用<code>startAt()</code>、<code>endAt()</code>和<code>equalTo()</code>时，如果子节点的value包含多种数据类型，将按照这些函数的参数的类型排序，即只能返回这个类型的有序数据。上面的数据如果使用<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">```json</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;linhenykus&quot; : 80,</div><div class=\"line\">    &quot;pterodactyl&quot; : 93</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p style='color:red'><em>注意：如果path与value的总长度超过1000字节时，使用<code>orderByValue()</code>将搜索不到该数据。</em></p>\n\n<p><strong>orderByPriority</strong><br>当使用<code>orderByPriority()</code>对数据进行排序时，子节点数据将按照优先级和字段名进行排序。<br><strong>注意</strong>：优先级的值只能是数值型或字符串。<br>优先级的设置可参考 <a href=\"/api/sync/web.html#setPriority\">setPriority()</a></p>\n<ul>\n<li><p>１. 没有设置优先级的数据优先。</p>\n</li>\n<li><p>２. 接下来是优先级为数值型的子节点。它们按照优先级数值排序，由小到大。</p>\n</li>\n<li><p>３. 接下来是优先级为字符串的子节点。它们按照优先级的字典序排列。</p>\n</li>\n<li><p>４. 当多个子节点拥有相同的优先级时（包括没有优先级的情况），它们按照节点名排序。节点名可以转换为数值类型的子节点优先（数值排序），接下来是剩余的子节点（字典序排列）。</p>\n</li>\n</ul>\n"},{"title":"操作数据","_content":"\n以下四种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nset() | 将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 \npush() | 添加数据到列表。向指定路径下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。\nupdate() | 更新指定路径下的部分key的值，而不替换所有数据。 \ntransaction() | 提供事务性更新，用于并发更新操作的场景。 \n\n## 写入数据\n\n`set()` 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。\n`set()` 可以传入几种数据类型 `string`, `number`, `boolean`, `object` 做为参数。\n例如，社交博客应用可以使用 `set()` 添加用户信息，如你想给 `Jone` 添加个人信息：\n\n```js\n// 初始化\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\nref.child(\"Jone\").set({\n    username: name,\n    email: email\n});\n```\n\n野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后SDK去将数据与云端进行同步。\n也就是说，当 `set()` 方法返回的时候，数据可能还没有同步到云端。\n若要确保同步到云端完成，需要使用 `set()` 方法的第二个参数，该参数是一个回调函数，代码示例如下：\n\n```js\n// 初始化\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\n// 向 \"Jone\" 节点下写数据\nref.child(\"Jone\").set({\n    username: name,\n    email: email\n}, function(error) {\n    if (error == null){\n        // 数据同步到野狗云端成功完成\n    }\n});\n```\n\n## 更新数据\n\n如果只更新指定子节点，而不覆盖其它的子节点，可以使用 update() 方法:\n\n```js\n//原数据如下\n{\n    \"gracehop\": {\n        \"nickname\": \"Nice Grace\",\n        \"date_of_birth\": \"December 9, 1906\",\n        \"full_name \": \"Grace Lee\"\n    }\n}\n```\n```js\n// 只更新 gracehop 的 nickname\nvar hopperRef = ref.child(\"gracehop\");\nhopperRef.update({\n  \"nickname\": \"Amazing grace\"\n});\n\n```\n\n这样会更新 gracehop 的 nickname 字段。如果我们用 `set()` 而不是 `update()`，那么 date_of_birth 和 full_name 都会被删除。\n`update` 也支持多路径更新，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:\n```js\n//原数据如下\n{\n    \"a\": {\n        \"b\": {\n            \"c\": \"cc\",\n            \"d\": \"dd\"\n        },\n        \"x\": {\n            \"y\": \"yy\",\n            \"z\": \"zz\"\n        }\n    }\n}\n```\n```js\n// 初始化（同上）\n······\n\n// 同时更新 b 节点下的 d，和 x 节点下的 z\nref.update({\n  \"b/d\": \"updateD\",\n  \"x/z\": \"updateZ\"\n});\n```\n可以看到，标识路径的时候，这里必须要用 `b/d`, 和 `x/z` ,而**不能**这样写：\n```js\n// 错误的多路径更新写法！！！\nref.update({\n    \"b\": {\n        \"d\": \"updateD\"\n    },\n    \"x\": {\n        \"z\": \"updateZ\"\n    }\n});\n```\n这样相当于 `set()` 操作，会把之前的数据覆盖掉。\n\n## 追加新节点\n\n当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，Wilddog `push()` 采用了生成唯一ID 作为key的方式。通过这种方式，多个用户同时在一个节点下面push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。\n\n用户可以用 `push` 向博客 app 中写新内容：\n\n\n```js\n  var postsRef = ref.child(\"posts\");\n\n  postsRef.push({\n    author: \"gracehop\",\n    title: \"Announcing COBOL, a New Programming Language\"\n  });\n\n  postsRef.push({\n    author: \"alanisawesome\",\n    title: \"The Turing Machine\"\n  });\n\n```\n\n产生的数据都有一个唯一ID:\n```json\n{\n\n  \"posts\": {\n    \"-JRHTHaIs-jNPLXO\": {\n      \"author\": \"gracehop\",\n      \"title\": \"Announcing COBOL, a New Programming Language\"\n    },\n\n    \"-JRHTHaKuITFIhnj\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n```\n\n**获取唯一ID**\n调用push会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 `key()` 来获取这个唯一ID\n\n```js\n // 通过push()来获得一个新的数据库地址\nvar newPostRef = postsRef.push({\n\tauthor: \"gracehop\",\n\ttitle: \"Announcing COBOL, a New Programming Language\"\n});\n\n// 获取push()生成的唯一ID\nvar postID = newPostRef.key();\n\n```\n## 删除数据\n删除数据最简单的方法是在引用上对这些数据所处的位置调用 `remove()`。\n\n此外，还可以通过将 null 指定为另一个写入操作（例如，`set()` 或 `update()`）的值来删除数据。 您可以结合使用此方法与 `update()`，在单一 API 调用中来删除多个子节点。\n\n**注意**：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。\n\n## 事务操作\n处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。\n\n更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。\n\n举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：\n```js\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\");\n\nupvotesRef.transaction(function (currentValue) {\n  return (currentValue || 0) + 1;\n});\n```\n我们使用 `currentValue || 0` 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。\n\n注意：`transaction()` 可能被多次被调用，必须处理 currentData 变量为 null 的情况。 当执行事务时，云端有数据存在，但是本地可能没有缓存，此时 currentData 为 null。\n更多使用参见 [transaction()](/api/sync/web.html#transaction)。\n\n\n","source":"guide/sync/web/save-data.md","raw":"title:  操作数据\n---\n\n以下四种方法可用于将数据写入野狗云端：\n\n方法 |  说明 \n----|------\nset() | 将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 \npush() | 添加数据到列表。向指定路径下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。\nupdate() | 更新指定路径下的部分key的值，而不替换所有数据。 \ntransaction() | 提供事务性更新，用于并发更新操作的场景。 \n\n## 写入数据\n\n`set()` 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。\n`set()` 可以传入几种数据类型 `string`, `number`, `boolean`, `object` 做为参数。\n例如，社交博客应用可以使用 `set()` 添加用户信息，如你想给 `Jone` 添加个人信息：\n\n```js\n// 初始化\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\nref.child(\"Jone\").set({\n    username: name,\n    email: email\n});\n```\n\n野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后SDK去将数据与云端进行同步。\n也就是说，当 `set()` 方法返回的时候，数据可能还没有同步到云端。\n若要确保同步到云端完成，需要使用 `set()` 方法的第二个参数，该参数是一个回调函数，代码示例如下：\n\n```js\n// 初始化\nvar config = {\n  authDomain: \"<appId>.wilddog.com\",\n  syncURL: \"https://<appId>.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\n// 向 \"Jone\" 节点下写数据\nref.child(\"Jone\").set({\n    username: name,\n    email: email\n}, function(error) {\n    if (error == null){\n        // 数据同步到野狗云端成功完成\n    }\n});\n```\n\n## 更新数据\n\n如果只更新指定子节点，而不覆盖其它的子节点，可以使用 update() 方法:\n\n```js\n//原数据如下\n{\n    \"gracehop\": {\n        \"nickname\": \"Nice Grace\",\n        \"date_of_birth\": \"December 9, 1906\",\n        \"full_name \": \"Grace Lee\"\n    }\n}\n```\n```js\n// 只更新 gracehop 的 nickname\nvar hopperRef = ref.child(\"gracehop\");\nhopperRef.update({\n  \"nickname\": \"Amazing grace\"\n});\n\n```\n\n这样会更新 gracehop 的 nickname 字段。如果我们用 `set()` 而不是 `update()`，那么 date_of_birth 和 full_name 都会被删除。\n`update` 也支持多路径更新，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:\n```js\n//原数据如下\n{\n    \"a\": {\n        \"b\": {\n            \"c\": \"cc\",\n            \"d\": \"dd\"\n        },\n        \"x\": {\n            \"y\": \"yy\",\n            \"z\": \"zz\"\n        }\n    }\n}\n```\n```js\n// 初始化（同上）\n······\n\n// 同时更新 b 节点下的 d，和 x 节点下的 z\nref.update({\n  \"b/d\": \"updateD\",\n  \"x/z\": \"updateZ\"\n});\n```\n可以看到，标识路径的时候，这里必须要用 `b/d`, 和 `x/z` ,而**不能**这样写：\n```js\n// 错误的多路径更新写法！！！\nref.update({\n    \"b\": {\n        \"d\": \"updateD\"\n    },\n    \"x\": {\n        \"z\": \"updateZ\"\n    }\n});\n```\n这样相当于 `set()` 操作，会把之前的数据覆盖掉。\n\n## 追加新节点\n\n当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。\n为了解决这个问题，Wilddog `push()` 采用了生成唯一ID 作为key的方式。通过这种方式，多个用户同时在一个节点下面push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。\n\n用户可以用 `push` 向博客 app 中写新内容：\n\n\n```js\n  var postsRef = ref.child(\"posts\");\n\n  postsRef.push({\n    author: \"gracehop\",\n    title: \"Announcing COBOL, a New Programming Language\"\n  });\n\n  postsRef.push({\n    author: \"alanisawesome\",\n    title: \"The Turing Machine\"\n  });\n\n```\n\n产生的数据都有一个唯一ID:\n```json\n{\n\n  \"posts\": {\n    \"-JRHTHaIs-jNPLXO\": {\n      \"author\": \"gracehop\",\n      \"title\": \"Announcing COBOL, a New Programming Language\"\n    },\n\n    \"-JRHTHaKuITFIhnj\": {\n      \"author\": \"alanisawesome\",\n      \"title\": \"The Turing Machine\"\n    }\n  }\n}\n```\n\n**获取唯一ID**\n调用push会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 `key()` 来获取这个唯一ID\n\n```js\n // 通过push()来获得一个新的数据库地址\nvar newPostRef = postsRef.push({\n\tauthor: \"gracehop\",\n\ttitle: \"Announcing COBOL, a New Programming Language\"\n});\n\n// 获取push()生成的唯一ID\nvar postID = newPostRef.key();\n\n```\n## 删除数据\n删除数据最简单的方法是在引用上对这些数据所处的位置调用 `remove()`。\n\n此外，还可以通过将 null 指定为另一个写入操作（例如，`set()` 或 `update()`）的值来删除数据。 您可以结合使用此方法与 `update()`，在单一 API 调用中来删除多个子节点。\n\n**注意**：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。\n\n## 事务操作\n处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。\n\n更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。\n\n举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：\n```js\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref(\"/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\");\n\nupvotesRef.transaction(function (currentValue) {\n  return (currentValue || 0) + 1;\n});\n```\n我们使用 `currentValue || 0` 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。\n\n注意：`transaction()` 可能被多次被调用，必须处理 currentData 变量为 null 的情况。 当执行事务时，云端有数据存在，但是本地可能没有缓存，此时 currentData 为 null。\n更多使用参见 [transaction()](/api/sync/web.html#transaction)。\n\n\n","date":"2016-09-06T03:38:22.546Z","updated":"2016-09-06T03:38:22.546Z","path":"guide/sync/web/save-data.html","comments":1,"layout":"page","_id":"cisswi9lw0023z4fwrk0coniw","content":"<p>以下四种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set()</td>\n<td>将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>push()</td>\n<td>添加数据到列表。向指定路径下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。</unique-post-id></td>\n</tr>\n<tr>\n<td>update()</td>\n<td>更新指定路径下的部分key的值，而不替换所有数据。 </td>\n</tr>\n<tr>\n<td>transaction()</td>\n<td>提供事务性更新，用于并发更新操作的场景。 </td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h2><p><code>set()</code> 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。<br><code>set()</code> 可以传入几种数据类型 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code> 做为参数。<br>例如，社交博客应用可以使用 <code>set()</code> 添加用户信息，如你想给 <code>Jone</code> 添加个人信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\">ref.child(<span class=\"string\">\"Jone\"</span>).set(&#123;</div><div class=\"line\">    username: name,</div><div class=\"line\">    email: email</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后SDK去将数据与云端进行同步。<br>也就是说，当 <code>set()</code> 方法返回的时候，数据可能还没有同步到云端。<br>若要确保同步到云端完成，需要使用 <code>set()</code> 方法的第二个参数，该参数是一个回调函数，代码示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 向 \"Jone\" 节点下写数据</span></div><div class=\"line\">ref.child(<span class=\"string\">\"Jone\"</span>).set(&#123;</div><div class=\"line\">    username: name,</div><div class=\"line\">    email: email</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">// 数据同步到野狗云端成功完成</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>如果只更新指定子节点，而不覆盖其它的子节点，可以使用 update() 方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原数据如下</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"gracehop\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"nickname\"</span>: <span class=\"string\">\"Nice Grace\"</span>,</div><div class=\"line\">        <span class=\"string\">\"date_of_birth\"</span>: <span class=\"string\">\"December 9, 1906\"</span>,</div><div class=\"line\">        <span class=\"string\">\"full_name \"</span>: <span class=\"string\">\"Grace Lee\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只更新 gracehop 的 nickname</span></div><div class=\"line\"><span class=\"keyword\">var</span> hopperRef = ref.child(<span class=\"string\">\"gracehop\"</span>);</div><div class=\"line\">hopperRef.update(&#123;</div><div class=\"line\">  <span class=\"string\">\"nickname\"</span>: <span class=\"string\">\"Amazing grace\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这样会更新 gracehop 的 nickname 字段。如果我们用 <code>set()</code> 而不是 <code>update()</code>，那么 date_of_birth 和 full_name 都会被删除。<br><code>update</code> 也支持多路径更新，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原数据如下</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"a\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"b\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"c\"</span>: <span class=\"string\">\"cc\"</span>,</div><div class=\"line\">            <span class=\"string\">\"d\"</span>: <span class=\"string\">\"dd\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"x\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"y\"</span>: <span class=\"string\">\"yy\"</span>,</div><div class=\"line\">            <span class=\"string\">\"z\"</span>: <span class=\"string\">\"zz\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 初始化（同上）</span></div><div class=\"line\">······</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 同时更新 b 节点下的 d，和 x 节点下的 z</span></div><div class=\"line\">ref.update(&#123;</div><div class=\"line\">  <span class=\"string\">\"b/d\"</span>: <span class=\"string\">\"updateD\"</span>,</div><div class=\"line\">  <span class=\"string\">\"x/z\"</span>: <span class=\"string\">\"updateZ\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>可以看到，标识路径的时候，这里必须要用 <code>b/d</code>, 和 <code>x/z</code> ,而<strong>不能</strong>这样写：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误的多路径更新写法！！！</span></div><div class=\"line\">ref.update(&#123;</div><div class=\"line\">    <span class=\"string\">\"b\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"d\"</span>: <span class=\"string\">\"updateD\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"x\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"z\"</span>: <span class=\"string\">\"updateZ\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这样相当于 <code>set()</code> 操作，会把之前的数据覆盖掉。</p>\n<h2 id=\"追加新节点\"><a href=\"#追加新节点\" class=\"headerlink\" title=\"追加新节点\"></a>追加新节点</h2><p>当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，Wilddog <code>push()</code> 采用了生成唯一ID 作为key的方式。通过这种方式，多个用户同时在一个节点下面push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>用户可以用 <code>push</code> 向博客 app 中写新内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> postsRef = ref.child(<span class=\"string\">\"posts\"</span>);</div><div class=\"line\"></div><div class=\"line\">postsRef.push(&#123;</div><div class=\"line\">  author: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">  title: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">postsRef.push(&#123;</div><div class=\"line\">  author: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">  title: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>产生的数据都有一个唯一ID:<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">\"posts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaIs-jNPLXO\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaKuITFIhnj\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>获取唯一ID</strong><br>调用push会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 <code>key()</code> 来获取这个唯一ID</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">// 通过push()来获得一个新的数据库地址</span></div><div class=\"line\"><span class=\"keyword\">var</span> newPostRef = postsRef.push(&#123;</div><div class=\"line\">\tauthor: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">\ttitle: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取push()生成的唯一ID</span></div><div class=\"line\"><span class=\"keyword\">var</span> postID = newPostRef.key();</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除数据最简单的方法是在引用上对这些数据所处的位置调用 <code>remove()</code>。</p>\n<p>此外，还可以通过将 null 指定为另一个写入操作（例如，<code>set()</code> 或 <code>update()</code>）的值来删除数据。 您可以结合使用此方法与 <code>update()</code>，在单一 API 调用中来删除多个子节点。</p>\n<p><strong>注意</strong>：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。</p>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。</p>\n<p>更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。</p>\n<p>举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>);</div><div class=\"line\"></div><div class=\"line\">upvotesRef.transaction(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">currentValue</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (currentValue || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们使用 <code>currentValue || 0</code> 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。</p>\n<p>注意：<code>transaction()</code> 可能被多次被调用，必须处理 currentData 变量为 null 的情况。 当执行事务时，云端有数据存在，但是本地可能没有缓存，此时 currentData 为 null。<br>更多使用参见 <a href=\"/api/sync/web.html#transaction\">transaction()</a>。</p>\n","excerpt":"","more":"<p>以下四种方法可用于将数据写入野狗云端：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set()</td>\n<td>将数据写入到指定的路径，如果指定路径已存在数据，那么数据将会被覆盖。 </td>\n</tr>\n<tr>\n<td>push()</td>\n<td>添加数据到列表。向指定路径下添加数据，由野狗自动生成唯一key。例如向 /posts 路径下 push 数据，数据会写入到/posts/<unique-post-id>下。</td>\n</tr>\n<tr>\n<td>update()</td>\n<td>更新指定路径下的部分key的值，而不替换所有数据。 </td>\n</tr>\n<tr>\n<td>transaction()</td>\n<td>提供事务性更新，用于并发更新操作的场景。 </td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"写入数据\"><a href=\"#写入数据\" class=\"headerlink\" title=\"写入数据\"></a>写入数据</h2><p><code>set()</code> 是最基本的写数据操作，它会将数据写入当前引用指向的节点。该节点如果已有数据，任何原有数据都将被删除和覆盖，包括其子节点的数据。<br><code>set()</code> 可以传入几种数据类型 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code> 做为参数。<br>例如，社交博客应用可以使用 <code>set()</code> 添加用户信息，如你想给 <code>Jone</code> 添加个人信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\">ref.child(<span class=\"string\">\"Jone\"</span>).set(&#123;</div><div class=\"line\">    username: name,</div><div class=\"line\">    email: email</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>野狗采用的是一个“数据同步”的架构。本地拥有数据副本。对数据的写入操作，首先写入本地副本，然后SDK去将数据与云端进行同步。<br>也就是说，当 <code>set()</code> 方法返回的时候，数据可能还没有同步到云端。<br>若要确保同步到云端完成，需要使用 <code>set()</code> 方法的第二个参数，该参数是一个回调函数，代码示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 初始化</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"&lt;appId&gt;.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://&lt;appId&gt;.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 向 \"Jone\" 节点下写数据</span></div><div class=\"line\">ref.child(<span class=\"string\">\"Jone\"</span>).set(&#123;</div><div class=\"line\">    username: name,</div><div class=\"line\">    email: email</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (error == <span class=\"literal\">null</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">// 数据同步到野狗云端成功完成</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"更新数据\"><a href=\"#更新数据\" class=\"headerlink\" title=\"更新数据\"></a>更新数据</h2><p>如果只更新指定子节点，而不覆盖其它的子节点，可以使用 update() 方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原数据如下</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"gracehop\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"nickname\"</span>: <span class=\"string\">\"Nice Grace\"</span>,</div><div class=\"line\">        <span class=\"string\">\"date_of_birth\"</span>: <span class=\"string\">\"December 9, 1906\"</span>,</div><div class=\"line\">        <span class=\"string\">\"full_name \"</span>: <span class=\"string\">\"Grace Lee\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 只更新 gracehop 的 nickname</span></div><div class=\"line\"><span class=\"keyword\">var</span> hopperRef = ref.child(<span class=\"string\">\"gracehop\"</span>);</div><div class=\"line\">hopperRef.update(&#123;</div><div class=\"line\">  <span class=\"string\">\"nickname\"</span>: <span class=\"string\">\"Amazing grace\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这样会更新 gracehop 的 nickname 字段。如果我们用 <code>set()</code> 而不是 <code>update()</code>，那么 date_of_birth 和 full_name 都会被删除。<br><code>update</code> 也支持多路径更新，即同时更新不同路径下的数据且不影响其他数据，但用法上有些特殊，举例如下:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原数据如下</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"a\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"b\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"c\"</span>: <span class=\"string\">\"cc\"</span>,</div><div class=\"line\">            <span class=\"string\">\"d\"</span>: <span class=\"string\">\"dd\"</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"string\">\"x\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"y\"</span>: <span class=\"string\">\"yy\"</span>,</div><div class=\"line\">            <span class=\"string\">\"z\"</span>: <span class=\"string\">\"zz\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 初始化（同上）</span></div><div class=\"line\">······</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 同时更新 b 节点下的 d，和 x 节点下的 z</span></div><div class=\"line\">ref.update(&#123;</div><div class=\"line\">  <span class=\"string\">\"b/d\"</span>: <span class=\"string\">\"updateD\"</span>,</div><div class=\"line\">  <span class=\"string\">\"x/z\"</span>: <span class=\"string\">\"updateZ\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>可以看到，标识路径的时候，这里必须要用 <code>b/d</code>, 和 <code>x/z</code> ,而<strong>不能</strong>这样写：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误的多路径更新写法！！！</span></div><div class=\"line\">ref.update(&#123;</div><div class=\"line\">    <span class=\"string\">\"b\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"d\"</span>: <span class=\"string\">\"updateD\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"x\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"z\"</span>: <span class=\"string\">\"updateZ\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这样相当于 <code>set()</code> 操作，会把之前的数据覆盖掉。</p>\n<h2 id=\"追加新节点\"><a href=\"#追加新节点\" class=\"headerlink\" title=\"追加新节点\"></a>追加新节点</h2><p>当多个用户同时试图在一个节点下新增一个子节点的时候，这时，数据就会被重写覆盖。<br>为了解决这个问题，Wilddog <code>push()</code> 采用了生成唯一ID 作为key的方式。通过这种方式，多个用户同时在一个节点下面push 数据，他们的 key 一定是不同的。这个 key 是通过一个基于时间戳和随机算法生成的，即使在一毫秒内也不会相同，并且表明了时间的先后，Wilddog 采用了足够多的位数保证唯一性。</p>\n<p>用户可以用 <code>push</code> 向博客 app 中写新内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> postsRef = ref.child(<span class=\"string\">\"posts\"</span>);</div><div class=\"line\"></div><div class=\"line\">postsRef.push(&#123;</div><div class=\"line\">  author: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">  title: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">postsRef.push(&#123;</div><div class=\"line\">  author: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">  title: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>产生的数据都有一个唯一ID:<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">\"posts\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaIs-jNPLXO\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">\"-JRHTHaKuITFIhnj\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"alanisawesome\"</span>,</div><div class=\"line\">      <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"The Turing Machine\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>获取唯一ID</strong><br>调用push会返回一个引用，这个引用指向新增数据所在的节点。你可以通过调用 <code>key()</code> 来获取这个唯一ID</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">// 通过push()来获得一个新的数据库地址</span></div><div class=\"line\"><span class=\"keyword\">var</span> newPostRef = postsRef.push(&#123;</div><div class=\"line\">\tauthor: <span class=\"string\">\"gracehop\"</span>,</div><div class=\"line\">\ttitle: <span class=\"string\">\"Announcing COBOL, a New Programming Language\"</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取push()生成的唯一ID</span></div><div class=\"line\"><span class=\"keyword\">var</span> postID = newPostRef.key();</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><p>删除数据最简单的方法是在引用上对这些数据所处的位置调用 <code>remove()</code>。</p>\n<p>此外，还可以通过将 null 指定为另一个写入操作（例如，<code>set()</code> 或 <code>update()</code>）的值来删除数据。 您可以结合使用此方法与 <code>update()</code>，在单一 API 调用中来删除多个子节点。</p>\n<p><strong>注意</strong>：Wilddog 不会保存空路径，即如果 /a/b/c 节点下的值被设为 null，这条路径下又没其他的含有非空值的子节点存在，那么云端就会把这条路径删除。</p>\n<h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>处理可能因并发修改而损坏的数据（例如，增量计数器）时，可以使用事务处理操作。你可以为此操作提供更新函数和完成后的回调（可选）。</p>\n<p>更新函数会获取当前值作为参数，当你的数据提交到服务端时，会判断你调用的更新函数传递的当前值是否与实际当前值相等，如果相等，则更新数据为你提交的数据，如果不相等，则返回新的当前值，更新函数使用新的当前值和你提交的数据重复尝试更新，直到成功为止。</p>\n<p>举例说明，如果我们想在一个的博文上计算点赞的数量，可以这样写一个事务：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref(<span class=\"string\">\"/saving-data/wildblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes\"</span>);</div><div class=\"line\"></div><div class=\"line\">upvotesRef.transaction(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">currentValue</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (currentValue || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我们使用 <code>currentValue || 0</code> 来判断计数器是否为空或者是自增加。 如果上面的代码没有使用事务, 当两个客户端在同时试图累加，那结果可能是为数字 1 而非数字 2。</p>\n<p>注意：<code>transaction()</code> 可能被多次被调用，必须处理 currentData 变量为 null 的情况。 当执行事务时，云端有数据存在，但是本地可能没有缓存，此时 currentData 为 null。<br>更多使用参见 <a href=\"/api/sync/web.html#transaction\">transaction()</a>。</p>\n"},{"title":"组织数据","_content":"\nWilddog 云端数据库属于 [NoSQL](http://baike.baidu.com/view/2677528.htm) 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： \n\n\n```json\n{\n  \"users\": {\n    \"mchen\": {\n      \"friends\": { \"brinchen\": true },\n      \"name\": \"Mary Chen\",\n      \"widgets\": { \"one\": true, \"three\": true }\n    },\n    \"brinchen\": { ... },\n    \"hmadi\": { ... }\n  }\n}\n```\n\n构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。\n\n## 避免层级过深\n\n尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。\n\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n```json\n{\n  // 一个非常差的充满嵌套的数据结构。请勿模仿。\n    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\",\n        \"messages\": {\n          \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n          \"m2\": { ... },\n          // 非常长的messages列表\n        }\n      }\n    }\n}\n```\n\n对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。\n\n#### 使数据扁平化\n\n如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：\n\n\n```json\n{\n    // rooms数据节点下仅包含房间的基本信息和唯一ID。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\"\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    },\n\n    //room成员可以很方便的的存取\n    \"members\": {\n      \"one\": {\n        \"mchen\": true,\n        \"hmadi\": true\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n\n    },\n\n    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。\n  //消息数据可以通过room ID方便的分页和查询。\n    \"messages\": {\n      \"one\": {\n        \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n        \"m2\": { ... },\n        \"m3\": { ... }\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    }\n\n  }\n```\n\n这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。\n\n<br>\n\n## 使数据可扩展\n很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：\n\n\n```json\n{\n    \"users\": {\n      \"john\": {\n         \"todoList\": {\n            \"rec1\": \"Walk the dog\",\n            \"rec2\": \"Buy milk\",\n            \"rec3\": \"Win a gold medal in the Olympics\"\n         }\n      }\n    }\n  }\n\n```\n\n但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。\n\n但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：\n\n\n```json\n{\n    \"users\": {\n      \"mchen\": { \"name\": \"Mary Chen\" },\n      \"brinchen\": { \"name\": \"Byambyn Rinchen\" },\n      \"hmadi\": { \"name\": \"Hamadi Madi\" }\n    },\n    \"groups\": {\n      \"alpha\": {\n         \"name\": \"Alpha Tango\",\n         \"members\": {\n            \"m1\": \"mchen\",\n            \"m2\": \"brinchen\",\n            \"m3\": \"hamadi\"\n         }\n      },\n      \"bravo\": { ... },\n      \"charlie\": { ... }\n    }\n  }\n```\n\n看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。\n\n我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：\n\n```json\n{\n    \"users\": {\n      \"mchen\": {\n        \"name\": \"Mary Chen\",\n        // 在Mary的数据下，建立他所属group的索引。\n        \"groups\": {\n           // 这里的值是什么并不重要。重要的是这个子节点的key存在。\n           \"alpha\": true,\n           \"charlie\": true\n        }\n      },\n      ...\n    },\n    \"groups\": { ... }\n  }\n```\n\n我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。\n\n对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。\n\n为什么我们把 id 作为 key，而把 value 设置为`true`呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取`/users/mchen/groups/$group_id`，看它是否为 null 就可以了。\n\n如果我们要判断 Mary 是否属于 alpha group，示例如下：\n\n```js\n// 判断Mary是否属于alpha group\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\nref.once('value', function(snap) {\n  var result = snap.val() === null? 'is not' : 'is';\n  console.log('Mary ' + result + ' a member of alpha group');\n});\n```\n","source":"guide/sync/web/structure-data.md","raw":"title:  组织数据\n---\n\nWilddog 云端数据库属于 [NoSQL](http://baike.baidu.com/view/2677528.htm) 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： \n\n\n```json\n{\n  \"users\": {\n    \"mchen\": {\n      \"friends\": { \"brinchen\": true },\n      \"name\": \"Mary Chen\",\n      \"widgets\": { \"one\": true, \"three\": true }\n    },\n    \"brinchen\": { ... },\n    \"hmadi\": { ... }\n  }\n}\n```\n\n构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。\n\n## 避免层级过深\n\n尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。\n\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n```json\n{\n  // 一个非常差的充满嵌套的数据结构。请勿模仿。\n    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\",\n        \"messages\": {\n          \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n          \"m2\": { ... },\n          // 非常长的messages列表\n        }\n      }\n    }\n}\n```\n\n对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。\n\n#### 使数据扁平化\n\n如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：\n\n\n```json\n{\n    // rooms数据节点下仅包含房间的基本信息和唯一ID。\n    \"rooms\": {\n      \"one\": {\n        \"name\": \"room alpha\",\n        \"type\": \"private\"\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    },\n\n    //room成员可以很方便的的存取\n    \"members\": {\n      \"one\": {\n        \"mchen\": true,\n        \"hmadi\": true\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n\n    },\n\n    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。\n  //消息数据可以通过room ID方便的分页和查询。\n    \"messages\": {\n      \"one\": {\n        \"m1\": { \"sender\": \"mchen\", \"message\": \"foo\" },\n        \"m2\": { ... },\n        \"m3\": { ... }\n      },\n      \"two\": { ... },\n      \"three\": { ... }\n    }\n\n  }\n```\n\n这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。\n\n<br>\n\n## 使数据可扩展\n很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：\n\n\n```json\n{\n    \"users\": {\n      \"john\": {\n         \"todoList\": {\n            \"rec1\": \"Walk the dog\",\n            \"rec2\": \"Buy milk\",\n            \"rec3\": \"Win a gold medal in the Olympics\"\n         }\n      }\n    }\n  }\n\n```\n\n但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。\n\n但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：\n\n\n```json\n{\n    \"users\": {\n      \"mchen\": { \"name\": \"Mary Chen\" },\n      \"brinchen\": { \"name\": \"Byambyn Rinchen\" },\n      \"hmadi\": { \"name\": \"Hamadi Madi\" }\n    },\n    \"groups\": {\n      \"alpha\": {\n         \"name\": \"Alpha Tango\",\n         \"members\": {\n            \"m1\": \"mchen\",\n            \"m2\": \"brinchen\",\n            \"m3\": \"hamadi\"\n         }\n      },\n      \"bravo\": { ... },\n      \"charlie\": { ... }\n    }\n  }\n```\n\n看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。\n\n我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：\n\n```json\n{\n    \"users\": {\n      \"mchen\": {\n        \"name\": \"Mary Chen\",\n        // 在Mary的数据下，建立他所属group的索引。\n        \"groups\": {\n           // 这里的值是什么并不重要。重要的是这个子节点的key存在。\n           \"alpha\": true,\n           \"charlie\": true\n        }\n      },\n      ...\n    },\n    \"groups\": { ... }\n  }\n```\n\n我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。\n\n对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。\n\n为什么我们把 id 作为 key，而把 value 设置为`true`呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取`/users/mchen/groups/$group_id`，看它是否为 null 就可以了。\n\n如果我们要判断 Mary 是否属于 alpha group，示例如下：\n\n```js\n// 判断Mary是否属于alpha group\nvar config = {\n  authDomain: \"docs-examples.wilddog.com\",\n  syncURL: \"https://docs-examples.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\nref.once('value', function(snap) {\n  var result = snap.val() === null? 'is not' : 'is';\n  console.log('Mary ' + result + ' a member of alpha group');\n});\n```\n","date":"2016-09-06T03:38:22.547Z","updated":"2016-09-06T03:38:22.547Z","path":"guide/sync/web/structure-data.html","comments":1,"layout":"page","_id":"cisswi9lw0024z4fwey1wjkjd","content":"<p>Wilddog 云端数据库属于 <a href=\"http://baike.baidu.com/view/2677528.htm\" target=\"_blank\" rel=\"external\">NoSQL</a> 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： </p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"users\": &#123;</div><div class=\"line\">    \"mchen\": &#123;</div><div class=\"line\">      \"friends\": &#123; \"brinchen\": true &#125;,</div><div class=\"line\">      \"name\": \"Mary Chen\",</div><div class=\"line\">      \"widgets\": &#123; \"one\": true, \"three\": true &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"brinchen\": &#123; ... &#125;,</div><div class=\"line\">    \"hmadi\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。</p>\n<h2 id=\"避免层级过深\"><a href=\"#避免层级过深\" class=\"headerlink\" title=\"避免层级过深\"></a>避免层级过深</h2><p>尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。</p>\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  // 一个非常差的充满嵌套的数据结构。请勿模仿。</div><div class=\"line\">    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\",</div><div class=\"line\">        \"messages\": &#123;</div><div class=\"line\">          \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">          \"m2\": &#123; ... &#125;,</div><div class=\"line\">          // 非常长的messages列表</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。</p>\n<h4 id=\"使数据扁平化\"><a href=\"#使数据扁平化\" class=\"headerlink\" title=\"使数据扁平化\"></a>使数据扁平化</h4><p>如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    // rooms数据节点下仅包含房间的基本信息和唯一ID。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\"</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //room成员可以很方便的的存取</div><div class=\"line\">    \"members\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"mchen\": true,</div><div class=\"line\">        \"hmadi\": true</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。</div><div class=\"line\">  //消息数据可以通过room ID方便的分页和查询。</div><div class=\"line\">    \"messages\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">        \"m2\": &#123; ... &#125;,</div><div class=\"line\">        \"m3\": &#123; ... &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。</p>\n<p><br></p>\n<h2 id=\"使数据可扩展\"><a href=\"#使数据可扩展\" class=\"headerlink\" title=\"使数据可扩展\"></a>使数据可扩展</h2><p>很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"john\"</span>: &#123;</div><div class=\"line\">         <span class=\"attr\">\"todoList\"</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">\"rec1\"</span>: <span class=\"string\">\"Walk the dog\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec2\"</span>: <span class=\"string\">\"Buy milk\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec3\"</span>: <span class=\"string\">\"Win a gold medal in the Olympics\"</span></div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。</p>\n<p>但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123; \"name\": \"Mary Chen\" &#125;,</div><div class=\"line\">      \"brinchen\": &#123; \"name\": \"Byambyn Rinchen\" &#125;,</div><div class=\"line\">      \"hmadi\": &#123; \"name\": \"Hamadi Madi\" &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123;</div><div class=\"line\">      \"alpha\": &#123;</div><div class=\"line\">         \"name\": \"Alpha Tango\",</div><div class=\"line\">         \"members\": &#123;</div><div class=\"line\">            \"m1\": \"mchen\",</div><div class=\"line\">            \"m2\": \"brinchen\",</div><div class=\"line\">            \"m3\": \"hamadi\"</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"bravo\": &#123; ... &#125;,</div><div class=\"line\">      \"charlie\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。</p>\n<p>我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123;</div><div class=\"line\">        \"name\": \"Mary Chen\",</div><div class=\"line\">        // 在Mary的数据下，建立他所属group的索引。</div><div class=\"line\">        \"groups\": &#123;</div><div class=\"line\">           // 这里的值是什么并不重要。重要的是这个子节点的key存在。</div><div class=\"line\">           \"alpha\": true,</div><div class=\"line\">           \"charlie\": true</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。</p>\n<p>对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。</p>\n<p>为什么我们把 id 作为 key，而把 value 设置为<code>true</code>呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取<code>/users/mchen/groups/$group_id</code>，看它是否为 null 就可以了。</p>\n<p>如果我们要判断 Mary 是否属于 alpha group，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 判断Mary是否属于alpha group</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\">ref.once(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = snap.val() === <span class=\"literal\">null</span>? <span class=\"string\">'is not'</span> : <span class=\"string\">'is'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Mary '</span> + result + <span class=\"string\">' a member of alpha group'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Wilddog 云端数据库属于 <a href=\"http://baike.baidu.com/view/2677528.htm\">NoSQL</a> 类型数据库，数据以 JSON 为格式进行存储，没有传统关系型数据库中的表和记录等概念。如下： </p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  \"users\": &#123;</div><div class=\"line\">    \"mchen\": &#123;</div><div class=\"line\">      \"friends\": &#123; \"brinchen\": true &#125;,</div><div class=\"line\">      \"name\": \"Mary Chen\",</div><div class=\"line\">      \"widgets\": &#123; \"one\": true, \"three\": true &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"brinchen\": &#123; ... &#125;,</div><div class=\"line\">    \"hmadi\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造恰当的 NoSQL 存储结构需要事先考虑很多因素。最重要的是，必须要知道将来数据会被如何查询，如何存储数据才能使查询最方便。</p>\n<h2 id=\"避免层级过深\"><a href=\"#避免层级过深\" class=\"headerlink\" title=\"避免层级过深\"></a>避免层级过深</h2><p>尽管可以使用 JSON 任意地组织数据，但不同的组织方式对读取性能的影响是很大的。Wilddog  的工作方式是当你查询某个节点，Wilddog 会返回这个节点下的所有子节点。所以，应该尽可能使数据扁平化，就像组织 SQL 关系型数据表一样。</p>\n<div class=\"alert\"> 我们不推荐这种实践 </div>\n\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  // 一个非常差的充满嵌套的数据结构。请勿模仿。</div><div class=\"line\">    // 对\"rooms\"进行遍历查找来获得名字需要下载很多很多的messages。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\",</div><div class=\"line\">        \"messages\": &#123;</div><div class=\"line\">          \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">          \"m2\": &#123; ... &#125;,</div><div class=\"line\">          // 非常长的messages列表</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于这种嵌套存储的设计，很难遍历所有的数据。比如列出所有的 rooms 这样一个很简单的操作，也会查询整个 rooms 数据节点，返回所有的 rooms 下的数据节点到客户端。</p>\n<h4 id=\"使数据扁平化\"><a href=\"#使数据扁平化\" class=\"headerlink\" title=\"使数据扁平化\"></a>使数据扁平化</h4><p>如果数据分布到不同的路径下，那么就可以根据需要查询最小化的数据量，大大提高查询性能：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    // rooms数据节点下仅包含房间的基本信息和唯一ID。</div><div class=\"line\">    \"rooms\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"name\": \"room alpha\",</div><div class=\"line\">        \"type\": \"private\"</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //room成员可以很方便的的存取</div><div class=\"line\">    \"members\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"mchen\": true,</div><div class=\"line\">        \"hmadi\": true</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    //消息数据与其他数据分离开，这样我们在查询其他数据时就不收消息数据的影响，从而提升性能。</div><div class=\"line\">  //消息数据可以通过room ID方便的分页和查询。</div><div class=\"line\">    \"messages\": &#123;</div><div class=\"line\">      \"one\": &#123;</div><div class=\"line\">        \"m1\": &#123; \"sender\": \"mchen\", \"message\": \"foo\" &#125;,</div><div class=\"line\">        \"m2\": &#123; ... &#125;,</div><div class=\"line\">        \"m3\": &#123; ... &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"two\": &#123; ... &#125;,</div><div class=\"line\">      \"three\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>这样组织数据，就可以很方便的查询 room 列表了，只需要传输很少的字节数。message 数据也可以很容易的查询。</p>\n<p><br></p>\n<h2 id=\"使数据可扩展\"><a href=\"#使数据可扩展\" class=\"headerlink\" title=\"使数据可扩展\"></a>使数据可扩展</h2><p>很多时候需要查询一个列表的一个子集数据，尤其是当这个列表中包含多达数千条或更多记录时。当这个数据之间的关系是单向且数据比较稳定的时候，我们可以简单的把子节点数据嵌套到父节点之下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">\"users\"</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">\"john\"</span>: &#123;</div><div class=\"line\">         <span class=\"attr\">\"todoList\"</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">\"rec1\"</span>: <span class=\"string\">\"Walk the dog\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec2\"</span>: <span class=\"string\">\"Buy milk\"</span>,</div><div class=\"line\">            <span class=\"attr\">\"rec3\"</span>: <span class=\"string\">\"Win a gold medal in the Olympics\"</span></div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>但很多时候数据频发变化，或者有时候必须把数据拆分存储到不同的路径下（John 可能有一个长达数千项的 todo 列表）。通常可以通过查询一个列表的子集的方式来解决。</p>\n<p>但仅仅如此可能还是不够的。考虑一个例子，users 和 groups 之间的双向关系。user 可以属于 group，group 包含一个 user 列表。乍看之下数据可能这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123; \"name\": \"Mary Chen\" &#125;,</div><div class=\"line\">      \"brinchen\": &#123; \"name\": \"Byambyn Rinchen\" &#125;,</div><div class=\"line\">      \"hmadi\": &#123; \"name\": \"Hamadi Madi\" &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123;</div><div class=\"line\">      \"alpha\": &#123;</div><div class=\"line\">         \"name\": \"Alpha Tango\",</div><div class=\"line\">         \"members\": &#123;</div><div class=\"line\">            \"m1\": \"mchen\",</div><div class=\"line\">            \"m2\": \"brinchen\",</div><div class=\"line\">            \"m3\": \"hamadi\"</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      \"bravo\": &#123; ... &#125;,</div><div class=\"line\">      \"charlie\": &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>看起来不错。但是当需要判断一个 user 属于哪些 group 的时候，困难就来了。我们可以在数据发生改变的时候遍历并更新所有的 group，但这样做成本很高，也很慢。更糟糕的是，如果 Mary 没有权限查看所有的 group 时怎么办呢？当查询整个列表时，会得到一个没有权限访问的错误。</p>\n<p>我们需要的是一种优雅的方式，可以列出 Mary 属于哪些group，只需要查询这些 group 就行了。数据可以这样组织：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    \"users\": &#123;</div><div class=\"line\">      \"mchen\": &#123;</div><div class=\"line\">        \"name\": \"Mary Chen\",</div><div class=\"line\">        // 在Mary的数据下，建立他所属group的索引。</div><div class=\"line\">        \"groups\": &#123;</div><div class=\"line\">           // 这里的值是什么并不重要。重要的是这个子节点的key存在。</div><div class=\"line\">           \"alpha\": true,</div><div class=\"line\">           \"charlie\": true</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      ...</div><div class=\"line\">    &#125;,</div><div class=\"line\">    \"groups\": &#123; ... &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>我们把关系数据同时存储在了 Mary 的记录下和 group 数据下，这样造成了数据的重复。如果要把 Mary 从一个组中删除，就需要更新两个地方。</p>\n<p>对于双向的关系来说，这样的冗余是有必要的。这样做使我们可以很高效的查询 Mary 的个人信息，即使 users 和 groups 都有百万级的数据，且规则表达式禁止访问不相关的数据时。</p>\n<p>为什么我们把 id 作为 key，而把 value 设置为<code>true</code>呢？这样做是有好处的。这样使得检查一个 id 是否存在变得非常简单，只需要读取<code>/users/mchen/groups/$group_id</code>，看它是否为 null 就可以了。</p>\n<p>如果我们要判断 Mary 是否属于 alpha group，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 判断Mary是否属于alpha group</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"docs-examples.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://docs-examples.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\">ref.once(<span class=\"string\">'value'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = snap.val() === <span class=\"literal\">null</span>? <span class=\"string\">'is not'</span> : <span class=\"string\">'is'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Mary '</span> + result + <span class=\"string\">' a member of alpha group'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"demo库","_content":"\n## 示例源码\n\n| 示例 | 贡献者 | 说明 | \n|----|----|----| \n|<a href=\"https://github.com/WildDogTeam/demo-c-rgblight\" target=\"_blank\">智能彩灯demo</a>|野狗官方 | 使用野狗 C/嵌入式 SDK 开发的一个智能彩灯demo |\n|<a href=\"https://github.com/WildDogTeam/demo-c-airmonitor\" target=\"_blank\">空气监测demo</a>|野狗官方 | 使用野狗 Arduino SDK 开发的一个空气监测demo |\n\n\n","source":"resources/sync/c/resources.md","raw":"title:  demo库\n---\n\n## 示例源码\n\n| 示例 | 贡献者 | 说明 | \n|----|----|----| \n|<a href=\"https://github.com/WildDogTeam/demo-c-rgblight\" target=\"_blank\">智能彩灯demo</a>|野狗官方 | 使用野狗 C/嵌入式 SDK 开发的一个智能彩灯demo |\n|<a href=\"https://github.com/WildDogTeam/demo-c-airmonitor\" target=\"_blank\">空气监测demo</a>|野狗官方 | 使用野狗 Arduino SDK 开发的一个空气监测demo |\n\n\n","date":"2016-09-07T13:24:23.123Z","updated":"2016-09-07T13:24:23.123Z","path":"resources/sync/c/resources.html","_id":"cisswi9lw0025z4fwo5blz05h","comments":1,"layout":"page","content":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>示例</th>\n<th>贡献者</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-c-rgblight\" target=\"_blank\">智能彩灯demo</a></td>\n<td>野狗官方</td>\n<td>使用野狗 C/嵌入式 SDK 开发的一个智能彩灯demo</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-c-airmonitor\" target=\"_blank\">空气监测demo</a></td>\n<td>野狗官方</td>\n<td>使用野狗 Arduino SDK 开发的一个空气监测demo</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>示例</th>\n<th>贡献者</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-c-rgblight\" target=\"_blank\">智能彩灯demo</a></td>\n<td>野狗官方</td>\n<td>使用野狗 C/嵌入式 SDK 开发的一个智能彩灯demo</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-c-airmonitor\" target=\"_blank\">空气监测demo</a></td>\n<td>野狗官方</td>\n<td>使用野狗 Arduino SDK 开发的一个空气监测demo</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"实战教程","_content":"\n本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读[快速入门](/quickstart/sync/ios.html)。\n\n# 弹幕\n\n## 示例说明\n示例的最终的展示效果如下： \n![](/images/ios-danmu.png)\n\n野狗很适合做一些多端（web、iOS、android 等其他客户端）实时同步的应用，弹幕就是其中一个。使用 Wilddog SDK，百余行代码即可完全实现弹幕功能。可见 Wilddog 在实时领域的简单与强大。\n\n## 具体步骤\n\n### 引入 Wilddog iOS SDK \n\nSDK 的导入方式有两种，你可以选择下面方式的其中一种：\n\n#### 第一种：使用 CocoaPods \n要将 Wilddog SDK 导入到你的工程中，推荐使用 [CocoaPods](https://cocoapods.org/)，如果没用过 CocoaPods，请先访问 [CocoaPods getting started](https://guides.cocoapods.org/using/getting-started.html)。 \n\n\n打开工程目录，新建一个 Podfile 文件\n\n\t$ cd your-project-directory\n\t$ pod init\n\t$ open -a Xcode Podfile # opens your Podfile in XCode\n\n然后在 Podfile 文件中添加以下语句\n\n\tpod 'Wilddog'\n\t\n最后安装 SDK\n\n\t$ pod install\n\t$ open your-project.xcworkspace\n\t\n#### 第二种：手动集成 \n\n1、下载 SDK。[下载地址](https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip)         \n2、把 WilddogSync.Framework 拖到工程目录中。  \n3、选中 Copy items if needed 、Create Groups，点击 Finish。  \n4、点击工程文件 -> TARGETS -> General，在 Linked Frameworks and Libraries 选项中点击 '+'，将 JavaScriptCore.framework、 libsqlite3 加入列表中。\n\n\n### 初始化\n\n```objectivec\n// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的\n_wilddog = [[Wilddog alloc] initWithUrl:@\"https://danmu.wilddogio.com/message\"];\n\n```\n\n### 发送弹幕\n这里用到 Wilddog 写入数据的一个 API [childByAutoId](/api/sync/ios.html#用childByAutoId追加新节点), 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。\n\n```objectivec\n// 获取输入框的数据， 将数据写到云端 message 节点下，childByAutoId 用来定位子节点\n- (BOOL)textFieldShouldReturn:(UITextField*)aTextField\n{    \n    [[self.wilddog childByAutoId] setValue:aTextField.text];\n    \n    [aTextField setText:@\"\"];\n    \n    return NO;\n}\n\n```\n数据库中的数据结构就是这个样子的：\n![](/images/data.jpg)\n\n### 设置监听\n```objectivec\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    \n    //初始化\n    _wilddog = [[Wilddog alloc] initWithUrl:kWilddogUrl];\n    \n    _snaps = [[NSMutableArray alloc] init];\n    _originFrame = self.view.frame;\n    \n    // 设置监听\n    // 绑定 WEventTypeChildAdded 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 snapshot 对象包含了新增的数据\n    [self.wilddog observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n        \n        [self sendLabel:snapshot];\n        [self.snaps addObject:snapshot];\n        \n    }];\n    \n    //添加定时器\n    [NSTimer scheduledTimerWithTimeInterval:.5 target:self selector:@selector(timer) userInfo:nil repeats:YES];\n}\n```\n\n### 取数据\n```objectivec\n//随机取出弹幕数据\n- (void)timer\n{\n    if (_snaps.count < 2) {\n        return;\n    }\n    int index = arc4random()%(self.snaps.count-1);\n    WDataSnapshot *snapshot = [self.snaps objectAtIndex:index];\n    [self sendLabel:snapshot];\n}\n\n```\n\n### 在屏幕显示\n`WDataSnapshot` 是野狗数据的一个快照，包含着正在监听的节点下，从云端数据取下来的数据。\n\n```objectivec\n//设置随机颜色，并显示在屏幕上\n- (UILabel *)sendLabel:(WDataSnapshot *)snapshot\n{\n    float top = (arc4random()% (int)self.view.frame.size.height)-100;\n    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(self.view.frame.size.width, top, 100, 30)];\n    label.textColor = [UIColor colorWithRed:arc4random()%255/255.f green:arc4random()%255/255.f blue:arc4random()%255/255.f alpha:1];\n    label.text = snapshot.value;\n    [UIView animateWithDuration:7 animations:^{\n        label.frame = CGRectMake(-label.frame.size.width, top, 100, 30);\n    }completion:^(BOOL finished){\n        [label removeFromSuperview];\n    }];\n    [self.view addSubview:label];\n    return label;\n}\n```\n\n\n## 获取源码\n本示例只是弹幕的一种简单实现方式，你可以开动大脑，做出更优雅的实现。\n点此处获取[示例源码](https://github.com/WildDogTeam/demo-ios-danmu)。\n\n\n\n","source":"resources/sync/ios/tutorial.md","raw":"title: 实战教程\n---\n\n本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读[快速入门](/quickstart/sync/ios.html)。\n\n# 弹幕\n\n## 示例说明\n示例的最终的展示效果如下： \n![](/images/ios-danmu.png)\n\n野狗很适合做一些多端（web、iOS、android 等其他客户端）实时同步的应用，弹幕就是其中一个。使用 Wilddog SDK，百余行代码即可完全实现弹幕功能。可见 Wilddog 在实时领域的简单与强大。\n\n## 具体步骤\n\n### 引入 Wilddog iOS SDK \n\nSDK 的导入方式有两种，你可以选择下面方式的其中一种：\n\n#### 第一种：使用 CocoaPods \n要将 Wilddog SDK 导入到你的工程中，推荐使用 [CocoaPods](https://cocoapods.org/)，如果没用过 CocoaPods，请先访问 [CocoaPods getting started](https://guides.cocoapods.org/using/getting-started.html)。 \n\n\n打开工程目录，新建一个 Podfile 文件\n\n\t$ cd your-project-directory\n\t$ pod init\n\t$ open -a Xcode Podfile # opens your Podfile in XCode\n\n然后在 Podfile 文件中添加以下语句\n\n\tpod 'Wilddog'\n\t\n最后安装 SDK\n\n\t$ pod install\n\t$ open your-project.xcworkspace\n\t\n#### 第二种：手动集成 \n\n1、下载 SDK。[下载地址](https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip)         \n2、把 WilddogSync.Framework 拖到工程目录中。  \n3、选中 Copy items if needed 、Create Groups，点击 Finish。  \n4、点击工程文件 -> TARGETS -> General，在 Linked Frameworks and Libraries 选项中点击 '+'，将 JavaScriptCore.framework、 libsqlite3 加入列表中。\n\n\n### 初始化\n\n```objectivec\n// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的\n_wilddog = [[Wilddog alloc] initWithUrl:@\"https://danmu.wilddogio.com/message\"];\n\n```\n\n### 发送弹幕\n这里用到 Wilddog 写入数据的一个 API [childByAutoId](/api/sync/ios.html#用childByAutoId追加新节点), 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。\n\n```objectivec\n// 获取输入框的数据， 将数据写到云端 message 节点下，childByAutoId 用来定位子节点\n- (BOOL)textFieldShouldReturn:(UITextField*)aTextField\n{    \n    [[self.wilddog childByAutoId] setValue:aTextField.text];\n    \n    [aTextField setText:@\"\"];\n    \n    return NO;\n}\n\n```\n数据库中的数据结构就是这个样子的：\n![](/images/data.jpg)\n\n### 设置监听\n```objectivec\n- (void)viewDidLoad \n{\n    [super viewDidLoad];\n    \n    //初始化\n    _wilddog = [[Wilddog alloc] initWithUrl:kWilddogUrl];\n    \n    _snaps = [[NSMutableArray alloc] init];\n    _originFrame = self.view.frame;\n    \n    // 设置监听\n    // 绑定 WEventTypeChildAdded 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 snapshot 对象包含了新增的数据\n    [self.wilddog observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) {\n        \n        [self sendLabel:snapshot];\n        [self.snaps addObject:snapshot];\n        \n    }];\n    \n    //添加定时器\n    [NSTimer scheduledTimerWithTimeInterval:.5 target:self selector:@selector(timer) userInfo:nil repeats:YES];\n}\n```\n\n### 取数据\n```objectivec\n//随机取出弹幕数据\n- (void)timer\n{\n    if (_snaps.count < 2) {\n        return;\n    }\n    int index = arc4random()%(self.snaps.count-1);\n    WDataSnapshot *snapshot = [self.snaps objectAtIndex:index];\n    [self sendLabel:snapshot];\n}\n\n```\n\n### 在屏幕显示\n`WDataSnapshot` 是野狗数据的一个快照，包含着正在监听的节点下，从云端数据取下来的数据。\n\n```objectivec\n//设置随机颜色，并显示在屏幕上\n- (UILabel *)sendLabel:(WDataSnapshot *)snapshot\n{\n    float top = (arc4random()% (int)self.view.frame.size.height)-100;\n    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(self.view.frame.size.width, top, 100, 30)];\n    label.textColor = [UIColor colorWithRed:arc4random()%255/255.f green:arc4random()%255/255.f blue:arc4random()%255/255.f alpha:1];\n    label.text = snapshot.value;\n    [UIView animateWithDuration:7 animations:^{\n        label.frame = CGRectMake(-label.frame.size.width, top, 100, 30);\n    }completion:^(BOOL finished){\n        [label removeFromSuperview];\n    }];\n    [self.view addSubview:label];\n    return label;\n}\n```\n\n\n## 获取源码\n本示例只是弹幕的一种简单实现方式，你可以开动大脑，做出更优雅的实现。\n点此处获取[示例源码](https://github.com/WildDogTeam/demo-ios-danmu)。\n\n\n\n","date":"2016-09-06T03:38:22.554Z","updated":"2016-09-06T03:38:22.554Z","path":"resources/sync/ios/tutorial.html","comments":1,"layout":"page","_id":"cisswi9lw0026z4fwedh9867m","content":"<p>本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读<a href=\"/quickstart/sync/ios.html\">快速入门</a>。</p>\n<h1 id=\"弹幕\"><a href=\"#弹幕\" class=\"headerlink\" title=\"弹幕\"></a>弹幕</h1><h2 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h2><p>示例的最终的展示效果如下：<br><img src=\"/images/ios-danmu.png\" alt=\"\"></p>\n<p>野狗很适合做一些多端（web、iOS、android 等其他客户端）实时同步的应用，弹幕就是其中一个。使用 Wilddog SDK，百余行代码即可完全实现弹幕功能。可见 Wilddog 在实时领域的简单与强大。</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"引入-Wilddog-iOS-SDK\"><a href=\"#引入-Wilddog-iOS-SDK\" class=\"headerlink\" title=\"引入 Wilddog iOS SDK\"></a>引入 Wilddog iOS SDK</h3><p>SDK 的导入方式有两种，你可以选择下面方式的其中一种：</p>\n<h4 id=\"第一种：使用-CocoaPods\"><a href=\"#第一种：使用-CocoaPods\" class=\"headerlink\" title=\"第一种：使用 CocoaPods\"></a>第一种：使用 CocoaPods</h4><p>要将 Wilddog SDK 导入到你的工程中，推荐使用 <a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">CocoaPods</a>，如果没用过 CocoaPods，请先访问 <a href=\"https://guides.cocoapods.org/using/getting-started.html\" target=\"_blank\" rel=\"external\">CocoaPods getting started</a>。 </p>\n<p>打开工程目录，新建一个 Podfile 文件</p>\n<pre><code>$ cd your-project-directory\n$ pod init\n$ open -a Xcode Podfile # opens your Podfile in XCode\n</code></pre><p>然后在 Podfile 文件中添加以下语句</p>\n<pre><code>pod &apos;Wilddog&apos;\n</code></pre><p>最后安装 SDK</p>\n<pre><code>$ pod install\n$ open your-project.xcworkspace\n</code></pre><h4 id=\"第二种：手动集成\"><a href=\"#第二种：手动集成\" class=\"headerlink\" title=\"第二种：手动集成\"></a>第二种：手动集成</h4><p>1、下载 SDK。<a href=\"https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip\" target=\"_blank\" rel=\"external\">下载地址</a><br>2、把 WilddogSync.Framework 拖到工程目录中。<br>3、选中 Copy items if needed 、Create Groups，点击 Finish。<br>4、点击工程文件 -&gt; TARGETS -&gt; General，在 Linked Frameworks and Libraries 选项中点击 ‘+’，将 JavaScriptCore.framework、 libsqlite3 加入列表中。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的</span></div><div class=\"line\">_wilddog = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://danmu.wilddogio.com/message\"</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"发送弹幕\"><a href=\"#发送弹幕\" class=\"headerlink\" title=\"发送弹幕\"></a>发送弹幕</h3><p>这里用到 Wilddog 写入数据的一个 API <a href=\"/api/sync/ios.html#用childByAutoId追加新节点\">childByAutoId</a>, 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取输入框的数据， 将数据写到云端 message 节点下，childByAutoId 用来定位子节点</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)textFieldShouldReturn:(<span class=\"built_in\">UITextField</span>*)aTextField</div><div class=\"line\">&#123;    </div><div class=\"line\">    [[<span class=\"keyword\">self</span>.wilddog childByAutoId] setValue:aTextField.text];</div><div class=\"line\">    </div><div class=\"line\">    [aTextField setText:<span class=\"string\">@\"\"</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>数据库中的数据结构就是这个样子的：<br><img src=\"/images/data.jpg\" alt=\"\"></p>\n<h3 id=\"设置监听\"><a href=\"#设置监听\" class=\"headerlink\" title=\"设置监听\"></a>设置监听</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//初始化</span></div><div class=\"line\">    _wilddog = [[Wilddog alloc] initWithUrl:kWilddogUrl];</div><div class=\"line\">    </div><div class=\"line\">    _snaps = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</div><div class=\"line\">    _originFrame = <span class=\"keyword\">self</span>.view.frame;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 设置监听</span></div><div class=\"line\">    <span class=\"comment\">// 绑定 WEventTypeChildAdded 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 snapshot 对象包含了新增的数据</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.wilddog observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">        </div><div class=\"line\">        [<span class=\"keyword\">self</span> sendLabel:snapshot];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.snaps addObject:snapshot];</div><div class=\"line\">        </div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//添加定时器</span></div><div class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">.5</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timer) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"取数据\"><a href=\"#取数据\" class=\"headerlink\" title=\"取数据\"></a>取数据</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//随机取出弹幕数据</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)timer</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (_snaps.count &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> index = arc4random()%(<span class=\"keyword\">self</span>.snaps.count<span class=\"number\">-1</span>);</div><div class=\"line\">    WDataSnapshot *snapshot = [<span class=\"keyword\">self</span>.snaps objectAtIndex:index];</div><div class=\"line\">    [<span class=\"keyword\">self</span> sendLabel:snapshot];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"在屏幕显示\"><a href=\"#在屏幕显示\" class=\"headerlink\" title=\"在屏幕显示\"></a>在屏幕显示</h3><p><code>WDataSnapshot</code> 是野狗数据的一个快照，包含着正在监听的节点下，从云端数据取下来的数据。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置随机颜色，并显示在屏幕上</span></div><div class=\"line\">- (<span class=\"built_in\">UILabel</span> *)sendLabel:(WDataSnapshot *)snapshot</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">float</span> top = (arc4random()% (<span class=\"keyword\">int</span>)<span class=\"keyword\">self</span>.view.frame.size.height)<span class=\"number\">-100</span>;</div><div class=\"line\">    <span class=\"built_in\">UILabel</span> *label = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"keyword\">self</span>.view.frame.size.width, top, <span class=\"number\">100</span>, <span class=\"number\">30</span>)];</div><div class=\"line\">    label.textColor = [<span class=\"built_in\">UIColor</span> colorWithRed:arc4random()%<span class=\"number\">255</span>/<span class=\"number\">255.</span>f green:arc4random()%<span class=\"number\">255</span>/<span class=\"number\">255.</span>f blue:arc4random()%<span class=\"number\">255</span>/<span class=\"number\">255.</span>f alpha:<span class=\"number\">1</span>];</div><div class=\"line\">    label.text = snapshot.value;</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">7</span> animations:^&#123;</div><div class=\"line\">        label.frame = <span class=\"built_in\">CGRectMake</span>(-label.frame.size.width, top, <span class=\"number\">100</span>, <span class=\"number\">30</span>);</div><div class=\"line\">    &#125;completion:^(<span class=\"built_in\">BOOL</span> finished)&#123;</div><div class=\"line\">        [label removeFromSuperview];</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:label];</div><div class=\"line\">    <span class=\"keyword\">return</span> label;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h2><p>本示例只是弹幕的一种简单实现方式，你可以开动大脑，做出更优雅的实现。<br>点此处获取<a href=\"https://github.com/WildDogTeam/demo-ios-danmu\" target=\"_blank\" rel=\"external\">示例源码</a>。</p>\n","excerpt":"","more":"<p>本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读<a href=\"/quickstart/sync/ios.html\">快速入门</a>。</p>\n<h1 id=\"弹幕\"><a href=\"#弹幕\" class=\"headerlink\" title=\"弹幕\"></a>弹幕</h1><h2 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h2><p>示例的最终的展示效果如下：<br><img src=\"/images/ios-danmu.png\" alt=\"\"></p>\n<p>野狗很适合做一些多端（web、iOS、android 等其他客户端）实时同步的应用，弹幕就是其中一个。使用 Wilddog SDK，百余行代码即可完全实现弹幕功能。可见 Wilddog 在实时领域的简单与强大。</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"引入-Wilddog-iOS-SDK\"><a href=\"#引入-Wilddog-iOS-SDK\" class=\"headerlink\" title=\"引入 Wilddog iOS SDK\"></a>引入 Wilddog iOS SDK</h3><p>SDK 的导入方式有两种，你可以选择下面方式的其中一种：</p>\n<h4 id=\"第一种：使用-CocoaPods\"><a href=\"#第一种：使用-CocoaPods\" class=\"headerlink\" title=\"第一种：使用 CocoaPods\"></a>第一种：使用 CocoaPods</h4><p>要将 Wilddog SDK 导入到你的工程中，推荐使用 <a href=\"https://cocoapods.org/\">CocoaPods</a>，如果没用过 CocoaPods，请先访问 <a href=\"https://guides.cocoapods.org/using/getting-started.html\">CocoaPods getting started</a>。 </p>\n<p>打开工程目录，新建一个 Podfile 文件</p>\n<pre><code>$ cd your-project-directory\n$ pod init\n$ open -a Xcode Podfile # opens your Podfile in XCode\n</code></pre><p>然后在 Podfile 文件中添加以下语句</p>\n<pre><code>pod &apos;Wilddog&apos;\n</code></pre><p>最后安装 SDK</p>\n<pre><code>$ pod install\n$ open your-project.xcworkspace\n</code></pre><h4 id=\"第二种：手动集成\"><a href=\"#第二种：手动集成\" class=\"headerlink\" title=\"第二种：手动集成\"></a>第二种：手动集成</h4><p>1、下载 SDK。<a href=\"https://cdn.wilddog.com/sdk/ios/2.0.0/WilddogSync.framework-2.0.0.zip\">下载地址</a><br>2、把 WilddogSync.Framework 拖到工程目录中。<br>3、选中 Copy items if needed 、Create Groups，点击 Finish。<br>4、点击工程文件 -&gt; TARGETS -&gt; General，在 Linked Frameworks and Libraries 选项中点击 ‘+’，将 JavaScriptCore.framework、 libsqlite3 加入列表中。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的</span></div><div class=\"line\">_wilddog = [[Wilddog alloc] initWithUrl:<span class=\"string\">@\"https://danmu.wilddogio.com/message\"</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"发送弹幕\"><a href=\"#发送弹幕\" class=\"headerlink\" title=\"发送弹幕\"></a>发送弹幕</h3><p>这里用到 Wilddog 写入数据的一个 API <a href=\"/api/sync/ios.html#用childByAutoId追加新节点\">childByAutoId</a>, 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取输入框的数据， 将数据写到云端 message 节点下，childByAutoId 用来定位子节点</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)textFieldShouldReturn:(<span class=\"built_in\">UITextField</span>*)aTextField</div><div class=\"line\">&#123;    </div><div class=\"line\">    [[<span class=\"keyword\">self</span>.wilddog childByAutoId] setValue:aTextField.text];</div><div class=\"line\">    </div><div class=\"line\">    [aTextField setText:<span class=\"string\">@\"\"</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>数据库中的数据结构就是这个样子的：<br><img src=\"/images/data.jpg\" alt=\"\"></p>\n<h3 id=\"设置监听\"><a href=\"#设置监听\" class=\"headerlink\" title=\"设置监听\"></a>设置监听</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//初始化</span></div><div class=\"line\">    _wilddog = [[Wilddog alloc] initWithUrl:kWilddogUrl];</div><div class=\"line\">    </div><div class=\"line\">    _snaps = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</div><div class=\"line\">    _originFrame = <span class=\"keyword\">self</span>.view.frame;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 设置监听</span></div><div class=\"line\">    <span class=\"comment\">// 绑定 WEventTypeChildAdded 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 snapshot 对象包含了新增的数据</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.wilddog observeEventType:WEventTypeChildAdded withBlock:^(WDataSnapshot *snapshot) &#123;</div><div class=\"line\">        </div><div class=\"line\">        [<span class=\"keyword\">self</span> sendLabel:snapshot];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.snaps addObject:snapshot];</div><div class=\"line\">        </div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//添加定时器</span></div><div class=\"line\">    [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">.5</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timer) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"取数据\"><a href=\"#取数据\" class=\"headerlink\" title=\"取数据\"></a>取数据</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//随机取出弹幕数据</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)timer</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (_snaps.count &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> index = arc4random()%(<span class=\"keyword\">self</span>.snaps.count<span class=\"number\">-1</span>);</div><div class=\"line\">    WDataSnapshot *snapshot = [<span class=\"keyword\">self</span>.snaps objectAtIndex:index];</div><div class=\"line\">    [<span class=\"keyword\">self</span> sendLabel:snapshot];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"在屏幕显示\"><a href=\"#在屏幕显示\" class=\"headerlink\" title=\"在屏幕显示\"></a>在屏幕显示</h3><p><code>WDataSnapshot</code> 是野狗数据的一个快照，包含着正在监听的节点下，从云端数据取下来的数据。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置随机颜色，并显示在屏幕上</span></div><div class=\"line\">- (<span class=\"built_in\">UILabel</span> *)sendLabel:(WDataSnapshot *)snapshot</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">float</span> top = (arc4random()% (<span class=\"keyword\">int</span>)<span class=\"keyword\">self</span>.view.frame.size.height)<span class=\"number\">-100</span>;</div><div class=\"line\">    <span class=\"built_in\">UILabel</span> *label = [[<span class=\"built_in\">UILabel</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"keyword\">self</span>.view.frame.size.width, top, <span class=\"number\">100</span>, <span class=\"number\">30</span>)];</div><div class=\"line\">    label.textColor = [<span class=\"built_in\">UIColor</span> colorWithRed:arc4random()%<span class=\"number\">255</span>/<span class=\"number\">255.</span>f green:arc4random()%<span class=\"number\">255</span>/<span class=\"number\">255.</span>f blue:arc4random()%<span class=\"number\">255</span>/<span class=\"number\">255.</span>f alpha:<span class=\"number\">1</span>];</div><div class=\"line\">    label.text = snapshot.value;</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">7</span> animations:^&#123;</div><div class=\"line\">        label.frame = <span class=\"built_in\">CGRectMake</span>(-label.frame.size.width, top, <span class=\"number\">100</span>, <span class=\"number\">30</span>);</div><div class=\"line\">    &#125;completion:^(<span class=\"built_in\">BOOL</span> finished)&#123;</div><div class=\"line\">        [label removeFromSuperview];</div><div class=\"line\">    &#125;];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addSubview:label];</div><div class=\"line\">    <span class=\"keyword\">return</span> label;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h2><p>本示例只是弹幕的一种简单实现方式，你可以开动大脑，做出更优雅的实现。<br>点此处获取<a href=\"https://github.com/WildDogTeam/demo-ios-danmu\">示例源码</a>。</p>\n"},{"title":"demo库","_content":"\n## 示例源码\n\n| 示例 | 贡献者 | 说明 | \n|----|----|----| \n|<a href=\"https://github.com/WildDogTeam/demo-ios-swiftchat\" target=\"_blank\">SwiftChat</a>|野狗官方 | SwiftChat 是一个基于 Wilddog iOS SDK 开发的多人实时聊天 demo，登录之后即可聊天|\n|<a href=\"https://github.com/WildDogTeam/demo-ios-drawing\" target=\"_blank\">Drawing</a> | 野狗官方 | Drawing 是一个基于 Wilddog iOS SDK 开发的实时画图 demo，可多终端登录来一起画画，同步显示图画效果 |\n|<a href=\"https://github.com/WildDogTeam/demo-ios-weather\" target=\"_blank\">Weather</a>|野狗官方 | Weather 是一个基于 Wilddog iOS SDK 开发的修改天气状态 demo，主要实现 Wilddog 数据多设备同步修改和加载 |\n|<a href=\"https://github.com/WildDogTeam/demo-ios-danmu\" target=\"_blank\">Danmu</a>|野狗官方 | Danmu 是一个基于 Wilddog iOS SDK 实现的弹幕 |\n|<a href=\"https://github.com/WildDogTeam/demo-ios-wildchat\" target=\"_blank\">WildChat</a> |野狗官方 | WildChat 是一个基于 Wilddog iOS SDK 实现的简单聊天通讯类 APP |\n\n\n","source":"resources/sync/ios/resources.md","raw":"title:  demo库\n---\n\n## 示例源码\n\n| 示例 | 贡献者 | 说明 | \n|----|----|----| \n|<a href=\"https://github.com/WildDogTeam/demo-ios-swiftchat\" target=\"_blank\">SwiftChat</a>|野狗官方 | SwiftChat 是一个基于 Wilddog iOS SDK 开发的多人实时聊天 demo，登录之后即可聊天|\n|<a href=\"https://github.com/WildDogTeam/demo-ios-drawing\" target=\"_blank\">Drawing</a> | 野狗官方 | Drawing 是一个基于 Wilddog iOS SDK 开发的实时画图 demo，可多终端登录来一起画画，同步显示图画效果 |\n|<a href=\"https://github.com/WildDogTeam/demo-ios-weather\" target=\"_blank\">Weather</a>|野狗官方 | Weather 是一个基于 Wilddog iOS SDK 开发的修改天气状态 demo，主要实现 Wilddog 数据多设备同步修改和加载 |\n|<a href=\"https://github.com/WildDogTeam/demo-ios-danmu\" target=\"_blank\">Danmu</a>|野狗官方 | Danmu 是一个基于 Wilddog iOS SDK 实现的弹幕 |\n|<a href=\"https://github.com/WildDogTeam/demo-ios-wildchat\" target=\"_blank\">WildChat</a> |野狗官方 | WildChat 是一个基于 Wilddog iOS SDK 实现的简单聊天通讯类 APP |\n\n\n","date":"2016-09-07T13:24:23.126Z","updated":"2016-09-07T13:24:23.126Z","path":"resources/sync/ios/resources.html","_id":"cisswi9lw0027z4fw0d36wwp5","comments":1,"layout":"page","content":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>示例</th>\n<th>贡献者</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-swiftchat\" target=\"_blank\">SwiftChat</a></td>\n<td>野狗官方</td>\n<td>SwiftChat 是一个基于 Wilddog iOS SDK 开发的多人实时聊天 demo，登录之后即可聊天</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-drawing\" target=\"_blank\">Drawing</a></td>\n<td>野狗官方</td>\n<td>Drawing 是一个基于 Wilddog iOS SDK 开发的实时画图 demo，可多终端登录来一起画画，同步显示图画效果</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-weather\" target=\"_blank\">Weather</a></td>\n<td>野狗官方</td>\n<td>Weather 是一个基于 Wilddog iOS SDK 开发的修改天气状态 demo，主要实现 Wilddog 数据多设备同步修改和加载</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-danmu\" target=\"_blank\">Danmu</a></td>\n<td>野狗官方</td>\n<td>Danmu 是一个基于 Wilddog iOS SDK 实现的弹幕</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-wildchat\" target=\"_blank\">WildChat</a></td>\n<td>野狗官方</td>\n<td>WildChat 是一个基于 Wilddog iOS SDK 实现的简单聊天通讯类 APP</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>示例</th>\n<th>贡献者</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-swiftchat\" target=\"_blank\">SwiftChat</a></td>\n<td>野狗官方</td>\n<td>SwiftChat 是一个基于 Wilddog iOS SDK 开发的多人实时聊天 demo，登录之后即可聊天</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-drawing\" target=\"_blank\">Drawing</a></td>\n<td>野狗官方</td>\n<td>Drawing 是一个基于 Wilddog iOS SDK 开发的实时画图 demo，可多终端登录来一起画画，同步显示图画效果</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-weather\" target=\"_blank\">Weather</a></td>\n<td>野狗官方</td>\n<td>Weather 是一个基于 Wilddog iOS SDK 开发的修改天气状态 demo，主要实现 Wilddog 数据多设备同步修改和加载</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-danmu\" target=\"_blank\">Danmu</a></td>\n<td>野狗官方</td>\n<td>Danmu 是一个基于 Wilddog iOS SDK 实现的弹幕</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-ios-wildchat\" target=\"_blank\">WildChat</a></td>\n<td>野狗官方</td>\n<td>WildChat 是一个基于 Wilddog iOS SDK 实现的简单聊天通讯类 APP</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"实战教程","_content":"在网络飞速发展的今天，设备已经遍布各处，它们之间的通信极其重要。设备通信中最重要的是同步和更新的实时性。以物联网为例，传感器采集的数据需要实时同步到用户 APP ，以及控制中心；同时用户的操作和控制指令，也需要实时更新到设备中。\n\n本部分展示了借助 Wilddog C/嵌入式 SDK 实现一个简单的远程加法器的示例。在示例中有两个端（或抽象成设备），即网页端和客户端。在控制台网页上输入两个值，这两个值能够被实时同步到客户端。当客户端收到这两个值后，将这两个值的和计算出来，并同步到网页端。抽象到物联网设备上，网页端可以类比成用户 APP，客户端可以类比成嵌入式设备。用户 APP 发送控制命令给嵌入式设备，设备执行操作后并将结果实时反馈回用户 APP。\n\n\n# 远程计算器\n\n## 示例说明\n\n远程计算器示例的最终的效果如下：\n![](/images/c_tutorial_a.jpg)\n\n在这种多端交互的应用，即使是在嵌入式中，借助 Wilddog C/嵌入式 SDK，只需要百余行代码即可实现，足见 Wilddog 在实时领域的简单与强大。\n\n\n## 具体步骤\n\n### 建立 Wilddog 引用\n初始化一个 Wilddog 会话，该会话连接到 `YOUR_URL` 。\n```c\nWilddog_T wilddog = wilddog_initWithUrl((Wilddog_Str_T*)YOUR_URL);\n```\n\n### 监听输入\n\n监听加数和被加数对应的父节点，一旦加数和被加数被修改时，客户端会收到推送。\n注意我们监听的是操作数的父节点，收到的推送如下  '\"/\":{\"sum\":0, \"augend\":0, \"addend\":0}'\n```c\nwilddog_addObserver(wilddog,WD_ET_VALUECHANGE,(onEventFunc)addObserver_callback,(void*)wilddog);\n```\n网页端的数据结构如下：\n![](/images/c_tutorial_b.jpg)\n\n### 获取输入\n\n客户端接收到的数据节点加数 `append`、被加数`augend`和结果`sum`位于同一层级，是通过双向链表组织起来，可以遍历这个链表获取对应的节点.\n```c\n/* get node pointer according the key value */\nSTATIC Wilddog_Node_T *node_get(Wilddog_Node_T *p_head,const char* key_name)\n{\n    Wilddog_Node_T *node = p_head;\n    u8 len = 0;\n    while(node )\n    {\n        if( node->p_wn_key )\n        {\n            /* get the short len*/\n            len = strlen((const char*)key_name)>strlen((const char*)node->p_wn_key)\\\n                    ?strlen((const char*)node->p_wn_key):strlen((const char*)key_name);\n            if( !memcmp(key_name,node->p_wn_key,len))\n                return node;\n        }\n        node=node->p_wn_next;\n        if(node == p_head)\n            return NULL;\n    }\n    return NULL;\n}\n```\n利用wilddog_node_getValue() 方法获取它们的 value 如下 ： \n```c\n    Wilddog_Node_T *p_augend = node_get(p_node,\"augend\");\n    Wilddog_Node_T *p_addend = node_get(p_node,\"append\");\n    Wilddog_Node_T *p_sum = node_get(p_node,\"sum\");\n    s32 augend = *(s32*)wilddog_node_getValue(p_augend,&len);   \n    s32 addend = *(s32*)wilddog_node_getValue(p_addend,&len);\n```\n\n### 推送计算结果到服务端\n通过 `wilddog_node_setValue()` 方法设置`sum`节点对应的 `value` ，并调用 `wilddog_setValue` 把数据推送到服务端。\n\n```c\ns32 sum = augend + addend;\nwilddog_node_setValue(p_sum,(u8*)&sum,sizeof(sum));\nwilddog_setValue(wilddog,(Wilddog_Node_T*)p_newdata,sumSet_callback,NULL);\n```\n\n## 获取源码\n本示例只是一个简单的远程计算器，展示如何利用 Wilddog C/嵌入式 SDK 构建一个多端的实时应用，你可以动手利用 Wilddog 和硬件构建更加有意思的实时应用。\n点此查看完整的[示例源码](https://github.com/skylli/demo-c-doc4.git)。\n\n\n\n","source":"resources/sync/c/tutorial.md","raw":"title: 实战教程\n---\n在网络飞速发展的今天，设备已经遍布各处，它们之间的通信极其重要。设备通信中最重要的是同步和更新的实时性。以物联网为例，传感器采集的数据需要实时同步到用户 APP ，以及控制中心；同时用户的操作和控制指令，也需要实时更新到设备中。\n\n本部分展示了借助 Wilddog C/嵌入式 SDK 实现一个简单的远程加法器的示例。在示例中有两个端（或抽象成设备），即网页端和客户端。在控制台网页上输入两个值，这两个值能够被实时同步到客户端。当客户端收到这两个值后，将这两个值的和计算出来，并同步到网页端。抽象到物联网设备上，网页端可以类比成用户 APP，客户端可以类比成嵌入式设备。用户 APP 发送控制命令给嵌入式设备，设备执行操作后并将结果实时反馈回用户 APP。\n\n\n# 远程计算器\n\n## 示例说明\n\n远程计算器示例的最终的效果如下：\n![](/images/c_tutorial_a.jpg)\n\n在这种多端交互的应用，即使是在嵌入式中，借助 Wilddog C/嵌入式 SDK，只需要百余行代码即可实现，足见 Wilddog 在实时领域的简单与强大。\n\n\n## 具体步骤\n\n### 建立 Wilddog 引用\n初始化一个 Wilddog 会话，该会话连接到 `YOUR_URL` 。\n```c\nWilddog_T wilddog = wilddog_initWithUrl((Wilddog_Str_T*)YOUR_URL);\n```\n\n### 监听输入\n\n监听加数和被加数对应的父节点，一旦加数和被加数被修改时，客户端会收到推送。\n注意我们监听的是操作数的父节点，收到的推送如下  '\"/\":{\"sum\":0, \"augend\":0, \"addend\":0}'\n```c\nwilddog_addObserver(wilddog,WD_ET_VALUECHANGE,(onEventFunc)addObserver_callback,(void*)wilddog);\n```\n网页端的数据结构如下：\n![](/images/c_tutorial_b.jpg)\n\n### 获取输入\n\n客户端接收到的数据节点加数 `append`、被加数`augend`和结果`sum`位于同一层级，是通过双向链表组织起来，可以遍历这个链表获取对应的节点.\n```c\n/* get node pointer according the key value */\nSTATIC Wilddog_Node_T *node_get(Wilddog_Node_T *p_head,const char* key_name)\n{\n    Wilddog_Node_T *node = p_head;\n    u8 len = 0;\n    while(node )\n    {\n        if( node->p_wn_key )\n        {\n            /* get the short len*/\n            len = strlen((const char*)key_name)>strlen((const char*)node->p_wn_key)\\\n                    ?strlen((const char*)node->p_wn_key):strlen((const char*)key_name);\n            if( !memcmp(key_name,node->p_wn_key,len))\n                return node;\n        }\n        node=node->p_wn_next;\n        if(node == p_head)\n            return NULL;\n    }\n    return NULL;\n}\n```\n利用wilddog_node_getValue() 方法获取它们的 value 如下 ： \n```c\n    Wilddog_Node_T *p_augend = node_get(p_node,\"augend\");\n    Wilddog_Node_T *p_addend = node_get(p_node,\"append\");\n    Wilddog_Node_T *p_sum = node_get(p_node,\"sum\");\n    s32 augend = *(s32*)wilddog_node_getValue(p_augend,&len);   \n    s32 addend = *(s32*)wilddog_node_getValue(p_addend,&len);\n```\n\n### 推送计算结果到服务端\n通过 `wilddog_node_setValue()` 方法设置`sum`节点对应的 `value` ，并调用 `wilddog_setValue` 把数据推送到服务端。\n\n```c\ns32 sum = augend + addend;\nwilddog_node_setValue(p_sum,(u8*)&sum,sizeof(sum));\nwilddog_setValue(wilddog,(Wilddog_Node_T*)p_newdata,sumSet_callback,NULL);\n```\n\n## 获取源码\n本示例只是一个简单的远程计算器，展示如何利用 Wilddog C/嵌入式 SDK 构建一个多端的实时应用，你可以动手利用 Wilddog 和硬件构建更加有意思的实时应用。\n点此查看完整的[示例源码](https://github.com/skylli/demo-c-doc4.git)。\n\n\n\n","date":"2016-09-06T03:38:22.553Z","updated":"2016-09-06T03:38:22.553Z","path":"resources/sync/c/tutorial.html","comments":1,"layout":"page","_id":"cisswi9lw0028z4fwdhzd85du","content":"<p>在网络飞速发展的今天，设备已经遍布各处，它们之间的通信极其重要。设备通信中最重要的是同步和更新的实时性。以物联网为例，传感器采集的数据需要实时同步到用户 APP ，以及控制中心；同时用户的操作和控制指令，也需要实时更新到设备中。</p>\n<p>本部分展示了借助 Wilddog C/嵌入式 SDK 实现一个简单的远程加法器的示例。在示例中有两个端（或抽象成设备），即网页端和客户端。在控制台网页上输入两个值，这两个值能够被实时同步到客户端。当客户端收到这两个值后，将这两个值的和计算出来，并同步到网页端。抽象到物联网设备上，网页端可以类比成用户 APP，客户端可以类比成嵌入式设备。用户 APP 发送控制命令给嵌入式设备，设备执行操作后并将结果实时反馈回用户 APP。</p>\n<h1 id=\"远程计算器\"><a href=\"#远程计算器\" class=\"headerlink\" title=\"远程计算器\"></a>远程计算器</h1><h2 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h2><p>远程计算器示例的最终的效果如下：<br><img src=\"/images/c_tutorial_a.jpg\" alt=\"\"></p>\n<p>在这种多端交互的应用，即使是在嵌入式中，借助 Wilddog C/嵌入式 SDK，只需要百余行代码即可实现，足见 Wilddog 在实时领域的简单与强大。</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"建立-Wilddog-引用\"><a href=\"#建立-Wilddog-引用\" class=\"headerlink\" title=\"建立 Wilddog 引用\"></a>建立 Wilddog 引用</h3><p>初始化一个 Wilddog 会话，该会话连接到 <code>YOUR_URL</code> 。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_T wilddog = wilddog_initWithUrl((Wilddog_Str_T*)YOUR_URL);</div></pre></td></tr></table></figure></p>\n<h3 id=\"监听输入\"><a href=\"#监听输入\" class=\"headerlink\" title=\"监听输入\"></a>监听输入</h3><p>监听加数和被加数对应的父节点，一旦加数和被加数被修改时，客户端会收到推送。<br>注意我们监听的是操作数的父节点，收到的推送如下  ‘“/“:{“sum”:0, “augend”:0, “addend”:0}’<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_addObserver(wilddog,WD_ET_VALUECHANGE,(onEventFunc)addObserver_callback,(<span class=\"keyword\">void</span>*)wilddog);</div></pre></td></tr></table></figure></p>\n<p>网页端的数据结构如下：<br><img src=\"/images/c_tutorial_b.jpg\" alt=\"\"></p>\n<h3 id=\"获取输入\"><a href=\"#获取输入\" class=\"headerlink\" title=\"获取输入\"></a>获取输入</h3><p>客户端接收到的数据节点加数 <code>append</code>、被加数<code>augend</code>和结果<code>sum</code>位于同一层级，是通过双向链表组织起来，可以遍历这个链表获取对应的节点.<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* get node pointer according the key value */</span></div><div class=\"line\"><span class=\"function\">STATIC Wilddog_Node_T *<span class=\"title\">node_get</span><span class=\"params\">(Wilddog_Node_T *p_head,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* key_name)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    Wilddog_Node_T *node = p_head;</div><div class=\"line\">    u8 len = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(node )</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( node-&gt;p_wn_key )</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">/* get the short len*/</span></div><div class=\"line\">            len = <span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)key_name)&gt;<span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)node-&gt;p_wn_key)\\</div><div class=\"line\">                    ?<span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)node-&gt;p_wn_key):<span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)key_name);</div><div class=\"line\">            <span class=\"keyword\">if</span>( !<span class=\"built_in\">memcmp</span>(key_name,node-&gt;p_wn_key,len))</div><div class=\"line\">                <span class=\"keyword\">return</span> node;</div><div class=\"line\">        &#125;</div><div class=\"line\">        node=node-&gt;p_wn_next;</div><div class=\"line\">        <span class=\"keyword\">if</span>(node == p_head)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>利用wilddog_node_getValue() 方法获取它们的 value 如下 ：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_augend = node_get(p_node,<span class=\"string\">\"augend\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_addend = node_get(p_node,<span class=\"string\">\"append\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_sum = node_get(p_node,<span class=\"string\">\"sum\"</span>);</div><div class=\"line\">s32 augend = *(s32*)wilddog_node_getValue(p_augend,&amp;len);   </div><div class=\"line\">s32 addend = *(s32*)wilddog_node_getValue(p_addend,&amp;len);</div></pre></td></tr></table></figure></p>\n<h3 id=\"推送计算结果到服务端\"><a href=\"#推送计算结果到服务端\" class=\"headerlink\" title=\"推送计算结果到服务端\"></a>推送计算结果到服务端</h3><p>通过 <code>wilddog_node_setValue()</code> 方法设置<code>sum</code>节点对应的 <code>value</code> ，并调用 <code>wilddog_setValue</code> 把数据推送到服务端。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">s32 sum = augend + addend;</div><div class=\"line\">wilddog_node_setValue(p_sum,(u8*)&amp;sum,<span class=\"keyword\">sizeof</span>(sum));</div><div class=\"line\">wilddog_setValue(wilddog,(Wilddog_Node_T*)p_newdata,sumSet_callback,<span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h2><p>本示例只是一个简单的远程计算器，展示如何利用 Wilddog C/嵌入式 SDK 构建一个多端的实时应用，你可以动手利用 Wilddog 和硬件构建更加有意思的实时应用。<br>点此查看完整的<a href=\"https://github.com/skylli/demo-c-doc4.git\" target=\"_blank\" rel=\"external\">示例源码</a>。</p>\n","excerpt":"","more":"<p>在网络飞速发展的今天，设备已经遍布各处，它们之间的通信极其重要。设备通信中最重要的是同步和更新的实时性。以物联网为例，传感器采集的数据需要实时同步到用户 APP ，以及控制中心；同时用户的操作和控制指令，也需要实时更新到设备中。</p>\n<p>本部分展示了借助 Wilddog C/嵌入式 SDK 实现一个简单的远程加法器的示例。在示例中有两个端（或抽象成设备），即网页端和客户端。在控制台网页上输入两个值，这两个值能够被实时同步到客户端。当客户端收到这两个值后，将这两个值的和计算出来，并同步到网页端。抽象到物联网设备上，网页端可以类比成用户 APP，客户端可以类比成嵌入式设备。用户 APP 发送控制命令给嵌入式设备，设备执行操作后并将结果实时反馈回用户 APP。</p>\n<h1 id=\"远程计算器\"><a href=\"#远程计算器\" class=\"headerlink\" title=\"远程计算器\"></a>远程计算器</h1><h2 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h2><p>远程计算器示例的最终的效果如下：<br><img src=\"/images/c_tutorial_a.jpg\" alt=\"\"></p>\n<p>在这种多端交互的应用，即使是在嵌入式中，借助 Wilddog C/嵌入式 SDK，只需要百余行代码即可实现，足见 Wilddog 在实时领域的简单与强大。</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"建立-Wilddog-引用\"><a href=\"#建立-Wilddog-引用\" class=\"headerlink\" title=\"建立 Wilddog 引用\"></a>建立 Wilddog 引用</h3><p>初始化一个 Wilddog 会话，该会话连接到 <code>YOUR_URL</code> 。<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_T wilddog = wilddog_initWithUrl((Wilddog_Str_T*)YOUR_URL);</div></pre></td></tr></table></figure></p>\n<h3 id=\"监听输入\"><a href=\"#监听输入\" class=\"headerlink\" title=\"监听输入\"></a>监听输入</h3><p>监听加数和被加数对应的父节点，一旦加数和被加数被修改时，客户端会收到推送。<br>注意我们监听的是操作数的父节点，收到的推送如下  ‘“/“:{“sum”:0, “augend”:0, “addend”:0}’<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">wilddog_addObserver(wilddog,WD_ET_VALUECHANGE,(onEventFunc)addObserver_callback,(<span class=\"keyword\">void</span>*)wilddog);</div></pre></td></tr></table></figure></p>\n<p>网页端的数据结构如下：<br><img src=\"/images/c_tutorial_b.jpg\" alt=\"\"></p>\n<h3 id=\"获取输入\"><a href=\"#获取输入\" class=\"headerlink\" title=\"获取输入\"></a>获取输入</h3><p>客户端接收到的数据节点加数 <code>append</code>、被加数<code>augend</code>和结果<code>sum</code>位于同一层级，是通过双向链表组织起来，可以遍历这个链表获取对应的节点.<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* get node pointer according the key value */</span></div><div class=\"line\"><span class=\"function\">STATIC Wilddog_Node_T *<span class=\"title\">node_get</span><span class=\"params\">(Wilddog_Node_T *p_head,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* key_name)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    Wilddog_Node_T *node = p_head;</div><div class=\"line\">    u8 len = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(node )</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( node-&gt;p_wn_key )</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">/* get the short len*/</span></div><div class=\"line\">            len = <span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)key_name)&gt;<span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)node-&gt;p_wn_key)\\</div><div class=\"line\">                    ?<span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)node-&gt;p_wn_key):<span class=\"built_in\">strlen</span>((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*)key_name);</div><div class=\"line\">            <span class=\"keyword\">if</span>( !<span class=\"built_in\">memcmp</span>(key_name,node-&gt;p_wn_key,len))</div><div class=\"line\">                <span class=\"keyword\">return</span> node;</div><div class=\"line\">        &#125;</div><div class=\"line\">        node=node-&gt;p_wn_next;</div><div class=\"line\">        <span class=\"keyword\">if</span>(node == p_head)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>利用wilddog_node_getValue() 方法获取它们的 value 如下 ：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">Wilddog_Node_T *p_augend = node_get(p_node,<span class=\"string\">\"augend\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_addend = node_get(p_node,<span class=\"string\">\"append\"</span>);</div><div class=\"line\">Wilddog_Node_T *p_sum = node_get(p_node,<span class=\"string\">\"sum\"</span>);</div><div class=\"line\">s32 augend = *(s32*)wilddog_node_getValue(p_augend,&amp;len);   </div><div class=\"line\">s32 addend = *(s32*)wilddog_node_getValue(p_addend,&amp;len);</div></pre></td></tr></table></figure></p>\n<h3 id=\"推送计算结果到服务端\"><a href=\"#推送计算结果到服务端\" class=\"headerlink\" title=\"推送计算结果到服务端\"></a>推送计算结果到服务端</h3><p>通过 <code>wilddog_node_setValue()</code> 方法设置<code>sum</code>节点对应的 <code>value</code> ，并调用 <code>wilddog_setValue</code> 把数据推送到服务端。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">s32 sum = augend + addend;</div><div class=\"line\">wilddog_node_setValue(p_sum,(u8*)&amp;sum,<span class=\"keyword\">sizeof</span>(sum));</div><div class=\"line\">wilddog_setValue(wilddog,(Wilddog_Node_T*)p_newdata,sumSet_callback,<span class=\"literal\">NULL</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h2><p>本示例只是一个简单的远程计算器，展示如何利用 Wilddog C/嵌入式 SDK 构建一个多端的实时应用，你可以动手利用 Wilddog 和硬件构建更加有意思的实时应用。<br>点此查看完整的<a href=\"https://github.com/skylli/demo-c-doc4.git\">示例源码</a>。</p>\n"},{"title":"demo库","_content":"\n## 示例源码\n\n名称 | 描述\n----|------\n[Drawing](https://github.com/WildDogTeam/demo-js-drawing) | Drawing 是一个使用Wilddog实现的画图示例。一端用户用在canvas上画图，笔画会实时传输到其他客户端，可以多人协作一起画图！\n[Star Wars](https://github.com/WildDogTeam/demo-js-starwars) | Star Wars 是一个基于Wilddog JavaScript SDK实现的多人实时对战游戏。可以匿名对战，也可以使用微信帐号登陆，以便于在积分排行榜上留名。\n[Danmu](https://github.com/WildDogTeam/demo-js-danmu) | Danmu 是一个基于Wilddog JavaScript SDK实现的弹幕。","source":"resources/sync/web/resources.md","raw":"title:  demo库\n---\n\n## 示例源码\n\n名称 | 描述\n----|------\n[Drawing](https://github.com/WildDogTeam/demo-js-drawing) | Drawing 是一个使用Wilddog实现的画图示例。一端用户用在canvas上画图，笔画会实时传输到其他客户端，可以多人协作一起画图！\n[Star Wars](https://github.com/WildDogTeam/demo-js-starwars) | Star Wars 是一个基于Wilddog JavaScript SDK实现的多人实时对战游戏。可以匿名对战，也可以使用微信帐号登陆，以便于在积分排行榜上留名。\n[Danmu](https://github.com/WildDogTeam/demo-js-danmu) | Danmu 是一个基于Wilddog JavaScript SDK实现的弹幕。","date":"2016-09-07T13:24:23.128Z","updated":"2016-09-07T13:24:23.128Z","path":"resources/sync/web/resources.html","_id":"cisswi9lw0029z4fwg5b73gki","comments":1,"layout":"page","content":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-js-drawing\" target=\"_blank\" rel=\"external\">Drawing</a></td>\n<td>Drawing 是一个使用Wilddog实现的画图示例。一端用户用在canvas上画图，笔画会实时传输到其他客户端，可以多人协作一起画图！</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-js-starwars\" target=\"_blank\" rel=\"external\">Star Wars</a></td>\n<td>Star Wars 是一个基于Wilddog JavaScript SDK实现的多人实时对战游戏。可以匿名对战，也可以使用微信帐号登陆，以便于在积分排行榜上留名。</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-js-danmu\" target=\"_blank\" rel=\"external\">Danmu</a></td>\n<td>Danmu 是一个基于Wilddog JavaScript SDK实现的弹幕。</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h2 id=\"示例源码\"><a href=\"#示例源码\" class=\"headerlink\" title=\"示例源码\"></a>示例源码</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-js-drawing\">Drawing</a></td>\n<td>Drawing 是一个使用Wilddog实现的画图示例。一端用户用在canvas上画图，笔画会实时传输到其他客户端，可以多人协作一起画图！</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-js-starwars\">Star Wars</a></td>\n<td>Star Wars 是一个基于Wilddog JavaScript SDK实现的多人实时对战游戏。可以匿名对战，也可以使用微信帐号登陆，以便于在积分排行榜上留名。</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/WildDogTeam/demo-js-danmu\">Danmu</a></td>\n<td>Danmu 是一个基于Wilddog JavaScript SDK实现的弹幕。</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"实战教程","_content":"\n本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读[快速入门](/quickstart/sync/web.html)。\n\n# 弹幕\n\n## 示例说明\n示例的最终的展示效果如下：\n![](/images/display.jpg)\n\n与平常见到的弹幕一样，可多端互动。使用 Wilddog SDK，百余行代码即可完全实现。可见 Wilddog 在实时领域的简单与强大。\n\n## 具体步骤\n\n### 引入 Wilddog js SDK\n\n```js\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\"></script>\n```\n### “说点什么” 与 “发射”\n\n这里用到 Wilddog 写入数据的一个 API [push()](/guide/sync/web/save-data.html#追加新节点), 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。\n```js\n// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的\nvar config = {\n  authDomain: \"danmu.wilddog.com\",\n  syncURL: \"https://danmu.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\n// 获取输入框的数据\nvar text = $(\".s_txt\").val();\n// 将数据写到云端 message 节点下，child 用来定位子节点\nref.child('message').push(text);\n```\n数据库中的数据结构就是这个样子的：\n![](/images/data.jpg)\n\n### “清屏”\n就是删除数据，定位到节点下调用 API `remove()` 即可。\n\n```js\nref.remove();\n```\n### 在窗口显示\n即读取数据，Wilddog [获取数据](/guide/sync/web/retrieve-data.html)是先绑定监听事件，然后在回调函数中获取数据：\n\n```js\n// 绑定 'child_added' 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 `snapshot` 对象包含了新增的数据\nref.child('message').on('child_added', function(snapshot) {\n\tvar text = snapshot.val();\n});\n```\n如果有人“清屏”了，如何获取这个事件呢？与上面的 `'child_added'` 类似，有个 `'child_removed'` 事件：\n```js\nref.on('child_removed', function(snapshot) {\n\n});\n```\n用到的相关 Wilddog API 就这么多，接下来就是弹幕相关的特定实现了。\n\n\n### 画出页面轮廓\n只是牵涉到 web 页面的基础知识，这里不再叙述，可直接到最下方查看源码。\n\n### 滚动及逐行显示\n\n```js\nvar arr = [];\t\t\t\t\t\t// 此数组用来存放所有的消息元素\nvar topMin = $('.d_mask').offset().top; \t // 显示框距顶部距离\nvar topMax = topMin + $('.d_mask').height(); // 显示框底部距顶部距离\nvar _top = topMin; // 每个滚动消息距顶部距离\n\nvar moveObj = function(obj) {\n\tvar _left = $('.d_mask').width() - obj.width();\n\t_top = _top + 50;\n\tif (_top > (topMax - 50)) {\n\t\t_top = topMin;\n\t}\n\tobj.css({\n\t\tleft : _left,\n\t\ttop : _top,\n\t\tcolor : getRandomColor()  // 获取随机颜色，之后讲\n\t});\n\tvar time = 20000 + 10000 * Math.random();\n\t// animate() 方法执行 CSS 属性集的自定义动画。逐渐改变的，这样就可以创建动画效果。\n\tobj.animate({\t\t\t\t\t\t\t\t\n\t\tleft : \"-\" + _left + \"px\"  // 让消息距左距离逐渐减小，产生右向左滚动动画。\n\t}, time, function() {\n\t\tobj.remove();\n\t});\n}\n```\n\n### 每3s随机选取一条消息播放\n\n```js\nvar getAndRun = function() {\n\tif (arr.length > 0) {\n\t\tvar n = Math.floor(Math.random() * arr.length + 1) - 1;\n\t\tvar textObj = $(\"<div>\" + arr[n] + \"</div>\");\n\t\t$(\".d_show\").append(textObj);\n\t\tmoveObj(textObj);\n\t}\n\n\tsetTimeout(getAndRun, 3000);\n}\n```\n\n### 生成随机颜色\n\n```js\nvar getRandomColor = function() {\n\treturn '#' + (function(h) {\n\t\treturn new Array(7 - h.length).join(\"0\") + h\n\t})((Math.random() * 0x1000000 << 0).toString(16))\n}\n```\n\n\n\n","source":"resources/sync/web/tutorial.md","raw":"title: 实战教程\n---\n\n本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读[快速入门](/quickstart/sync/web.html)。\n\n# 弹幕\n\n## 示例说明\n示例的最终的展示效果如下：\n![](/images/display.jpg)\n\n与平常见到的弹幕一样，可多端互动。使用 Wilddog SDK，百余行代码即可完全实现。可见 Wilddog 在实时领域的简单与强大。\n\n## 具体步骤\n\n### 引入 Wilddog js SDK\n\n```js\n<script type=\"text/javascript\" src=\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\"></script>\n```\n### “说点什么” 与 “发射”\n\n这里用到 Wilddog 写入数据的一个 API [push()](/guide/sync/web/save-data.html#追加新节点), 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。\n```js\n// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的\nvar config = {\n  authDomain: \"danmu.wilddog.com\",\n  syncURL: \"https://danmu.wilddogio.com\"\n};\nwilddog.initializeApp(config);\nvar ref = wilddog.sync().ref();\n\n// 获取输入框的数据\nvar text = $(\".s_txt\").val();\n// 将数据写到云端 message 节点下，child 用来定位子节点\nref.child('message').push(text);\n```\n数据库中的数据结构就是这个样子的：\n![](/images/data.jpg)\n\n### “清屏”\n就是删除数据，定位到节点下调用 API `remove()` 即可。\n\n```js\nref.remove();\n```\n### 在窗口显示\n即读取数据，Wilddog [获取数据](/guide/sync/web/retrieve-data.html)是先绑定监听事件，然后在回调函数中获取数据：\n\n```js\n// 绑定 'child_added' 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 `snapshot` 对象包含了新增的数据\nref.child('message').on('child_added', function(snapshot) {\n\tvar text = snapshot.val();\n});\n```\n如果有人“清屏”了，如何获取这个事件呢？与上面的 `'child_added'` 类似，有个 `'child_removed'` 事件：\n```js\nref.on('child_removed', function(snapshot) {\n\n});\n```\n用到的相关 Wilddog API 就这么多，接下来就是弹幕相关的特定实现了。\n\n\n### 画出页面轮廓\n只是牵涉到 web 页面的基础知识，这里不再叙述，可直接到最下方查看源码。\n\n### 滚动及逐行显示\n\n```js\nvar arr = [];\t\t\t\t\t\t// 此数组用来存放所有的消息元素\nvar topMin = $('.d_mask').offset().top; \t // 显示框距顶部距离\nvar topMax = topMin + $('.d_mask').height(); // 显示框底部距顶部距离\nvar _top = topMin; // 每个滚动消息距顶部距离\n\nvar moveObj = function(obj) {\n\tvar _left = $('.d_mask').width() - obj.width();\n\t_top = _top + 50;\n\tif (_top > (topMax - 50)) {\n\t\t_top = topMin;\n\t}\n\tobj.css({\n\t\tleft : _left,\n\t\ttop : _top,\n\t\tcolor : getRandomColor()  // 获取随机颜色，之后讲\n\t});\n\tvar time = 20000 + 10000 * Math.random();\n\t// animate() 方法执行 CSS 属性集的自定义动画。逐渐改变的，这样就可以创建动画效果。\n\tobj.animate({\t\t\t\t\t\t\t\t\n\t\tleft : \"-\" + _left + \"px\"  // 让消息距左距离逐渐减小，产生右向左滚动动画。\n\t}, time, function() {\n\t\tobj.remove();\n\t});\n}\n```\n\n### 每3s随机选取一条消息播放\n\n```js\nvar getAndRun = function() {\n\tif (arr.length > 0) {\n\t\tvar n = Math.floor(Math.random() * arr.length + 1) - 1;\n\t\tvar textObj = $(\"<div>\" + arr[n] + \"</div>\");\n\t\t$(\".d_show\").append(textObj);\n\t\tmoveObj(textObj);\n\t}\n\n\tsetTimeout(getAndRun, 3000);\n}\n```\n\n### 生成随机颜色\n\n```js\nvar getRandomColor = function() {\n\treturn '#' + (function(h) {\n\t\treturn new Array(7 - h.length).join(\"0\") + h\n\t})((Math.random() * 0x1000000 << 0).toString(16))\n}\n```\n\n\n\n","date":"2016-09-06T09:00:14.845Z","updated":"2016-09-06T09:00:14.845Z","path":"resources/sync/web/tutorial.html","comments":1,"layout":"page","_id":"cisswi9lw002az4fw2u893mr0","content":"<p>本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读<a href=\"/quickstart/sync/web.html\">快速入门</a>。</p>\n<h1 id=\"弹幕\"><a href=\"#弹幕\" class=\"headerlink\" title=\"弹幕\"></a>弹幕</h1><h2 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h2><p>示例的最终的展示效果如下：<br><img src=\"/images/display.jpg\" alt=\"\"></p>\n<p>与平常见到的弹幕一样，可多端互动。使用 Wilddog SDK，百余行代码即可完全实现。可见 Wilddog 在实时领域的简单与强大。</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"引入-Wilddog-js-SDK\"><a href=\"#引入-Wilddog-js-SDK\" class=\"headerlink\" title=\"引入 Wilddog js SDK\"></a>引入 Wilddog js SDK</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<h3 id=\"“说点什么”-与-“发射”\"><a href=\"#“说点什么”-与-“发射”\" class=\"headerlink\" title=\"“说点什么” 与 “发射”\"></a>“说点什么” 与 “发射”</h3><p>这里用到 Wilddog 写入数据的一个 API <a href=\"/guide/sync/web/save-data.html#追加新节点\">push()</a>, 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"danmu.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://danmu.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取输入框的数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> text = $(<span class=\"string\">\".s_txt\"</span>).val();</div><div class=\"line\"><span class=\"comment\">// 将数据写到云端 message 节点下，child 用来定位子节点</span></div><div class=\"line\">ref.child(<span class=\"string\">'message'</span>).push(text);</div></pre></td></tr></table></figure></p>\n<p>数据库中的数据结构就是这个样子的：<br><img src=\"/images/data.jpg\" alt=\"\"></p>\n<h3 id=\"“清屏”\"><a href=\"#“清屏”\" class=\"headerlink\" title=\"“清屏”\"></a>“清屏”</h3><p>就是删除数据，定位到节点下调用 API <code>remove()</code> 即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.remove();</div></pre></td></tr></table></figure>\n<h3 id=\"在窗口显示\"><a href=\"#在窗口显示\" class=\"headerlink\" title=\"在窗口显示\"></a>在窗口显示</h3><p>即读取数据，Wilddog <a href=\"/guide/sync/web/retrieve-data.html\">获取数据</a>是先绑定监听事件，然后在回调函数中获取数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 绑定 'child_added' 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 `snapshot` 对象包含了新增的数据</span></div><div class=\"line\">ref.child(<span class=\"string\">'message'</span>).on(<span class=\"string\">'child_added'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> text = snapshot.val();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果有人“清屏”了，如何获取这个事件呢？与上面的 <code>&#39;child_added&#39;</code> 类似，有个 <code>&#39;child_removed&#39;</code> 事件：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.on(<span class=\"string\">'child_removed'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>用到的相关 Wilddog API 就这么多，接下来就是弹幕相关的特定实现了。</p>\n<h3 id=\"画出页面轮廓\"><a href=\"#画出页面轮廓\" class=\"headerlink\" title=\"画出页面轮廓\"></a>画出页面轮廓</h3><p>只是牵涉到 web 页面的基础知识，这里不再叙述，可直接到最下方查看源码。</p>\n<h3 id=\"滚动及逐行显示\"><a href=\"#滚动及逐行显示\" class=\"headerlink\" title=\"滚动及逐行显示\"></a>滚动及逐行显示</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [];\t\t\t\t\t\t<span class=\"comment\">// 此数组用来存放所有的消息元素</span></div><div class=\"line\"><span class=\"keyword\">var</span> topMin = $(<span class=\"string\">'.d_mask'</span>).offset().top; \t <span class=\"comment\">// 显示框距顶部距离</span></div><div class=\"line\"><span class=\"keyword\">var</span> topMax = topMin + $(<span class=\"string\">'.d_mask'</span>).height(); <span class=\"comment\">// 显示框底部距顶部距离</span></div><div class=\"line\"><span class=\"keyword\">var</span> _top = topMin; <span class=\"comment\">// 每个滚动消息距顶部距离</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> moveObj = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> _left = $(<span class=\"string\">'.d_mask'</span>).width() - obj.width();</div><div class=\"line\">\t_top = _top + <span class=\"number\">50</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (_top &gt; (topMax - <span class=\"number\">50</span>)) &#123;</div><div class=\"line\">\t\t_top = topMin;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tobj.css(&#123;</div><div class=\"line\">\t\tleft : _left,</div><div class=\"line\">\t\ttop : _top,</div><div class=\"line\">\t\tcolor : getRandomColor()  <span class=\"comment\">// 获取随机颜色，之后讲</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t<span class=\"keyword\">var</span> time = <span class=\"number\">20000</span> + <span class=\"number\">10000</span> * <span class=\"built_in\">Math</span>.random();</div><div class=\"line\">\t<span class=\"comment\">// animate() 方法执行 CSS 属性集的自定义动画。逐渐改变的，这样就可以创建动画效果。</span></div><div class=\"line\">\tobj.animate(&#123;\t\t\t\t\t\t\t\t</div><div class=\"line\">\t\tleft : <span class=\"string\">\"-\"</span> + _left + <span class=\"string\">\"px\"</span>  <span class=\"comment\">// 让消息距左距离逐渐减小，产生右向左滚动动画。</span></div><div class=\"line\">\t&#125;, time, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tobj.remove();</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"每3s随机选取一条消息播放\"><a href=\"#每3s随机选取一条消息播放\" class=\"headerlink\" title=\"每3s随机选取一条消息播放\"></a>每3s随机选取一条消息播放</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getAndRun = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (arr.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> n = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * arr.length + <span class=\"number\">1</span>) - <span class=\"number\">1</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> textObj = $(<span class=\"string\">\"&lt;div&gt;\"</span> + arr[n] + <span class=\"string\">\"&lt;/div&gt;\"</span>);</div><div class=\"line\">\t\t$(<span class=\"string\">\".d_show\"</span>).append(textObj);</div><div class=\"line\">\t\tmoveObj(textObj);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tsetTimeout(getAndRun, <span class=\"number\">3000</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"生成随机颜色\"><a href=\"#生成随机颜色\" class=\"headerlink\" title=\"生成随机颜色\"></a>生成随机颜色</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getRandomColor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">h</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">7</span> - h.length).join(<span class=\"string\">\"0\"</span>) + h</div><div class=\"line\">\t&#125;)((<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0x1000000</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>本部分内容将给出一些详尽的示例教程。一些基础教程如创建应用、读写数据这里不再重复，不了解的话请先阅读<a href=\"/quickstart/sync/web.html\">快速入门</a>。</p>\n<h1 id=\"弹幕\"><a href=\"#弹幕\" class=\"headerlink\" title=\"弹幕\"></a>弹幕</h1><h2 id=\"示例说明\"><a href=\"#示例说明\" class=\"headerlink\" title=\"示例说明\"></a>示例说明</h2><p>示例的最终的展示效果如下：<br><img src=\"/images/display.jpg\" alt=\"\"></p>\n<p>与平常见到的弹幕一样，可多端互动。使用 Wilddog SDK，百余行代码即可完全实现。可见 Wilddog 在实时领域的简单与强大。</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"引入-Wilddog-js-SDK\"><a href=\"#引入-Wilddog-js-SDK\" class=\"headerlink\" title=\"引入 Wilddog js SDK\"></a>引入 Wilddog js SDK</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"https://cdn.wilddog.com/sdk/js/2.0.0/wilddog-sync.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<h3 id=\"“说点什么”-与-“发射”\"><a href=\"#“说点什么”-与-“发射”\" class=\"headerlink\" title=\"“说点什么” 与 “发射”\"></a>“说点什么” 与 “发射”</h3><p>这里用到 Wilddog 写入数据的一个 API <a href=\"/guide/sync/web/save-data.html#追加新节点\">push()</a>, 它用来在当前节点下生成随机子节点，以保证键的不重复和有序。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建数据库引用。最好自己创建一个应用，把 danmu 即 `appId` 换成你自己的</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = &#123;</div><div class=\"line\">  authDomain: <span class=\"string\">\"danmu.wilddog.com\"</span>,</div><div class=\"line\">  syncURL: <span class=\"string\">\"https://danmu.wilddogio.com\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\">wilddog.initializeApp(config);</div><div class=\"line\"><span class=\"keyword\">var</span> ref = wilddog.sync().ref();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取输入框的数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> text = $(<span class=\"string\">\".s_txt\"</span>).val();</div><div class=\"line\"><span class=\"comment\">// 将数据写到云端 message 节点下，child 用来定位子节点</span></div><div class=\"line\">ref.child(<span class=\"string\">'message'</span>).push(text);</div></pre></td></tr></table></figure></p>\n<p>数据库中的数据结构就是这个样子的：<br><img src=\"/images/data.jpg\" alt=\"\"></p>\n<h3 id=\"“清屏”\"><a href=\"#“清屏”\" class=\"headerlink\" title=\"“清屏”\"></a>“清屏”</h3><p>就是删除数据，定位到节点下调用 API <code>remove()</code> 即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.remove();</div></pre></td></tr></table></figure>\n<h3 id=\"在窗口显示\"><a href=\"#在窗口显示\" class=\"headerlink\" title=\"在窗口显示\"></a>在窗口显示</h3><p>即读取数据，Wilddog <a href=\"/guide/sync/web/retrieve-data.html\">获取数据</a>是先绑定监听事件，然后在回调函数中获取数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 绑定 'child_added' 事件，当 message 节点下有子节点新增时，就会触发回调，回调的 `snapshot` 对象包含了新增的数据</span></div><div class=\"line\">ref.child(<span class=\"string\">'message'</span>).on(<span class=\"string\">'child_added'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> text = snapshot.val();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果有人“清屏”了，如何获取这个事件呢？与上面的 <code>&#39;child_added&#39;</code> 类似，有个 <code>&#39;child_removed&#39;</code> 事件：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ref.on(<span class=\"string\">'child_removed'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">snapshot</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>用到的相关 Wilddog API 就这么多，接下来就是弹幕相关的特定实现了。</p>\n<h3 id=\"画出页面轮廓\"><a href=\"#画出页面轮廓\" class=\"headerlink\" title=\"画出页面轮廓\"></a>画出页面轮廓</h3><p>只是牵涉到 web 页面的基础知识，这里不再叙述，可直接到最下方查看源码。</p>\n<h3 id=\"滚动及逐行显示\"><a href=\"#滚动及逐行显示\" class=\"headerlink\" title=\"滚动及逐行显示\"></a>滚动及逐行显示</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [];\t\t\t\t\t\t<span class=\"comment\">// 此数组用来存放所有的消息元素</span></div><div class=\"line\"><span class=\"keyword\">var</span> topMin = $(<span class=\"string\">'.d_mask'</span>).offset().top; \t <span class=\"comment\">// 显示框距顶部距离</span></div><div class=\"line\"><span class=\"keyword\">var</span> topMax = topMin + $(<span class=\"string\">'.d_mask'</span>).height(); <span class=\"comment\">// 显示框底部距顶部距离</span></div><div class=\"line\"><span class=\"keyword\">var</span> _top = topMin; <span class=\"comment\">// 每个滚动消息距顶部距离</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> moveObj = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> _left = $(<span class=\"string\">'.d_mask'</span>).width() - obj.width();</div><div class=\"line\">\t_top = _top + <span class=\"number\">50</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (_top &gt; (topMax - <span class=\"number\">50</span>)) &#123;</div><div class=\"line\">\t\t_top = topMin;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tobj.css(&#123;</div><div class=\"line\">\t\tleft : _left,</div><div class=\"line\">\t\ttop : _top,</div><div class=\"line\">\t\tcolor : getRandomColor()  <span class=\"comment\">// 获取随机颜色，之后讲</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t<span class=\"keyword\">var</span> time = <span class=\"number\">20000</span> + <span class=\"number\">10000</span> * <span class=\"built_in\">Math</span>.random();</div><div class=\"line\">\t<span class=\"comment\">// animate() 方法执行 CSS 属性集的自定义动画。逐渐改变的，这样就可以创建动画效果。</span></div><div class=\"line\">\tobj.animate(&#123;\t\t\t\t\t\t\t\t</div><div class=\"line\">\t\tleft : <span class=\"string\">\"-\"</span> + _left + <span class=\"string\">\"px\"</span>  <span class=\"comment\">// 让消息距左距离逐渐减小，产生右向左滚动动画。</span></div><div class=\"line\">\t&#125;, time, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\tobj.remove();</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"每3s随机选取一条消息播放\"><a href=\"#每3s随机选取一条消息播放\" class=\"headerlink\" title=\"每3s随机选取一条消息播放\"></a>每3s随机选取一条消息播放</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getAndRun = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (arr.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> n = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * arr.length + <span class=\"number\">1</span>) - <span class=\"number\">1</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> textObj = $(<span class=\"string\">\"&lt;div&gt;\"</span> + arr[n] + <span class=\"string\">\"&lt;/div&gt;\"</span>);</div><div class=\"line\">\t\t$(<span class=\"string\">\".d_show\"</span>).append(textObj);</div><div class=\"line\">\t\tmoveObj(textObj);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tsetTimeout(getAndRun, <span class=\"number\">3000</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"生成随机颜色\"><a href=\"#生成随机颜色\" class=\"headerlink\" title=\"生成随机颜色\"></a>生成随机颜色</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getRandomColor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">h</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">7</span> - h.length).join(<span class=\"string\">\"0\"</span>) + h</div><div class=\"line\">\t&#125;)((<span class=\"built_in\">Math</span>.random() * <span class=\"number\">0x1000000</span> &lt;&lt; <span class=\"number\">0</span>).toString(<span class=\"number\">16</span>))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"}],"Post":[{"title":"Hello World","_content":"","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n","slug":"hello-world","published":1,"date":"2016-09-06T03:38:22.512Z","updated":"2016-09-06T03:38:22.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cisswi9gv0000z4fwf5u8izh8","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}